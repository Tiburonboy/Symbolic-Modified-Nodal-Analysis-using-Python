<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Introduction – Symbolic Modified Nodal Analysis&lt;br&gt;using Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Basic_concepts.html" rel="next">
<link href="./Preface.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-d6667c7b59069bf82d0268b148e64a53.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Introduction.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Symbolic Modified Nodal Analysis<br>using Python</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/Tiburonboy/Symbolic-Modified-Nodal-Analysis-using-Python" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Introduction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Basic_concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Basic Concepts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Modified_Nodal_Analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Modified Nodal Analysis</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./MNA_with_python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">MNA with Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Resistive_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Resistive Networks</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RLC_networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">RLC Networks</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Transfer_function.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Transfer Function</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Transient_analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Transient Analysis</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Mutual_inductance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Mutual Inductance</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Initial_conditions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Initial Conditions</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./Example-problems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Example Problems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Two port parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Two Port Parameters</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Thevenin equivalent circuit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Thevenin Equivalent Circuit</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./State-variable-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">State Variable Filter</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Superposition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Superposition</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2nd_order_BRF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">2nd Order BRF</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Elliptic-function-LPF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Elliptic Function LPF</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Bridge-T.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Bridge-T</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Pi-Filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Pi Filter</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./SIDO-low-pass-filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">SIDO Low Pass Filter</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Super-node.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Super Node</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Modeling Op Amps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Modeling Op Amps</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Op Amp circuits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Op Amp Circuits</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Two amplifier RIAA Phono Preamp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Two Amplifier RIAA Phono Preamp</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./mech-sys.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Mechanical Systems</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Klon Centaur part 1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Klon Centaur, Part 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Klon Centaur part 2v0.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Klon Centaur, Part 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Klon Centaur part 3v1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Klon Centaur, Part 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Wien bridge oscillator.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Wien Bridge Oscillator</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Diode Circuit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Diode Circuit</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Bridged-T-coil_v2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Bridged T Coil</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./Validation-tests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Validation Tests</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Test 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Test 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Test 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Test 4</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Test 5</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Test 6</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">37</span>&nbsp; <span class="chapter-title">Test 7</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">38</span>&nbsp; <span class="chapter-title">Test 8</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">39</span>&nbsp; <span class="chapter-title">Test 9</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">40</span>&nbsp; <span class="chapter-title">Test 10</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">41</span>&nbsp; <span class="chapter-title">Test 11</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">42</span>&nbsp; <span class="chapter-title">Test 12</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">43</span>&nbsp; <span class="chapter-title">Test 13</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">44</span>&nbsp; <span class="chapter-title">Test 14</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./test_15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">45</span>&nbsp; <span class="chapter-title">Test 15</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./References.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./SymMNA_py.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">SymMNA.py</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Change-log.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Change Log</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Google Colab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Google Colab</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./SMNA_mobile.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">SMNA Mobile</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./EasyEDA_schematic_editor.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">EasyEDA</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./History_of_Electric_Circuit_Analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">History of Electric Circuit Analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Quick_ref.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">Quick Reference</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-is-circuit-analysis-and-who-is-this-book-for" id="toc-what-is-circuit-analysis-and-who-is-this-book-for" class="nav-link active" data-scroll-target="#what-is-circuit-analysis-and-who-is-this-book-for"><span class="header-section-number">1.1</span> What Is Circuit Analysis and Who Is This Book For?</a></li>
  <li><a href="#who-is-this-book-not-for" id="toc-who-is-this-book-not-for" class="nav-link" data-scroll-target="#who-is-this-book-not-for"><span class="header-section-number">1.2</span> Who Is This Book Not For?</a></li>
  <li><a href="#assumptions" id="toc-assumptions" class="nav-link" data-scroll-target="#assumptions"><span class="header-section-number">1.3</span> Assumptions</a></li>
  <li><a href="#why-not-just-use-spice-or-some-other-program" id="toc-why-not-just-use-spice-or-some-other-program" class="nav-link" data-scroll-target="#why-not-just-use-spice-or-some-other-program"><span class="header-section-number">1.4</span> Why Not Just Use SPICE or Some Other Program?</a></li>
  <li><a href="#why-use-symbolic-circuit-analysis" id="toc-why-use-symbolic-circuit-analysis" class="nav-link" data-scroll-target="#why-use-symbolic-circuit-analysis"><span class="header-section-number">1.5</span> Why Use Symbolic Circuit Analysis?</a></li>
  <li><a href="#getting-started" id="toc-getting-started" class="nav-link" data-scroll-target="#getting-started"><span class="header-section-number">1.6</span> Getting Started</a></li>
  <li><a href="#about-the-math" id="toc-about-the-math" class="nav-link" data-scroll-target="#about-the-math"><span class="header-section-number">1.7</span> About the Math</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">1.8</span> Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!--
Last update: 17 Dec 2025  
Source: 
/home/jeff32/Documents/Quarto_projects/Circuit-Analysis-using-Python/Introduction.odt   

The idea of this book is more of a How To or User's Guide  

-->
<p>The purpose of this book is to describe a method implemented in the Python programming language that will automatically generate symbolic network equations from a circuit’s netlist. The Python programming language and the associated libraries such as SymPy and NumPy make analyzing electric circuits almost effortless and the JupyterLab Notebooks described in this book can be used as template for analyzing almost any linear electric circuit.</p>
<p>This book is not a college text book about circuit analysis, there are many good books available that cover this topic. This book is about using Modified Nodal Analysis and the Python programming language to analyze electric circuits. Python’s open-source nature makes it a powerful and cost-effective tool for complex computational problems.</p>
<p>Circuit analysis is a foundational skill necessary for a broad range of professionals whose work involves the design and development of electronic systems. Electrical Engineers and Circuit Designers are the core audience, as they rely on techniques like Kirchhoff’s Laws to create efficient circuits, calculate voltage drops and current flows, and simulate how an electric circuit will behave before it’s ever built. Fields like Power Systems Engineering, Control Systems Engineering and even Physics require this knowledge to understand energy distribution, optimize system performance and analyze complex physical models where circuits are used as analogues.</p>
<p>The Modified Nodal Analysis (MNA) is an essential extension of standard Nodal Analysis, and its primary benefits revolve around its systematic and comprehensive nature, particularly for computer-aided analysis. The key advantage of MNA is its ability to accommodate many types of circuit elements in a single, unified matrix formulation. Unlike traditional Nodal Analysis, which struggles to directly model voltage sources and components whose current is not easily defined by node voltages (such as dependent voltage sources and inductors), MNA introduces the currents through these elements as additional unknown variables. This standardization makes the process of formulating the circuit equations highly algorithmic and straightforward to automate, forming the backbone of professional circuit simulators like SPICE. Consequently, MNA eliminates the need for manual, ad-hoc techniques like supernodes or source transformations, allowing for the rapid and reliable analysis of large, complex, and linear circuits.</p>
<!--

**About This Book**

This Book is a users guide for doing symbolic circuit analysis with Python. 

This book is about … 

**Who should read this book**


whats in this book ...

- MNA is an algorithmic technique to derive network equations from a circuit's netlist
- uses SymPy and NumPy and to solve the equations.
- Plots are generated with Matplotlib
- example circuits
- 

-->
<section id="what-is-circuit-analysis-and-who-is-this-book-for" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="what-is-circuit-analysis-and-who-is-this-book-for"><span class="header-section-number">1.1</span> What Is Circuit Analysis and Who Is This Book For?</h2>
<p>Electric circuit analysis is the process of figuring out the unknown currents and voltages in a network of connected electrical components, which is commonly call a circuit. It is a fundamental skill that is taught to engineering students and serves as the bedrock for understanding and designing virtually all modern electrical and electronic systems.</p>
<p>Circuit analysis is used for calculating power flow, voltage drops and fault currents in power grids; designing amplifiers, filters, power supplies and logic circuits for devices like smartphones and computers. This process relies on using basic physical laws and systematic mathematical techniques to create and solve a system of independent equations.</p>
<p>This method presented in this book will be particularly useful when the circuit is of simple to moderate complexity and symbolic network equations are desired. In some cases, symbolic solutions for the equations can be obtained.</p>
</section>
<section id="who-is-this-book-not-for" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="who-is-this-book-not-for"><span class="header-section-number">1.2</span> Who Is This Book Not For?</h2>
<p>There are a few cases where MNA and the Python code presented in this book may not be that useful for you.</p>
<ul>
<li>This book or the JupyterLab notebooks may not be particularly useful for students doing circuit analysis homework assignments by hand with pencil and paper. If the student is asked to find the loop equations or traditional node equations, the automatically generated MNA equations will be different.</li>
<li>The input to the Python code is a netlist and generating the netlist either by hand or with a schematic capture program may be more work than just determining the network equations in the traditional way.</li>
<li>If the circuit is so simple that the unknown variables can be solve for almost by inspection, starting with a netlist is not necessary and requires unnecessary additional work.</li>
</ul>
<!--

 The core purpose of this rigorous exercise is to understand precisely how energy is transferred, converted, and managed within a circuit. The deep knowledge gained from this analysis is vital for predicting a circuit's performance and, most importantly, ensuring it functions correctly and safely.

The primary tools that form the bedrock of circuit analysis are three fundamental laws. 

1. Ohm's Law, which establishes the core relationship between voltage, current, and resistance in a simple way.
1. Kirchhoff's Current Law (KCL), a principle based on the conservation of charge, stating that the sum of all currents entering a node (or junction) must exactly equal the sum of all currents leaving it.
1. Kirchhoff's Voltage Law (KVL), which is based on the conservation of energy and dictates that the sum of all voltage drops around any closed loop within the circuit must equal zero.

For more complex circuits that would be unwieldy to solve using just the fundamental laws directly, engineers employ systematic methods to simplify the process. These include the Node Voltage Method and the Mesh Current Method, which provide structured ways to set up the necessary systems of equations. Furthermore, powerful theorems like Thévenin's and Norton's are used to reduce large, complicated networks into much simpler equivalent circuits, thereby making the overall analysis manageable and efficient.

Circuit analysis is a foundational skill primarily for electrical and computer engineers but is also relevant to other technical fields. 

**Why Circuit Analysis is Essential**

- It's the core discipline for designing and analyzing virtually all electrical systems, including
  - Power Systems: Calculating power flow, voltage drops, and fault currents in power grids.
  - Electronics: Designing amplifiers, filters, power supplies, and logic circuits for devices like smartphones and computers. 
- Renewable Energy: Optimizing power converters and inverters in solar and wind systems.

Electrical circuit analysis is a fundamental skill that serves as the bedrock for understanding and designing virtually all modern electrical and electronic systems. It is the process of finding all the currents and voltages within a network of interconnected electrical components, which is crucial for predicting circuit behavior, ensuring proper functionality, and optimizing performance. This analysis is ubiquitous across numerous industries, playing a vital role in everything from consumer electronics like smartphones and computers to complex industrial systems. For example, it is essential in power systems to calculate power flow and fault currents across a grid, and in the automotive industry for designing sensors, control modules, and onboard entertainment systems. Other applications include the design of medical devices (like pacemakers and monitors), communication systems (such as radio and cellular networks), and control systems (used in robotics and automation), often employing analysis techniques like Kirchhoff's Laws, nodal analysis, and the superposition theorem.

Ultimately, anyone involved in the design, development, or maintenance of electronic or electrical systems relies on a deep understanding of circuit analysis to ensure their creations are efficient, reliable, and safe.

Understanding and solving any electric circuit relies on two fundamental categories of mathematical tools: the laws governing individual components and the laws governing component interconnections. The foundational tool for the components themselves is Ohm's Law, which provides the basic device equation for a resistor, stating that voltage (V) equals the product of current (I) and resistance (R), or V=IR. This law establishes the essential relationship between the three primary electrical quantities.

For governing how these components are connected, we turn to Kirchhoff's Laws, which serve as the key connection equations. These laws are the bedrock for distributing voltage and current throughout the network. Kirchhoff's Current Law (KCL) states that the algebraic sum of currents entering a node (or junction) must equal zero, which is a direct application of the principle of the conservation of charge. Complementary to this is Kirchhoff's Voltage Law (KVL), which asserts that the algebraic sum of all voltage drops and rises encountered while tracing any closed loop within the circuit must equal zero, embodying the conservation of energy.

To analyze more complex circuits efficiently, engineers use systematic analytical techniques. Node-Voltage Analysis is a method that primarily uses KCL to determine the unknown voltages at the main nodes of a circuit. Conversely, Mesh-Current Analysis utilizes KVL to find the unknown currents circulating in the closed loops (meshes) of the circuit. Both methods translate the circuit problem into a solvable set of equations.

The level of mathematics required for circuit analysis escalates with the circuit's complexity and nature. For the most basic circuits, simple Algebra is sufficient to solve Ohm's Law and the small systems of equations derived directly from KCL and KVL. However, when dealing with the large, complicated systems of equations generated by Node-Voltage and Mesh-Current analysis, Linear Algebra becomes essential. This involves working with matrices and determinants to solve the resulting systems of simultaneous linear equations. For dynamic circuits that incorporate energy-storage components like capacitors and inductors (e.g., RL, RC, and RLC circuits), the voltages and currents change over time, requiring the use of Calculus and Differential Equations for analysis. Finally, AC circuit analysis, which involves sinusoidal sources, relies heavily on Complex Numbers and Complex Analysis. This is crucial because quantities like impedance are represented as complex numbers to simplify calculations involving magnitude and phase shifts. A related, advanced tool, the Laplace Transform, is often used in this context to transform differential equations from the time domain into simpler algebraic problems in the complex frequency domain.

That's a great choice. Applying Linear Algebra to solve circuit equations, specifically those derived from the Node-Voltage Analysis method (which uses KCL), transforms a tedious algebra problem into a systematic matrix calculation.

Here is a step-by-step example showing how the equations derived from Kirchhoff's Current Law (KCL) at the nodes of a circuit are organized into a system of simultaneous linear equations and then solved using matrices.

-->
</section>
<section id="assumptions" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="assumptions"><span class="header-section-number">1.3</span> Assumptions</h2>
<p>A basic understanding of Python programming is helpful, meaning you should be familiar with core concepts such as variables, data types (e.g., lists, dictionaries and strings), control flow (using <code>if</code> <code>else</code> statements and <code>for</code> <code>while</code> loops) and defining and calling functions.</p>
<p>Additionally, familiarity with JupyterLab notebooks is required. This involves knowing how to navigate the interface, create new notebooks, write and run code within cells, and utilize Markdown cells for documentation and annotation. JupyterLab serves as the primary interactive environment for writing and testing Python code.</p>
<p>The analysis of electric circuits, whether done by hand or with the help of Python and MNA, fundamentally relies on the concept of ideal components. These are theoretical abstractions that possess perfect behavior (e.g., a resistor has only resistance, an inductor has only inductance) and ignore the inevitable imperfections of real-world devices, such as parasitic capacitance, lead resistance, or temperature dependence.</p>
<p>Furthermore, almost all conventional circuit analysis methods, including Nodal and Mesh analysis, rely on the assumption of a lumped-element model, which assumes the circuit is small enough that electrical effects occur instantaneously throughout the circuit, neglecting the time delay associated with the propagation of electromagnetic fields. This allows us to treat the circuit’s current and voltage as functions of time alone, rather than of both position and time (as required for wave propagation or transmission line effects). Finally, the systematic matrix methods discussed (MNA) are designed specifically for linear time-invariant (LTI) circuits, where the relationship between voltage and current is linear (e.g., Ohm’s law holds true) and the component values or connections do not change over time.</p>
</section>
<section id="why-not-just-use-spice-or-some-other-program" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="why-not-just-use-spice-or-some-other-program"><span class="header-section-number">1.4</span> Why Not Just Use SPICE or Some Other Program?</h2>
<p>The core reason you need symbolic analysis even with powerful numerical tools like SPICE is the difference between a number and a formula. SPICE and similar programs are numerical simulators. They give you a specific number for a specific set of component values and inputs.</p>
<p>Symbolic analysis, however, gives you the actual algebraic formulas for the circuit’s behavior. While powerful, exact symbolic analysis is typically limited to smaller circuits because the complexity and length of the resulting expressions grow dramatically with the number of components and branches in the network.</p>
<p>The Python code presented in this notebook is somewhat unique since Python is open source, free and runs on a variety of platforms, the code presented in the JupyterLab notebooks is portable. As described in the <em>Welcome</em> page, the Python code is made available under a public domain license and archived in a GitHub repository, see <a href="index.html#sec-source_code" class="quarto-xref"><span>Section 1</span></a>.</p>
<p>There are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, <a href="https://www.tina.com/">TINA</a> and <a href="https://www.maplesoft.com/">Maple</a>.</p>
<p><a href="https://analog-electronics.tudelft.nl/SLiCAP.html">SLiCAP</a> is a symbolic linear analysis tool. SLiCAP is now a Python program, but originally it was written in MATLAB.</p>
<p>TINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some <a href="https://www.tina.com/symbolic-analysis">symbolic analysis capability</a>.</p>
<p>Maple is a mathematical package and there is an application <a href="https://www.maplesoft.com/applications/view.aspx?SID=1427">note</a> available describing its use in symbolic circuit analysis. The application note presents a method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.</p>
<p><a href="https://rodanski.net/ben/work/symbolic/index.htm">Symbolic Circuit Analysis</a> is a web page devoted to symbolic circuit analysis.</p>
<p><a href="http://www.ewh.ieee.org/soc/es/May2001/12/Begin.htm">SAPWIN</a> is a windows program package for symbolic and numerical simulation of analog circuits.</p>
<p><a href="https://github.com/mph-/lcapy">Lcapy</a> is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics. <span class="citation" data-cites="Hayes2022">Hayes (<a href="References.html#ref-Hayes2022" role="doc-biblioref">2022</a>)</span> provides an overview of Lcapy as well as a survey of symbolic circuit analysis packages.</p>
<p><a href="https://www.analog.com/en/resources/design-tools-and-calculators/ltspice-simulator.html">LTSpice</a> has been used extensively to verify the MNA numerical results in addition to drawing the circuit schematics shown in this book’s examples.</p>
<!--

For larger circuits, symbolic approximation (which simplifies the expression by discarding numerically insignificant terms based on reference values) is often used to keep the resulting formula manageable and interpretable.

**What are the current modern SPICE programs?**

SPICE and similar programs are numerical simulators. They give you a specific number for a specific set of component values and inputs. You get how much the gain is (e.g., 10.5) but not why.

Symbolic analysis, however, gives you the actual algebraic formula for the circuit's behavior. 

List of free electronics circuit simulators
https://en.wikipedia.org/wiki/List_of_free_electronics_circuit_simulators


This provides three critical things that numerical simulation cannot:

Insight and Understanding

Symbolic analysis provides the "Aha!" moment for a circuit designer:

- Qualitative Insight: The symbolic formula instantly shows the relationship between the performance (like gain, pole frequency, or bandwidth) and all the component values ($R_1$, $C_2$, $g_m$, etc.). You can see at a glance if a certain resistor has a minor or major impact.
- Dominant Terms: In a complex expression, you can identify the dominant terms that control the behavior. This is crucial for simplifying the circuit design or creating hand-calculation models.
- Design Trade-offs: You can use the formula to understand the trade-offs between different performance metrics. For example, the same formula might show that increasing one resistor value increases gain but decreases bandwidth.

Optimization and Parameter Sweeps

For design and manufacturing, the formula is far more powerful than a single number:

- Sensitivity Analysis: You can easily calculate the sensitivity (how much the output changes for a tiny change in a component value) by simply taking the derivative of the symbolic expression with respect to that component. In numerical tools, this requires many time-consuming simulations.
- Design Optimization: The closed-form expression can be used in optimization algorithms to automatically find the best component values for a given specification, which is much faster and more robust than running thousands of SPICE iterations.
- Tolerance and Yield Analysis: The symbolic form can be used to quickly evaluate the impact of component manufacturing tolerances on the final circuit performance, helping to predict the manufacturing yield without extensive Monte Carlo simulations.

In essence, SPICE tells you what happens for one specific circuit, while symbolic analysis tells you why it happens for all possible variations of that circuit. The formula is a universal blueprint for that circuit topology.

Used in documenting the design.

-->
</section>
<section id="why-use-symbolic-circuit-analysis" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="why-use-symbolic-circuit-analysis"><span class="header-section-number">1.5</span> Why Use Symbolic Circuit Analysis?</h2>
<p>Symbolic circuit analysis is a formal technique where the behavior or characteristic of a circuit (like voltage gain or impedance) is calculated with the circuit components and frequency (or time) represented by symbols instead of numerical values.</p>
<p>For small circuits, the analytical expression (e.g., a transfer function) explicitly shows how each component affects the circuit’s performance metrics (gain, poles, zeros, etc.). This allows a designer to immediately see which elements are dominant and how to modify component values to meet specifications. A symbolic expression remains valid across a range of component values and operating conditions (as long as the underlying model is valid). By using symbolic analysis the network equations in symbolic form can be useful to document a design or to include in a technical paper.</p>
<!--

The main reasons to use symbolic circuit analysis are to gain deep qualitative insight into a circuit's operation and to facilitate design and optimization.

Key Advantages of Symbolic Analysis

Symbolic analysis offers benefits that purely numerical simulation (like SPICE) cannot:

- Qualitative Insight: The resulting analytical expression (e.g., a transfer function) explicitly shows how each component affects the circuit's performance metrics (gain, poles, zeros, etc.). This allows a designer to immediately see which elements are dominant and how to modify component values to meet specifications.
- Design and Optimization: The symbolic formula can be used directly for sensitivity analysis (how a small change in a component value affects the output) or for automated design optimization, bypassing the need for repeated, slow numerical simulations.
- Generality and Reusability: A symbolic expression remains valid across a range of component values and operating conditions (as long as the underlying model is valid). Designers can use the same formula to quickly evaluate performance at different design points without re-analyzing the circuit from scratch.
- Exact Solutions: For linear circuits, symbolic analysis can provide the exact analytical solution, avoiding the potential for numerical instability and accumulated errors associated with numerical approximation techniques.
- generate equations for technical papers, see @Tiburonboy2025b, where the network equations were generated and formatted for the paper.

Practical network size

-->
</section>
<section id="getting-started" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="getting-started"><span class="header-section-number">1.6</span> Getting Started</h2>
<p>The best way to begin your journey into symbolic circuit analysis with Python is through hands-on practice. The most effective approach is to copy one of the provided JupyterLab Notebooks and use it as a template for analyzing your own circuits. By doing this, you’ll immediately begin applying the Modified Nodal Analysis (MNA) method and leverage the computational power of Python libraries like SymPy for symbolic computation, NumPy for numerical handling, and Matplotlib for generating plots.</p>
<p>This practical, project-oriented approach will quickly familiarize you with setting up a circuit’s netlist, deriving its symbolic network equations, solving for unknown voltages and currents, and gaining the deep, qualitative insights that only symbolic analysis can provide.</p>
<p>Source code for this book is available <a href="https://github.com/Tiburonboy/Symbolic-Modified-Nodal-Analysis-using-Python/tree/main/backup">here</a> and related material is located <a href="https://github.com/Tiburonboy/Symbolic-modified-nodal-analysis">here</a>. Python code contained in this book can run in a browser-based environment, see <a href="Google Colab.html" class="quarto-xref"><span>Appendix C</span></a>. Additionally, online schematics editors are available, see <a href="EasyEDA_schematic_editor.html" class="quarto-xref"><span>Appendix E</span></a>. By using web based tools, the reader is not required to install any programs.</p>
<p>Rewrite this section and point to <a href="index.html#sec-source_code" class="quarto-xref"><span>Section 1</span></a> to keep Github links all in one place.</p>
</section>
<section id="about-the-math" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="about-the-math"><span class="header-section-number">1.7</span> About the Math</h2>
<p>The type of math used in circuit analysis depends on the complexity and nature of the circuit. Solving calculus and differential equations are not used in the analysis presented in this book. Since the Python modules SymPy and NumPy are being extensively employed, actual proficiency with the math is not really required. However, there are some advance concepts that are used throughout the book and that are not really explained.</p>
<ul>
<li>Complex Numbers: Crucial for AC circuit analysis, where quantities like impedance are represented as complex numbers to simplify calculations involving magnitude and phase shifts in sinusoidal waveforms. The Laplace Transform is used to convert differential equations into algebraic equations.</li>
<li>Linear Algebra: Essential for solving systems of simultaneous linear equations that result from MNA.</li>
</ul>
<!--
## How The Book Is Organized
The book is structured as a user's guide for performing symbolic circuit analysis with Python, with a strong focus on practical application. 

After the initial Introduction, which establishes the purpose, audience, and the importance of Modified Nodal Analysis (MNA) and symbolic analysis, the subsequent chapters focus on implementation. 

The book includes sections on Basic Concepts (Ideal Components, Electrical Units, etc.) and a chapter on the necessary Math (Linear Algebra, Laplace Transform). 

The core of the book is dedicated to describing the MNA process, including the matrix formulation, $V = I \cdot Z$, and its application to Laplace Transformed Circuit Models. Crucially, the final sections, such as Running Python and Examples, provide practical, hands-on examples, with the best use recommended to be copying the provided JupyterLab notebooks for direct application as templates to analyze the user's own circuits.

The first four chapters describe my implementation of symbolic circuit analysis with Python. The next part of the book consists of 15 circuits that are used to validate the Python code. These are Jupyter notebooks that have been rendered into chapters. The last part of the book contains circuit analysis example problems; followed by references, code listing and a change log. Section links are provided below.

- @sec-Introduction introduces the topic of MNA and describes how Python can easily solve mathematical expressions that would be very hard and laborious to do with pencil and paper.
  - Jupyterlab, variable names, large exponents
  - Practical network size for symbolic solutions
  - Linear and nonlinear circuits
  - State variables
  - Pros and cons of MNA
- @sec-History-Theory describes the history of circuit analysis and the theory behind MNA.
- @sec-example walks through a circuit analysis problem from netlist generation to AC analysis and generation of a frequency response plot of the circuit.
- @sec-SMNA-func provides a description of the Python function that implements the symbolic MNA procedure.

**Example problems**: A collection of interesting circuits (at least to me) that showcase the power and ease with which the Python code can solve circuit analysis problems.

**Validation tests**: There are 15 circuits that were used to validate the Python code. These circuits range from simple circuits that you would find in textbooks, to complex circuits that would be very difficult to analyze if not for computers. There are also a couple of test circuits designed to generate sub-matrices of all zeros during the formulation of the network equations.

**References**: This section provides information about works cited in this book.

@sec-SymMNA_py is the Python source listing of the MNA function called in the verification tests and example problems sections.

@sec-Change-log is a list of the changes to the MNA code and this book.

@sec-google_colab provides instructions about running the code contained in this book in Google's Colab. All that is needed is a gmail account.

@sec-SMNA_mobile is a JupyterLab notebook that can be used as a template for circuit analysis using Colab on a mobile device.

@sec-EasyEDA_schematic_editor provides a link to an web based schematic editor program than can be used to generate schematics and a netlist from a schematic.

-->
</section>
<section id="summary" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="summary"><span class="header-section-number">1.8</span> Summary</h2>
<p>This book serves as a practical guide for performing symbolic circuit analysis using the Python programming language and its associated scientific libraries, such as SymPy and NumPy. The primary goal is to provide a systematic and computationally efficient method for analyzing linear electric circuits, utilizing JupyterLab Notebooks as adaptable templates.</p>
<p>The book is not a traditional circuit analysis textbook but focuses specifically on implementing the Modified Nodal Analysis (MNA) method. MNA is an essential extension of standard nodal analysis that allows all types of circuit elements (including voltage sources, inductors, and dependent sources) to be incorporated into a single, unified matrix formulation. This approach forms the algorithmic backbone of professional circuit simulators like SPICE.</p>
<p>Important Points:</p>
<ul>
<li>Symbolic Analysis: This technique calculates a circuit’s behavior (e.g., gain, impedance) with components and frequency represented by symbols instead of numerical values. This provides qualitative insight into the circuit’s operation, aids in design optimization, and yields exact analytical solutions that numerical simulators (like SPICE) cannot.</li>
<li>Target Audience: Circuit analysis is a foundational skill for a broad range of professionals, including Electrical Engineers, Circuit Designers, Electronics Technicians and those in Power Systems and Control Systems Engineering.</li>
<li>Modified Nodal Analysis (MNA): The book leverages MNA to formulate the circuit problem as a system of simultaneous linear equations, <span class="math inline">\(\mathbf{G} \cdot \mathbf{V} = \mathbf{I}\)</span>, which are then solved using matrix inversion implemented in Python.</li>
<li>Advanced Concepts (The s-Domain): The text covers Laplace Transformed Circuit Models, which convert time-domain differential equations into simpler algebraic equations in the s-domain (complex frequency domain). This is crucial for analyzing circuits with energy storage elements (capacitors and inductors) and determining their transient and transfer functions.</li>
<li>Foundations of Circuit Analysis: A review of fundamental concepts is provided, including Ohm’s Law, Kirchhoff’s Current Law (KCL), and Kirchhoff’s Voltage Law (KVL), along with an overview of the key mathematical tools required (Algebra, Linear Algebra, Calculus, and Complex Numbers).</li>
</ul>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Hayes2022" class="csl-entry" role="listitem">
Hayes, M. 2022. <span>“Lcapy: Symbolic Linear Circuit Analysis with Python.”</span> <a href="https://doi.org/10.7717/peerj-cs.875">https://doi.org/10.7717/peerj-cs.875</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Preface.html" class="pagination-link" aria-label="Preface">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Preface</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Basic_concepts.html" class="pagination-link" aria-label="Basic Concepts">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Basic Concepts</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>