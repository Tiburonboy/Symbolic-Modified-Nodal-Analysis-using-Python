[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "About this book\nThis website is my online book - Symbolic Modified Nodal Analysis using Python. Symbolic circuit analysis is a circuit analysis method that derives network equations with the circuit elements represented by symbols and the topology of the circuit described by a netlist. Python is a general purpose programing lauguage with a large standard library and packages.\nThe circuit analysis technique presented in this book covers circuits driven with sinusoidal sources where the DC or AC steady state response is obtained. The inductors and capacitors in the circuit are replaced by their transformed values. Inductors are replace by their steady state Laplace value, \\(sL\\), where L is the value of the inductor with units of henrys (named after Joseph Henery) and \\(s\\) is the Laplace variable equal to \\(j \\omega\\) where \\(j\\) is the imaginary number and \\(\\omega\\) is the radian frequency. Capacitors in the circuit are replace by their steady state Laplace value, \\(\\frac {1}{sC}\\) where C is the value of the capacitor with units in farads (named after Micheal Faraday).\nThere are 15 code validation test circuits along with a few project circuits. The chapters for each of the circuits can be referenced as examples of how to use my Python code to analyze electrical circuits.\nThis book was written in R MarkDown using plain text files and JupyterLab notebooks. The source files were rendered into a book using Quarto, an open-source scientific and technical publishing system. Quarto does a good job of formatting the documents into web pages for a book. Some of the lines of code and mathematical expressions are wider than the page and Quarto inserts a slider bar in the code or equation windows. Chapter and paragraph numbering are automatically generated by Quarto as well as the numbering of figures and tables.\nSource code for this book is available here and related material is located here",
    "crumbs": [
      "About this book"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "Python module version\nThe following versions were used in this book.\n\n\n\nTable 1: Python packages\n\n\n\n\n\n\n\n\n\nPackage\nversion\n\n\n\n\nPython\n3.10.9\n\n\nJupyterLab\n3.5.3\n\n\nIPython\n8.10.0\n\n\nNumPy\n1.23.5\n\n\nSymPy\n1.11.1\n\n\nSciPy\n1.10.0\n\n\nPandas\n1.5.3\n\n\nTabulate\n0.8.10\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8\n\n\n\n\n\n\n\n\nUpdate History\nThis book will be updated occasionally to fix typos, spelling and grammer mistakes. Additionally, new content will be added as new chapters are written.\n\n\n\ndate\ndescription\n\n\n\n\n29 Dec 2023\ntest version\n\n\n26 Jan 2023\nanother book update\n\n\n\n\n\nProject ToDo List\nSince this project is still under construction, I have a list of to dos.\n\nfix spelling of netlist\nchange usage of spice to SPICE and define\nfix usage of Op Amp and make consistant thoughout\nupdate status in /Quarto_projects/Symbolic-Modified-Nodal-Analysis-using-Python/draft_docs/To Do List.odt\nclean up narrative on all the tests\nadd comment to each test about generating a symbolic solution\nreview each schematic and remove spice directives\n\nremove double spaces at end of sentences\nrewrite Two amplifier RIAA phono preamp\nCreate new example problems\nnon linear circuits, see YouTube MNA Introduction\nfinish Summary in state variable notebook\nspell and grammar check all files\n\n\n\n\nLicense\nThis work (includes python code, documentation, test circuits, etc.) is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\nShare — copy and redistribute the material in any medium or format\nAdapt — remix, transform, and build upon the material for any purpose, even commercially.\nhttps://creativecommons.org/licenses/by-sa/4.0/",
    "crumbs": [
      "About this book"
    ]
  },
  {
    "objectID": "Preface.html",
    "href": "Preface.html",
    "title": "Preface",
    "section": "",
    "text": "Survey of other symbolic circuit analysis code\nThe Python code presented in this notebook is somewhat unique since Python is open source, free and runs on a variety of platforms, the code presented in this IPython notebook is portable. As described in the About this book, this code is made available under a public domain license and archived in a github repository.\nThere are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, TINA and Maple.\nSLiCAP is a symbolic linear analysis tool. SLiCAP is now a Python program, but originally it was written in MATLAB.\nTINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some symbolic analysis capability.\nMaple is a mathematical package and there is an application note available describing its use in symbolic circuit analysis. The application note presents a method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.\nSymbolic Circuit Analysis is a web page devoted to symbolic circuit analysis.\nSAPWIN is a windows program package for symbolic and numerical simulation of analog circuits.\nLcapy is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics. Hayes (2022) provides an overview of Lcapy as well as a survey of symbolic circuit analysis packages.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Preface.html#chapter-contents",
    "href": "Preface.html#chapter-contents",
    "title": "Preface",
    "section": "Chapter contents",
    "text": "Chapter contents\nChapter 1 introduces the topic of MNA and describes how Python can easily solve mathematical expressions that would be very hard and laborious to do with pencil and paper. Chapter 2, describes the theory behind MNA. Chapter 3 walks through a circuit analysis problem from netlist generation to AC analysis and generation of a frequency response plot of the circuit. Chapter 4 provides a description of the Python function that implements the symbolic MNA procedure. There are 15 circuits that were used to validate the Python code. These circuits range from simple circuits that you would find in textbooks, to complex circuits that would be very difficult to analyze if not for computers. There are also a couple of test circuits designed to generate sub-matrices of all zeros during the formulation of the network equations. The last part of the book is a collection of interesting circuits (at least to me) that showcase the power and ease with which the Python code can solve circuit analysis problems. The appendices contain a listing for the smna function and a change log of the history of the project’s code development.\n\n\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nHayes, M. 2022. “Lcapy: Symbolic Linear Circuit Analysis with Python.” https://doi.org/10.7717/peerj-cs.875.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific Computing. Numerical Recipes in c Book Set. Cambridge University Press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 JupyterLab\nAll the validation and problem circuits are presented in JupyterLab notebooks and rendered into chapters by Quarto.\nVariable names\nI’ve tried to be consistent with the use of variable names throughout the Jupyter notebooks. Resistors, capacitors and inductors use R, L and C as reference designators. The names chosen for the other variables are listed in Table 1.1\nLarge exponents\nThe values of the exponents can be very large in the numerical solution to the network equations when using real component values. Often you will see in engineering text books that the author uses normalized component values, where the values have been frequency and impedance scaled to a frequency of \\(\\omega = 1\\) and one of the resistors or other components normalized to a value of one. This keeps the numerical values obtained in the solution to the network equations from getting very large or small.\nAlmost all platforms map Python floats to the IEEE754 double precision - 64 total bits. Using the sys package, the float information is reported as follows:\nmax=1.7976931348623157e+308\n max_exp=1024\n max_10_exp=308\n min=2.2250738585072014e-308\n min_exp=-1021\n min_10_exp=-307\n dig=15\n mant_dig=53\n epsilon=2.220446049250313e-16\n radix=2\n rounds=1\nThe maximum exponent that Python can use is 308. In this book, I’m going to let Python do the math and not worry about the size of the exponents. I suppose that large exponents don’t become a problem as long as they remain under two digits.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#jupyterlab",
    "href": "Introduction.html#jupyterlab",
    "title": "1  Introduction",
    "section": "",
    "text": "Table 1.1: Variable names\n\n\n\n\n\n\n\n\n\nVariable name\ndefinition\n\n\n\n\nNE_sym\nNetwork equations, symbolic\n\n\nNE\nNetwork equations with component values\n\n\nNE_dc\nNetwork equations with \\(s=0\\)\n\n\nNE_w1\nNetwork equations with \\(s=j \\omega\\) and \\(\\omega\\) equal to a numeric value\n\n\nU_sym\nThe solution to the symbolic network equations\n\n\nU\nThe solution to network equations with component values\n\n\nU_ac\nThe solution to network equations at some frequency\n\n\nH_sym\nsystem transfer function, symbolic\n\n\nH\nSystem transfer function with component values\n\n\n\\(V1, V2, etc.\\)\nCapital letter V for independent voltage sources\n\n\n\\(v_1, v_2, etc\\)\nSmall letter v for the node voltages\n\n\n\\(I1, I2, etc\\)\nCapital letter I for independent current sources\n\n\nE\nVoltage controlled voltage source (VCVS)\n\n\nF\nCurrent controlled current source (CCCS)\n\n\nG\nVoltage controlled current source (VCCS)\n\n\nH\nCurrent controlled voltage source (CCVS)\n\n\nK\nInductor coupling coefficient\n\n\nM\nMutual inductance\n\n\nO\nOp Amp component\n\n\nA\nConnectivity matrix\n\n\nX\nUnknown voltages and currents vector\n\n\nZ\nKnown voltages and currents vector",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#practical-network-size-for-symbolic-solutions",
    "href": "Introduction.html#practical-network-size-for-symbolic-solutions",
    "title": "1  Introduction",
    "section": "1.2 Practical network size for symbolic solutions",
    "text": "1.2 Practical network size for symbolic solutions\nTest circuit number 4, Chapter 8, has 26 branches, 13 nodes, 18 resistors, 4 independent sources and 4 dependent sources. A symbolic solution for this problem was taking too long on my i3 computer, so I interrupted the kernel, and proceeded with a numerical solution, which can be solved quite quickly. The complexity of a circuit can be reduced by letting some components have the same value, for example \\(R_1 = R_2 = R_3 = R\\), which would reduce the number of symbols that are being manipulated.\nAnother circuit, shown below, a 100 Hz low pass elliptic function filter, is an example of a circuit where the size of the symbolic expressions became too large and the number of terms too great to allow any reasonable interpenetration of the circuit’s operation. The Python kernel needed to be interrupted during the symbolic solution. After actual component values are substituted into the network equations a numerical solution was easily obtained by SymPy, see Chapter 26 for this circuit’s notebook.\n\n\n\nElliptic function low pass filter\n\n\nThe net list for this circuit is:\n* Elliptic function VCVS LPF\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7\nV1 1 0 1\nR5 6 0 10e3\nR6 7 6 44.2e3\nThe following circuit equations were generated by the MNA code in less than one second:\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\n\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\n\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\n\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\n\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\n\\(- C_{3} s v_{4} + I_{O} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{5} + v_{6} = 0\\)\nAfter about two hours running on an i3 machine a symbolic solution was obtained, but it’s too long to display and doesn’t offer too much insight into the function of the circuit.\nAfter substituting numerical values for the components, the following solution for the voltage at node 2 was obtained in less than one second.\n\\(\\frac{4.30028181226968 \\cdot \\left(1.0784981875 \\cdot 10^{-10} s^{3} + 2.263375 \\cdot 10^{-7} s^{2} + 0.000474999999999999 s + 1.0\\right)}{1.50943922351291 \\cdot 10^{-12} s^{4} + 4.7350839034956 \\cdot 10^{-9} s^{3} + 4.53071325287237 \\cdot 10^{-6} s^{2} + 0.00311443743767615 s + 1.0}\\)\nSee Chapter 25 for a reduced complexity version of the schematic above, for which a symbolic solution was obtained in less than one second.\nPython together with SymPy has enabled the ability to explore circuit analysis problems without having to resort to pages and pages of hand calculations and then to display the results with good looking graphics and equations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Theory.html",
    "href": "Theory.html",
    "title": "2  Theory",
    "section": "",
    "text": "2.1 Network equations\nThe network equations are a set of independent equations expressed in this code in matrix form. There is an equation for each node based on Kirchhoff’s current law and an equation for each current unknown. The current unknowns are the currents from the voltages sources, op amps, voltage controlled voltage sources, current controlled voltage sources, current controlled current sources and inductors.\nEquation 2.1 are the network equations in matrix form.\n\\[A\\cdot X = Z \\tag{2.1}\\]\nMatrix \\(A\\) describes the connectivity of the resistors, capacitors and G type (VCCS) circuit elements. The \\(X\\) vector contains unknown node voltages and unknown currents from the voltage sources and inductors. The \\(Z\\) vector contains the known voltages and currents. The \\(A\\) matrix is formed by four sub matrices, \\(G\\), \\(B\\), \\(C\\) and \\(D\\), which are described below.\n\\[A = \\begin{bmatrix}G B\\\\C D\\end{bmatrix} \\tag{2.2}\\]\nThe matrix \\(G\\) is formed from the coefficients representing the KCL equations for each node. The positive diagonal of \\(G_{k,k}\\) are the conductance terms of the resistor and capacitor elements connected to node k. The off diagonal terms of \\(G_{k,j}\\) are the resistors and capacitor conductances connecting node k to node j. G type elements (VCCS) have input to the G matrix at the connection and controlling node positions.\nThe \\(B\\) matrix describes the connectivity of the unknown branch currents. Independent voltage sources, op amps, H, F and E type elements as well as inductors have inputs to the B matrix.\nThe \\(C\\) matrix describes the connectivity of the unknown branch currents and is mainly the transpose of the \\(B\\) matrix, with the exception of the F type elements (CCCS) and includes the E type value.\nThe \\(D\\) matrix also describes connectivity of the unknown currents. The \\(D\\) matrix is composed of zeros unless there are controlled sources and inductors in the network.\nThe \\(X\\) vector is composed of the \\(V\\) and \\(J\\) vectors as shown in Equation 2.3.\n\\[X = \\begin{bmatrix}V\\\\J\\end{bmatrix} \\tag{2.3}\\]\nThe \\(V\\) vector contains the node voltages which are the voltage unknowns to be solved for. The \\(J\\) vector contains the unknown currents from each voltage source.\nThe \\(Z\\) vector is composed of the I and Ev vectors as shown Equation 2.4.\n\\[Z = \\begin{bmatrix}I\\\\Ev\\end{bmatrix} \\tag{2.4}\\]\nThe I vector contains the known currents and the Ev vector contains the known voltages. The name Ev is used because SymPy uses e and E sometimes for the constant 2.71, also called Euler’s number. The use of E or e as a symbol was causing some errors when the code was run.\nPutting all the parts together:\n\\[\\begin{bmatrix}G B\\\\C D\\end{bmatrix} \\cdot \\begin{bmatrix}V\\\\J\\end{bmatrix} = \\begin{bmatrix}I\\\\Ev\\end{bmatrix} \\tag{2.5}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#network-equations",
    "href": "Theory.html#network-equations",
    "title": "2  Theory",
    "section": "",
    "text": "2.1.1 Stamps\nStamps are templates for modifying the \\(B\\), \\(C\\) and \\(D\\) matrices and facilitate the construction of the matrices. The stamps used in this implementation of the MNA allow the circuit connections of the components to be used to directly populate the various matrices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#code-description",
    "href": "Theory.html#code-description",
    "title": "2  Theory",
    "section": "2.2 Code description",
    "text": "2.2 Code description\nThe code is divided in the following sections.\nPreprocessor: The preprocessor reads in the netlist text file and removes comments, extra spaces and blank lines. The first letter of the element type is capitalized to make subsequent parsing of the file easier. The number of lines are counted and the number of entries on each line are checked to make sure the count is consistent with the element type.\nParser: The parser code loads the preprocessed netlist into a data frame. A report is generated which consists of a count of the element types in the netlist.\nMatrix formulation: Each of the matrices and vectors are generated.\nCircuit equation generation: The circuit equations are generated in a loop. Sympy automatically does some simplification according to its default settings. Two for loops perform the matrix multiplication on the equation: \\(A\\cdot X = Z\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#netlist-file-format",
    "href": "Theory.html#netlist-file-format",
    "title": "2  Theory",
    "section": "2.3 Netlist file format",
    "text": "2.3 Netlist file format\nThe input file which describes the circuit is a text file called the netlist. A netlist consists of a statement defining each circuit element and its connection to circuit nodes. A node is any point on a circuit where two or more circuit elements meet. The nodes are numbered from 1 to N in any order and node 0 is the ground node or circuit common. A ground node is required. Choose a ground or reference node, which usually is taken to be at a potential of zero volts. All other node voltages constitute n unknowns. The nodes should be numbered in consecutive order. Each line in the netlist are either comments, spice directives or circuit elements.\nSpice directives are commands to spice and the first character on the line is a period. Comment lines start with a * or ;. The default file extension is ‘.net’. The Python code does some preprocessing of the netlist to check the basic formatting of the netlist is correct.\nThe preprocessor performs the following steps:\n\nremove blank lines and comments\n\nconvert first letter of element name to uppercase\n\nremoves extra spaces between entries\n\ncounts number of entries on each line to make sure the count is correct and counts each element type\n\nThe element types that are supported are resistors, capacitors, inductors, independent sources and controlled sources. Each line in the netlist file contains a circuit element.\nThe format for the element description is\nletterXX n1 n2 value\nWhere\nletter signifies the element type, i.e. R, L, C, V, I, O, E, F, G, H or K\nXX is a string of letters or numbers that uniquely identify the element.\nThe element types are described in the following sections.\n\n2.3.1 Resistors, capacitors and inductors\nThe resistors, capacitors and inductors are described by the following line:\nR/L/CXX N1 N2 value\nWhere:\nXX = the name of the component, can be any length\nN1 = the first terminal\nN2 = the second terminal\nValue = component value in ohms, Farads or Henrys.\nFor example, a resistor named R1 connected between nodes 1 and 2 with a value of 3000 ohms.\nR1 2 4 3000\nSpice supports other parameters, but these are not allowed in this Python implementation.\n\n\n2.3.2 Coupled inductors\nTwo coupled inductors are described by the following line.\nKXX LYY LZZ VALUE\nThe parameters are:\nLYY = the name of the first coupled inductor\nLZZ = the name of the second coupled inductor\nVALUE = the coefficient of coupling, K, where 0 &lt; K\nThe orientation of the inductors is determined by the first node, which is considered to be the dotted node. When LTspice generates a net list the phasing dot gets associated with the negative node. This does not seem to affect the equations generated by the Python code. LTspice uses the coupling coefficient, k. The symbolic equations use the mutual inductance, M as shown in Equation 2.6.\n\\[M = k\\sqrt{L_1L_2} \\tag{2.6}\\]\n\n\n2.3.3 Independent sources\nIndependent sources are formated as if they are DC sources, even if the source is intended to be an AC source. The value of the source or its type, AC or DC, doesn’t matter when seeking a symbolic solution. The numeric value of the source can be changed when doing a numerical analysis, by following the procedures illustrated in the test or problem circuits. A voltage source is described by the following line.\nVXX N+ N- VALUE\nThe parameters are:\nN+ = the name of the positive terminal\nN- = the name of the negative terminal\nVALUE = the value of the DC voltage\nA current source is described by the following line.\nIXX N+ N- VALUE\nThe parameters are:\nN+= the name of the positive terminal, current leaves this terminal (pointy end of the arrow)\nN- = the name of the negative terminal\nVALUE = the value of the DC current\n\n\n2.3.4 Controlled sources\nThe voltage-controlled dependent sources are defined using statements of the form\nG/EXX nout+ nout- nc+ nc- gain\nwhere E is a voltage-controlled voltage source, G is a voltage-controlled current source, the output voltage is connected between nodes nout+ and nout-, and the control voltage is measured at node nc+ with respect to node nc-.\nExamples:\nE1 5 1 4 3 10 defines a voltage source that makes node 5 a voltage 10 times (v4 − v3) above the voltage at node 1.\nG1 2 1 5 8 50 defines a current source connected between node 2 (the + node) and node 1 and supplying a current 50 times (v5 − v8).\nThe current-controlled dependent sources are defined by statements of the form\nF/HXX nout+ nout- Vcontrol gain\nwhere F is a current-controlled current source, H is a current-controlled voltage source, and the output current source is connected between nodes nout+ and nout-, with positive current flowing through the source from node nout+ to nout-. The control current flows from the positive node of the source Vcontrol through the source and out the negative node.\nExamples:\nFds 11 9 Vsens 1.25 defines a current source connected from node 11 to node 9 that generates a current 1.25 times the current flowing through the source Vsens.\nH1 30 20 V5 100 defines a voltage source connected from node 30 to node 20 and supplying a voltage 100 times the current through the source V5. It is frequently necessary to add a voltage source with value 0 V to the circuit to sense the control current for these sources.\nThe direction of positive controlling current flow is from the positive node, through the source, to the negative node of VNAM. VALUE is the current gain.\n\n\n2.3.5 Op Amps\nAn opamp component is described by the following line.\nOXX N+ N- Vout\nThe output of the opamp is a voltage source. Two input terminals are at the same potential.\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results will be likely erroneous. Need to work on implementing a better opamp model.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#analysis-procedure",
    "href": "Theory.html#analysis-procedure",
    "title": "2  Theory",
    "section": "2.4 Analysis procedure",
    "text": "2.4 Analysis procedure\n\nDraw the circuit to be analyzed in LTSpice or some other schematic capture program. Label the nodes. The Symbolic Modified Network Analysis code will provide warnings for netlist formatting errors and non consecutive node numbering, but will still generate nodal equations which may be erroneous. Users should verify the results.\n\nExport the netlist of the circuit and convert component values to units of Ohms, Farads and Henrys. Use scientific notation, for example, replace component values such as 2k with 2e3 and 2u with 2e-6.\n\nChange Op Amp reference designators, for example U1 to O1 (capitol letter O, not zero).\n\nVoltage sources and current sources need to be set to zero in some cases. See test circuits and problem circuits for examples.\n\nCall the function smna(net_list). Follow the example in Chapter 4.\nSee the test and problem circuits for examples on how to use Python to do circuit analysis.\n\n\n\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html",
    "href": "SMNA_example.html",
    "title": "3  SMNA Example",
    "section": "",
    "text": "3.1 Introduction\nThis chapter walks through the Python code used to generate and solve the circuit network equations. Figure 3.1 is the schematic for the circuit used in this example. The analysis procedure first requires a circuit net list, which can be gernerated by hand with a text editor. For small circuits, such as those found in circuit analysis text books, this is not difficult since the number of nodes and components is small. College text book problems are usually ment by the authors to be solved with pencil and paper by hand. In this example LTSpice was used to draw the schematic and label the components and nodes. Most schematic caputure programs have the ability to export a SPICE net list, which then can be pasted in to the procedure outlined here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#circuit-description",
    "href": "SMNA_example.html#circuit-description",
    "title": "3  SMNA Example",
    "section": "3.2 Circuit description",
    "text": "3.2 Circuit description\nThe circuit in Figure 3.1 is a 2nd order band pass filter with magnetic coupling. The netlist generated by LTSpice is shown below.\nV1 1 0 AC 1\nR1 3 1 1k\nR4 2 0 10k\nC1 3 0 0.01µ\nC2 2 0 0.01µ\nL1 4 0 1µ\nL2 5 0 1µ\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe LTSpice net list requires some editing. The line in the netlist that defines the independent AC source, V1, needs to be formated as if it were a DC source. For symbolic analysis we are only concerned with the label for the source at this time. Later, in the this example, an AC analysis will be performed and \\(j \\omega\\) will be sustituted for the Laplace variable, \\(s\\). Also, the suffixes that SPICE allows in the compent values e.g., k and \\(\\mu\\), need to be replaced by their corresponding multiplication factors as shown below.\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe following Python modules are used:\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom tabulate import tabulate\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#symbolic-mna-code",
    "href": "SMNA_example.html#symbolic-mna-code",
    "title": "3  SMNA Example",
    "section": "3.3 Symbolic MNA code",
    "text": "3.3 Symbolic MNA code\nA count of the component types are initialized to zero.\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "href": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "title": "3  SMNA Example",
    "section": "3.4 Read the net list and preprocess it",
    "text": "3.4 Read the net list and preprocess it\nThe circuit netlist is paseted into the code cell below. A new line character is required at the end of each line and the tripple quotes in the code cell below preserve the line breaks.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\n'''\n\nThe code cell below peformes the following operations:\n\nsplit the net list into a list of lines at the line breaks\nremove blank lines and comments\n\nconvert first letter of element name to upper case\n\nremoves extra spaces between entries\n\n\ncontent = net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove SPICE directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\n# display the cleaned up netlist\nfor i in content:\n    print(i)\n\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 l1 l2 0.15\n\n\n\n3.4.1 Process each line in the netlist\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#parser",
    "href": "SMNA_example.html#parser",
    "title": "3  SMNA Example",
    "section": "3.5 Parser",
    "text": "3.5 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTspice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: opamp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n3.5.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n3.5.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n# Check for position of voltages sources in the dataframe.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # re-order the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#print-net-list-report",
    "href": "SMNA_example.html#print-net-list-report",
    "title": "3  SMNA Example",
    "section": "3.6 Print net list report",
    "text": "3.6 Print net list report\n\n# print a report\nprint('Net list report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 3\nnumber of RLC (passive components): 8\nnumber of inductors: 2\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 1\n\n\n\ndf\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n3\n1\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n2\nR4\n2\n0\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n3\nC1\n3\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n4\nC2\n2\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nL1\n4\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n6\nL2\n5\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n7\nR2\n4\n3\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nR3\n2\n5\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n9\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.15\nNaN\nL1\nL2\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nL1\n4\n0\n\n\n2\nL2\n5\n0\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed\n\n\n# initialize some symbolic matrix with zeros\n# A is formed by [[G, C] [B, D]]\n# Z = [I,E]\n# X = [V, J]\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\nDebugging notes: Is it possible to have i_unk == 0 ?, what about a network with only current sources? This would make B = 0 for example. Did one test, need to run others\nIs there a valid op amp case where B is n by 1? See test_14 and test_15.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#g-matrix",
    "href": "SMNA_example.html#g-matrix",
    "title": "3  SMNA Example",
    "section": "3.7 G matrix",
    "text": "3.7 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}}\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#b-matrix",
    "href": "SMNA_example.html#b-matrix",
    "title": "3  SMNA Example",
    "section": "3.8 B Matrix",
    "text": "3.8 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The code loop through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & 0\\\\0 & 1 & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#c-matrix",
    "href": "SMNA_example.html#c-matrix",
    "title": "3  SMNA Example",
    "section": "3.9 C matrix",
    "text": "3.9 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\n3.9.1 Op Amp elements\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results likely will be erroneous. Chen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the opamp stamp.\n\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#d-matrix",
    "href": "SMNA_example.html#d-matrix",
    "title": "3  SMNA Example",
    "section": "3.10 D matrix",
    "text": "3.10 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n\nm = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes: 12/6/2017 doing some debugging on with coupled inductors; LTspice seems to put the phasing dot on the neg node when it generates the netlist. This code uses M for mutual inductance, LTspice uses k for the coupling coefficient.\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0\\\\0 & - L_{1} s & - M_{1} s\\\\0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#v-matrix",
    "href": "SMNA_example.html#v-matrix",
    "title": "3  SMNA Example",
    "section": "3.11 V matrix",
    "text": "3.11 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#j-matrix",
    "href": "SMNA_example.html#j-matrix",
    "title": "3  SMNA Example",
    "section": "3.12 J matrix",
    "text": "3.12 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{L1}\\\\I_{L2}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#i-matrix",
    "href": "SMNA_example.html#i-matrix",
    "title": "3  SMNA Example",
    "section": "3.13 I matrix",
    "text": "3.13 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ev-matrix",
    "href": "SMNA_example.html#ev-matrix",
    "title": "3  SMNA Example",
    "section": "3.14 Ev matrix",
    "text": "3.14 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#z-matrix",
    "href": "SMNA_example.html#z-matrix",
    "title": "3  SMNA Example",
    "section": "3.15 Z matrix",
    "text": "3.15 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#x-matrix",
    "href": "SMNA_example.html#x-matrix",
    "title": "3  SMNA Example",
    "section": "3.16 X matrix",
    "text": "3.16 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#a-matrix",
    "href": "SMNA_example.html#a-matrix",
    "title": "3  SMNA Example",
    "section": "3.17 A matrix",
    "text": "3.17 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n    A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}} & 0 & 0 & 0\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0 & 0 & 1 & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 1\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & - L_{1} s & - M_{1} s\\\\0 & 0 & 0 & 0 & 1 & 0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#generate-the-circuit-equations",
    "href": "SMNA_example.html#generate-the-circuit-equations",
    "title": "3  SMNA Example",
    "section": "3.18 generate the circuit equations",
    "text": "3.18 generate the circuit equations\n\nequ = Eq(A*Matrix(X),Matrix(Z))\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\\\v_{2} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}}\\\\v_{3} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\\\I_{L1} - \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}}\\\\I_{L2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{5}}{R_{3}}\\\\v_{1}\\\\- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{4}\\\\- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#symbolic-solution",
    "href": "SMNA_example.html#symbolic-solution",
    "title": "3  SMNA Example",
    "section": "3.19 Symbolic solution",
    "text": "3.19 Symbolic solution\n\n# turn the free symbols into SymPy variables\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{2}, \\  V_{1}, \\  s, \\  R_{1}, \\  v_{5}, \\  v_{2}, \\  R_{2}, \\  C_{1}, \\  L_{1}, \\  L_{2}, \\  I_{L1}, \\  R_{4}, \\  I_{L2}, \\  v_{4}, \\  v_{3}, \\  R_{3}, \\  v_{1}, \\  M_{1}, \\  I_{V1}\\right)\\)\n\n\n\nsymbolic_solution = solve(equ,X) # solve the equations\n\nDisplay the solutions.\n\ntemp = ''\nfor i in symbolic_solution.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(symbolic_solution[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{M_{1} R_{4} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{3} = \\frac{C_{2} L_{1} L_{2} R_{4} V_{1} s^{3} + C_{2} L_{1} R_{3} R_{4} V_{1} s^{2} + C_{2} L_{2} R_{2} R_{4} V_{1} s^{2} - C_{2} M_{1}^{2} R_{4} V_{1} s^{3} + C_{2} R_{2} R_{3} R_{4} V_{1} s + L_{1} L_{2} V_{1} s^{2} + L_{1} R_{3} V_{1} s + L_{1} R_{4} V_{1} s + L_{2} R_{2} V_{1} s - M_{1}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1} + R_{2} R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{4} = \\frac{C_{2} L_{1} L_{2} R_{4} V_{1} s^{3} + C_{2} L_{1} R_{3} R_{4} V_{1} s^{2} - C_{2} M_{1}^{2} R_{4} V_{1} s^{3} + L_{1} L_{2} V_{1} s^{2} + L_{1} R_{3} V_{1} s + L_{1} R_{4} V_{1} s - M_{1}^{2} V_{1} s^{2}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{5} = \\frac{C_{2} M_{1} R_{3} R_{4} V_{1} s^{2} + M_{1} R_{3} V_{1} s + M_{1} R_{4} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} L_{1} L_{2} R_{4} V_{1} s^{4} - C_{1} C_{2} L_{1} R_{3} R_{4} V_{1} s^{3} - C_{1} C_{2} L_{2} R_{2} R_{4} V_{1} s^{3} + C_{1} C_{2} M_{1}^{2} R_{4} V_{1} s^{4} - C_{1} C_{2} R_{2} R_{3} R_{4} V_{1} s^{2} - C_{1} L_{1} L_{2} V_{1} s^{3} - C_{1} L_{1} R_{3} V_{1} s^{2} - C_{1} L_{1} R_{4} V_{1} s^{2} - C_{1} L_{2} R_{2} V_{1} s^{2} + C_{1} M_{1}^{2} V_{1} s^{3} - C_{1} R_{2} R_{3} V_{1} s - C_{1} R_{2} R_{4} V_{1} s - C_{2} L_{2} R_{4} V_{1} s^{2} - C_{2} R_{3} R_{4} V_{1} s - L_{2} V_{1} s - R_{3} V_{1} - R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{L1} = \\frac{C_{2} L_{2} R_{4} V_{1} s^{2} + C_{2} R_{3} R_{4} V_{1} s + L_{2} V_{1} s + R_{3} V_{1} + R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{L2} = \\frac{- C_{2} M_{1} R_{4} V_{1} s^{2} - M_{1} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\n\n\nThe transfer function at node 2 is:\n\nH_sym = symbolic_solution[v2]/symbolic_solution[v1]\nH_sym\n\n\\(\\displaystyle \\frac{M_{1} R_{4} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\n\n\nThe transfer function can be cleaned up with the help of SymPy. The coefficients of the Laplace term can be collected.\n\nH_sym.collect(s)\n\n\\(\\displaystyle \\frac{M_{1} R_{4} s}{R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)}\\)\n\n\nThe numerator and denominator can be extraxed from the expression.\n\nnum_sym, denom_sym = fraction(H_sym)\n\n\nnum_sym\n\n\\(\\displaystyle M_{1} R_{4} s\\)\n\n\n\ndenom_sym\n\n\\(\\displaystyle C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}\\)\n\n\nThe terms in the denominator can be collected by power of \\(s\\).\n\ndenom_sym.collect(s)\n\n\\(\\displaystyle R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)\\)\n\n\n\n#solve(denom_sym,s)\n\nThe code above was taking a long time, so it was interrupted and commented out.\n\n3.19.1 Built a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:f},'.format(df.iloc[i]['element'].lower(),df.iloc[i]['value']))\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:.4e},'.format(df.iloc[i]['element'],df.iloc[i]['value']))\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nThe mutual inductance between L1 and L2 is calculated from the coupling coeeficient.\n\\(M = k\\sqrt{L_1L_2}\\)\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.000000150\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  K_{1} : 0.15, \\  L_{1} : 1.0 \\cdot 10^{-6}, \\  L_{2} : 1.0 \\cdot 10^{-6}, \\  M_{1} : 1.5 \\cdot 10^{-7}, \\  R_{1} : 1000.0, \\  R_{2} : 0.5, \\  R_{3} : 0.5, \\  R_{4} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#numeric-solution",
    "href": "SMNA_example.html#numeric-solution",
    "title": "3  SMNA Example",
    "section": "3.20 Numeric solution",
    "text": "3.20 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ1a = equ.subs(element_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.0001\\right) - 2.0 v_{5}\\\\- 0.001 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.001\\right) - 2.0 v_{4}\\\\I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\\\I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\\\v_{1}\\\\- 1.0 \\cdot 10^{-6} I_{L1} s - 1.5 \\cdot 10^{-7} I_{L2} s + v_{4}\\\\- 1.5 \\cdot 10^{-7} I_{L1} s - 1.0 \\cdot 10^{-6} I_{L2} s + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s and displaying the transfer function.\n\nU = solve(equ1a,X)\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\nThe numerator and denominator can be extraxed from the expression.\n\nnum, denom = fraction(H)\n\n\nnum\n\n\\(\\displaystyle 6.0 \\cdot 10^{20} s\\)\n\n\n\ndenom\n\n\\(\\displaystyle 391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}\\)\n\n\nThe roots of the denominator can be obtained with the solve function.\n\nsolve(denom,s)\n\n\\(\\displaystyle \\left[ -321649.557914015 - 10842889.0903087 i, \\  -321649.557914015 + 10842889.0903087 i, \\  -244859.393492634 - 9323420.66838014 i, \\  -244859.393492634 + 9323420.66838014 i\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ac-analysis",
    "href": "SMNA_example.html#ac-analysis",
    "title": "3  SMNA Example",
    "section": "3.21 AC analysis",
    "text": "3.21 AC analysis\nSolve equations a frequency of 1.491MHz or \\(\\omega\\) equal to 9.3682292e6 radians per second, s = 9.3682292e6j.\n\nequ1a_1rad_per_s = equ1a.subs({s:9.3682292e6j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\v_{2} \\cdot \\left(2.0001 + 0.093682292 i\\right) - 2.0 v_{5}\\\\- 0.001 v_{1} + v_{3} \\cdot \\left(2.001 + 0.093682292 i\\right) - 2.0 v_{4}\\\\I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\\\I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\\\v_{1}\\\\- 9.3682292 i I_{L1} - 1.40523438 i I_{L2} + v_{4}\\\\- 1.40523438 i I_{L1} - 9.3682292 i I_{L2} + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in ans1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.101262    -21.012442\nv3         0.101577     -5.111761\nv4         0.101240     -2.443264\nv5         0.101378    -18.330736\nI_V1       0.000899   -179.423099\nI_L1       0.009469    -89.691641\nI_L2       0.009486   -111.073602",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ac-sweep",
    "href": "SMNA_example.html#ac-sweep",
    "title": "3  SMNA Example",
    "section": "3.22 AC Sweep",
    "text": "3.22 AC Sweep\nLooking at node 2 voltage.\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\n\nx = np.logspace(6, 6.5, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w/(2*np.pi), phase,':',color='b')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('peak: {:.2f} dB at {:.3f} MHz'.format(mag.max(),w[np.argmax(mag)]/(2*np.pi)/1e6,))\n\npeak: -19.89 dB at 1.490 MHz",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#summary",
    "href": "SMNA_example.html#summary",
    "title": "3  SMNA Example",
    "section": "3.23 Summary",
    "text": "3.23 Summary\nIn this chapter a walk through of the Python code that implements the symbolic MNA procedure was presented. The network equations in symbolic form were solved and the filter’s symbolic transfer function was obtained. Then the component values were substitued into the network equations and solved again. The node voltages were obtained at a descreat frequency and then an AC sweep was done for the transfer function.\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA-function.html",
    "href": "SMNA-function.html",
    "title": "4  SMNA function",
    "section": "",
    "text": "4.1 AC analysis\nAn AC analysis of the circuit can also be performed by substituting \\(j \\omega\\) for \\(s\\) in the network equations and solving for the voltage at any desired node. The independent voltage source can be adjusted to a different amplitude and phase.\nFor example, we can change the independent voltage source, V1, to have an amplitude of 10 at a frequency of 10 Hz with a phase of shift of 30 degrees.\nsource_amp = 10\nsource_phase = 30 # phase in degrees\nnew_V1 = source_amp*np.exp(1j*(source_phase*np.pi/180))\n\nfreq_Hz = 10 #Hz\nw = 2*np.pi*freq_Hz # radian frequency\n\nelement_values[V1] = new_V1\nequ_Nw = equ.subs(element_values)\nequ_Nw = equ_Nw.subs({s:1j*w})\nequ_Nw  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.00166666666666667 v_{1} - 0.00166666666666667 v_{2}\\\\I_{L1} - 0.00166666666666667 v_{1} + v_{2} \\cdot \\left(0.00166666666666667 + 2.38761041672824 \\cdot 10^{-5} i\\right)\\\\- I_{L1} + v_{3} \\cdot \\left(0.00166666666666667 + 2.38761041672824 \\cdot 10^{-5} i\\right)\\\\v_{1}\\\\- 9.55044166691297 i I_{L1} + v_{2} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\8.66025403784439 + 5.0 i\\\\0\\end{matrix}\\right]\\)\nAgain, we can use the SymPy function, solve, to get a solution for \\(V_1 = 10 sin(2 \\pi 10 t + 30)\\) and print the unknown voltages and currents.\nU_Nw = solve(equ_Nw,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_Nw .items():\n  table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1         10.000000     30.000000\nv2          4.999392     29.635345\nv3          4.999899     28.723214\nI_V1        0.008335   -149.635448\nI_L1        0.008334     29.543958\nThe values obtained from the Python code agree with the results from LTSpice.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SMNA function</span>"
    ]
  },
  {
    "objectID": "SMNA-function.html#summary",
    "href": "SMNA-function.html#summary",
    "title": "4  SMNA function",
    "section": "4.2 Summary",
    "text": "4.2 Summary\nIn this chapter the use of the function smna(net_list) was described and an example circuit was analyzed.\n\n\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SMNA function</span>"
    ]
  },
  {
    "objectID": "Validation-tests.html",
    "href": "Validation-tests.html",
    "title": "Validation tests",
    "section": "",
    "text": "Summary of test results\nLTSpice displays results using 6 digits, with zero to two digits to the left of the decimal point and the remainder of the digits to the right of the decimal point. The Python results can be displayed with 6 digits to the left of the decimal point. So when comparing the numerical results there will be some rounding differences. Most of the test circuits analyzed with the MNA Python code produced numerical results that were identical within rounding, to those obtained from LTSpice. however there were a few exceptions discussed below.",
    "crumbs": [
      "Validation tests"
    ]
  },
  {
    "objectID": "Validation-tests.html#summary-of-test-results",
    "href": "Validation-tests.html#summary-of-test-results",
    "title": "Validation tests",
    "section": "",
    "text": "Test circuit 8\n\nThe circuit shown above is the test circuit for Test 8. This circuit is too large to produce meaningful symbolic solutions. The numeric results obtained from the Python MNA code has larger differences to LTSpice than was typical for the other test circuits. There are small differences at \\(\\omega = 0\\) and \\(\\omega = 1\\) between the Python NMA code and LTSpice solutions; with the differences being less than 0.001. The results for the AC sweep had larger differences. The magnitude and phase results over the frequency range of 0.01 to 10 Hz shows that the magnitude difference was as much as 0.005 and the phase was as much as 0.02 difference. At this time I don’t have an explanation for the differences.\n\n\nTest circuit 12\n\nThe Python MNA code produced node voltage solutions for the AC sweep that were slightly different than those obtained from LTSpice for the test circuit shown above. The magnitude difference was at most 0.001 and the phase difference was as much as 0.175 degrees. I’m not sure why for some circuits there is an almost exact numerical agreement to the LTSpice results and for other circuits there is as much as a 0.001 difference.\n\n\nTest circuit 13\n\nThe circuit constructed for Test 13, shown above, was designed to see how the MNA code would handle such an unusual circuit. A loop of inductors and current sources is not a typical circuit configuration. LTSpice produced an error during the operating point analysis, whereas the Python MNA code would generate network equations without issue. However, the Python code would not produce a solution for all the circuit unknowns; the current in L4 was not determined. To fix this problem a small series resistor was added to L1.\nIf we stop to consider how the circuit is operating at DC, we see that each of the current sources have an inductor in parallel, which at DC, acts as a short circuit. Which means that the node voltages would all be equal, \\(v_1 = v_2 = v_3 = v_{ref}\\). So the solution to the network equations at DC should be \\(v_1 = v_2 = v_3 = 0\\). At a frequency of \\(\\omega = \\infty\\), the inductors would act as an open circuits and the currents flowing into each node would not be equal, because the current sources are not equal or opposite, so Kirchhoff’s current law would be violated. So this is a pathological case and such cases might not be obvious by inspection. Also, without the small series resistor added to L1, the AC analysis results produced by the Python MNA code agreed with the LTSpice results. The conclusion is that some sort of sanity check is needed for the circuit and just because the Python code spits out answers that are correct at some frequencies, it does not mean that the MNA circuit equations are valid at all frequencies.\n\n\nTest circuit 14\n\nThe circuit above was designed to have only one unknown current. The magnitude difference was at most 0.006 and the phase difference was as much as 0.6 degrees between the Python MNA and LTSpice results. It is kind of curious that circuits for Tests 12, 13, and 14 which are all driven by sinusoidal current sources have AC solutions which are slightly different than LTSpice.  \nThe following file types are in each github folder located here:\n\n\n\nTable 2: Test circuit files\n\n\n\n\n\n\n\n\n\nfile name\nDescription\n\n\n\n\ntest_*.asc\nLTSpice circuit schematic\n\n\nreadme.md\na description of the circuit\n\n\ntest_*.ipynb\ntest report Jupyter notebook\n\n\ntest_*.net\nSpice net list\n\n\ntest_*.png\nimage of the schematic for display in the notebook\n\n\ntest_*.csv\ncsv data exported from LTSpice",
    "crumbs": [
      "Validation tests"
    ]
  },
  {
    "objectID": "test_1.html",
    "href": "test_1.html",
    "title": "5  Test 1",
    "section": "",
    "text": "5.1 Load the net list\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\nnet_list = '''\nR2 1 2 1\nR3 4 3 1\nR4 2 5 2\nV1 1 0 2\nI1 4 0 9\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_1.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "5  Test 1",
    "section": "5.2 Call the symbolic modified nodal analysis function",
    "text": "5.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{F1} + v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} + \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\n\n\n\n5.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 4\nnumber of RLC (passive components): 4\nnumber of inductors: 0\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n5.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 1\\\\0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 1 & -1\\\\- \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{4}} & 0 & 0 & \\frac{1}{R_{4}} & 0 & -1 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1\\end{matrix}\\right]\\)\n\n\n\n\n5.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}\\right]\\)\n\n\n\n\n5.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0\\right]\\)\n\n\n\n\n5.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n3\nR3\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n4\nR4\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nI1\n4\n0\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n6\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n5.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n\n\n\n\n\n\n\n5.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} - \\frac{v_{4}}{R_{1}}\\\\I_{F1} + v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{1}}{R_{2}}\\\\I_{Ea1} - I_{F1} + \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{3}}\\\\v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{1}}\\\\- I_{V2} - \\frac{v_{2}}{R_{4}} + \\frac{v_{5}}{R_{4}}\\\\v_{1}\\\\- v_{5}\\\\- ea_{1} v_{1} + ea_{1} v_{4} + v_{3}\\\\I_{F1} - I_{V2} f_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\- I_{1}\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{4}, \\  f_{1}, \\  v_{2}, \\  R_{3}, \\  V_{1}, \\  v_{3}, \\  I_{V2}, \\  I_{V1}, \\  R_{1}, \\  I_{F1}, \\  ea_{1}, \\  v_{5}, \\  V_{2}, \\  I_{1}, \\  I_{Ea1}, \\  R_{2}, \\  v_{4}, \\  v_{1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#symbolic-solution",
    "href": "test_1.html#symbolic-solution",
    "title": "5  Test 1",
    "section": "5.3 Symbolic solution",
    "text": "5.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{2} V_{2} f_{1} + R_{2} V_{2} - R_{4} V_{1}}{R_{2} f_{1} - R_{2} - R_{4}}\\)\\(v_{3} = \\frac{I_{1} R_{1} R_{3} ea_{1} + R_{1} V_{1} ea_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}\\)\\(v_{4} = \\frac{- I_{1} R_{1} R_{3} + R_{1} V_{1} ea_{1} + R_{3} V_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}\\)\\(v_{5} = - V_{2}\\)\\(I_{V1} = \\frac{- I_{1} R_{2} R_{3} f_{1} + I_{1} R_{2} R_{3} + I_{1} R_{3} R_{4} - R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} ea_{1} - R_{1} V_{1} f_{1} + R_{1} V_{1} - R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} ea_{1} - R_{1} V_{2} f_{1} + R_{1} V_{2} - R_{2} V_{1} f_{1} + R_{2} V_{1} - R_{3} V_{1} f_{1} + R_{3} V_{1} - R_{3} V_{2} f_{1} + R_{3} V_{2} + R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}\\)\\(I_{V2} = \\frac{V_{1} + V_{2}}{R_{2} f_{1} - R_{2} - R_{4}}\\)\\(I_{Ea1} = \\frac{- I_{1} R_{1} R_{2} ea_{1} f_{1} + I_{1} R_{1} R_{2} ea_{1} - I_{1} R_{1} R_{2} f_{1} + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{4} ea_{1} + I_{1} R_{1} R_{4} + R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} f_{1} + R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} f_{1} + R_{2} V_{1} f_{1} - R_{2} V_{1} + R_{3} V_{1} f_{1} + R_{3} V_{2} f_{1} - R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}\\)\\(I_{F1} = \\frac{V_{1} f_{1} + V_{2} f_{1}}{R_{2} f_{1} - R_{2} - R_{4}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#construct-a-dictionary-of-element-values",
    "href": "test_1.html#construct-a-dictionary-of-element-values",
    "title": "5  Test 1",
    "section": "5.4 Construct a dictionary of element values",
    "text": "5.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 9.0, \\  R_{1} : 2.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{4} : 2.0, \\  V_{1} : 2.0, \\  V_{2} : 0.0, \\  ea_{1} : 2.0, \\  f_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#numerical-solution",
    "href": "test_1.html#numerical-solution",
    "title": "5  Test 1",
    "section": "5.5 Numerical solution",
    "text": "5.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.5 v_{1} - 1.0 v_{2} - 0.5 v_{4}\\\\I_{F1} - 1.0 v_{1} + 1.5 v_{2} - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} + 1.0 v_{3} - 1.0 v_{4}\\\\- 0.5 v_{1} - 1.0 v_{3} + 1.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\-9.0\\\\0\\\\2.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution. Six significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           4.000000\nv3           6.285714\nv4          -1.142857\nv5           0.000000\nI_V1         0.428571\nI_V2        -2.000000\nI_Ea1      -11.428571\nI_F1        -4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_2.html",
    "href": "test_2.html",
    "title": "6  Test 2",
    "section": "",
    "text": "6.1 Load the net list\nnet_list = '''\nR1 9 5 5\nR2 5 1 2\nR5 6 2 3\nR6 2 0 5\nR8 8 7 8\nR10 10 9 9\nR11 6 5 4\nR12 2 1 2\nR14 7 6 10\nR15 11 10 5\nV1 9 0 10\nV2 1 0 2\nV3 7 3 3\nV4 7 11 5\nI1 4 0 3\nI2 2 3 1\nI3 10 6 2\nI4 8 12 2\nR7 8 4 10\nR16 3 0 6\nR3 12 11 10\nR4 4 3 3\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_2.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "6  Test 2",
    "section": "6.2 Call the symbolic modified nodal analysis function",
    "text": "6.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = - I_{1}\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{6}}{R_{11}} - \\frac{v_{9}}{R_{1}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{7}}{R_{14}} - \\frac{v_{5}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{7} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{6}}{R_{14}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{8}} - \\frac{v_{4}}{R_{7}} = - I_{4}\\)\\(I_{V1} + v_{9} \\cdot \\left(\\frac{1}{R_{10}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{10}} - \\frac{v_{5}}{R_{1}} = 0\\)\\(v_{10} \\cdot \\left(\\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{11}}{R_{15}} - \\frac{v_{9}}{R_{10}} = - I_{3}\\)\\(- I_{V4} + v_{11} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{12}}{R_{3}} - \\frac{v_{10}}{R_{15}} = 0\\)\\(- \\frac{v_{11}}{R_{3}} + \\frac{v_{12}}{R_{3}} = I_{4}\\)\\(v_{9} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(- v_{3} + v_{7} = V_{3}\\)\\(- v_{11} + v_{7} = V_{4}\\)\n\n\n\n6.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 22\nnumber of branches: 22\nnumber of nodes: 12\nnumber of unknown currents: 4\nnumber of RLC (passive components): 14\nnumber of inductors: 0\nnumber of independent voltage sources: 4\nnumber of independent current sources: 4\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n6.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & - \\frac{1}{R_{5}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\\\0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & - \\frac{1}{R_{8}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & \\frac{1}{R_{10}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{10}} & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{10}} & \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{3}} + \\frac{1}{R_{15}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n6.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}\\right]\\)\n\n\n\n\n6.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  - I_{1}, \\  0, \\  I_{3}, \\  0, \\  - I_{4}, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}\\right]\\)\n\n\n\n\n6.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n9\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n7\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n7\n11\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nR1\n9\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n5\nR2\n5\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n6\nR5\n6\n2\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n7\nR6\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n8\nR8\n8\n7\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n9\nR10\n10\n9\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n10\nR11\n6\n5\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n11\nR12\n2\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n12\nR14\n7\n6\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n13\nR15\n11\n10\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n14\nI1\n4\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n15\nI2\n2\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n16\nI3\n10\n6\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n17\nI4\n8\n12\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n18\nR7\n8\n4\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n19\nR16\n3\n0\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n20\nR3\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n21\nR4\n4\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n6.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n9\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n7\n3\n\n\n3\nV4\n7\n11\n\n\n\n\n\n\n\n\n\n6.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{2}}{R_{12}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{1}}{R_{12}}\\\\- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}}\\\\v_{4} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{6}}{R_{11}} - \\frac{v_{9}}{R_{1}}\\\\v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{7}}{R_{14}} - \\frac{v_{5}}{R_{11}}\\\\I_{V3} + I_{V4} + v_{7} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{6}}{R_{14}}\\\\v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{8}} - \\frac{v_{4}}{R_{7}}\\\\I_{V1} + v_{9} \\cdot \\left(\\frac{1}{R_{10}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{10}} - \\frac{v_{5}}{R_{1}}\\\\v_{10} \\cdot \\left(\\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{11}}{R_{15}} - \\frac{v_{9}}{R_{10}}\\\\- I_{V4} + v_{11} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{12}}{R_{3}} - \\frac{v_{10}}{R_{15}}\\\\- \\frac{v_{11}}{R_{3}} + \\frac{v_{12}}{R_{3}}\\\\v_{9}\\\\v_{1}\\\\- v_{3} + v_{7}\\\\- v_{11} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\- I_{2}\\\\I_{2}\\\\- I_{1}\\\\0\\\\I_{3}\\\\0\\\\- I_{4}\\\\0\\\\- I_{3}\\\\0\\\\I_{4}\\\\V_{1}\\\\V_{2}\\\\V_{3}\\\\V_{4}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{4}, \\  R_{10}, \\  R_{6}, \\  V_{1}, \\  I_{3}, \\  R_{2}, \\  v_{9}, \\  R_{5}, \\  R_{8}, \\  v_{12}, \\  R_{14}, \\  I_{V4}, \\  v_{7}, \\  v_{2}, \\  I_{2}, \\  I_{4}, \\  R_{12}, \\  V_{2}, \\  I_{V3}, \\  I_{V1}, \\  R_{3}, \\  v_{6}, \\  R_{7}, \\  v_{8}, \\  R_{15}, \\  v_{11}, \\  R_{16}, \\  V_{4}, \\  I_{V2}, \\  I_{1}, \\  v_{4}, \\  R_{11}, \\  R_{1}, \\  v_{1}, \\  v_{5}, \\  V_{3}, \\  v_{10}, \\  v_{3}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#symbolic-solution",
    "href": "test_2.html#symbolic-solution",
    "title": "6  Test 2",
    "section": "6.3 Symbolic solution",
    "text": "6.3 Symbolic solution\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#construct-a-dictionary-of-element-values",
    "href": "test_2.html#construct-a-dictionary-of-element-values",
    "title": "6  Test 2",
    "section": "6.4 Construct a dictionary of element values",
    "text": "6.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 3.0, \\  I_{2} : 1.0, \\  I_{3} : 2.0, \\  I_{4} : 2.0, \\  R_{1} : 5.0, \\  R_{10} : 9.0, \\  R_{11} : 4.0, \\  R_{12} : 2.0, \\  R_{14} : 10.0, \\  R_{15} : 5.0, \\  R_{16} : 6.0, \\  R_{2} : 2.0, \\  R_{3} : 10.0, \\  R_{4} : 3.0, \\  R_{5} : 3.0, \\  R_{6} : 5.0, \\  R_{7} : 10.0, \\  R_{8} : 8.0, \\  V_{1} : 10.0, \\  V_{2} : 2.0, \\  V_{3} : 3.0, \\  V_{4} : 5.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#numerical-solution",
    "href": "test_2.html#numerical-solution",
    "title": "6  Test 2",
    "section": "6.5 Numerical solution",
    "text": "6.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{5}\\\\- 0.5 v_{1} + 1.03333333333333 v_{2} - 0.333333333333333 v_{6}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\- 0.333333333333333 v_{3} + 0.433333333333333 v_{4} - 0.1 v_{8}\\\\- 0.5 v_{1} + 0.95 v_{5} - 0.25 v_{6} - 0.2 v_{9}\\\\- 0.333333333333333 v_{2} - 0.25 v_{5} + 0.683333333333333 v_{6} - 0.1 v_{7}\\\\I_{V3} + I_{V4} - 0.1 v_{6} + 0.225 v_{7} - 0.125 v_{8}\\\\- 0.1 v_{4} - 0.125 v_{7} + 0.225 v_{8}\\\\I_{V1} - 0.111111111111111 v_{10} - 0.2 v_{5} + 0.311111111111111 v_{9}\\\\0.311111111111111 v_{10} - 0.2 v_{11} - 0.111111111111111 v_{9}\\\\- I_{V4} - 0.2 v_{10} + 0.3 v_{11} - 0.1 v_{12}\\\\- 0.1 v_{11} + 0.1 v_{12}\\\\v_{9}\\\\v_{1}\\\\- v_{3} + v_{7}\\\\- v_{11} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\-1.0\\\\1.0\\\\-3.0\\\\0\\\\2.0\\\\0\\\\-2.0\\\\0\\\\-2.0\\\\0\\\\2.0\\\\10.0\\\\2.0\\\\3.0\\\\5.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           1.532489\nv3          -6.665281\nv4         -16.236710\nv5           4.408083\nv6           4.750715\nv7          -3.665281\nv8         -18.141472\nv9          10.000000\nv10         -8.427681\nv11         -8.665281\nv12         11.334719\nI_V1        -3.165903\nI_V2         0.970286\nI_V3         1.079596\nI_V4        -2.047520\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(9):    10  voltage\nV(5):    4.40808     voltage\nV(1):    2   voltage\nV(6):    4.75072     voltage\nV(2):    1.53249     voltage\nV(8):    -18.1415    voltage\nV(7):    -3.66528    voltage\nV(10):   -8.42768    voltage\nV(11):   -8.66528    voltage\nV(3):    -6.66528    voltage\nV(4):    -16.2367    voltage\nV(12):   11.3347     voltage\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   1.11838     device_current\nI(R2):   1.20404     device_current\nI(R5):   1.07274     device_current\nI(R6):   0.306498    device_current\nI(R8):   -1.80952    device_current\nI(R10):  -2.04752    device_current\nI(R11):  0.0856581   device_current\nI(R12):  -0.233756   device_current\nI(R14):  -0.8416     device_current\nI(R15):  -0.0475201  device_current\nI(R7):   -0.190476   device_current\nI(R16):  -1.11088    device_current\nI(R3):   2   device_current\nI(R4):   -3.19048    device_current\nI(V1):   -3.1659     device_current\nI(V2):   0.970286    device_current\nI(V3):   1.0796  device_current\nI(V4):   -2.04752    device_current\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_3.html",
    "href": "test_3.html",
    "title": "7  Test 3",
    "section": "",
    "text": "7.1 Load the net list\nnet_list = '''\nR2 2 5 2\nV1 1 0 1\nI1 4 0 9\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\nC1 1 2 1\nL1 4 3 1\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_3.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "7  Test 3",
    "section": "7.2 Call the symbolic modified nodal analysis function",
    "text": "7.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{2} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{1} s v_{1} + I_{F1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} - I_{L1} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{5}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- I_{L1} L_{1} s - v_{3} + v_{4} = 0\\)\n\n\n\n7.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 5\nnumber of RLC (passive components): 4\nnumber of inductors: 1\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n7.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{1}} & - C_{1} s & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0 & 0\\\\- C_{1} s & C_{1} s + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & -1\\\\- \\frac{1}{R_{1}} & 0 & 0 & \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & - \\frac{1}{R_{2}} & 0 & 0 & \\frac{1}{R_{2}} & 0 & -1 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0\\\\0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & - L_{1} s\\end{matrix}\\right]\\)\n\n\n\n\n7.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}, \\  I_{L1}\\right]\\)\n\n\n\n\n7.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n7.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nI1\n4\n0\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n4\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n6\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nC1\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n8\nL1\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n7.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n4\nL1\n4\n3\n\n\n\n\n\n\n\n\n\n7.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{2} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}}\\\\- C_{1} s v_{1} + I_{F1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}}\\\\- I_{V2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{5}}{R_{2}}\\\\v_{1}\\\\- v_{5}\\\\- ea_{1} v_{1} + ea_{1} v_{4} + v_{3}\\\\I_{F1} - I_{V2} f_{1}\\\\- I_{L1} L_{1} s - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\- I_{1}\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( ea_{1}, \\  R_{1}, \\  I_{1}, \\  V_{1}, \\  f_{1}, \\  v_{1}, \\  v_{4}, \\  I_{F1}, \\  v_{2}, \\  I_{V2}, \\  I_{Ea1}, \\  v_{3}, \\  I_{L1}, \\  L_{1}, \\  I_{V1}, \\  V_{2}, \\  s, \\  v_{5}, \\  R_{2}, \\  C_{1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#symbolic-solution",
    "href": "test_3.html#symbolic-solution",
    "title": "7  Test 3",
    "section": "7.3 Symbolic solution",
    "text": "7.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} R_{2} V_{1} s + V_{2} f_{1} - V_{2}}{C_{1} R_{2} s - f_{1} + 1}\\)\\(v_{3} = \\frac{I_{1} L_{1} R_{1} ea_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)\\(v_{4} = \\frac{- I_{1} L_{1} R_{1} s + L_{1} V_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)\\(v_{5} = - V_{2}\\)\\(I_{V1} = \\frac{- C_{1} I_{1} L_{1} R_{2} s^{2} + C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{1} s^{2} + C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} L_{1} V_{2} s^{2} + C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} ea_{1} s + C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{1} s + C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} s + C_{1} R_{1} V_{2} f_{1} s - C_{1} R_{1} V_{2} s - C_{1} R_{2} V_{1} s + I_{1} L_{1} f_{1} s - I_{1} L_{1} s + V_{1} f_{1} - V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}\\)\\(I_{V2} = \\frac{- C_{1} V_{1} s - C_{1} V_{2} s}{C_{1} R_{2} s - f_{1} + 1}\\)\\(I_{Ea1} = \\frac{- C_{1} I_{1} R_{1} R_{2} ea_{1} s - C_{1} I_{1} R_{1} R_{2} s - C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} f_{1} s + C_{1} R_{2} V_{1} s + I_{1} R_{1} ea_{1} f_{1} - I_{1} R_{1} ea_{1} + I_{1} R_{1} f_{1} - I_{1} R_{1} - V_{1} f_{1} + V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}\\)\\(I_{F1} = \\frac{- C_{1} V_{1} f_{1} s - C_{1} V_{2} f_{1} s}{C_{1} R_{2} s - f_{1} + 1}\\)\\(I_{L1} = \\frac{- I_{1} R_{1} ea_{1} - I_{1} R_{1} + V_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#construct-a-dictionary-of-element-values",
    "href": "test_3.html#construct-a-dictionary-of-element-values",
    "title": "7  Test 3",
    "section": "7.4 Construct a dictionary of element values",
    "text": "7.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  I_{1} : 9.0, \\  L_{1} : 1.0, \\  R_{1} : 2.0, \\  R_{2} : 2.0, \\  V_{1} : 1.0, \\  V_{2} : 0.0, \\  ea_{1} : 2.0, \\  f_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#dc-operating-point",
    "href": "test_3.html#dc-operating-point",
    "title": "7  Test 3",
    "section": "7.5 DC operating point",
    "text": "7.5 DC operating point\nBoth V1 and I1 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.5 v_{1} - 0.5 v_{4}\\\\I_{F1} + 0.5 v_{2} - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\-9.0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          1.000000\nv2          0.000000\nv3          0.666667\nv4          0.666667\nv5          0.000000\nI_V1       -0.166667\nI_V2        0.000000\nI_Ea1      -8.833333\nI_F1        0.000000\nI_L1       -8.833333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    -2e-12  voltage\nV(5):    0   voltage\nV(1):    1   voltage\nV(4):    0.666667    voltage\nV(3):    0.666667    voltage\nI(C1):   1e-12   device_current\nI(F1):   2e-12   device_current\nI(L1):   -8.83333    device_current\nI(I1):   9   device_current\nI(R2):   -1e-12  device_current\nI(R1):   0.166667    device_current\nI(E1):   -8.83333    device_current\nI(V1):   -0.166667   device_current\nI(V2):   1e-12   device_current\nThe results from LTSpice agree with the SymPy results.\n\n7.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I1 = 0\n\nelement_values[I1] = 0\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.5 + 1.0 i\\right) - 1.0 i v_{2} - 0.5 v_{4}\\\\I_{F1} - 1.0 i v_{1} + v_{2} \\cdot \\left(0.5 + 1.0 i\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 i I_{L1} - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.894427    -26.565051\nv3         0.657596     -9.462322\nv4         0.677834      4.573921\nv5         0.000000    nan\nI_V1       0.294086    -36.027373\nI_V2       0.447214    153.434949\nI_Ea1      0.738882    149.683220\nI_F1       0.894427    153.434949\nI_L1       0.164399     -9.462322\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:   0.894427 phase:   -26.5651°  voltage\nV(5):   mag:          0 phase:          0°  voltage\nV(1):   mag:          1 phase:          0°  voltage\nV(4):   mag:   0.677834 phase:    4.57392°  voltage\nV(3):   mag:   0.657596 phase:   -9.46232°  voltage\nI(C1):  mag:   0.447214 phase:    153.435°  device_current\nI(F1):  mag:   0.894427 phase:    153.435°  device_current\nI(L1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(R2):  mag:   0.447214 phase:   -26.5651°  device_current\nI(R1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(E1):  mag:   0.738882 phase:    149.683°  device_current\nI(V1):  mag:   0.294086 phase:   -36.0274°  device_current\nI(V2):  mag:   0.447214 phase:    153.435°  device_current\n\n\n7.5.2 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. Thr frequenct weep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 1.0 s v_{2} + v_{1} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{4}\\\\I_{F1} - 1.0 s v_{1} + v_{2} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 I_{L1} s - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n7.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_3.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_4.html",
    "href": "test_4.html",
    "title": "8  Test 4",
    "section": "",
    "text": "8.1 Load the net list\nnet_list = '''\nV4 1 2 10\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR5 4 8 5\nR9 1 9 9\nR1 1 5 3\nR10 8 0 10\nR13 9 11 7\nR14 10 9 10\nR15 0 11 3\nR2 3 5 5\nR6 7 1 2\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_4.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "8  Test 4",
    "section": "8.2 Call the symbolic modified nodal analysis function",
    "text": "8.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V4} + v_{1} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) - \\frac{v_{9}}{R_{9}} - \\frac{v_{7}}{R_{6}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(\\frac{v_{4}}{R_{5}} - \\frac{v_{8}}{R_{5}} = I_{2}\\)\\(I_{F1} - I_{V2} + v_{1} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- g_{1} v_{4} + g_{1} v_{9} + v_{7} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{1}}{R_{6}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} - \\frac{v_{4}}{R_{5}} = 0\\)\\(- I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{1}}{R_{9}} - \\frac{v_{11}}{R_{13}} = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\n\n\n\n8.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 26\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 6\nnumber of RLC (passive components): 18\nnumber of inductors: 0\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n8.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccc}\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} - \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{6}} & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{5}} & 0 & 0 & 0 & - \\frac{1}{R_{5}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{3}} - \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{6}} & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & \\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & - \\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & - \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{13}} & 0 & \\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n8.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}\\right]\\)\n\n\n\n\n8.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n8.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR5\n4\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n11\nR9\n1\n9\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n12\nR1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n13\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n14\nR13\n9\n11\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n15\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n16\nR15\n0\n11\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n17\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n18\nR6\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n19\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n20\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n21\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n22\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n23\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n24\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n25\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n8.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n\n\n\n\n\n\n\n8.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V4} + v_{1} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) - \\frac{v_{9}}{R_{9}} - \\frac{v_{7}}{R_{6}}\\\\I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}}\\\\- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}}\\\\\\frac{v_{4}}{R_{5}} - \\frac{v_{8}}{R_{5}}\\\\I_{F1} - I_{V2} + v_{1} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}}\\\\- g_{1} v_{4} + g_{1} v_{9} + v_{7} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{1}}{R_{6}} - \\frac{v_{3}}{R_{4}}\\\\v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} - \\frac{v_{4}}{R_{5}}\\\\- I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{1}}{R_{9}} - \\frac{v_{11}}{R_{13}}\\\\g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right)\\\\v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}}\\\\I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}}\\\\I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - I_{V1} f_{1}\\\\ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3}\\\\- I_{V2} h_{1} - v_{12} + v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{2}\\\\I_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{4}\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{H1}, \\  v_{12}, \\  v_{10}, \\  v_{7}, \\  v_{6}, \\  V_{4}, \\  v_{13}, \\  R_{15}, \\  v_{2}, \\  R_{14}, \\  f_{1}, \\  R_{18}, \\  I_{V1}, \\  I_{F1}, \\  R_{8}, \\  v_{9}, \\  v_{3}, \\  I_{Ea1}, \\  R_{13}, \\  R_{1}, \\  R_{4}, \\  R_{16}, \\  I_{V4}, \\  R_{12}, \\  v_{11}, \\  v_{4}, \\  v_{1}, \\  R_{11}, \\  h_{1}, \\  R_{17}, \\  R_{2}, \\  v_{8}, \\  g_{1}, \\  I_{V2}, \\  R_{7}, \\  R_{9}, \\  ea_{1}, \\  R_{10}, \\  R_{3}, \\  v_{5}, \\  I_{2}, \\  V_{2}, \\  R_{6}, \\  V_{1}, \\  R_{5}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#symbolic-solution",
    "href": "test_4.html#symbolic-solution",
    "title": "8  Test 4",
    "section": "8.3 Symbolic solution",
    "text": "8.3 Symbolic solution\nSymbolic solution commented out\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#construct-a-dictionary-of-element-values",
    "href": "test_4.html#construct-a-dictionary-of-element-values",
    "title": "8  Test 4",
    "section": "8.4 Construct a dictionary of element values",
    "text": "8.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{2} : 5.0, \\  R_{1} : 3.0, \\  R_{10} : 10.0, \\  R_{11} : 5.0, \\  R_{12} : 9.0, \\  R_{13} : 7.0, \\  R_{14} : 10.0, \\  R_{15} : 3.0, \\  R_{16} : 10.0, \\  R_{17} : 8.0, \\  R_{18} : 4.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  R_{4} : 1.0, \\  R_{5} : 5.0, \\  R_{6} : 2.0, \\  R_{7} : 6.0, \\  R_{8} : 5.0, \\  R_{9} : 9.0, \\  V_{1} : 0.0, \\  V_{2} : 0.0, \\  V_{4} : 10.0, \\  ea_{1} : 3.0, \\  f_{1} : 5.0, \\  g_{1} : 2.0, \\  h_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#numerical-solution",
    "href": "test_4.html#numerical-solution",
    "title": "8  Test 4",
    "section": "8.5 Numerical solution",
    "text": "8.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V4} + 1.04444444444444 v_{1} - 0.433333333333333 v_{5} - 0.5 v_{7} - 0.111111111111111 v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.2 v_{4} - 0.2 v_{8}\\\\I_{F1} - I_{V2} - 0.433333333333333 v_{1} - 0.2 v_{3} + 0.633333333333333 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 0.5 v_{1} - 1.0 v_{3} - 2.0 v_{4} + 1.66666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.2 v_{4} - 0.166666666666667 v_{7} + 0.666666666666667 v_{8}\\\\- I_{F1} - 0.111111111111111 v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.553968253968254 v_{9}\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\0.576190476190476 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-5.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          -2.528148\nv2         -12.528148\nv3         -26.854161\nv4          18.928828\nv5         -21.885182\nv6         -26.854161\nv7         -14.774289\nv8          -6.071172\nv9          16.675687\nv10          1.207520\nv11          1.418845\nv12        -15.647159\nv13        -21.885182\nI_V4       -12.377360\nI_V1         1.790752\nI_V2         1.559506\nI_F1         8.953758\nI_Ea1      -14.021017\nI_H1       -14.168112\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -2.52815    voltage\nV(2):    -12.5281    voltage\nV(3):    -26.8542    voltage\nV(4):    18.9288     voltage\nV(5):    -21.8852    voltage\nV(9):    16.6757     voltage\nV(12):   -15.6472    voltage\nV(10):   1.20752     voltage\nV(7):    -14.7743    voltage\nV(8):    -6.07117    voltage\nV(11):   1.41885     voltage\nV(6):    -26.8542    voltage\nV(13):   -21.8852    voltage\nI(F1):   8.95376     device_current\nI(H1):   -14.1681    device_current\nI(I2):   5   device_current\nI(R3):   -1.9357     device_current\nI(R4):   -12.0799    device_current\nI(R5):   5   device_current\nI(R9):   -2.13376    device_current\nI(R1):   6.45234     device_current\nI(R10):  -0.607117   device_current\nI(R13):  2.17955     device_current\nI(R14):  -1.54682    device_current\nI(R15):  -0.472948   device_current\nI(R2):   -0.993796   device_current\nI(R6):   -6.12307    device_current\nI(R7):   1.45052     device_current\nI(R11):  -3.09363    device_current\nI(R12):  -0.134169   device_current\nI(R16):  -1.7066     device_current\nI(R8):   -4.1566     device_current\nI(R17):  1.79075     device_current\nI(R18):  1.55951     device_current\nI(G1):   -4.50628    device_current\nI(E1):   -14.021     device_current\nI(V4):   -12.3774    device_current\nI(V1):   1.79075     device_current\nI(V2):   1.55951     device_current\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_5.html",
    "href": "test_5.html",
    "title": "9  Test 5",
    "section": "",
    "text": "9.1 Load the net list\nnet_list = '''\nV4 1 2 20\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR9 4 8 9\nR10 8 0 10\nR13 9 11 7\nR14 10 9 10\nR2 3 5 5\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\nC1 7 1 2\nC2 1 9 5\nL1 1 5 3 \nL2 0 11 8 \n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_5.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "9  Test 5",
    "section": "9.2 Call the symbolic modified nodal analysis function",
    "text": "9.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(\\frac{v_{4}}{R_{9}} - \\frac{v_{8}}{R_{9}} = I_{2}\\)\\(I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{4}}{R_{9}} - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{2} s v_{1} - I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{11}}{R_{13}} = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(- I_{L2} + v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L2} L_{2} s - v_{11} = 0\\)\n\n\n\n9.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 26\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 8\nnumber of RLC (passive components): 18\nnumber of inductors: 2\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n9.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccccc}C_{1} s + C_{2} s + \\frac{1}{R_{3}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} & 0 & - C_{1} s & 0 & - C_{2} s & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{9}} & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{3}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{1} s & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & - \\frac{1}{R_{9}} & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & - \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{13}} & 0 & \\frac{1}{R_{16}} + \\frac{1}{R_{13}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{2} s\\end{array}\\right]\\)\n\n\n\n\n9.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}\\right]\\)\n\n\n\n\n9.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n9.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR9\n4\n8\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n11\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n12\nR13\n9\n11\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n13\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n14\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n15\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n16\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n17\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n18\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n19\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n20\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n21\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n22\nC1\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n23\nC2\n1\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n24\nL1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n25\nL2\n0\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n9.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n6\nL1\n1\n5\n\n\n7\nL2\n0\n11\n\n\n\n\n\n\n\n\n\n9.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}}\\\\I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}}\\\\- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}}\\\\\\frac{v_{4}}{R_{9}} - \\frac{v_{8}}{R_{9}}\\\\I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}}\\\\I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}}\\\\- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}}\\\\v_{8} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{4}}{R_{9}} - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}}\\\\- C_{2} s v_{1} - I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{11}}{R_{13}}\\\\g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right)\\\\- I_{L2} + v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}}\\\\I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}}\\\\I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - I_{V1} f_{1}\\\\ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3}\\\\- I_{V2} h_{1} - v_{12} + v_{2}\\\\- I_{L1} L_{1} s + v_{1} - v_{5}\\\\- I_{L2} L_{2} s - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{2}\\\\I_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{4}\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{F1}, \\  v_{12}, \\  R_{2}, \\  I_{Ea1}, \\  R_{17}, \\  v_{2}, \\  ea_{1}, \\  C_{1}, \\  v_{5}, \\  I_{V2}, \\  g_{1}, \\  R_{14}, \\  R_{13}, \\  f_{1}, \\  R_{9}, \\  v_{7}, \\  s, \\  v_{3}, \\  R_{3}, \\  R_{7}, \\  R_{10}, \\  v_{4}, \\  I_{H1}, \\  I_{2}, \\  I_{L1}, \\  I_{V4}, \\  V_{4}, \\  V_{1}, \\  v_{6}, \\  v_{9}, \\  R_{12}, \\  I_{V1}, \\  v_{8}, \\  v_{1}, \\  v_{10}, \\  R_{16}, \\  v_{11}, \\  I_{L2}, \\  h_{1}, \\  L_{2}, \\  R_{18}, \\  C_{2}, \\  v_{13}, \\  R_{11}, \\  V_{2}, \\  R_{8}, \\  R_{4}, \\  L_{1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#symbolic-solution",
    "href": "test_5.html#symbolic-solution",
    "title": "9  Test 5",
    "section": "9.3 Symbolic solution",
    "text": "9.3 Symbolic solution\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#construct-a-dictionary-of-element-values",
    "href": "test_5.html#construct-a-dictionary-of-element-values",
    "title": "9  Test 5",
    "section": "9.4 Construct a dictionary of element values",
    "text": "9.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  C_{2} : 5.0, \\  I_{2} : 5.0, \\  L_{1} : 3.0, \\  L_{2} : 8.0, \\  R_{10} : 10.0, \\  R_{11} : 5.0, \\  R_{12} : 9.0, \\  R_{13} : 7.0, \\  R_{14} : 10.0, \\  R_{16} : 10.0, \\  R_{17} : 8.0, \\  R_{18} : 4.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  R_{4} : 1.0, \\  R_{7} : 6.0, \\  R_{8} : 5.0, \\  R_{9} : 9.0, \\  V_{1} : 0.0, \\  V_{2} : 0.0, \\  V_{4} : 20.0, \\  ea_{1} : 3.0, \\  f_{1} : 5.0, \\  g_{1} : 2.0, \\  h_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#dc-operating-point",
    "href": "test_5.html#dc-operating-point",
    "title": "9  Test 5",
    "section": "9.5 DC operating point",
    "text": "9.5 DC operating point\nBoth V4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + 0.1 v_{1} - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 1.0 v_{3} - 2.0 v_{4} + 1.16666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.442857142857143 v_{9}\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\v_{1} - v_{5}\\\\- v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-5.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          -5.020059\nv2         -25.020059\nv3         -40.666907\nv4          26.781121\nv5          -5.020059\nv6         -40.666907\nv7         -32.212572\nv8         -18.218879\nv9          23.720095\nv10          2.417779\nv11          0.000000\nv12        -18.353392\nv13         -5.020059\nI_V4       -20.241983\nI_V1         1.955856\nI_V2        -3.333333\nI_F1         9.779280\nI_Ea1      -17.029166\nI_H1       -22.197839\nI_L1        20.241983\nI_L2        -1.553246\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -5.02006    voltage\nV(2):    -25.0201    voltage\nV(3):    -40.6669    voltage\nV(4):    26.7811     voltage\nV(5):    -5.02006    voltage\nV(9):    23.7201     voltage\nV(12):   -18.3534    voltage\nV(10):   2.41778     voltage\nV(7):    -32.2126    voltage\nV(8):    -18.2189    voltage\nV(11):   0   voltage\nV(6):    -40.6669    voltage\nV(13):   -5.02006    voltage\nI(C1):   -5.4385e-11     device_current\nI(C2):   -1.43701e-10    device_current\nI(F1):   9.77928     device_current\nI(H1):   -22.1978    device_current\nI(L1):   20.242  device_current\nI(L2):   -1.55325    device_current\nI(I2):   5   device_current\nI(R3):   -8.88178e-16    device_current\nI(R4):   -8.45434    device_current\nI(R9):   5   device_current\nI(R10):  -1.82189    device_current\nI(R13):  3.38859     device_current\nI(R14):  -2.13023    device_current\nI(R2):   -7.12937    device_current\nI(R7):   2.33228     device_current\nI(R11):  -4.26046    device_current\nI(R12):  -0.268642   device_current\nI(R16):  -1.83534    device_current\nI(R8):   -4.48961    device_current\nI(R17):  1.95586     device_current\nI(R18):  -3.33333    device_current\nI(G1):   -6.12205    device_current\nI(E1):   -17.0292    device_current\nI(V4):   -20.242     device_current\nI(V1):   1.95586     device_current\nI(V2):   -3.33333    device_current\nThe results from LTSpice agree with the SymPy results.\n\n9.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I2 = 0\n\nelement_values[I2] = 0\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 5.0 i v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(0.442857142857143 + 5.0 i\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- 3.0 i I_{L1} + v_{1} - v_{5}\\\\- 8.0 i I_{L2} - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          3.599764    -52.169011\nv2         18.017879   -170.920917\nv3          1.855665     65.635428\nv4          1.903808      8.371520\nv5         14.354390     47.295045\nv6          1.855665     65.635428\nv7          4.531708    -16.043028\nv8          1.903808      8.371520\nv9          1.498280    -10.433515\nv10         3.010258   -107.783771\nv11         2.426237   -163.488259\nv12         8.767364    169.347366\nv13        14.354390     47.295045\nI_V4       10.838028   -177.106564\nI_V1        2.387928   -166.271733\nI_V2        5.102027   -154.058091\nI_F1       11.939640   -166.271733\nI_Ea1       3.858821    148.425320\nI_H1        8.504523    179.867890\nI_L1        5.120760    150.658972\nI_L2        0.303280    -73.488259\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    3.59976 phase:    -52.169°  voltage\nV(2):   mag:    18.0179 phase:   -170.921°  voltage\nV(3):   mag:    1.85567 phase:    65.6354°  voltage\nV(4):   mag:    1.90381 phase:    8.37152°  voltage\nV(5):   mag:    14.3544 phase:     47.295°  voltage\nV(9):   mag:    1.49828 phase:   -10.4335°  voltage\nV(12):  mag:    8.76736 phase:    169.347°  voltage\nV(10):  mag:    3.01026 phase:   -107.784°  voltage\nV(7):   mag:    4.53171 phase:    -16.043°  voltage\nV(8):   mag:    1.90381 phase:    8.37152°  voltage\nV(11):  mag:    2.42624 phase:   -163.488°  voltage\nV(6):   mag:    1.85567 phase:    65.6354°  voltage\nV(13):  mag:    14.3544 phase:     47.295°  voltage\nI(C1):  mag:    5.34483 phase:    126.532°  device_current\nI(C2):  mag:    13.3732 phase:    15.9359°  device_current\nI(F1):  mag:    11.9396 phase:   -166.272°  device_current\nI(H1):  mag:    8.50452 phase:    179.868°  device_current\nI(L1):  mag:    5.12076 phase:    150.659°  device_current\nI(L2):  mag:    0.30328 phase:   -73.4883°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:    1.53623 phase:     60.659°  device_current\nI(R4):  mag:    4.64174 phase:    140.656°  device_current\nI(R9):  mag:          0 phase:          0°  device_current\nI(R10): mag:   0.190381 phase:    8.37152°  device_current\nI(R13): mag:   0.546091 phase:    6.28131°  device_current\nI(R14): mag:   0.352995 phase:   -132.679°  device_current\nI(R2):  mag:     2.5213 phase:    -135.36°  device_current\nI(R7):  mag:   0.484448 phase:     148.25°  device_current\nI(R11): mag:   0.705989 phase:   -132.679°  device_current\nI(R12): mag:   0.334473 phase:    72.2162°  device_current\nI(R16): mag:   0.670093 phase:    159.833°  device_current\nI(R8):  mag:   0.360393 phase:    128.347°  device_current\nI(R17): mag:    2.38793 phase:   -166.272°  device_current\nI(R18): mag:    5.10203 phase:   -154.058°  device_current\nI(G1):  mag:    1.36963 phase:   -126.779°  device_current\nI(E1):  mag:    3.85882 phase:    148.425°  device_current\nI(V4):  mag:     10.838 phase:   -177.107°  device_current\nI(V1):  mag:    2.38793 phase:   -166.272°  device_current\nI(V2):  mag:    5.10203 phase:   -154.058°  device_current\n\n\n\n9.5.2 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 5.0 s v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(5.0 s + 0.442857142857143\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- 3.0 I_{L1} s + v_{1} - v_{5}\\\\- 8.0 I_{L2} s - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n9.5.3 Plot the voltage at node 5\n\nH = U_ac[v5]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_5.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_6.html",
    "href": "test_6.html",
    "title": "10  Test 6",
    "section": "",
    "text": "10.1 Load the net list\nnet_list = '''\nV4 1 2 20\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR10 8 0 10\nR14 10 9 10\nR2 3 5 5\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\nC1 7 1 2\nC2 1 9 5\nL1 1 5 3\nL2 0 11 8\nL3 9 11 8\nL4 4 8 10\nK1 L3 L4 0.5\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_6.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "10  Test 6",
    "section": "10.2 Call the symbolic modified nodal analysis function",
    "text": "10.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(I_{L4} = I_{2}\\)\\(I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(- I_{L4} + v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{2} s v_{1} - I_{F1} + I_{L3} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(- I_{L2} - I_{L3} + \\frac{v_{11}}{R_{16}} - \\frac{v_{12}}{R_{16}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L2} L_{2} s - v_{11} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{1} s - v_{11} + v_{9} = 0\\)\\(- I_{L3} M_{1} s - I_{L4} L_{4} s + v_{4} - v_{8} = 0\\)\n\n\n\n10.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 27\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 10\nnumber of RLC (passive components): 18\nnumber of inductors: 4\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 1\n\n\n\n\n\n10.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccccccc}C_{1} s + C_{2} s + \\frac{1}{R_{3}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} & 0 & - C_{1} s & 0 & - C_{2} s & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\- \\frac{1}{R_{3}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{1} s & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & 0 & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\- C_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{16}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{2} s & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{1} s\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{4} s\\end{array}\\right]\\)\n\n\n\n\n10.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}\\right]\\)\n\n\n\n\n10.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n10.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n11\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n12\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n13\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n14\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n15\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n16\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n17\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n18\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n19\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n20\nC1\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n21\nC2\n1\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n22\nL1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n23\nL2\n0\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n24\nL3\n9\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n25\nL4\n4\n8\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n26\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.5\nNaN\nL3\nL4\n\n\n\n\n\n\n\n\n\n10.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n6\nL1\n1\n5\n\n\n7\nL2\n0\n11\n\n\n8\nL3\n9\n11\n\n\n9\nL4\n4\n8\n\n\n\n\n\n\n\n\n\n10.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}}\\\\I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}}\\\\- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}}\\\\I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}}\\\\- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}}\\\\- I_{L4} + v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}}\\\\- C_{2} s v_{1} - I_{F1} + I_{L3} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right)\\\\g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right)\\\\- I_{L2} - I_{L3} + \\frac{v_{11}}{R_{16}} - \\frac{v_{12}}{R_{16}}\\\\I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}}\\\\I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - I_{V1} f_{1}\\\\ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3}\\\\- I_{V2} h_{1} - v_{12} + v_{2}\\\\- I_{L1} L_{1} s + v_{1} - v_{5}\\\\- I_{L2} L_{2} s - v_{11}\\\\- I_{L3} L_{3} s - I_{L4} M_{1} s - v_{11} + v_{9}\\\\- I_{L3} M_{1} s - I_{L4} L_{4} s + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{2}\\\\I_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{4}\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L2}, \\  R_{14}, \\  I_{V1}, \\  I_{Ea1}, \\  C_{2}, \\  I_{L1}, \\  M_{1}, \\  v_{7}, \\  ea_{1}, \\  s, \\  R_{3}, \\  R_{11}, \\  R_{10}, \\  R_{18}, \\  R_{4}, \\  V_{1}, \\  V_{2}, \\  g_{1}, \\  R_{7}, \\  v_{1}, \\  L_{4}, \\  I_{H1}, \\  L_{3}, \\  v_{2}, \\  L_{2}, \\  v_{6}, \\  R_{16}, \\  I_{V2}, \\  v_{5}, \\  C_{1}, \\  L_{1}, \\  V_{4}, \\  R_{17}, \\  v_{3}, \\  I_{L4}, \\  v_{9}, \\  v_{10}, \\  I_{F1}, \\  f_{1}, \\  R_{2}, \\  I_{L3}, \\  v_{11}, \\  v_{12}, \\  R_{12}, \\  v_{4}, \\  R_{8}, \\  v_{13}, \\  I_{V4}, \\  h_{1}, \\  I_{2}, \\  v_{8}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#symbolic-solution",
    "href": "test_6.html#symbolic-solution",
    "title": "10  Test 6",
    "section": "10.3 Symbolic solution",
    "text": "10.3 Symbolic solution\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#construct-a-dictionary-of-element-values",
    "href": "test_6.html#construct-a-dictionary-of-element-values",
    "title": "10  Test 6",
    "section": "10.4 Construct a dictionary of element values",
    "text": "10.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\n10.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt; K1 L3 L4 0.5\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 4.472135955\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  C_{2} : 5.0, \\  I_{2} : 5.0, \\  K_{1} : 0.5, \\  L_{1} : 3.0, \\  L_{2} : 8.0, \\  L_{3} : 8.0, \\  L_{4} : 10.0, \\  M_{1} : 4.47213595499958, \\  R_{10} : 10.0, \\  R_{11} : 5.0, \\  R_{12} : 9.0, \\  R_{14} : 10.0, \\  R_{16} : 10.0, \\  R_{17} : 8.0, \\  R_{18} : 4.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  R_{4} : 1.0, \\  R_{7} : 6.0, \\  R_{8} : 5.0, \\  V_{1} : 0.0, \\  V_{2} : 0.0, \\  V_{4} : 20.0, \\  ea_{1} : 3.0, \\  f_{1} : 5.0, \\  g_{1} : 2.0, \\  h_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#dc-operating-point",
    "href": "test_6.html#dc-operating-point",
    "title": "10  Test 6",
    "section": "10.5 DC operating point",
    "text": "10.5 DC operating point\nBoth V4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + 0.1 v_{1} - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 1.0 v_{3} - 2.0 v_{4} + 1.16666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 0.3 v_{10} + 0.3 v_{9}\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\v_{1} - v_{5}\\\\- v_{11}\\\\- v_{11} + v_{9}\\\\v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-5.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           3.367922\nv2         -16.632078\nv3         -15.060648\nv4          -1.041413\nv5           3.367922\nv6         -15.060648\nv7         -14.843180\nv8          -1.041413\nv9           0.000000\nv10          5.066334\nv11          0.000000\nv12         -9.965411\nv13          3.367922\nI_V4        -6.036903\nI_V1        -0.196429\nI_V2        -3.333333\nI_F1        -0.982144\nI_Ea1       -1.510600\nI_H1        -5.840475\nI_L1         6.036903\nI_L2         0.458785\nI_L3         0.537756\nI_L4         5.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    3.36792     voltage\nV(2):    -16.6321    voltage\nV(3):    -15.0606    voltage\nV(4):    -1.04141    voltage\nV(5):    3.36792     voltage\nV(9):    1.11022e-16     voltage\nV(12):   -9.96541    voltage\nV(10):   5.06633     voltage\nV(7):    -14.8432    voltage\nV(8):    -1.04141    voltage\nV(11):   0   voltage\nV(6):    -15.0606    voltage\nV(13):   3.36792     voltage\nI(C1):   -3.64222e-11    device_current\nI(C2):   1.68396e-11     device_current\nI(F1):   -0.982144   device_current\nI(H1):   -5.84047    device_current\nI(L1):   6.0369  device_current\nI(L2):   0.458785    device_current\nI(L3):   0.537756    device_current\nI(L4):   5   device_current\nI(I2):   5   device_current\nI(R3):   5.32907e-16     device_current\nI(R4):   -0.217468   device_current\nI(R10):  -0.104141   device_current\nI(R14):  0.506633    device_current\nI(R2):   -3.68571    device_current\nI(R7):   2.30029     device_current\nI(R11):  1.01327     device_current\nI(R12):  -0.562926   device_current\nI(R16):  -0.996541   device_current\nI(R8):   -2.80385    device_current\nI(R17):  -0.196429   device_current\nI(R18):  -3.33333    device_current\nI(G1):   2.08283     device_current\nI(E1):   -1.5106     device_current\nI(V4):   -6.0369     device_current\nI(V1):   -0.196429   device_current\nI(V2):   -3.33333    device_current\nThe results from LTSpice agree with the SymPy results.\n\n10.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I2 = 0 and V4 = 10\n\nelement_values[I2] = 0\nelement_values[V4] = 10\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 5.0 i v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(0.3 + 5.0 i\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- 3.0 i I_{L1} + v_{1} - v_{5}\\\\- 8.0 i I_{L2} - v_{11}\\\\- 8.0 i I_{L3} - 4.47213595499958 i I_{L4} - v_{11} + v_{9}\\\\- 4.47213595499958 i I_{L3} - 10.0 i I_{L4} + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.636070    -13.116769\nv2         8.414810   -177.471137\nv3         0.586907     -3.586473\nv4         1.987061     30.488547\nv5         7.659782     29.941452\nv6         0.586907     -3.586473\nv7         1.673460      2.228237\nv8         0.848285      0.506771\nv9         1.767765     29.618572\nv10        0.268017     -3.585934\nv11        0.916416    -90.556353\nv12        3.543942    163.157171\nv13        7.659782     29.941452\nI_V4       5.376987   -165.047830\nI_V1       1.124824   -177.869238\nI_V2       2.602977   -164.421170\nI_F1       5.624122   -177.869238\nI_Ea1      1.485962   -145.541756\nI_H1       4.287481   -161.710238\nI_L1       2.186723    129.745082\nI_L2       0.114552     -0.556353\nI_L3       0.295629    -40.810152\nI_L4       0.000000    nan\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    1.63607 phase:   -13.1168°  voltage\nV(2):   mag:    8.41481 phase:   -177.471°  voltage\nV(3):   mag:   0.586907 phase:   -3.58647°  voltage\nV(4):   mag:    1.98706 phase:    30.4885°  voltage\nV(5):   mag:    7.65978 phase:    29.9415°  voltage\nV(9):   mag:    1.76776 phase:    29.6186°  voltage\nV(12):  mag:    3.54394 phase:    163.157°  voltage\nV(10):  mag:   0.268017 phase:   -3.58593°  voltage\nV(7):   mag:    1.67346 phase:    2.22824°  voltage\nV(8):   mag:   0.848285 phase:   0.506771°  voltage\nV(11):  mag:   0.916416 phase:   -90.5564°  voltage\nV(6):   mag:   0.586907 phase:   -3.58647°  voltage\nV(13):  mag:    7.65978 phase:    29.9415°  voltage\nI(C1):  mag:   0.886817 phase:    169.762°  device_current\nI(C2):  mag:    6.23121 phase:    2.60332°  device_current\nI(F1):  mag:    5.62412 phase:   -177.869°  device_current\nI(H1):  mag:    4.28748 phase:    -161.71°  device_current\nI(L1):  mag:    2.18672 phase:    129.745°  device_current\nI(L2):  mag:   0.114552 phase:  -0.556353°  device_current\nI(L3):  mag:   0.295629 phase:   -40.8102°  device_current\nI(L4):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:   0.656017 phase:    39.7451°  device_current\nI(R4):  mag:    1.09119 phase:   -174.648°  device_current\nI(R10): mag:  0.0848285 phase:   0.506771°  device_current\nI(R14): mag:   0.155047 phase:   -144.949°  device_current\nI(R2):  mag:    1.43557 phase:    -147.47°  device_current\nI(R7):  mag:   0.137659 phase:   -176.004°  device_current\nI(R11): mag:   0.310094 phase:   -144.949°  device_current\nI(R12): mag:  0.0297797 phase:    176.414°  device_current\nI(R16): mag:    0.39014 phase:    150.127°  device_current\nI(R8):  mag:  0.0532384 phase:   -170.438°  device_current\nI(R17): mag:    1.12482 phase:   -177.869°  device_current\nI(R18): mag:    2.60298 phase:   -164.421°  device_current\nI(G1):  mag:   0.442271 phase:    -142.54°  device_current\nI(E1):  mag:    1.48596 phase:   -145.542°  device_current\nI(V4):  mag:    5.37699 phase:   -165.048°  device_current\nI(V1):  mag:    1.12482 phase:   -177.869°  device_current\nI(V2):  mag:    2.60298 phase:   -164.421°  device_current\n\n\n10.5.2 AC Sweep\nLooking at node 10 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 5.0 s v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(5.0 s + 0.3\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- 3.0 I_{L1} s + v_{1} - v_{5}\\\\- 8.0 I_{L2} s - v_{11}\\\\- 8.0 I_{L3} s - 4.47213595499958 I_{L4} s - v_{11} + v_{9}\\\\- 4.47213595499958 I_{L3} s - 10.0 I_{L4} s + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n10.5.3 Plot the voltage at node 10\n\nH = U_ac[v10]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 1000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_6.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_7.html",
    "href": "test_7.html",
    "title": "11  Test 7",
    "section": "",
    "text": "11.1 Load the net list\nnet_list = '''\nR1 16 8 5\nR2 8 1 2\nR6 2 0 5\nR8 11 10 8\nR10 23 22 9\nR11 9 8 4\nR12 2 1 2\nR14 10 9 10\nR15 24 23 5\nV1 22 0 10 \nV2 1 0 2\nV3 10 3 3\nV4 10 20 5\nI1 5 0 3\nI2 2 3 1\nI3 16 9 2\nI4 12 18 2\nR7 12 5 10\nR16 3 0 6\nR3 26 25 10\nR4 4 3 3\nF1 14 7 V2 2\nE1 15 21 2 7 2\nH1 4 0 V2 3\nG1 11 4 13 12 2\nL1 16 23 1 \nL2 25 9 4 \nV5 20 28 0\nV6 23 27 0\nL3 22 21 2 \nL4 17 11 5 \nC1 23 18 2\nC2 12 11 2\nL5 0 7 1 \nL6 9 2 2 \nF2 0 27 V2 2\nE2 17 26 10 9 2\nH2 27 26 V2 3\nG2 16 28 0 5 2\nV7 24 25 0\nV8 0 6 0\nR9 22 16 3\nR13 15 0 5\nR17 19 13 5\nR18 13 6 2\nR19 23 19 7\nR20 20 19 5\nR21 19 18 3\nR22 14 13 3\nR23 5 4 1\nR24 20 14 3\nR25 23 28 10\nR5 28 0 3\nK1 L1 L2 0.707\nK2 L3 L4 0.707\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_7.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "11  Test 7",
    "section": "11.2 Call the symbolic modified nodal analysis function",
    "text": "11.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}} = - I_{1}\\)\\(- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}} = 0\\)\\(- I_{F1} - I_{L5} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}} = 0\\)\\(- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}} = 0\\)\\(- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}} = 0\\)\\(- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}} = - I_{4}\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}} = 0\\)\\(I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}} = 0\\)\\(I_{Ea1} + \\frac{v_{15}}{R_{13}} = 0\\)\\(I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}} = - I_{3}\\)\\(I_{Ea2} + I_{L4} = 0\\)\\(- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}} = I_{4}\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}} = 0\\)\\(- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}} = 0\\)\\(- I_{Ea1} - I_{L3} = 0\\)\\(I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}} = 0\\)\\(- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}} = 0\\)\\(I_{V7} - \\frac{v_{23}}{R_{15}} + \\frac{v_{24}}{R_{15}} = 0\\)\\(I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{F2} + I_{H2} - I_{V6} = 0\\)\\(- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}} = 0\\)\\(v_{22} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(v_{10} - v_{3} = V_{3}\\)\\(v_{10} - v_{20} = V_{4}\\)\\(v_{20} - v_{28} = V_{5}\\)\\(v_{23} - v_{27} = V_{6}\\)\\(v_{24} - v_{25} = V_{7}\\)\\(- v_{6} = V_{8}\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21} = 0\\)\\(- I_{V2} h_{1} + v_{4} = 0\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22} = 0\\)\\(- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17} = 0\\)\\(- I_{L5} L_{5} s - v_{7} = 0\\)\\(- I_{L6} L_{6} s - v_{2} + v_{9} = 0\\)\\(I_{F2} - I_{V2} f_{2} = 0\\)\\(- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26} = 0\\)\\(- I_{V2} h_{2} - v_{26} + v_{27} = 0\\)\n\n\n\n11.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 55\nnumber of branches: 53\nnumber of nodes: 28\nnumber of unknown currents: 20\nnumber of RLC (passive components): 33\nnumber of inductors: 6\nnumber of independent voltage sources: 8\nnumber of independent current sources: 4\nnumber of op amps: 0\nnumber of E - VCVS: 2\nnumber of G - VCCS: 2\nnumber of F - CCCS: 2\nnumber of H - CCVS: 2\nnumber of K - Coupled inductors: 2\n\n\n\n\n\n11.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccccccccccccccccccccccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{23}} & - \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & g_{1} & - g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & - \\frac{1}{R_{23}} & \\frac{1}{R_{7}} + \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{8}} & C_{2} s + \\frac{1}{R_{8}} & - C_{2} s - g_{1} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & - C_{2} s & C_{2} s + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{22}} & \\frac{1}{R_{24}} + \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - g_{2} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{1} s + \\frac{1}{R_{21}} & - \\frac{1}{R_{21}} & 0 & 0 & 0 & - C_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{21}} & \\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{20}} & 0 & 0 & - \\frac{1}{R_{19}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{20}} & \\frac{1}{R_{24}} + \\frac{1}{R_{20}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - C_{1} s & - \\frac{1}{R_{19}} & 0 & 0 & - \\frac{1}{R_{10}} & C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 1\\\\0 & 0 & 0 & 0 & g_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - ea_{1} & 0 & 0 & 0 & 0 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{2} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{2} s & - L_{4} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{5} s & 0 & 0 & 0 & 0\\\\0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{6} s & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ea_{2} & - ea_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & - h_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n11.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  v_{14}, \\  v_{15}, \\  v_{16}, \\  v_{17}, \\  v_{18}, \\  v_{19}, \\  v_{20}, \\  v_{21}, \\  v_{22}, \\  v_{23}, \\  v_{24}, \\  v_{25}, \\  v_{26}, \\  v_{27}, \\  v_{28}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}, \\  I_{V5}, \\  I_{V6}, \\  I_{V7}, \\  I_{V8}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}, \\  I_{L5}, \\  I_{L6}, \\  I_{F2}, \\  I_{Ea2}, \\  I_{H2}\\right]\\)\n\n\n\n\n11.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  0, \\  - I_{1}, \\  0, \\  0, \\  0, \\  I_{3}, \\  0, \\  0, \\  - I_{4}, \\  0, \\  0, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}, \\  V_{5}, \\  V_{6}, \\  V_{7}, \\  V_{8}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n11.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n22\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n10\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n10\n20\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nV5\n20\n28\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nV6\n23\n27\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n6\nV7\n24\n25\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n7\nV8\n0\n6\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n8\nR1\n16\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n9\nR2\n8\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n10\nR6\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n11\nR8\n11\n10\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n12\nR10\n23\n22\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n13\nR11\n9\n8\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n14\nR12\n2\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n15\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n16\nR15\n24\n23\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n17\nI1\n5\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n18\nI2\n2\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n19\nI3\n16\n9\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n20\nI4\n12\n18\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n21\nR7\n12\n5\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n22\nR16\n3\n0\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n23\nR3\n26\n25\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n24\nR4\n4\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n25\nF1\n14\n7\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n26\nEa1\n15\n21\n2\n7\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n27\nH1\n4\n0\nNaN\nNaN\nNaN\n3.0\nV2\nNaN\nNaN\n\n\n28\nG1\n11\n4\n13\n12\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n29\nL1\n16\n23\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n30\nL2\n25\n9\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n31\nL3\n22\n21\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n32\nL4\n17\n11\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n33\nC1\n23\n18\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n34\nC2\n12\n11\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n35\nL5\n0\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n36\nL6\n9\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n37\nF2\n0\n27\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n38\nEa2\n17\n26\n10\n9\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n39\nH2\n27\n26\nNaN\nNaN\nNaN\n3.0\nV2\nNaN\nNaN\n\n\n40\nG2\n16\n28\n0\n5\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n41\nR9\n22\n16\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n42\nR13\n15\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n43\nR17\n19\n13\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n44\nR18\n13\n6\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n45\nR19\n23\n19\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n46\nR20\n20\n19\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n47\nR21\n19\n18\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n48\nR22\n14\n13\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n49\nR23\n5\n4\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n50\nR24\n20\n14\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n51\nR25\n23\n28\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n52\nR5\n28\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n53\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.707\nNaN\nL1\nL2\n\n\n54\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.707\nNaN\nL3\nL4\n\n\n\n\n\n\n\n\n\n11.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n22\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n10\n3\n\n\n3\nV4\n10\n20\n\n\n4\nV5\n20\n28\n\n\n5\nV6\n23\n27\n\n\n6\nV7\n24\n25\n\n\n7\nV8\n0\n6\n\n\n8\nF1\n14\n7\n\n\n9\nEa1\n15\n21\n\n\n10\nH1\n4\n0\n\n\n11\nL1\n16\n23\n\n\n12\nL2\n25\n9\n\n\n13\nL3\n22\n21\n\n\n14\nL4\n17\n11\n\n\n15\nL5\n0\n7\n\n\n16\nL6\n9\n2\n\n\n17\nF2\n0\n27\n\n\n18\nEa2\n17\n26\n\n\n19\nH2\n27\n26\n\n\n\n\n\n\n\n\n\n11.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}}\\\\- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}}\\\\- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}}\\\\I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}}\\\\- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}}\\\\- I_{F1} - I_{L5}\\\\v_{8} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}}\\\\- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}}\\\\I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}}\\\\- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}}\\\\- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}}\\\\v_{13} \\cdot \\left(\\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}}\\\\I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}}\\\\I_{Ea1} + \\frac{v_{15}}{R_{13}}\\\\I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}}\\\\I_{Ea2} + I_{L4}\\\\- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}}\\\\v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}}\\\\- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}}\\\\- I_{Ea1} - I_{L3}\\\\I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}}\\\\- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}}\\\\I_{V7} - \\frac{v_{23}}{R_{15}} + \\frac{v_{24}}{R_{15}}\\\\I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}}\\\\- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - I_{V2} f_{1}\\\\- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21}\\\\- I_{V2} h_{1} + v_{4}\\\\- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23}\\\\- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9}\\\\- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22}\\\\- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17}\\\\- I_{L5} L_{5} s - v_{7}\\\\- I_{L6} L_{6} s - v_{2} + v_{9}\\\\I_{F2} - I_{V2} f_{2}\\\\- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26}\\\\- I_{V2} h_{2} - v_{26} + v_{27}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\- I_{2}\\\\I_{2}\\\\0\\\\- I_{1}\\\\0\\\\0\\\\0\\\\I_{3}\\\\0\\\\0\\\\- I_{4}\\\\0\\\\0\\\\0\\\\- I_{3}\\\\0\\\\I_{4}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\V_{3}\\\\V_{4}\\\\V_{5}\\\\V_{6}\\\\V_{7}\\\\V_{8}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( h_{2}, \\  v_{17}, \\  V_{8}, \\  v_{18}, \\  I_{V7}, \\  L_{2}, \\  v_{15}, \\  v_{22}, \\  R_{2}, \\  v_{24}, \\  ea_{1}, \\  R_{23}, \\  V_{3}, \\  g_{2}, \\  I_{V2}, \\  R_{21}, \\  v_{13}, \\  v_{20}, \\  R_{9}, \\  v_{9}, \\  g_{1}, \\  I_{V4}, \\  L_{1}, \\  f_{2}, \\  v_{10}, \\  R_{7}, \\  R_{6}, \\  R_{20}, \\  I_{Ea1}, \\  I_{L3}, \\  v_{5}, \\  v_{27}, \\  R_{18}, \\  v_{11}, \\  v_{25}, \\  V_{4}, \\  v_{14}, \\  f_{1}, \\  R_{3}, \\  I_{V1}, \\  ea_{2}, \\  I_{Ea2}, \\  I_{V3}, \\  L_{3}, \\  R_{19}, \\  I_{V5}, \\  R_{24}, \\  v_{28}, \\  I_{H1}, \\  V_{2}, \\  h_{1}, \\  R_{25}, \\  v_{4}, \\  I_{2}, \\  I_{L4}, \\  v_{21}, \\  R_{4}, \\  s, \\  V_{1}, \\  v_{7}, \\  R_{11}, \\  I_{V6}, \\  R_{12}, \\  v_{26}, \\  R_{8}, \\  M_{1}, \\  I_{V8}, \\  v_{16}, \\  R_{14}, \\  R_{5}, \\  L_{6}, \\  v_{2}, \\  I_{H2}, \\  I_{L6}, \\  v_{6}, \\  R_{17}, \\  v_{19}, \\  I_{F1}, \\  R_{10}, \\  L_{4}, \\  R_{16}, \\  I_{L2}, \\  V_{6}, \\  R_{1}, \\  V_{5}, \\  C_{2}, \\  R_{13}, \\  I_{F2}, \\  M_{2}, \\  v_{1}, \\  v_{8}, \\  I_{1}, \\  C_{1}, \\  v_{12}, \\  R_{15}, \\  v_{23}, \\  V_{7}, \\  I_{L1}, \\  I_{3}, \\  R_{22}, \\  L_{5}, \\  I_{L5}, \\  I_{4}, \\  v_{3}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#symbolic-solution",
    "href": "test_7.html#symbolic-solution",
    "title": "11  Test 7",
    "section": "11.3 Symbolic solution",
    "text": "11.3 Symbolic solution\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#construct-a-dictionary-of-element-values",
    "href": "test_7.html#construct-a-dictionary-of-element-values",
    "title": "11  Test 7",
    "section": "11.4 Construct a dictionary of element values",
    "text": "11.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\n11.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt;K1 L1 L2 0.707\nK2 L3 L4 0.707\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nmutual inductance, M1 = 1.414000000\nmutual inductance, M2 = 2.235730306\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  C_{2} : 2.0, \\  I_{1} : 3.0, \\  I_{2} : 1.0, \\  I_{3} : 2.0, \\  I_{4} : 2.0, \\  K_{1} : 0.707, \\  K_{2} : 0.707, \\  L_{1} : 1.0, \\  L_{2} : 4.0, \\  L_{3} : 2.0, \\  L_{4} : 5.0, \\  L_{5} : 1.0, \\  L_{6} : 2.0, \\  M_{1} : 1.414, \\  M_{2} : 2.23573030573904, \\  R_{1} : 5.0, \\  R_{10} : 9.0, \\  R_{11} : 4.0, \\  R_{12} : 2.0, \\  R_{13} : 5.0, \\  R_{14} : 10.0, \\  R_{15} : 5.0, \\  R_{16} : 6.0, \\  R_{17} : 5.0, \\  R_{18} : 2.0, \\  R_{19} : 7.0, \\  R_{2} : 2.0, \\  R_{20} : 5.0, \\  R_{21} : 3.0, \\  R_{22} : 3.0, \\  R_{23} : 1.0, \\  R_{24} : 3.0, \\  R_{25} : 10.0, \\  R_{3} : 10.0, \\  R_{4} : 3.0, \\  R_{5} : 3.0, \\  R_{6} : 5.0, \\  R_{7} : 10.0, \\  R_{8} : 8.0, \\  R_{9} : 3.0, \\  V_{1} : 10.0, \\  V_{2} : 2.0, \\  V_{3} : 3.0, \\  V_{4} : 5.0, \\  V_{5} : 0.0, \\  V_{6} : 0.0, \\  V_{7} : 0.0, \\  V_{8} : 0.0, \\  ea_{1} : 2.0, \\  ea_{2} : 2.0, \\  f_{1} : 2.0, \\  f_{2} : 2.0, \\  g_{1} : 2.0, \\  g_{2} : 2.0, \\  h_{1} : 3.0, \\  h_{2} : 3.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#dc-operating-point",
    "href": "test_7.html#dc-operating-point",
    "title": "11  Test 7",
    "section": "11.5 DC operating point",
    "text": "11.5 DC operating point\nBoth ?\nV4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + 0.125 v_{11} - 2.0 v_{12} + 2.0 v_{13}\\\\0.1 v_{12} - 0.1 v_{5}\\\\1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\0.333333333333333 v_{18} - 0.333333333333333 v_{19}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + 0.553968253968254 v_{23} - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\v_{16} - v_{23}\\\\v_{25} - v_{9}\\\\- v_{21} + v_{22}\\\\- v_{11} + v_{17}\\\\- v_{7}\\\\- v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\-1.0\\\\1.0\\\\0\\\\-3.0\\\\0\\\\0\\\\0\\\\2.0\\\\0\\\\0\\\\-2.0\\\\0\\\\0\\\\0\\\\-2.0\\\\0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\2.0\\\\3.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           5.971750\nv3         -10.279202\nv4          13.605119\nv5           8.605119\nv6           0.000000\nv7           0.000000\nv8           7.098329\nv9           5.971750\nv10         -7.279202\nv11        -18.854648\nv12        -11.394881\nv13         -7.101000\nv14        -23.295220\nv15         21.943500\nv16         21.252375\nv17        -18.854648\nv18          8.136867\nv19          2.136867\nv20        -12.279202\nv21         10.000000\nv22         10.000000\nv23         21.252375\nv24          5.971750\nv25          5.971750\nv26          7.647256\nv27         21.252375\nv28        -12.279202\nI_V1         0.612356\nI_V2         4.535040\nI_V3       -10.674641\nI_V4        10.552805\nI_V5         9.764013\nI_V6        -1.761697\nI_V7         3.056125\nI_V8         3.550500\nI_F1         9.070079\nI_Ea1       -4.388700\nI_H1        -4.373678\nI_L1         8.628637\nI_L2         3.223676\nI_L3         4.388700\nI_L4         7.140832\nI_L5        -9.070079\nI_L6         4.180225\nI_F2         9.070079\nI_Ea2       -7.140832\nI_H2         7.308382\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(16):   21.2524     voltage\nV(8):    7.09833     voltage\nV(1):    2   voltage\nV(2):    5.97175     voltage\nV(11):   -18.8546    voltage\nV(10):   -7.2792     voltage\nV(23):   21.2524     voltage\nV(22):   10  voltage\nV(9):    5.97175     voltage\nV(24):   5.97175     voltage\nV(3):    -10.2792    voltage\nV(20):   -12.2792    voltage\nV(5):    8.60512     voltage\nV(12):   -11.3949    voltage\nV(18):   8.13687     voltage\nV(26):   7.64726     voltage\nV(25):   5.97175     voltage\nV(4):    13.6051     voltage\nV(14):   -23.2952    voltage\nV(7):    0   voltage\nV(15):   21.9435     voltage\nV(21):   10  voltage\nV(13):   -7.101  voltage\nV(28):   -12.2792    voltage\nV(27):   21.2524     voltage\nV(17):   -18.8546    voltage\nV(6):    0   voltage\nV(19):   2.13687     voltage\nI(C1):   2.6231e-11  device_current\nI(C2):   1.49195e-11     device_current\nI(F1):   9.07008     device_current\nI(F2):   9.07008     device_current\nI(H1):   -4.37368    device_current\nI(H2):   7.30838     device_current\nI(L1):   8.62864     device_current\nI(L2):   3.22368     device_current\nI(L3):   4.3887  device_current\nI(L4):   7.14083     device_current\nI(L5):   -9.07008    device_current\nI(L6):   4.18022     device_current\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   2.83081     device_current\nI(R2):   2.54916     device_current\nI(R6):   1.19435     device_current\nI(R8):   -1.44693    device_current\nI(R10):  1.25026     device_current\nI(R11):  -0.281645   device_current\nI(R12):  1.98588     device_current\nI(R14):  -1.3251     device_current\nI(R15):  -3.05612    device_current\nI(R7):   -2  device_current\nI(R16):  -1.7132     device_current\nI(R3):   0.167551    device_current\nI(R4):   7.96144     device_current\nI(R9):   -3.75079    device_current\nI(R13):  4.3887  device_current\nI(R17):  1.84757     device_current\nI(R18):  -3.5505     device_current\nI(R19):  2.73079     device_current\nI(R20):  -2.88321    device_current\nI(R21):  -2  device_current\nI(R22):  -5.39807    device_current\nI(R23):  -5  device_current\nI(R24):  3.67201     device_current\nI(R25):  3.35316     device_current\nI(R5):   -4.09307    device_current\nI(G1):   8.58776     device_current\nI(G2):   -17.2102    device_current\nI(E1):   -4.3887     device_current\nI(E2):   -7.14083    device_current\nI(V1):   0.612356    device_current\nI(V2):   4.53504     device_current\nI(V3):   -10.6746    device_current\nI(V4):   10.5528     device_current\nI(V5):   9.76401     device_current\nI(V6):   -1.7617     device_current\nI(V7):   3.05612     device_current\nI(V8):   3.5505  device_current\n\nThe results from LTSpice agree with the SymPy results.\n\n11.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\nV2, V3, V4, I1, I2, I3, I4 are DC sources and are set to zero for AC analysis.\n\nelement_values[V2] = 0\nelement_values[V3] = 0\nelement_values[V4] = 0\nelement_values[I1] = 0\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\\\- 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\\\1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 i I_{L1} - 1.414 i I_{L2} + v_{16} - v_{23}\\\\- 1.414 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\\\- 2.0 i I_{L3} - 2.23573030573904 i I_{L4} - v_{21} + v_{22}\\\\- 2.23573030573904 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\\\- 1.0 i I_{L5} - v_{7}\\\\- 2.0 i I_{L6} - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          0.000000    nan\nv2          1.269063   -156.737432\nv3          5.563110     92.699863\nv4          5.822884    -82.858298\nv5          5.049515    -83.161299\nv6          0.000000    nan\nv7          3.881923      7.141702\nv8          3.734176    -63.802595\nv9          2.183378   -102.275110\nv10         5.563110     92.699863\nv11         2.699909     95.168114\nv12         2.700976    103.385120\nv13         2.281731     84.349178\nv14         9.719907     94.381715\nv15         5.149976   -119.308730\nv16        15.692738    -57.591025\nv17        10.020727     70.734148\nv18        12.269643    -67.106998\nv19         5.029569    -61.518344\nv20         5.563110     92.699863\nv21         7.926685    -18.560431\nv22        10.000000      0.000000\nv23        12.247990    -72.779714\nv24        10.615913    -41.644709\nv25        10.615913    -41.644709\nv26         6.594170    -63.890173\nv27        12.247990    -72.779714\nv28         5.563110     92.699863\nI_V1        4.873462    -98.660056\nI_V2        1.940961    -82.858298\nI_V3        4.719081     94.525274\nI_V4        5.842672    -86.521779\nI_V5        6.490055    -83.573802\nI_V6        3.704717     80.775839\nI_V7        1.266856   -132.840858\nI_V8        1.140866    -95.650822\nI_F1        3.881923    -82.858298\nI_Ea1       1.029995     60.691270\nI_H1        4.026860     71.937257\nI_L1        3.651246    -84.027986\nI_L2        1.589691   -149.132274\nI_L3        1.029995   -119.308730\nI_L4        1.609380    -11.044380\nI_L5        3.881923     97.141702\nI_L6        0.888344   -156.737432\nI_F2        3.881923    -82.858298\nI_Ea2       1.609380    168.955620\nI_H2        1.093990    -10.267379\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    15.6927 phase:    -57.591°  voltage\nV(8):   mag:    3.73418 phase:   -63.8026°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:    1.26906 phase:   -156.737°  voltage\nV(11):  mag:    2.69991 phase:    95.1681°  voltage\nV(10):  mag:    5.56311 phase:    92.6999°  voltage\nV(23):  mag:     12.248 phase:   -72.7797°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:    2.18338 phase:   -102.275°  voltage\nV(24):  mag:    10.6159 phase:   -41.6447°  voltage\nV(3):   mag:    5.56311 phase:    92.6999°  voltage\nV(20):  mag:    5.56311 phase:    92.6999°  voltage\nV(5):   mag:    5.04951 phase:   -83.1613°  voltage\nV(12):  mag:    2.70098 phase:    103.385°  voltage\nV(18):  mag:    12.2696 phase:    -67.107°  voltage\nV(26):  mag:    6.59417 phase:   -63.8902°  voltage\nV(25):  mag:    10.6159 phase:   -41.6447°  voltage\nV(4):   mag:    5.82288 phase:   -82.8583°  voltage\nV(14):  mag:    9.71991 phase:    94.3817°  voltage\nV(7):   mag:    3.88192 phase:     7.1417°  voltage\nV(15):  mag:    5.14998 phase:   -119.309°  voltage\nV(21):  mag:    7.92669 phase:   -18.5604°  voltage\nV(13):  mag:    2.28173 phase:    84.3492°  voltage\nV(28):  mag:    5.56311 phase:    92.6999°  voltage\nV(27):  mag:     12.248 phase:   -72.7797°  voltage\nV(17):  mag:    10.0207 phase:    70.7341°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    5.02957 phase:   -61.5183°  voltage\nI(C1):  mag:    2.42683 phase:   -70.9646°  device_current\nI(C2):  mag:   0.773901 phase:   -80.8809°  device_current\nI(F1):  mag:    3.88192 phase:   -82.8583°  device_current\nI(F2):  mag:    3.88192 phase:   -82.8583°  device_current\nI(H1):  mag:    4.02686 phase:    71.9373°  device_current\nI(H2):  mag:    1.09399 phase:   -10.2674°  device_current\nI(L1):  mag:    3.65125 phase:    -84.028°  device_current\nI(L2):  mag:    1.58969 phase:   -149.132°  device_current\nI(L3):  mag:       1.03 phase:   -119.309°  device_current\nI(L4):  mag:    1.60938 phase:   -11.0444°  device_current\nI(L5):  mag:    3.88192 phase:    97.1417°  device_current\nI(L6):  mag:   0.888344 phase:   -156.737°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:    2.39746 phase:   -55.6595°  device_current\nI(R2):  mag:    1.86709 phase:   -63.8026°  device_current\nI(R6):  mag:   0.253813 phase:   -156.737°  device_current\nI(R8):  mag:   0.358508 phase:   -89.6236°  device_current\nI(R10): mag:     1.4803 phase:   -118.583°  device_current\nI(R11): mag:   0.609557 phase:    150.054°  device_current\nI(R12): mag:   0.634531 phase:   -156.737°  device_current\nI(R14): mag:   0.769305 phase:    88.4942°  device_current\nI(R15): mag:    1.26686 phase:    47.1591°  device_current\nI(R7):  mag:   0.773901 phase:    99.1191°  device_current\nI(R16): mag:   0.927185 phase:    92.6999°  device_current\nI(R3):  mag:   0.515704 phase:    167.307°  device_current\nI(R4):  mag:    3.79248 phase:   -85.0285°  device_current\nI(R9):  mag:    4.44783 phase:    83.1593°  device_current\nI(R13): mag:       1.03 phase:   -119.309°  device_current\nI(R17): mag:    1.40714 phase:   -72.0029°  device_current\nI(R18): mag:    1.14087 phase:    84.3492°  device_current\nI(R19): mag:    1.05441 phase:   -80.4269°  device_current\nI(R20): mag:    2.06528 phase:     104.93°  device_current\nI(R21): mag:    2.42683 phase:    109.035°  device_current\nI(R22): mag:    2.49454 phase:    97.4264°  device_current\nI(R23): mag:   0.773901 phase:    99.1191°  device_current\nI(R24): mag:    1.38747 phase:   -83.3702°  device_current\nI(R25): mag:    1.76885 phase:   -77.3024°  device_current\nI(R5):  mag:    1.85437 phase:    92.6999°  device_current\nI(G1):  mag:    1.84371 phase:   -22.7819°  device_current\nI(G2):  mag:     10.099 phase:    96.8387°  device_current\nI(E1):  mag:       1.03 phase:    60.6913°  device_current\nI(E2):  mag:    1.60938 phase:    168.956°  device_current\nI(V1):  mag:    4.87346 phase:   -98.6601°  device_current\nI(V2):  mag:    1.94096 phase:   -82.8583°  device_current\nI(V3):  mag:    4.71908 phase:    94.5253°  device_current\nI(V4):  mag:    5.84267 phase:   -86.5218°  device_current\nI(V5):  mag:    6.49005 phase:   -83.5738°  device_current\nI(V6):  mag:    3.70472 phase:    80.7758°  device_current\nI(V7):  mag:    1.26686 phase:   -132.841°  device_current\nI(V8):  mag:    1.14087 phase:   -95.6508°  device_current\n\n\n11.5.2 AC Sweep\nLooking at node 17 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(2.0 s + 0.125\\right) + v_{12} \\left(- 2.0 s - 2.0\\right) + 2.0 v_{13}\\\\- 2.0 s v_{11} + v_{12} \\cdot \\left(2.0 s + 0.1\\right) - 0.1 v_{5}\\\\1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\- 2.0 s v_{23} + v_{18} \\cdot \\left(2.0 s + 0.333333333333333\\right) - 0.333333333333333 v_{19}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 s v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(2.0 s + 0.553968253968254\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 I_{L1} s - 1.414 I_{L2} s + v_{16} - v_{23}\\\\- 1.414 I_{L1} s - 4.0 I_{L2} s + v_{25} - v_{9}\\\\- 2.0 I_{L3} s - 2.23573030573904 I_{L4} s - v_{21} + v_{22}\\\\- 2.23573030573904 I_{L3} s - 5.0 I_{L4} s - v_{11} + v_{17}\\\\- 1.0 I_{L5} s - v_{7}\\\\- 2.0 I_{L6} s - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n11.5.3 Plot the voltage at node 10\n\nH = U_ac[v17]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 1000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_7.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_8.html",
    "href": "test_8.html",
    "title": "12  Test 8",
    "section": "",
    "text": "12.1 Load the net list\nnet_list = '''\nR1 16 8 5\nR2 8 1 2\nR6 2 0 5\nR8 11 10 8\nR10 23 22 9\nR11 9 8 4\nR12 2 1 2\nR14 10 9 10\nR15 24 23 5\nV1 22 0 10\nV2 1 0 2\nV3 10 3 3\nV4 10 20 5\nI1 5 0 3\nI2 2 3 1\nI3 16 9 2\nI4 12 18 2\nR7 12 5 10\nR16 3 0 6\nR3 26 25 10\nR4 4 3 3\nF1 14 7 V2 2\nE1 15 21 2 7 2\nH1 4 0 V2 3\nG1 11 4 13 12 2\nL1 16 23 1 \nL2 25 9 4 \nV5 20 28 0\nV6 23 27 0\nL3 22 21 2 \nL4 17 11 5 \nC1 23 18 2\nC2 12 11 2\nL5 0 7 1 \nL6 9 2 2 \nF2 0 27 V2 2\nE2 17 26 10 9 2\nH2 27 26 V2 3\nG2 16 28 0 5 2\nV7 24 25 0\nV8 0 6 0\nR9 22 16 3\nR13 15 0 5\nR17 19 13 5\nR18 13 6 2\nR19 23 19 7\nR20 20 19 5\nR21 19 18 3\nR22 14 13 3\nR23 5 4 1\nR24 20 14 3\nR25 23 28 10\nR5 28 0 3\nR26 32 31 20e3\nR27 30 29 10e3\nR28 13 30 2\nR29 24 32 5\nR30 29 21 20e3\nR31 31 8 10e3\nO1 29 0 30 \nO2 31 0 32 \nK1 L1 L2 0.8\nK2 L3 L4 0.2\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_8.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "12  Test 8",
    "section": "12.2 Call the symbolic modified nodal analysis function",
    "text": "12.2 Call the symbolic modified nodal analysis function\nThe circuit has 32 nodes and 59 branches, which results in 54 network equations. The Python code can generate these equations in about 1 second.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}} = - I_{1}\\)\\(- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}} = 0\\)\\(- I_{F1} - I_{L5} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{31}}{R_{31}} - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}} = 0\\)\\(- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}} = 0\\)\\(- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}} = 0\\)\\(- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}} = - I_{4}\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{30}}{R_{28}} - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}} = 0\\)\\(I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}} = 0\\)\\(I_{Ea1} + \\frac{v_{15}}{R_{13}} = 0\\)\\(I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}} = - I_{3}\\)\\(I_{Ea2} + I_{L4} = 0\\)\\(- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}} = I_{4}\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}} = 0\\)\\(- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}} = 0\\)\\(- I_{Ea1} - I_{L3} + \\frac{v_{21}}{R_{30}} - \\frac{v_{29}}{R_{30}} = 0\\)\\(I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}} = 0\\)\\(- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}} = 0\\)\\(I_{V7} + v_{24} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{32}}{R_{29}} - \\frac{v_{23}}{R_{15}} = 0\\)\\(I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{F2} + I_{H2} - I_{V6} = 0\\)\\(- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}} = 0\\)\\(v_{29} \\cdot \\left(\\frac{1}{R_{30}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{21}}{R_{30}} - \\frac{v_{30}}{R_{27}} = 0\\)\\(I_{O1} + v_{30} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{13}}{R_{28}} - \\frac{v_{29}}{R_{27}} = 0\\)\\(v_{31} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{8}}{R_{31}} - \\frac{v_{32}}{R_{26}} = 0\\)\\(I_{O2} + v_{32} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{24}}{R_{29}} - \\frac{v_{31}}{R_{26}} = 0\\)\\(v_{22} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(v_{10} - v_{3} = V_{3}\\)\\(v_{10} - v_{20} = V_{4}\\)\\(v_{20} - v_{28} = V_{5}\\)\\(v_{23} - v_{27} = V_{6}\\)\\(v_{24} - v_{25} = V_{7}\\)\\(- v_{6} = V_{8}\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21} = 0\\)\\(- I_{V2} h_{1} + v_{4} = 0\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22} = 0\\)\\(- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17} = 0\\)\\(- I_{L5} L_{5} s - v_{7} = 0\\)\\(- I_{L6} L_{6} s - v_{2} + v_{9} = 0\\)\\(I_{F2} - I_{V2} f_{2} = 0\\)\\(- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26} = 0\\)\\(- I_{V2} h_{2} - v_{26} + v_{27} = 0\\)\\(v_{29} = 0\\)\\(v_{31} = 0\\)\n\n\n\nprint('There are {:d} network equations for this circuit generated by MNA'.format(len(X)))\n\nThere are 54 network equations for this circuit generated by MNA\n\n\n\n12.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 63\nnumber of branches: 59\nnumber of nodes: 32\nnumber of unknown currents: 22\nnumber of RLC (passive components): 39\nnumber of inductors: 6\nnumber of independent voltage sources: 8\nnumber of independent current sources: 4\nnumber of op amps: 2\nnumber of E - VCVS: 2\nnumber of G - VCCS: 2\nnumber of F - CCCS: 2\nnumber of H - CCVS: 2\nnumber of K - Coupled inductors: 2\n\n\n\n\n\n12.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccccccccccccccccccccccccccccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{23}} & - \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & g_{1} & - g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & - \\frac{1}{R_{23}} & \\frac{1}{R_{7}} + \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{31}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{8}} & C_{2} s + \\frac{1}{R_{8}} & - C_{2} s - g_{1} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & - C_{2} s & C_{2} s + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{28}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{22}} & \\frac{1}{R_{24}} + \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - g_{2} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{1} s + \\frac{1}{R_{21}} & - \\frac{1}{R_{21}} & 0 & 0 & 0 & - C_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{21}} & \\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{20}} & 0 & 0 & - \\frac{1}{R_{19}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{20}} & \\frac{1}{R_{24}} + \\frac{1}{R_{20}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - C_{1} s & - \\frac{1}{R_{19}} & 0 & 0 & - \\frac{1}{R_{10}} & C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{29}} + \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{29}} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 1 & 0 & 0\\\\0 & 0 & 0 & 0 & g_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{30}} + \\frac{1}{R_{27}} & - \\frac{1}{R_{27}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{28}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{27}} & \\frac{1}{R_{28}} + \\frac{1}{R_{27}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{31}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{31}} + \\frac{1}{R_{26}} & - \\frac{1}{R_{26}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{29}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{26}} & \\frac{1}{R_{29}} + \\frac{1}{R_{26}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - ea_{1} & 0 & 0 & 0 & 0 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{2} s & - L_{4} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{5} s & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{6} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ea_{2} & - ea_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n12.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  v_{14}, \\  v_{15}, \\  v_{16}, \\  v_{17}, \\  v_{18}, \\  v_{19}, \\  v_{20}, \\  v_{21}, \\  v_{22}, \\  v_{23}, \\  v_{24}, \\  v_{25}, \\  v_{26}, \\  v_{27}, \\  v_{28}, \\  v_{29}, \\  v_{30}, \\  v_{31}, \\  v_{32}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}, \\  I_{V5}, \\  I_{V6}, \\  I_{V7}, \\  I_{V8}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}, \\  I_{L5}, \\  I_{L6}, \\  I_{F2}, \\  I_{Ea2}, \\  I_{H2}, \\  I_{O1}, \\  I_{O2}\\right]\\)\n\n\n\n\n12.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  0, \\  - I_{1}, \\  0, \\  0, \\  0, \\  I_{3}, \\  0, \\  0, \\  - I_{4}, \\  0, \\  0, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}, \\  V_{5}, \\  V_{6}, \\  V_{7}, \\  V_{8}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n12.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n22\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n10\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n10\n20\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nV5\n20\n28\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nR31\n31\n8\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n59\nO1\n29\n0\nNaN\nNaN\n30\nNaN\nNaN\nNaN\nNaN\n\n\n60\nO2\n31\n0\nNaN\nNaN\n32\nNaN\nNaN\nNaN\nNaN\n\n\n61\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.8\nNaN\nL1\nL2\n\n\n62\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.2\nNaN\nL3\nL4\n\n\n\n\n63 rows × 10 columns\n\n\n\n\n\n12.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n22\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n10\n3\n\n\n3\nV4\n10\n20\n\n\n4\nV5\n20\n28\n\n\n5\nV6\n23\n27\n\n\n6\nV7\n24\n25\n\n\n7\nV8\n0\n6\n\n\n8\nF1\n14\n7\n\n\n9\nEa1\n15\n21\n\n\n10\nH1\n4\n0\n\n\n11\nL1\n16\n23\n\n\n12\nL2\n25\n9\n\n\n13\nL3\n22\n21\n\n\n14\nL4\n17\n11\n\n\n15\nL5\n0\n7\n\n\n16\nL6\n9\n2\n\n\n17\nF2\n0\n27\n\n\n18\nEa2\n17\n26\n\n\n19\nH2\n27\n26\n\n\n20\nO1\n29\n0\n\n\n21\nO2\n31\n0\n\n\n\n\n\n\n\n\n\n12.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}}\\\\- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}}\\\\- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}}\\\\I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}}\\\\- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}}\\\\- I_{F1} - I_{L5}\\\\v_{8} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{31}}{R_{31}} - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}}\\\\- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}}\\\\I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}}\\\\- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}}\\\\- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}}\\\\v_{13} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{30}}{R_{28}} - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}}\\\\I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}}\\\\I_{Ea1} + \\frac{v_{15}}{R_{13}}\\\\I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}}\\\\I_{Ea2} + I_{L4}\\\\- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}}\\\\v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}}\\\\- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}}\\\\- I_{Ea1} - I_{L3} + \\frac{v_{21}}{R_{30}} - \\frac{v_{29}}{R_{30}}\\\\I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}}\\\\- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}}\\\\I_{V7} + v_{24} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{32}}{R_{29}} - \\frac{v_{23}}{R_{15}}\\\\I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}}\\\\- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}}\\\\v_{29} \\cdot \\left(\\frac{1}{R_{30}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{21}}{R_{30}} - \\frac{v_{30}}{R_{27}}\\\\I_{O1} + v_{30} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{13}}{R_{28}} - \\frac{v_{29}}{R_{27}}\\\\v_{31} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{8}}{R_{31}} - \\frac{v_{32}}{R_{26}}\\\\I_{O2} + v_{32} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{24}}{R_{29}} - \\frac{v_{31}}{R_{26}}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - I_{V2} f_{1}\\\\- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21}\\\\- I_{V2} h_{1} + v_{4}\\\\- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23}\\\\- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9}\\\\- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22}\\\\- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17}\\\\- I_{L5} L_{5} s - v_{7}\\\\- I_{L6} L_{6} s - v_{2} + v_{9}\\\\I_{F2} - I_{V2} f_{2}\\\\- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26}\\\\- I_{V2} h_{2} - v_{26} + v_{27}\\\\v_{29}\\\\v_{31}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\- I_{2}\\\\I_{2}\\\\0\\\\- I_{1}\\\\0\\\\0\\\\0\\\\I_{3}\\\\0\\\\0\\\\- I_{4}\\\\0\\\\0\\\\0\\\\- I_{3}\\\\0\\\\I_{4}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\V_{3}\\\\V_{4}\\\\V_{5}\\\\V_{6}\\\\V_{7}\\\\V_{8}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{26}, \\  I_{V2}, \\  v_{15}, \\  R_{23}, \\  I_{1}, \\  R_{7}, \\  I_{V1}, \\  V_{3}, \\  R_{27}, \\  C_{1}, \\  C_{2}, \\  I_{L2}, \\  I_{V7}, \\  L_{4}, \\  I_{H2}, \\  g_{2}, \\  I_{O2}, \\  v_{2}, \\  R_{20}, \\  I_{Ea2}, \\  v_{27}, \\  L_{3}, \\  f_{2}, \\  v_{7}, \\  R_{21}, \\  R_{4}, \\  v_{18}, \\  I_{V6}, \\  R_{28}, \\  L_{6}, \\  V_{4}, \\  v_{31}, \\  v_{20}, \\  R_{5}, \\  ea_{2}, \\  v_{6}, \\  R_{1}, \\  v_{14}, \\  V_{2}, \\  R_{6}, \\  I_{3}, \\  v_{21}, \\  v_{30}, \\  v_{8}, \\  I_{V8}, \\  h_{2}, \\  V_{6}, \\  v_{12}, \\  R_{19}, \\  R_{11}, \\  R_{25}, \\  v_{28}, \\  R_{29}, \\  L_{1}, \\  L_{5}, \\  v_{16}, \\  v_{32}, \\  h_{1}, \\  v_{11}, \\  R_{30}, \\  R_{2}, \\  R_{22}, \\  R_{16}, \\  v_{13}, \\  v_{5}, \\  M_{2}, \\  R_{31}, \\  R_{24}, \\  v_{4}, \\  R_{9}, \\  I_{V5}, \\  f_{1}, \\  I_{H1}, \\  I_{V4}, \\  v_{26}, \\  L_{2}, \\  v_{10}, \\  v_{19}, \\  I_{L3}, \\  V_{8}, \\  I_{F2}, \\  V_{7}, \\  v_{24}, \\  v_{3}, \\  ea_{1}, \\  I_{O1}, \\  I_{L4}, \\  R_{18}, \\  s, \\  I_{2}, \\  I_{4}, \\  V_{1}, \\  g_{1}, \\  v_{22}, \\  I_{L6}, \\  R_{14}, \\  R_{3}, \\  v_{23}, \\  v_{29}, \\  R_{13}, \\  v_{9}, \\  I_{Ea1}, \\  V_{5}, \\  I_{V3}, \\  R_{8}, \\  v_{25}, \\  I_{L5}, \\  I_{F1}, \\  v_{1}, \\  R_{15}, \\  R_{17}, \\  I_{L1}, \\  M_{1}, \\  v_{17}, \\  R_{10}, \\  R_{12}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#symbolic-solution",
    "href": "test_8.html#symbolic-solution",
    "title": "12  Test 8",
    "section": "12.3 Symbolic solution",
    "text": "12.3 Symbolic solution\nThe symbolic solution was interrupted since it was taking a long time.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#construct-a-dictionary-of-element-values",
    "href": "test_8.html#construct-a-dictionary-of-element-values",
    "title": "12  Test 8",
    "section": "12.4 Construct a dictionary of element values",
    "text": "12.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n\n12.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt;K1 L1 L2 0.8\nK2 L3 L4 0.2\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2 = symbols('K1 K2')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nmutual inductance, M1 = 1.600000000\nmutual inductance, M2 = 0.632455532\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  C_{2} : 2.0, \\  I_{1} : 3.0, \\  I_{2} : 1.0, \\  I_{3} : 2.0, \\  I_{4} : 2.0, \\  K_{1} : 0.8, \\  K_{2} : 0.2, \\  L_{1} : 1.0, \\  L_{2} : 4.0, \\  L_{3} : 2.0, \\  L_{4} : 5.0, \\  L_{5} : 1.0, \\  L_{6} : 2.0, \\  M_{1} : 1.6, \\  M_{2} : 0.632455532033676, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 5.0, \\  R_{10} : 9.0, \\  R_{11} : 4.0, \\  R_{12} : 2.0, \\  R_{13} : 5.0, \\  R_{14} : 10.0, \\  R_{15} : 5.0, \\  R_{16} : 6.0, \\  R_{17} : 5.0, \\  R_{18} : 2.0, \\  R_{19} : 7.0, \\  R_{2} : 2.0, \\  R_{20} : 5.0, \\  R_{21} : 3.0, \\  R_{22} : 3.0, \\  R_{23} : 1.0, \\  R_{24} : 3.0, \\  R_{25} : 10.0, \\  R_{26} : 20000.0, \\  R_{27} : 10000.0, \\  R_{28} : 2.0, \\  R_{29} : 5.0, \\  R_{3} : 10.0, \\  R_{30} : 20000.0, \\  R_{31} : 10000.0, \\  R_{4} : 3.0, \\  R_{5} : 3.0, \\  R_{6} : 5.0, \\  R_{7} : 10.0, \\  R_{8} : 8.0, \\  R_{9} : 3.0, \\  V_{1} : 10.0, \\  V_{2} : 2.0, \\  V_{3} : 3.0, \\  V_{4} : 5.0, \\  V_{5} : 0.0, \\  V_{6} : 0.0, \\  V_{7} : 0.0, \\  V_{8} : 0.0, \\  ea_{1} : 2.0, \\  ea_{2} : 2.0, \\  f_{1} : 2.0, \\  f_{2} : 2.0, \\  g_{1} : 2.0, \\  g_{2} : 2.0, \\  h_{1} : 3.0, \\  h_{2} : 3.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#dc-operating-point",
    "href": "test_8.html#dc-operating-point",
    "title": "12  Test 8",
    "section": "12.5 DC operating point",
    "text": "12.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + 0.125 v_{11} - 2.0 v_{12} + 2.0 v_{13}\\\\0.1 v_{12} - 0.1 v_{5}\\\\1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\0.333333333333333 v_{18} - 0.333333333333333 v_{19}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + 0.553968253968254 v_{23} - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\- 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\\\I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\\\0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\\\I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\v_{16} - v_{23}\\\\v_{25} - v_{9}\\\\- v_{21} + v_{22}\\\\- v_{11} + v_{17}\\\\- v_{7}\\\\- v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{29}\\\\v_{31}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\-1.0\\\\1.0\\\\0\\\\-3.0\\\\0\\\\0\\\\0\\\\2.0\\\\0\\\\0\\\\-2.0\\\\0\\\\0\\\\0\\\\-2.0\\\\0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\2.0\\\\3.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           5.487985\nv3         -13.447794\nv4          17.339762\nv5          12.339762\nv6           0.000000\nv7           0.000000\nv8          10.071856\nv9           5.487985\nv10        -10.447794\nv11        -13.224949\nv12         -7.660238\nv13         -7.240585\nv14        -28.683952\nv15         20.975971\nv16         35.986371\nv17        -13.224949\nv18         10.795432\nv19          4.795432\nv20        -15.447794\nv21         10.000000\nv22         10.000000\nv23         35.986371\nv24          5.487985\nv25          5.487985\nv26         18.646609\nv27         35.986371\nv28        -15.447794\nv29          0.000000\nv30         -5.000000\nv31          0.000000\nv32        -20.143712\nI_V1         7.353804\nI_V2         5.779921\nI_V3       -13.503818\nI_V4        14.750251\nI_V5        14.386843\nI_V6        -9.751819\nI_V7         0.973338\nI_V8         3.620293\nI_F1        11.559841\nI_Ea1       -4.195194\nI_H1       -14.423214\nI_L1         8.834498\nI_L2         2.289200\nI_L3         4.195694\nI_L4         0.492160\nI_L5       -11.559841\nI_L6         3.841590\nI_F2        11.559841\nI_Ea2       -0.492160\nI_H2         1.808023\nI_O1        -1.119793\nI_O2         5.127347\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(16):   35.9859     voltage\nV(8):    10.0718     voltage\nV(1):    2   voltage\nV(2):    5.48801     voltage\nV(11):   -13.2252    voltage\nV(10):   -10.4477    voltage\nV(23):   35.9859     voltage\nV(22):   10  voltage\nV(9):    5.48801     voltage\nV(24):   5.48801     voltage\nV(3):    -13.4477    voltage\nV(20):   -15.4477    voltage\nV(5):    12.3397     voltage\nV(12):   -7.66035    voltage\nV(18):   10.7954     voltage\nV(26):   18.6462     voltage\nV(25):   5.48801     voltage\nV(4):    17.3397     voltage\nV(14):   -28.6838    voltage\nV(7):    0   voltage\nV(15):   20.976  voltage\nV(21):   10  voltage\nV(13):   -7.24054    voltage\nV(28):   -15.4477    voltage\nV(27):   35.9859     voltage\nV(17):   -13.2252    voltage\nV(6):    0   voltage\nV(19):   4.79535     voltage\nV(32):   -20.1428    voltage\nV(31):   0.000252699     voltage\nV(30):   -4.99994    voltage\nV(29):   3.88014e-05     voltage\nI(C1):   5.03811e-11     device_current\nI(C2):   1.11297e-11     device_current\nI(F1):   11.5598     device_current\nI(F2):   11.5598     device_current\nI(H1):   -14.4228    device_current\nI(H2):   1.80825     device_current\nI(L1):   8.83452     device_current\nI(L2):   2.28924     device_current\nI(L3):   4.1957  device_current\nI(L4):   0.492428    device_current\nI(L5):   -11.5598    device_current\nI(L6):   3.84161     device_current\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   5.18282     device_current\nI(R2):   4.03588     device_current\nI(R6):   1.0976  device_current\nI(R8):   -0.347188   device_current\nI(R10):  2.88732     device_current\nI(R11):  -1.14594    device_current\nI(R12):  1.744   device_current\nI(R14):  -1.59357    device_current\nI(R15):  -6.09957    device_current\nI(R7):   -2  device_current\nI(R16):  -2.24128    device_current\nI(R3):   1.31582     device_current\nI(R4):   10.2625     device_current\nI(R9):   -8.66196    device_current\nI(R13):  4.1952  device_current\nI(R17):  2.40718     device_current\nI(R18):  -3.62027    device_current\nI(R19):  4.45579     device_current\nI(R20):  -4.04861    device_current\nI(R21):  -2  device_current\nI(R22):  -7.14775    device_current\nI(R23):  -5  device_current\nI(R24):  4.41202     device_current\nI(R25):  5.14336     device_current\nI(R5):   -5.14924    device_current\nI(R26):  -0.00100715     device_current\nI(R27):  -0.000499998    device_current\nI(R28):  -1.1203     device_current\nI(R29):  5.12615     device_current\nI(R30):  -0.000499998    device_current\nI(R31):  -0.00100715     device_current\nI(G1):   0.839616    device_current\nI(G2):   -24.6793    device_current\nI(E1):   -4.1952     device_current\nI(E2):   -0.492428   device_current\nI(V1):   7.35358     device_current\nI(V2):   5.77988     device_current\nI(V3):   -13.5037    device_current\nI(V4):   14.7501     device_current\nI(V5):   14.3867     device_current\nI(V6):   -9.75152    device_current\nI(V7):   0.97342     device_current\nI(V8):   3.62027     device_current\nIx(u1:3):    -1.1198     subckt_current\nIx(u2:3):    5.12716     subckt_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n12.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\nV2, V3, V4, I1, I2, I3, I4 are DC sources and are set to zero for AC analysis.\n\nelement_values[V2] = 0\nelement_values[V3] = 0\nelement_values[V4] = 0\nelement_values[I1] = 0\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\\\- 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\\\1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\- 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\\\I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\\\0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\\\I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 i I_{L1} - 1.6 i I_{L2} + v_{16} - v_{23}\\\\- 1.6 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\\\- 2.0 i I_{L3} - 0.632455532033676 i I_{L4} - v_{21} + v_{22}\\\\- 0.632455532033676 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\\\- 1.0 i I_{L5} - v_{7}\\\\- 2.0 i I_{L6} - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{29}\\\\v_{31}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          0.000000    nan\nv2          0.529312   -148.498854\nv3          2.318355    160.462708\nv4          2.716202    -16.110995\nv5          2.274423    -15.079695\nv6          0.000000    nan\nv7          1.810802     73.889005\nv8          2.202609     -5.887185\nv9          0.910663    -94.036532\nv10         2.318355    160.462708\nv11         2.230400    146.370665\nv12         2.194128    152.046037\nv13         1.799206    158.492008\nv14         4.771405    162.040739\nv15         8.166288    -49.821325\nv16        10.488620      0.340133\nv17         3.084191     60.400459\nv18         8.481449     -4.374848\nv19         3.704998     -2.371134\nv20         2.318355    160.462708\nv21         7.507931    -17.093526\nv22        10.000000      0.000000\nv23         8.497267     -9.753103\nv24         4.119822      7.433394\nv25         4.119822      7.433394\nv26         5.805567     -6.783261\nv27         8.497267     -9.753103\nv28         2.318355    160.462708\nv29         0.000000    nan\nv30         3.753966    162.906474\nv31         0.000000    nan\nv32         4.405217    174.112815\nI_V1        1.542202    134.030697\nI_V2        0.905401    -16.110995\nI_V3        2.063669    161.965216\nI_V4        2.338768    -18.698461\nI_V5        2.701207    -15.096706\nI_V6        1.422424   -174.447987\nI_V7        0.931072   -153.824119\nI_V8        0.899603    -21.507992\nI_F1        1.810802    -16.110995\nI_Ea1       1.633258    130.178675\nI_H1        1.484613   -177.450035\nI_L1        2.862976    -26.151162\nI_L2        0.854027   -141.418577\nI_L3        1.633573    -49.814207\nI_L4        0.541202    -73.251389\nI_L5        1.810802    163.889005\nI_L6        0.370519   -148.498854\nI_F2        1.810802    -16.110995\nI_Ea2       0.541202    106.748611\nI_H2        0.717411    -63.158104\nI_O1        0.982866    -13.053681\nI_O2        1.693733      0.548292\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    10.4887 phase:   0.339452°  voltage\nV(8):   mag:    2.20263 phase:    -5.8879°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:   0.529319 phase:   -148.499°  voltage\nV(11):  mag:    2.23038 phase:    146.371°  voltage\nV(10):  mag:    2.31839 phase:    160.462°  voltage\nV(23):  mag:    8.49732 phase:   -9.75384°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:   0.910675 phase:   -94.0363°  voltage\nV(24):  mag:     4.1199 phase:    7.43283°  voltage\nV(3):   mag:    2.31839 phase:    160.462°  voltage\nV(20):  mag:    2.31839 phase:    160.462°  voltage\nV(5):   mag:    2.27445 phase:   -15.0807°  voltage\nV(12):  mag:    2.19411 phase:    152.046°  voltage\nV(18):  mag:     8.4815 phase:   -4.37559°  voltage\nV(26):  mag:    5.80559 phase:   -6.78388°  voltage\nV(25):  mag:     4.1199 phase:    7.43283°  voltage\nV(4):   mag:    2.71624 phase:   -16.1119°  voltage\nV(14):  mag:    4.77144 phase:     162.04°  voltage\nV(7):   mag:    1.81082 phase:    73.8881°  voltage\nV(15):  mag:    8.16625 phase:   -49.8218°  voltage\nV(21):  mag:    7.50792 phase:   -17.0934°  voltage\nV(13):  mag:    1.79919 phase:    158.492°  voltage\nV(28):  mag:    2.31839 phase:    160.462°  voltage\nV(27):  mag:    8.49732 phase:   -9.75384°  voltage\nV(17):  mag:    3.08423 phase:    60.4014°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    3.70502 phase:   -2.37192°  voltage\nV(32):  mag:    4.40507 phase:    174.112°  voltage\nV(31):  mag: 6.0913e-05 phase:   -4.03597°  voltage\nV(30):  mag:    3.75389 phase:    162.907°  voltage\nV(29):  mag: 4.73489e-05 phase:   -16.1831°     voltage\nI(C1):  mag:     1.5935 phase:   -5.92837°  device_current\nI(C2):  mag:   0.444041 phase:   -21.4012°  device_current\nI(F1):  mag:    1.81082 phase:   -16.1119°  device_current\nI(F2):  mag:    1.81082 phase:   -16.1119°  device_current\nI(H1):  mag:    1.48461 phase:   -177.452°  device_current\nI(H2):  mag:   0.717409 phase:   -63.1574°  device_current\nI(L1):  mag:    2.86299 phase:   -26.1518°  device_current\nI(L2):  mag:   0.854034 phase:   -141.418°  device_current\nI(L3):  mag:    1.63357 phase:   -49.8147°  device_current\nI(L4):  mag:   0.541197 phase:   -73.2497°  device_current\nI(L5):  mag:    1.81082 phase:    163.888°  device_current\nI(L6):  mag:   0.370523 phase:   -148.499°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:     1.6605 phase:    1.98853°  device_current\nI(R2):  mag:    1.10131 phase:    -5.8879°  device_current\nI(R6):  mag:   0.105864 phase:   -148.499°  device_current\nI(R8):  mag:  0.0705929 phase:    54.5194°  device_current\nI(R10): mag:   0.241259 phase:   -138.471°  device_current\nI(R11): mag:   0.589029 phase:   -163.163°  device_current\nI(R12): mag:    0.26466 phase:   -148.499°  device_current\nI(R14): mag:   0.270792 phase:    141.553°  device_current\nI(R15): mag:   0.944208 phase:    155.303°  device_current\nI(R7):  mag:   0.444041 phase:    158.599°  device_current\nI(R16): mag:   0.386398 phase:    160.462°  device_current\nI(R3):  mag:   0.207524 phase:   -35.9644°  device_current\nI(R4):  mag:    1.67746 phase:   -17.6897°  device_current\nI(R9):  mag:   0.164149 phase:   -172.751°  device_current\nI(R13): mag:    1.63325 phase:   -49.8218°  device_current\nI(R17): mag:    1.08737 phase:   -8.59974°  device_current\nI(R18): mag:   0.899593 phase:    158.492°  device_current\nI(R19): mag:   0.692348 phase:   -15.3907°  device_current\nI(R20): mag:    1.19191 phase:    171.035°  device_current\nI(R21): mag:     1.5935 phase:    174.072°  device_current\nI(R22): mag:   0.992596 phase:    164.183°  device_current\nI(R23): mag:   0.444041 phase:    158.599°  device_current\nI(R24): mag:   0.818256 phase:   -16.4696°  device_current\nI(R25): mag:    1.07892 phase:   -11.8466°  device_current\nI(R5):  mag:   0.772795 phase:    160.462°  device_current\nI(R26): mag: 0.000220257 phase:    174.112°     device_current\nI(R27): mag: 0.000375394 phase:    162.907°     device_current\nI(R28): mag:   0.982466 phase:   -13.0516°  device_current\nI(R29): mag:     1.6935 phase:   0.548618°  device_current\nI(R30): mag: 0.000375394 phase:    162.907°     device_current\nI(R31): mag: 0.000220257 phase:    174.112°     device_current\nI(G1):  mag:    0.90747 phase:   -54.3873°  device_current\nI(G2):  mag:    4.54891 phase:    164.919°  device_current\nI(E1):  mag:    1.63325 phase:    130.178°  device_current\nI(E2):  mag:   0.541197 phase:     106.75°  device_current\nI(V1):  mag:    1.54213 phase:    134.031°  device_current\nI(V2):  mag:   0.905412 phase:   -16.1119°  device_current\nI(V3):  mag:     2.0637 phase:    161.964°  device_current\nI(V4):  mag:     2.3388 phase:   -18.6996°  device_current\nI(V5):  mag:    2.70125 phase:   -15.0979°  device_current\nI(V6):  mag:    1.42243 phase:    -174.45°  device_current\nI(V7):  mag:   0.931071 phase:   -153.824°  device_current\nI(V8):  mag:   0.899593 phase:   -21.5082°  device_current\nIx(u1:3):   mag:    0.98284 phase:   -13.0531°  subckt_current\nIx(u2:3):   mag:    1.69372 phase:   0.547783°  subckt_current\n\n\n\n12.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(2.0 s + 0.125\\right) + v_{12} \\left(- 2.0 s - 2.0\\right) + 2.0 v_{13}\\\\- 2.0 s v_{11} + v_{12} \\cdot \\left(2.0 s + 0.1\\right) - 0.1 v_{5}\\\\1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\- 2.0 s v_{23} + v_{18} \\cdot \\left(2.0 s + 0.333333333333333\\right) - 0.333333333333333 v_{19}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 s v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(2.0 s + 0.553968253968254\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\- 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\\\I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\\\0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\\\I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 I_{L1} s - 1.6 I_{L2} s + v_{16} - v_{23}\\\\- 1.6 I_{L1} s - 4.0 I_{L2} s + v_{25} - v_{9}\\\\- 2.0 I_{L3} s - 0.632455532033676 I_{L4} s - v_{21} + v_{22}\\\\- 0.632455532033676 I_{L3} s - 5.0 I_{L4} s - v_{11} + v_{17}\\\\- 1.0 I_{L5} s - v_{7}\\\\- 2.0 I_{L6} s - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{29}\\\\v_{31}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n12.5.3 Plot the voltage at node 10\n\nH = U_ac[v21]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 10*2*np.pi, 1000, endpoint=True)\nx = np.logspace(-2, 1, 300, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_8.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_9.html",
    "href": "test_9.html",
    "title": "13  Test 9",
    "section": "",
    "text": "13.1 Load the net list\nnet_list = '''\nG1 0 1 1 0 0.6\nI1 0 1 10\nG2 1 0 1 0 0.8\n*R1 1 0 100e6\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_9.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "13  Test 9",
    "section": "13.2 Call the symbolic modified nodal analysis function",
    "text": "13.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\left(- g_{1} + g_{2}\\right) = I_{1}\\)\n\n\n\n13.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 3\nnumber of branches: 3\nnumber of nodes: 1\nnumber of unknown currents: 0\nnumber of RLC (passive components): 0\nnumber of inductors: 0\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 2\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n13.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}- g_{1} + g_{2}\\end{matrix}\\right]\\)\n\n\n\n\n13.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}\\right]\\)\n\n\n\n\n13.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{1}\\right]\\)\n\n\n\n\n13.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nG1\n0\n1\n1\n0\nNaN\n0.6\nNaN\nNaN\nNaN\n\n\n1\nI1\n0\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nG2\n1\n0\n1\n0\nNaN\n0.8\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n13.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n\n\n\n\n\n\n\n13.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1} \\left(- g_{1} + g_{2}\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( g_{2}, \\  I_{1}, \\  v_{1}, \\  g_{1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#symbolic-solution",
    "href": "test_9.html#symbolic-solution",
    "title": "13  Test 9",
    "section": "13.3 Symbolic solution",
    "text": "13.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = - \\frac{I_{1}}{g_{1} - g_{2}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#construct-a-dictionary-of-element-values",
    "href": "test_9.html#construct-a-dictionary-of-element-values",
    "title": "13  Test 9",
    "section": "13.4 Construct a dictionary of element values",
    "text": "13.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 10.0, \\  g_{1} : 0.6, \\  g_{2} : 0.8\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#numerical-solution",
    "href": "test_9.html#numerical-solution",
    "title": "13  Test 9",
    "section": "13.5 Numerical solution",
    "text": "13.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}10.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1         50.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n\n  --- Operating Point ---\nV(1): 50 voltage I(I1): 10 device_current I(R1): 5e-07 device_current I(G1): 30 device_current I(G2): 40 device_current\nThe results from LTSpice agree with the SymPy results.\n\nFind the power absorbed by each source in the circuit.  \nThe results from LTSpice agree with the SymPy results.\n\nelement_values[g1]*U[v1]**2 # power through G1\n\n\\(\\displaystyle 1500.0\\)\n\n\n\nelement_values[g2]*U[v1]**2 # power through G2\n\n\\(\\displaystyle 2000.0\\)\n\n\n\nelement_values[I1]*U[v1] # power through I1\n\n\\(\\displaystyle 500.0\\)\n\n\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_10.html",
    "href": "test_10.html",
    "title": "14  Test 10",
    "section": "",
    "text": "14.1 Load the net list\nnet_list = '''\nI1 3 2 2\nI2 0 1 -3\nI3 4 0 4\nV1 2 3 -5\nV2 2 0 3\nV3 3 4 4\nV4 2 1 12\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_10.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "14  Test 10",
    "section": "14.2 Call the symbolic modified nodal analysis function",
    "text": "14.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- I_{V4} = I_{2}\\)\\(I_{V1} + I_{V2} + I_{V4} = I_{1}\\)\\(- I_{V1} + I_{V3} = - I_{1}\\)\\(- I_{V3} = - I_{3}\\)\\(v_{2} - v_{3} = V_{1}\\)\\(v_{2} = V_{2}\\)\\(v_{3} - v_{4} = V_{3}\\)\\(- v_{1} + v_{2} = V_{4}\\)\n\n\n\n14.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 7\nnumber of branches: 7\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 0\nnumber of inductors: 0\nnumber of independent voltage sources: 4\nnumber of independent current sources: 3\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n14.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 1 & 1 & 0 & 1\\\\0 & 0 & 0 & 0 & -1 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\0 & 1 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 1 & -1 & 0 & 0 & 0 & 0\\\\-1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\end{matrix}\\right]\\)\n\n\n\n\n14.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}\\right]\\)\n\n\n\n\n14.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{2}, \\  I_{1}, \\  - I_{1}, \\  - I_{3}, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}\\right]\\)\n\n\n\n\n14.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n2\n3\nNaN\nNaN\nNaN\n-5.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n2\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n3\n4\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n2\n1\nNaN\nNaN\nNaN\n12.0\nNaN\nNaN\nNaN\n\n\n4\nI1\n3\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nI2\n0\n1\nNaN\nNaN\nNaN\n-3.0\nNaN\nNaN\nNaN\n\n\n6\nI3\n4\n0\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n14.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n2\n3\n\n\n1\nV2\n2\n0\n\n\n2\nV3\n3\n4\n\n\n3\nV4\n2\n1\n\n\n\n\n\n\n\n\n\n14.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{V4}\\\\I_{V1} + I_{V2} + I_{V4}\\\\- I_{V1} + I_{V3}\\\\- I_{V3}\\\\v_{2} - v_{3}\\\\v_{2}\\\\v_{3} - v_{4}\\\\- v_{1} + v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{2}\\\\I_{1}\\\\- I_{1}\\\\- I_{3}\\\\V_{1}\\\\V_{2}\\\\V_{3}\\\\V_{4}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( V_{2}, \\  V_{3}, \\  I_{3}, \\  I_{V2}, \\  v_{3}, \\  I_{1}, \\  I_{2}, \\  I_{V3}, \\  I_{V4}, \\  V_{1}, \\  V_{4}, \\  v_{4}, \\  v_{1}, \\  I_{V1}, \\  v_{2}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#symbolic-solution",
    "href": "test_10.html#symbolic-solution",
    "title": "14  Test 10",
    "section": "14.3 Symbolic solution",
    "text": "14.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(I_{V1} = I_{1} + I_{3}\\)\\(I_{V2} = I_{2} - I_{3}\\)\\(I_{V3} = I_{3}\\)\\(I_{V4} = - I_{2}\\)\\(v_{1} = V_{2} - V_{4}\\)\\(v_{2} = V_{2}\\)\\(v_{3} = - V_{1} + V_{2}\\)\\(v_{4} = - V_{1} + V_{2} - V_{3}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#construct-a-dictionary-of-element-values",
    "href": "test_10.html#construct-a-dictionary-of-element-values",
    "title": "14  Test 10",
    "section": "14.4 Construct a dictionary of element values",
    "text": "14.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 2.0, \\  I_{2} : -3.0, \\  I_{3} : 4.0, \\  V_{1} : -5.0, \\  V_{2} : 3.0, \\  V_{3} : 4.0, \\  V_{4} : 12.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#numerical-solution",
    "href": "test_10.html#numerical-solution",
    "title": "14  Test 10",
    "section": "14.5 Numerical solution",
    "text": "14.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{V4}\\\\I_{V1} + I_{V2} + I_{V4}\\\\- I_{V1} + I_{V3}\\\\- I_{V3}\\\\v_{2} - v_{3}\\\\v_{2}\\\\v_{3} - v_{4}\\\\- v_{1} + v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-3.0\\\\2.0\\\\-2.0\\\\-4.0\\\\-5.0\\\\3.0\\\\4.0\\\\12.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nI_V1        6.000000\nI_V2       -7.000000\nI_V3        4.000000\nI_V4        3.000000\nv1         -9.000000\nv2          3.000000\nv3          8.000000\nv4          4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\nV(3):    8   voltage\nV(2):    3   voltage\nV(1):    -9  voltage\nV(4):    4   voltage\nI(I1):   2   device_current\nI(I2):   -3  device_current\nI(I3):   4   device_current\nI(V1):   6   device_current\nI(V2):   -7  device_current\nI(V3):   4   device_current\nI(V4):   3   device_current\nThe results from LTSpice agree with the SymPy results.\nFind the power absorbed by each source in the circuit.\nThe results from LTSpice agree with the SymPy results.\n\nLooking at equation I_V1 = I₁ + I₃, set I_V1  to zero\n\n::: {#cell-37 .cell execution_count=19}\n``` {.python .cell-code}\nelement_values[I1] + element_values[I3] - 0\n\n\\(\\displaystyle 6.0\\)\n\n:::\nBy inspection a value of I3 = -2 will make I_V1 = 0\n\nelement_values[I1] + (-2) - 0\n\n\\(\\displaystyle 0.0\\)\n\n\nanswer is -2\nText book’s answers are: (a) 30W; (b) -2A\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_11.html",
    "href": "test_11.html",
    "title": "15  Test 11",
    "section": "",
    "text": "15.1 Load the net list\nnet_list = '''\nL1 1 0 10 \nL2 0 2 20 \nL3 4 0 30\nR2 2 0 5\nR3 4 0 10\nR1 1 3 2\nV1 3 0 10\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_11.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "15  Test 11",
    "section": "15.2 Call the symbolic modified nodal analysis function",
    "text": "15.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L2} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L3} + \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{3} = V_{1}\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s - I_{L3} M_{2} s + v_{1} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s - I_{L3} M_{3} s - v_{2} = 0\\)\\(- I_{L1} M_{2} s - I_{L2} M_{3} s - I_{L3} L_{3} s + v_{4} = 0\\)\n\n\n\n15.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 7\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 6\nnumber of inductors: 3\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 3\n\n\n\n\n\n15.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & -1 & 0\\\\- \\frac{1}{R_{1}} & 0 & \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 0 & 1\\\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & - M_{2} s\\\\0 & -1 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & - M_{3} s\\\\0 & 0 & 0 & 1 & 0 & - M_{2} s & - M_{3} s & - L_{3} s\\end{matrix}\\right]\\)\n\n\n\n\n15.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}\\right]\\)\n\n\n\n\n15.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n15.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n3\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nL1\n1\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nL2\n0\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n3\nL3\n4\n0\nNaN\nNaN\nNaN\n30.0\nNaN\nNaN\nNaN\n\n\n4\nR2\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n5\nR3\n4\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n6\nR1\n1\n3\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.2\nNaN\nL1\nL2\n\n\n8\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.8\nNaN\nL1\nL3\n\n\n9\nK3\nNaN\nNaN\nNaN\nNaN\nNaN\n0.5\nNaN\nL2\nL3\n\n\n\n\n\n\n\n\n\n15.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n3\n0\n\n\n1\nL1\n1\n0\n\n\n2\nL2\n0\n2\n\n\n3\nL3\n4\n0\n\n\n\n\n\n\n\n\n\n15.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\\\- I_{L2} + \\frac{v_{2}}{R_{2}}\\\\I_{V1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}}\\\\I_{L3} + \\frac{v_{4}}{R_{3}}\\\\v_{3}\\\\- I_{L1} L_{1} s - I_{L2} M_{1} s - I_{L3} M_{2} s + v_{1}\\\\- I_{L1} M_{1} s - I_{L2} L_{2} s - I_{L3} M_{3} s - v_{2}\\\\- I_{L1} M_{2} s - I_{L2} M_{3} s - I_{L3} L_{3} s + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( M_{2}, \\  R_{1}, \\  L_{3}, \\  v_{4}, \\  I_{L3}, \\  v_{3}, \\  I_{V1}, \\  I_{L2}, \\  L_{2}, \\  R_{2}, \\  v_{2}, \\  L_{1}, \\  V_{1}, \\  R_{3}, \\  I_{L1}, \\  s, \\  v_{1}, \\  M_{1}, \\  M_{3}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#symbolic-solution",
    "href": "test_11.html#symbolic-solution",
    "title": "15  Test 11",
    "section": "15.3 Symbolic solution",
    "text": "15.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{L_{1} L_{2} L_{3} V_{1} s^{3} + L_{1} L_{2} R_{3} V_{1} s^{2} + L_{1} L_{3} R_{2} V_{1} s^{2} - L_{1} M_{3}^{2} V_{1} s^{3} + L_{1} R_{2} R_{3} V_{1} s - L_{2} M_{2}^{2} V_{1} s^{3} - L_{3} M_{1}^{2} V_{1} s^{3} - M_{1}^{2} R_{3} V_{1} s^{2} + 2 M_{1} M_{2} M_{3} V_{1} s^{3} - M_{2}^{2} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{2} = \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{L_{2} M_{2} R_{3} V_{1} s^{2} - M_{1} M_{3} R_{3} V_{1} s^{2} + M_{2} R_{2} R_{3} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{V1} = \\frac{- L_{2} L_{3} V_{1} s^{2} - L_{2} R_{3} V_{1} s - L_{3} R_{2} V_{1} s + M_{3}^{2} V_{1} s^{2} - R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L1} = \\frac{L_{2} L_{3} V_{1} s^{2} + L_{2} R_{3} V_{1} s + L_{3} R_{2} V_{1} s - M_{3}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L2} = \\frac{- L_{3} M_{1} V_{1} s^{2} - M_{1} R_{3} V_{1} s + M_{2} M_{3} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L3} = \\frac{- L_{2} M_{2} V_{1} s^{2} + M_{1} M_{3} V_{1} s^{2} - M_{2} R_{2} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#construct-a-dictionary-of-element-values",
    "href": "test_11.html#construct-a-dictionary-of-element-values",
    "title": "15  Test 11",
    "section": "15.4 Construct a dictionary of element values",
    "text": "15.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\n15.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit.\n\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(M_1 = K1 \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = K2 \\times {\\sqrt{L_1 \\times L_3}}\\)\n\\(M_3 = K3 \\times {\\sqrt{L_2 \\times L_3}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L1] * element_values[L3])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nelement_values[M3] = element_values[K3]*np.sqrt(element_values[L2] * element_values[L3])\nprint('mutual inductance, M3 = {:.9f}'.format(element_values[M3]))\n\nmutual inductance, M1 = 2.828427125\nmutual inductance, M2 = 13.856406461\nmutual inductance, M3 = 12.247448714\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ K_{1} : 0.2, \\  K_{2} : 0.8, \\  K_{3} : 0.5, \\  L_{1} : 10.0, \\  L_{2} : 20.0, \\  L_{3} : 30.0, \\  M_{1} : 2.82842712474619, \\  M_{2} : 13.856406460551, \\  M_{3} : 12.2474487139159, \\  R_{1} : 2.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  V_{1} : 10.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#dc-operating-point",
    "href": "test_11.html#dc-operating-point",
    "title": "15  Test 11",
    "section": "15.5 DC operating point",
    "text": "15.5 DC operating point\nBoth ?\nV4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\v_{1}\\\\- v_{2}\\\\v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          0.000000\nv3         10.000000\nI_V1       -5.000000\nI_L1        5.000000\nv2          0.000000\nI_L2        0.000000\nv4          0.000000\nI_L3        0.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    0   voltage\nV(2):    0   voltage\nV(4):    0   voltage\nV(3):    10  voltage\nI(L1):   5   device_current\nI(L2):   0   device_current\nI(L3):   0   device_current\nI(R2):   0   device_current\nI(R3):   0   device_current\nI(R1):   -5  device_current\nI(V1):   -5  device_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n15.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\- 10.0 i I_{L1} - 2.82842712474619 i I_{L2} - 13.856406460551 i I_{L3} + v_{1}\\\\- 2.82842712474619 i I_{L1} - 20.0 i I_{L2} - 12.2474487139159 i I_{L3} - v_{2}\\\\- 13.856406460551 i I_{L1} - 12.2474487139159 i I_{L2} - 30.0 i I_{L3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          8.002110     16.522966\nv2          1.369735     15.274587\nv3         10.000000      0.000000\nv4          7.724137    -19.105758\nI_V1        1.627911    135.653713\nI_L1        1.627911    -44.346287\nI_L2        0.273947     15.274587\nI_L3        0.772414    160.894242\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\n\n15.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\- 10.0 I_{L1} s - 2.82842712474619 I_{L2} s - 13.856406460551 I_{L3} s + v_{1}\\\\- 2.82842712474619 I_{L1} s - 20.0 I_{L2} s - 12.2474487139159 I_{L3} s - v_{2}\\\\- 13.856406460551 I_{L1} s - 12.2474487139159 I_{L2} s - 30.0 I_{L3} s + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n15.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 10*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 1, 300, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_11.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_12.html",
    "href": "test_12.html",
    "title": "16  Test 12",
    "section": "",
    "text": "16.1 Load the net list\nnet_list = '''\nC3 2 0 3.7642\nI1 0 1 1\nC5 3 0 4.015\nC7 4 0 3.0182\nL2 1 2 0.7529\nL4 2 3 0.9276\nL6 3 4 0.9142\nRs 1 0 0.5\nRl 4 0 1\nC1 1 0 1.5948\n\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_12.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "16  Test 12",
    "section": "16.2 Call the symbolic modified nodal analysis function",
    "text": "16.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L2} + v_{1} \\left(C_{1} s + \\frac{1}{Rs}\\right) = I_{1}\\)\\(C_{3} s v_{2} - I_{L2} + I_{L4} = 0\\)\\(C_{5} s v_{3} - I_{L4} + I_{L6} = 0\\)\\(- I_{L6} + v_{4} \\left(C_{7} s + \\frac{1}{Rl}\\right) = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{2} = 0\\)\\(- I_{L4} L_{4} s + v_{2} - v_{3} = 0\\)\\(- I_{L6} L_{6} s + v_{3} - v_{4} = 0\\)\n\n\n\n16.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 10\nnumber of nodes: 4\nnumber of unknown currents: 3\nnumber of RLC (passive components): 9\nnumber of inductors: 3\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n16.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{Rs} & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & C_{3} s & 0 & 0 & -1 & 1 & 0\\\\0 & 0 & C_{5} s & 0 & 0 & -1 & 1\\\\0 & 0 & 0 & C_{7} s + \\frac{1}{Rl} & 0 & 0 & -1\\\\1 & -1 & 0 & 0 & - L_{2} s & 0 & 0\\\\0 & 1 & -1 & 0 & 0 & - L_{4} s & 0\\\\0 & 0 & 1 & -1 & 0 & 0 & - L_{6} s\\end{matrix}\\right]\\)\n\n\n\n\n16.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{L2}, \\  I_{L4}, \\  I_{L6}\\right]\\)\n\n\n\n\n16.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{1}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n16.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nC3\n2\n0\nNaN\nNaN\nNaN\n3.7642\nNaN\nNaN\nNaN\n\n\n1\nI1\n0\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n2\nC5\n3\n0\nNaN\nNaN\nNaN\n4.015\nNaN\nNaN\nNaN\n\n\n3\nC7\n4\n0\nNaN\nNaN\nNaN\n3.0182\nNaN\nNaN\nNaN\n\n\n4\nL2\n1\n2\nNaN\nNaN\nNaN\n0.7529\nNaN\nNaN\nNaN\n\n\n5\nL4\n2\n3\nNaN\nNaN\nNaN\n0.9276\nNaN\nNaN\nNaN\n\n\n6\nL6\n3\n4\nNaN\nNaN\nNaN\n0.9142\nNaN\nNaN\nNaN\n\n\n7\nRs\n1\n0\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nRl\n4\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n9\nC1\n1\n0\nNaN\nNaN\nNaN\n1.5948\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n16.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL2\n1\n2\n\n\n1\nL4\n2\n3\n\n\n2\nL6\n3\n4\n\n\n\n\n\n\n\n\n\n16.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\left(C_{1} s + \\frac{1}{Rs}\\right)\\\\C_{3} s v_{2} - I_{L2} + I_{L4}\\\\C_{5} s v_{3} - I_{L4} + I_{L6}\\\\- I_{L6} + v_{4} \\left(C_{7} s + \\frac{1}{Rl}\\right)\\\\- I_{L2} L_{2} s + v_{1} - v_{2}\\\\- I_{L4} L_{4} s + v_{2} - v_{3}\\\\- I_{L6} L_{6} s + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{3}, \\  L_{2}, \\  I_{1}, \\  C_{7}, \\  v_{4}, \\  I_{L4}, \\  v_{3}, \\  L_{4}, \\  s, \\  Rs, \\  C_{1}, \\  Rl, \\  v_{2}, \\  v_{1}, \\  C_{5}, \\  I_{L2}, \\  L_{6}, \\  I_{L6}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#symbolic-solution",
    "href": "test_12.html#symbolic-solution",
    "title": "16  Test 12",
    "section": "16.3 Symbolic solution",
    "text": "16.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{3} C_{5} C_{7} I_{1} L_{2} L_{4} L_{6} Rl Rs s^{6} + C_{3} C_{5} I_{1} L_{2} L_{4} L_{6} Rs s^{5} + C_{3} C_{5} I_{1} L_{2} L_{4} Rl Rs s^{4} + C_{3} C_{7} I_{1} L_{2} L_{4} Rl Rs s^{4} + C_{3} C_{7} I_{1} L_{2} L_{6} Rl Rs s^{4} + C_{3} I_{1} L_{2} L_{4} Rs s^{3} + C_{3} I_{1} L_{2} L_{6} Rs s^{3} + C_{3} I_{1} L_{2} Rl Rs s^{2} + C_{5} C_{7} I_{1} L_{2} L_{6} Rl Rs s^{4} + C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{4} + C_{5} I_{1} L_{2} L_{6} Rs s^{3} + C_{5} I_{1} L_{2} Rl Rs s^{2} + C_{5} I_{1} L_{4} L_{6} Rs s^{3} + C_{5} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{2} Rl Rs s^{2} + C_{7} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{2} Rs s + I_{1} L_{4} Rs s + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{2} = \\frac{C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{4} + C_{5} I_{1} L_{4} L_{6} Rs s^{3} + C_{5} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{4} Rs s + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{3} = \\frac{C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{4} = \\frac{I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L2} = \\frac{C_{3} C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} I_{1} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} I_{1} L_{4} Rl Rs s^{3} + C_{3} C_{7} I_{1} L_{4} Rl Rs s^{3} + C_{3} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{3} I_{1} L_{4} Rs s^{2} + C_{3} I_{1} L_{6} Rs s^{2} + C_{3} I_{1} Rl Rs s + C_{5} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{5} I_{1} L_{6} Rs s^{2} + C_{5} I_{1} Rl Rs s + C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L4} = \\frac{C_{5} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{5} I_{1} L_{6} Rs s^{2} + C_{5} I_{1} Rl Rs s + C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L6} = \\frac{C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#construct-a-dictionary-of-element-values",
    "href": "test_12.html#construct-a-dictionary-of-element-values",
    "title": "16  Test 12",
    "section": "16.4 Construct a dictionary of element values",
    "text": "16.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.5948, \\  C_{3} : 3.7642, \\  C_{5} : 4.015, \\  C_{7} : 3.0182, \\  I_{1} : 1.0, \\  L_{2} : 0.7529, \\  L_{4} : 0.9276, \\  L_{6} : 0.9142, \\  Rl : 1.0, \\  Rs : 0.5\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#dc-operating-point",
    "href": "test_12.html#dc-operating-point",
    "title": "16  Test 12",
    "section": "16.5 DC operating point",
    "text": "16.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 2.0 v_{1}\\\\- I_{L2} + I_{L4}\\\\- I_{L4} + I_{L6}\\\\- I_{L6} + 1.0 v_{4}\\\\v_{1} - v_{2}\\\\v_{2} - v_{3}\\\\v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown         mag\n---------  --------\nv1         0.333333\nv2         0.333333\nv3         0.333333\nv4         0.333333\nI_L2       0.333333\nI_L4       0.333333\nI_L6       0.333333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    0.333333    voltage\nV(1):    0.333333    voltage\nV(3):    0.333333    voltage\nV(4):    0.333333    voltage\nI(C3):   1.25473e-12     device_current\nI(C5):   1.33833e-12     device_current\nI(C7):   1.00607e-12     device_current\nI(C1):   5.316e-13   device_current\nI(L2):   0.333333    device_current\nI(L4):   0.333333    device_current\nI(L6):   0.333333    device_current\nI(I1):   1   device_current\nI(Rs):   0.666667    device_current\nI(Rl):   0.333333    device_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n16.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\cdot \\left(2.0 + 1.5948 i\\right)\\\\- I_{L2} + I_{L4} + 3.7642 i v_{2}\\\\- I_{L4} + I_{L6} + 4.015 i v_{3}\\\\- I_{L6} + v_{4} \\cdot \\left(1.0 + 3.0182 i\\right)\\\\- 0.7529 i I_{L2} + v_{1} - v_{2}\\\\- 0.9276 i I_{L4} + v_{2} - v_{3}\\\\- 0.9142 i I_{L6} + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.247674     43.979099\nv2         0.596900   -119.590485\nv3         0.467235     71.054634\nv4         0.235668    -81.486420\nI_L2       1.112227    -34.389344\nI_L4       1.142319    155.081675\nI_L6       0.749319     -9.817657\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:     0.5969 phase:    -119.59°  voltage\nV(1):   mag:   0.247674 phase:    43.9791°  voltage\nV(3):   mag:   0.467235 phase:    71.0546°  voltage\nV(4):   mag:   0.235668 phase:   -81.4864°  voltage\nI(C3):  mag:    2.24685 phase:   -29.5905°  device_current\nI(C5):  mag:    1.87595 phase:    161.055°  device_current\nI(C7):  mag:   0.711294 phase:    8.51358°  device_current\nI(C1):  mag:   0.394991 phase:    133.979°  device_current\nI(L2):  mag:    1.11223 phase:   -34.3893°  device_current\nI(L4):  mag:    1.14232 phase:    155.082°  device_current\nI(L6):  mag:   0.749319 phase:   -9.81766°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(Rs):  mag:   0.495349 phase:    43.9791°  device_current\nI(Rl):  mag:   0.235668 phase:   -81.4864°  device_current\n\n\n\n16.5.2 AC Sweep\nLooking at node 4 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\cdot \\left(1.5948 s + 2.0\\right)\\\\- I_{L2} + I_{L4} + 3.7642 s v_{2}\\\\- I_{L4} + I_{L6} + 4.015 s v_{3}\\\\- I_{L6} + v_{4} \\cdot \\left(3.0182 s + 1.0\\right)\\\\- 0.7529 I_{L2} s + v_{1} - v_{2}\\\\- 0.9276 I_{L4} s + v_{2} - v_{3}\\\\- 0.9142 I_{L6} s + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n16.5.3 Plot the voltage at node 2\n\nH = U_ac[v4]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_12_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfrequency[0]\n\n\\(\\displaystyle 0.01\\)\n\n\n\nfrequency[-1]\n\n\\(\\displaystyle 1.0\\)\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1]) - 10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2)*180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response difference')\nplt.show()",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#poles-and-zeros-of-the-transfer-function",
    "href": "test_12.html#poles-and-zeros-of-the-transfer-function",
    "title": "16  Test 12",
    "section": "16.6 Poles and zeros of the transfer function",
    "text": "16.6 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n16.6.0.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 7\n-0.01+0.16j Hz\n-0.01-0.16j Hz\n-0.04+0.12j Hz\n-0.04-0.12j Hz\n-0.05+0.07j Hz\n-0.05-0.07j Hz\n-0.06+0.00j Hz",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#impulse-and-step-response",
    "href": "test_12.html#impulse-and-step-response",
    "title": "16  Test 12",
    "section": "16.7 Impulse and step response",
    "text": "16.7 Impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n16.7.1 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\n#w_preamp, mag_preamp, phase_preamp = bp_sys.bode(w=x_axis_range)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley & Sons.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_13.html",
    "href": "test_13.html",
    "title": "17  Test 13",
    "section": "",
    "text": "17.1 Load the net list\nNode 5 added manually along with R1 = 1e-20 ohms in series with L1.\nnet_list = '''\n*L1 2 3 5 \nL1 2 4 5\nR1 4 3 1e-20\nI1 1 2 2 \nL2 0 3 3 \nL3 2 1 1 \nL4 1 0 1 \nI2 0 1 1\nI3 3 0 5\nI4 2 3 3\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_13.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "17  Test 13",
    "section": "17.2 Call the symbolic modified nodal analysis function",
    "text": "17.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- I_{L3} + I_{L4} = - I_{1} + I_{2}\\)\\(I_{L1} + I_{L3} = I_{1} - I_{4}\\)\\(- I_{L2} + \\frac{v_{3}}{R_{1}} - \\frac{v_{4}}{R_{1}} = - I_{3} + I_{4}\\)\\(- I_{L1} - \\frac{v_{3}}{R_{1}} + \\frac{v_{4}}{R_{1}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} - v_{4} = 0\\)\\(- I_{L2} L_{2} s - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{1} + v_{2} = 0\\)\\(- I_{L4} L_{4} s + v_{1} = 0\\)\n\n\n\n17.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 5\nnumber of inductors: 4\nnumber of independent voltage sources: 0\nnumber of independent current sources: 4\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n17.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0 & 0 & -1 & 1\\\\0 & 0 & 0 & 0 & 1 & 0 & 1 & 0\\\\0 & 0 & \\frac{1}{R_{1}} & - \\frac{1}{R_{1}} & 0 & -1 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{1}} & \\frac{1}{R_{1}} & -1 & 0 & 0 & 0\\\\0 & 1 & 0 & -1 & - L_{1} s & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & - L_{2} s & 0 & 0\\\\-1 & 1 & 0 & 0 & 0 & 0 & - L_{3} s & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{4} s\\end{matrix}\\right]\\)\n\n\n\n\n17.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}\\right]\\)\n\n\n\n\n17.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1} + I_{2}, \\  I_{1} - I_{4}, \\  - I_{3} + I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n17.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nL1\n2\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n4\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nI1\n1\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nL2\n0\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n4\nL3\n2\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n5\nL4\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n6\nI2\n0\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n7\nI3\n3\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n8\nI4\n2\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n17.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL1\n2\n4\n\n\n1\nL2\n0\n3\n\n\n2\nL3\n2\n1\n\n\n3\nL4\n1\n0\n\n\n\n\n\n\n\n\n\n17.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L2} + \\frac{v_{3}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\\\- I_{L1} - \\frac{v_{3}}{R_{1}} + \\frac{v_{4}}{R_{1}}\\\\- I_{L1} L_{1} s + v_{2} - v_{4}\\\\- I_{L2} L_{2} s - v_{3}\\\\- I_{L3} L_{3} s - v_{1} + v_{2}\\\\- I_{L4} L_{4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1} + I_{2}\\\\I_{1} - I_{4}\\\\- I_{3} + I_{4}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{3}, \\  v_{4}, \\  L_{2}, \\  v_{3}, \\  v_{2}, \\  L_{1}, \\  I_{L3}, \\  L_{4}, \\  R_{1}, \\  I_{L2}, \\  s, \\  I_{2}, \\  I_{4}, \\  I_{3}, \\  I_{1}, \\  v_{1}, \\  I_{L4}, \\  I_{L1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#symbolic-solution",
    "href": "test_13.html#symbolic-solution",
    "title": "17  Test 13",
    "section": "17.3 Symbolic solution",
    "text": "17.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- I_{1} L_{3} L_{4} s^{2} + I_{2} L_{1} L_{4} s^{2} + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{3} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{2} L_{4} s^{2} - I_{4} L_{1} L_{4} s^{2} - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{2} = \\frac{I_{1} L_{1} L_{3} s^{2} + I_{1} L_{2} L_{3} s^{2} + I_{1} L_{3} R_{1} s + I_{2} L_{1} L_{4} s^{2} + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} - I_{4} L_{1} L_{3} s^{2} - I_{4} L_{1} L_{4} s^{2} - I_{4} L_{3} R_{1} s - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{3} = \\frac{I_{1} L_{2} L_{3} s^{2} + I_{2} L_{2} L_{4} s^{2} - I_{3} L_{1} L_{2} s^{2} - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} - I_{3} L_{2} R_{1} s + I_{4} L_{1} L_{2} s^{2} + I_{4} L_{2} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{4} = \\frac{I_{1} L_{2} L_{3} s^{2} + I_{1} L_{3} R_{1} s + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{1} L_{2} s^{2} - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} + I_{4} L_{1} L_{2} s^{2} - I_{4} L_{3} R_{1} s - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} L_{3} s + I_{2} L_{4} s + I_{3} L_{2} s - I_{4} L_{2} s - I_{4} L_{3} s - I_{4} L_{4} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L2} = \\frac{- I_{1} L_{3} s - I_{2} L_{4} s + I_{3} L_{1} s + I_{3} L_{3} s + I_{3} L_{4} s + I_{3} R_{1} - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L3} = \\frac{I_{1} L_{1} s + I_{1} L_{2} s + I_{1} L_{4} s + I_{1} R_{1} - I_{2} L_{4} s - I_{3} L_{2} s - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L4} = \\frac{- I_{1} L_{3} s + I_{2} L_{1} s + I_{2} L_{2} s + I_{2} L_{3} s + I_{2} R_{1} - I_{3} L_{2} s - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#construct-a-dictionary-of-element-values",
    "href": "test_13.html#construct-a-dictionary-of-element-values",
    "title": "17  Test 13",
    "section": "17.4 Construct a dictionary of element values",
    "text": "17.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 2.0, \\  I_{2} : 1.0, \\  I_{3} : 5.0, \\  I_{4} : 3.0, \\  L_{1} : 5.0, \\  L_{2} : 3.0, \\  L_{3} : 1.0, \\  L_{4} : 1.0, \\  R_{1} : 1.0 \\cdot 10^{-20}\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#dc-operating-point",
    "href": "test_13.html#dc-operating-point",
    "title": "17  Test 13",
    "section": "17.5 DC operating point",
    "text": "17.5 DC operating point\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L2} + \\frac{v_{3}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\\\- I_{L1} - \\frac{v_{3}}{R_{1}} + \\frac{v_{4}}{R_{1}}\\\\- I_{L1} L_{1} s + v_{2} - v_{4}\\\\- I_{L2} L_{2} s - v_{3}\\\\- I_{L3} L_{3} s - v_{1} + v_{2}\\\\- I_{L4} L_{4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1} + I_{2}\\\\I_{1} - I_{4}\\\\- I_{3} + I_{4}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\\\- I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\\\v_{2} - v_{4}\\\\- v_{3}\\\\- v_{1} + v_{2}\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\-1.0\\\\-2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\\\- I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\\\- 5.0 I_{L1} s + v_{2} - v_{4}\\\\- 3.0 I_{L2} s - v_{3}\\\\- 1.0 I_{L3} s - v_{1} + v_{2}\\\\- 1.0 I_{L4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\-1.0\\\\-2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\n\nU_dc\n\n\\(\\displaystyle \\left\\{ I_{L1} : 0.0, \\  I_{L2} : 2.0, \\  I_{L3} : -1.0, \\  I_{L4} : -2.0, \\  v_{1} : 0.0, \\  v_{2} : 0.0, \\  v_{3} : 0.0, \\  v_{4} : 0.0\\right\\}\\)\n\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          0.000000\nv2          0.000000\nv3          0.000000\nv4          0.000000\nI_L1        0.000000\nI_L2        2.000000\nI_L3       -1.000000\nI_L4       -2.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(2):    0   voltage\nV(3):    0   voltage\nV(1):    0   voltage\nI(L1):   -1  device_current\nI(L2):   3   device_current\nI(L3):   0   device_current\nI(L4):   -1  device_current\nI(I1):   2   device_current\nI(I2):   1   device_current\nI(I3):   5   device_current\nI(I4):   3   device_current\n\n\n17.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\\\- I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\\\- 5.0 i I_{L1} + v_{2} - v_{4}\\\\- 3.0 i I_{L2} - v_{3}\\\\- 1.0 i I_{L3} - v_{1} + v_{2}\\\\- 1.0 i I_{L4} + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.200000    -90.000000\nv2         1.600000     90.000000\nv3         0.600000     90.000000\nv4         0.600000     90.000000\nI_L1       0.200000      0.000000\nI_L2       0.200000   -180.000000\nI_L3       1.800000     -0.000000\nI_L4       0.200000   -180.000000\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: -5.15662e-19°    device_current\nI(L2):  mag:        0.2 phase:        180°  device_current\nI(L3):  mag:        1.8 phase: 5.72958e-20°     device_current\nI(L4):  mag:        0.2 phase:        180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\n\nThere are some small numeric differences in some node voltages and phases because of the series resistance. Also note the the phase of the current for L2 and L4 from LTSpice is -180 vs +180 as calculated by SymPy.\n\n\n17.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\\\- I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\\\- 5.0 I_{L1} s + v_{2} - v_{4}\\\\- 3.0 I_{L2} s - v_{3}\\\\- 1.0 I_{L3} s - v_{1} + v_{2}\\\\- 1.0 I_{L4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n17.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.1*2*np.pi, 10*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-1, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_13.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_14.html",
    "href": "test_14.html",
    "title": "18  Test 14",
    "section": "",
    "text": "18.1 Load the net list\nnet_list = '''\nI1 1 0 1 \nR1 1 0 0.05\nL1 1 2 0.025\nC1 2 0 0.25\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_14.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "18  Test 14",
    "section": "18.2 Call the symbolic modified nodal analysis function",
    "text": "18.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(C_{1} s v_{2} - I_{L1} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{2} = 0\\)\n\n\n\n18.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 4\nnumber of branches: 4\nnumber of nodes: 2\nnumber of unknown currents: 1\nnumber of RLC (passive components): 3\nnumber of inductors: 1\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n18.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & 1\\\\0 & C_{1} s & -1\\\\1 & -1 & - L_{1} s\\end{matrix}\\right]\\)\n\n\n\n\n18.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  I_{L1}\\right]\\)\n\n\n\n\n18.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1}, \\  0, \\  0\\right]\\)\n\n\n\n\n18.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nI1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n1\n0\nNaN\nNaN\nNaN\n0.05\nNaN\nNaN\nNaN\n\n\n2\nL1\n1\n2\nNaN\nNaN\nNaN\n0.025\nNaN\nNaN\nNaN\n\n\n3\nC1\n2\n0\nNaN\nNaN\nNaN\n0.25\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n18.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL1\n1\n2\n\n\n\n\n\n\n\n\n\n18.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + \\frac{v_{1}}{R_{1}}\\\\C_{1} s v_{2} - I_{L1}\\\\- I_{L1} L_{1} s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{1}, \\  C_{1}, \\  L_{1}, \\  I_{1}, \\  v_{2}, \\  s, \\  R_{1}, \\  I_{L1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#symbolic-solution",
    "href": "test_14.html#symbolic-solution",
    "title": "18  Test 14",
    "section": "18.3 Symbolic solution",
    "text": "18.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C_{1} I_{1} L_{1} R_{1} s^{2} - I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)\\(v_{2} = - \\frac{I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)\\(I_{L1} = - \\frac{C_{1} I_{1} R_{1} s}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#construct-a-dictionary-of-element-values",
    "href": "test_14.html#construct-a-dictionary-of-element-values",
    "title": "18  Test 14",
    "section": "18.4 Construct a dictionary of element values",
    "text": "18.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.25, \\  I_{1} : 1.0, \\  L_{1} : 0.025, \\  R_{1} : 0.05\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#dc-operating-point",
    "href": "test_14.html#dc-operating-point",
    "title": "18  Test 14",
    "section": "18.5 DC operating point",
    "text": "18.5 DC operating point\nBoth ?\nV4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 20.0 v_{1}\\\\- I_{L1}\\\\v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1         -0.050000\nv2         -0.050000\nI_L1        0.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -0.05   voltage\nV(2):    -0.05   voltage\nI(C1):   -1.25e-14   device_current\nI(L1):   -1.24345e-14    device_current\nI(I1):   1   device_current\nI(R1):   -1  device_current\n\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n18.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 20.0 v_{1}\\\\- I_{L1} + 0.25 i v_{2}\\\\- 0.025 i I_{L1} + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.049996    179.279336\nv2         0.050310    179.279336\nI_L1       0.012578    -90.720664\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:   0.049996 phase:    179.279°  voltage\nV(2):   mag:  0.0503105 phase:    179.279°  voltage\nI(C1):  mag:  0.0125776 phase:   -90.7207°  device_current\nI(L1):  mag:  0.0125776 phase:   -90.7207°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.999921 phase:    179.279°  device_current\n\n\n\n18.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 20.0 v_{1}\\\\- I_{L1} + 0.25 s v_{2}\\\\- 0.025 I_{L1} s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n18.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nH\n\n\\(\\displaystyle - \\frac{8.0}{s^{2} + 2.0 s + 160.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_14.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2)[0:-1]),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(V_2)[0:-1]/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(V_2[0:-1]) - 10**(mag/20),'-k')\n#plt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2[0:-1]))-mag,'-k')\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_2[0:-1])*180/np.pi-phase,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results have small error.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_15.html",
    "href": "test_15.html",
    "title": "19  Test 15",
    "section": "",
    "text": "19.1 Load the net list\nnet_list = '''\nI1 1 0 1\nR1 1 0 10\nR2 2 1 10\nR3 3 2 1000\nC1 2 0 0.01\nC2 3 0 0.002\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_15.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "19  Test 15",
    "section": "19.2 Call the symbolic modified nodal analysis function",
    "text": "19.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = - I_{1}\\)\\(v_{2} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{3} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\n\n\n\n19.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 6\nnumber of branches: 6\nnumber of nodes: 3\nnumber of unknown currents: 0\nnumber of RLC (passive components): 5\nnumber of inductors: 0\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n19.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\- \\frac{1}{R_{2}} & C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & - \\frac{1}{R_{3}}\\\\0 & - \\frac{1}{R_{3}} & C_{2} s + \\frac{1}{R_{3}}\\end{matrix}\\right]\\)\n\n\n\n\n19.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}\\right]\\)\n\n\n\n\n19.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1}, \\  0, \\  0\\right]\\)\n\n\n\n\n19.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nI1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n1\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n3\nR3\n3\n2\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n4\nC1\n2\n0\nNaN\nNaN\nNaN\n0.01\nNaN\nNaN\nNaN\n\n\n5\nC2\n3\n0\nNaN\nNaN\nNaN\n0.002\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n19.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n\n\n\n\n\n\n\n19.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\v_{2} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\v_{3} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{1}, \\  I_{1}, \\  v_{1}, \\  C_{1}, \\  v_{3}, \\  s, \\  R_{3}, \\  C_{2}, \\  v_{2}, \\  R_{2}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#symbolic-solution",
    "href": "test_15.html#symbolic-solution",
    "title": "19  Test 15",
    "section": "19.3 Symbolic solution",
    "text": "19.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C_{1} C_{2} I_{1} R_{1} R_{2} R_{3} s^{2} - C_{1} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)\\(v_{2} = \\frac{- C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)\\(v_{3} = - \\frac{I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#construct-a-dictionary-of-element-values",
    "href": "test_15.html#construct-a-dictionary-of-element-values",
    "title": "19  Test 15",
    "section": "19.4 Construct a dictionary of element values",
    "text": "19.4 Construct a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(network_df)):\n    if network_df.iloc[i]['element'][0] == 'F' or network_df.iloc[i]['element'][0] == 'E' or network_df.iloc[i]['element'][0] == 'G' or network_df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(network_df.iloc[i]['element'].lower()))\n        element_value_values.append(network_df.iloc[i]['value'])\n    else:\n        element_value_keys.append(var(network_df.iloc[i]['element']))\n        element_value_values.append(network_df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.01, \\  C_{2} : 0.002, \\  I_{1} : 1.0, \\  R_{1} : 10.0, \\  R_{2} : 10.0, \\  R_{3} : 1000.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#dc-operating-point",
    "href": "test_15.html#dc-operating-point",
    "title": "19  Test 15",
    "section": "19.5 DC operating point",
    "text": "19.5 DC operating point\nBoth ?\nV4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1} - 0.1 v_{2}\\\\- 0.1 v_{1} + 0.101 v_{2} - 0.001 v_{3}\\\\- 0.001 v_{2} + 0.001 v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1         -10.000000\nv2         -10.000000\nv3         -10.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -10     voltage\nV(2):    -10     voltage\nV(3):    -10     voltage\nI(C1):   -1e-13  device_current\nI(C2):   -2e-14  device_current\nI(I1):   1   device_current\nI(R1):   -1  device_current\nI(R2):   1.20082e-13     device_current\nI(R3):   2e-14   device_current\n\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n19.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\nNE_w1  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1} - 0.1 v_{2}\\\\- 0.1 v_{1} + v_{2} \\cdot \\left(0.101 + 0.01 i\\right) - 0.001 v_{3}\\\\- 0.001 v_{2} + v_{3} \\cdot \\left(0.001 + 0.002 i\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         9.771261    174.320654\nv2         9.642525    168.430028\nv3         4.312268    104.995079\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    9.77126 phase:    174.321°  voltage\nV(2):   mag:    9.64252 phase:     168.43°  voltage\nV(3):   mag:    4.31227 phase:    104.995°  voltage\nI(C1):  mag:  0.0964252 phase:    -101.57°  device_current\nI(C2):  mag: 0.00862454 phase:   -165.005°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.977126 phase:    174.321°  device_current\nI(R2):  mag:   0.100579 phase:    74.0313°  device_current\nI(R3):  mag: 0.00862454 phase:    14.9951°  device_current\n\n\n\n\n19.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1} - 0.1 v_{2}\\\\- 0.1 v_{1} + v_{2} \\cdot \\left(0.01 s + 0.101\\right) - 0.001 v_{3}\\\\- 0.001 v_{2} + v_{3} \\cdot \\left(0.002 s + 0.001\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n19.5.3 Plot the voltage at node 3\n\nH = U_ac[v3]\n\n\nH\n\n\\(\\displaystyle - \\frac{250.0}{10.0 s^{2} + 56.0 s + 25.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_15.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\nV_3 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n    V_3[i] = LTSpice_data[i][5] + LTSpice_data[i][6]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the phase plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(V_3)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(V_3)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(V_3[0:-1])-10**(mag/20),'-k')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_3[0:-1])*180/np.pi-phase,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results have small error.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "Example-problems.html",
    "href": "Example-problems.html",
    "title": "Example problems",
    "section": "",
    "text": "Example problems\nThe table below lists the example problems completed so far.",
    "crumbs": [
      "Example problems"
    ]
  },
  {
    "objectID": "Example-problems.html#example-problems",
    "href": "Example-problems.html#example-problems",
    "title": "Example problems",
    "section": "",
    "text": "Circuit Description\nnotes\n\n\n\n\nTwo amplifier RIAA Phono Preamp\nA circuit for a phono preamp is analyzed.\n\n\nTwo port parameters\nTwo port parameters are derived from the circuit’s netlist.\n\n\nThevenin equivalent circuit\nThe Thevenin equivalent circuit is obtained from a netlist.\n\n\nState variable filter\nNetwork equations for a state variable filter are obtained from the netlist which are solved in symbolic form.\n\n\nSuperposition\nA circuit to illustrate superposition and polyphase circuit analysis.\n\n\nInitial conditions\nVoltage on the capacitor and current in the inductor at t=0\n\n\nTransient analysis\nExamining the transient response of a circuit",
    "crumbs": [
      "Example problems"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html",
    "href": "Two amplifier RIAA Phono Preamp.html",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "",
    "text": "Abstract\nThis paper analyizes the circuit for the RIAA preamp given in the Texas Instruments application note AN346, High-Performance Audio Applications of the LM833, shown in the app note as Figure 3. The schematic for the phono preamplifier was entered into LTSpice and the circuit net list was generated. A circuit analysis method called the Modified Nodal Analysis was used to derive the symbolic circuit equations and Python libraries were used to solve the equations. The preamplifier transfer function was used to calculate the Bode, impuse and step response plots. The Python results were compared to those from LTSpice. Deviation from the RIAA response curve was also examined. The sensitivity, Monte Carlo and worst case analysis for the preamplifier circuit was performed. The JupyterLab notebook show cases the use of Python in electrical engineering and circuit analysis.\nContents\n1. Introduction\n2. RIAA pre-emphasis curve\n3. AN346 RIAA Phono Preamplifier Design Procedure\n4. Analysis of the phono preamplifier circuit\n5. Summary",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#introduction",
    "href": "Two amplifier RIAA Phono Preamp.html#introduction",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.1 Introduction",
    "text": "20.1 Introduction\nThis JupyterLab notebook uses the SymPy, NumPy,SciPy and the Python programming language libraries to analyze a phono preamplifier circuit from the Texas Instruments application note, AN346, High-Performance Audio Applications of the LM833. The purpose of this analysis is to demonstrate the capability of using the Python libraries in electrical engineering circuit analysis. The circuit chosen for this analysis is a two stage RIAA Phono Preamplifier described in the application note. The preamplifier is designed to accurately reproduce the RIAA equalization curve required for play back of Vinyl LP records. The preamplifier provides about 35 dB of gain at 1kHz along with the proper gain profile and phase response. The schematic of the circuit is shown below with each node explicity annotated.\n\n\n\nSchematic\n\n\nThere has been a resurgence on the popularity of Vinyl LP records over the last few years. So the use of a RIAA Phono Preamplifier is still relevant in this age where most music is delivered by streaming. Two internet news stories describe the current market for Vinyl LP records:\nThey Said the Album Was Dying. They Were Wrong\n\nVinyl sales have grown steadily for 17 years, but jumped by a stunning 46% in 2020 and 51% in 2021 …\n\nWhy Vinyl Records Are Making a Comeback in 2022\n\nThis year, 2020, marks the first year in more than a generation since record sales — that is to say physical vinyl records — have surpassed CD sales. The reasons for this are twofold: CD sales have dropped dramatically in recent years, while sales of vinyl records are actually up this year. And while you might think it’s nostalgic Boomers or Gen Xers behind the renaissance of records, in fact surveys show it’s millennial consumers driving the rising trend in vinyl sales.\n\n\nSo vinyl is here to stay, it seems, despite all technological advances that would have seemed to threaten it. The same RIAA study that found records surpassing CDs also revealed that streaming music now account for more than 85% of all music enjoyed. Only 6% of music is now downloaded, even less than is physically purchased in the form of records, CDs, or the last tapes.\n\nToday there are hundreds of phono products sold on Amazon. Phono preamps range in price from $10 to $1,000 dollars.\nThe Phono Preamplifier also known as a phono stage, is an audio component that amplifies the signal from your turntable to a level that allows you to connect it to your sound system the same way you would with any other audio source. In addition to boosting the signal from the phono carterage, the preamp applies the RIAA equalization curve to the signal, reverting it back to the shape it was on the original recording. Phono cartridge output varies depending on the type of phono cartridge. Moving Magnet (MM) or Moving Iron (MI) cartridges typically produce a maximum output of 5mV. Moving Coil (MC) cartridges produce a much lower output, typically around 0.5mV maximum. Most phono preamps have switch that allow users to select the type of coil they have installed on their turn table arm.\nTexas Instruments provided the schematic of the preamplifier in their application note to highlight the types of applications their LM833 operational amplifier can support. Application notes are sometimes part of the marketing literature provided along with component data sheets by semiconductor manufactures.\nRIAA equalization is a specification for the recording and playback of phonograph records, established by the Recording Industry Association of America (RIAA). RIAA was formed in 1952. Its original mission was to administer recording copyright fees and problems, work with trade unions, and do research relating to the record industry and government regulations. Early RIAA standards included the RIAA equalization curve, the format of the stereophonic record groove and the dimensions of 33 1/3, 45, and 78 rpm records.\nThe purposes of the equalization are to permit greater recording times (by decreasing the mean width of each groove), to improve sound quality and to reduce the groove damage that would otherwise arise during playback. RIAA equalization is a form of pre-emphasis on recording and de-emphasis on playback. A recording is made with the low frequencies reduced and the high frequencies boosted, and on playback, the opposite occurs. The net result is a flat frequency response, but with attenuation of high-frequency noise such as hiss and clicks that arise from the recording medium. Reducing the low frequencies also limits the excursions the cutter needs to make when cutting a groove. Groove width is thus reduced, allowing more grooves to fit into a given surface area, permitting longer recording times. This also reduces physical stresses on the stylus, which might otherwise cause distortion or groove damage during playback.\n\n20.1.1 Scope\nThe analysis presented in this notebook is intended to illustrate the use of Python for circuit analysis. This is not a tutorial on how to design a better phono preamp. The circuit taken from the Texas Instruments application note is examined for what it is, which is a suggested application for the use of their audio grade op amp. However, in this analysis I don’t address the performance of the op amp relative to the implementation of the RIAA equalization curve. I’m more concerned with examining the circuit’s ability to reproduce the proper gain and phase over the audio band. The performance LM833 op amp is assumed to be sufficient for this application and in my analysis of the circuit, I’ve replaced the LM833 with an ideal op amp model. Also, it is assumed that the reader is familiar with electronic components such as resistors, capacitors and operational amplifiers also known as op amps or opamps.\n\n\n20.1.2 Methodology\nThe analysis presented in this notebook will cover a topics that are often presented during a design review. Ususaly during a design review conformance to requirements is presented. For the phono preamp circuit, the main performance requirement is minimum deviation from the RIAA curve. The application note from TI stated that the deviation is less than 0.1 dB over the audio band when using 1% resistors.\nIn this notebook the analysis is divided into sections.\n\nThe analysis will start with an description of the circuit operation and some basic calculations.\nThere are many symbols used in the equations and these are listed in a table for reference. I also tried to be constant with variable names.\nThe RIAA pre-emphasis curve is discussed and the transfer function, pole/zero plot and amplitude and phase response is plotted.\nCalculations for the phono preamplifier design procedure as covered in the application note are presented. The element values obtain with this procedure are the ones used in the analysis.\nThe equations for the transfer function of the preamp are derived by using a tecnhique known as modified nodal analysis.\nThe preamp poles and zeros are plotted and some comments about stability are provided.\nThe amplitude and phase responce of the preamp transfer function is plotted.\nThe impulse, step and group dealy are plotted\nThe amplitude and phase response of the preamp transfer function is plotted against results taken from LTSpice as a check and comparision.\nThe deviation of the amplitude and phase responce from the RIAA curve is plotted.\nSensitivity analsysis, component selection, monte carlo and worst case analysis are presented.\n\n\nimport os\nimport sys\nimport random\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\ninit_printing()\n\n\nDefine a function to return the system gain at a frequency: get_gain()\n\ndef get_gain(freq_Hz, sys):\n    '''\n    freq_Hz: the frequency in Hz for which the system gain is desired\n    sys: a SciPy instance of the LTI class or a tuple describing the system\n    '''\n    f1 = freq_Hz - freq_Hz*0.1 # lower limit of the frequency range\n    f1a = freq_Hz - freq_Hz*0.01 # lower interpolation point\n    f2 = freq_Hz + freq_Hz*0.1 # upper limit of the frequency range\n    f2a = freq_Hz + freq_Hz*0.01  # upper interpolation point\n\n    x_axis_range = np.linspace(f1*2*np.pi, f2*2*np.pi, 1000, endpoint=True) # define the range frequency range\n    w, mag, phase = sys.bode(w=x_axis_range)\n\n    index_for_f1a = np.where(w &gt; f1a*2*np.pi)[0][0]\n    index_for_f2a = np.where(w &gt; f2a*2*np.pi)[0][0]\n\n    return np.interp(freq_Hz, [w[index_for_f1a]/(2*np.pi),w[index_for_f2a]/(2*np.pi)], [mag[index_for_f1a],mag[index_for_f2a]])\n\n\n\n20.1.3 Schematic and circuit description\nThe circuit from Figure 3 of AN346 was entered into LTSpice and the circuit nodes were numbered as shown above. Any schematic capture program could be used to for this as long as a Spice like netlist can be generated. In the schematic, the voltage source V1, is set to 5 mV to represent the output of a Moving Magnet (MM) or Moving Iron (MI) cartridge. The input to the preamp is shunted by a capacitance, which is equal to the sum of the input cable capacitance and the cartridge. This capacitance resonates with the inductance of the moving magnet cartridge to determine the frequency response of the transducer, so when a moving magnet pickup is used, Cp should be carefully chosen so that the total capacitance is equal to the recommended load capitance for that particular cartridge. 100 pF is used in this analysis. Rp is the recommended resistive load for the phono cartridge. In some comercial preamp designs, the value of Rp is user selectable with switches. As shown in the calculations, Cp and Rp have a resonant frequency of 33.86kHz.\n\nCp = 100e-12\nRp = 47e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Rp*Cp)))\n\nresonant frequency: 33,862.8 Hz\n\n\n33,862 Hz is well above the audio range.\nThe first operational amplifier, U1, takes care of the 50 Hz and 500 Hz breakpoints. For the analysis with Python, the op amp is modeled as and ideal opamp. There is expected to be some differences between the LTSpice results and the Python analysis. Using two amplifiers results in accurate conformance to the RIAA curve without reverting to the noisy inverting topology, as well as lower distortion due to the fact that each amplifier is operating at a lower gain than would be the case in a single-amplifier design.\nThe resistor, R1, which has a value of 80.6k\\(\\Omega\\) and the capacitor C1, which has a value of 0.039 \\(\\mu\\)Farads, form a resonant pair with frequency of 50.6 Hz.\n\nR1 = 80.6e3\nC1 = 0.039e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R1*C1)))\n\nresonant frequency: 50.6 Hz\n\n\n50 Hz is one of the RIAA time constants required by the RIAA specification.\nFrom here on, I’ll refer to resistors that have values in 1000’s of Ohms by using k for thousands of Ohms or just the numerical value if it’s less than 1000. Capacitors will have values indicated in \\(\\mu\\) for micro Farads and p for pico Farads, designated as \\(\\mu\\) or p. \n\nR2 = 8.45e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R2*C1)))\n\nresonant frequency: 482.9 Hz\n\n\nC1 and R2, which has a value of 8.45k, have a resonant frequency of 482.94 Hz. As describe later, these frequencies correspond to the time constants required by the RIAA specification.\nCo provides an AC ground for the non-inverting configuration of U1. Ro along with R1 and R2 set the low frequency gain of U1.\n\nRo = 499\nCo = 200e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Ro*Co)))\n\nresonant frequency: 1.6 Hz\n\n\nRo=499 and Co=200\\(\\mu\\) have a resonant frequency of 1.6 Hz.\n\nRf=R1+R2\nprint('low frequency voltage gain of U1: {:,.2f} or {:,.1f}dB'.format(1+Rf/Ro, 20*np.log10(1+Rf/Ro)))\n\nlow frequency voltage gain of U1: 179.46 or 45.1dB\n\n\nRo along with R1 and R2 set the low frequency gain of U1 at 45 dB.\n\nR3 = 2.37e3\nC3 = 0.033e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R3*C3)))\n\nresonant frequency: 2,035.0 Hz\n\n\nR3=2.37k and C3=0.033\\(\\mu\\) have a resonant frequency of 2034.96 Hz and corresponds to the the third time constant specified by RIAA.\nC4=2\\(\\mu\\) and R6=54.9k form a high pass filter with a corner frequency of 1.45Hz.\n\nR6 = 54.9e3\nC4 = 2e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R6*C4)))\n\nresonant frequency: 1.4 Hz\n\n\nU2, R4 and R5 form a non inverting configuration with a voltage gain of 3.15 or 9.98 dB.\n\nR4=2e3\nR5=4.3e3\nprint('voltage gain of U2: {:,.2f} or {:,.1f}dB'.format(1+R5/R4, 20*np.log10(1+R5/R4)))\n\nvoltage gain of U2: 3.15 or 10.0dB\n\n\n\n\n20.1.4 Symbols\nIn this notebook the following symbols are used:\n\n\n\n\n\n\n\nSymbol\ndefininition\n\n\n\n\ns\nwhen used in a polynominal: the Laplace variable equal to \\(\\alpha + j\\omega\\)\n\n\n\\(\\mu\\)\n\\(1 \\times 10^{-6}\\) multiplier, either: \\(1 \\times 10^{-6}\\) seconds or \\(1 \\times 10^{-6}\\) Farads\n\n\nT\ntime constant: T1, T2, T3\n\n\n\\(\\omega\\)\nangular frequency, radians per second, \\(\\omega = 1/T\\)\n\n\nf\nfrequency in cycles per second, \\(f = \\frac{\\omega}{2\\pi}\\)\n\n\nR\nresistor: R1, R2 etc.\n\n\nC\ncapacitor: C1, C2 etc.\n\n\nv\nnode voltage: v1, v2, v3 etc.\n\n\nV\nvoltage source, e.g. V1\n\n\nA\nmatrix describing the connectivity of the resistors, capacitors and G type (VCCS) circuit elements\n\n\nX\nvector of unknown node voltages and unknown currents\n\n\nZ\nvector of known voltages and currents\n\n\nRIAA_num\nnumerator of the RIAA pre-emphsis transfer function\n\n\nRIAA_den\ndenominator of the RIAA pre-emphsis transfer function\n\n\nw_RIAA\nradian frequncy of the RIAA pre-emphsis transfer function\n\n\nmag_RIAA\nmagnitude of the RIAA pre-emphsis transfer function\n\n\nphase_RIAA\nphase of the RIAA pre-emphsis transfer function\n\n\nRIAA_gain_1kHz\ngain of the RIAA pre-emphsis transfer function at 1kHz\n\n\npreamp_equ_sym\npreamp circuit equations with symbolic values\n\n\nU_sym\nsymbolic solution to network equations, node voltages and unknown currents\n\n\nH_sym\ntransfer function with symbolic coefficients\n\n\npreamp_equ\ncircuit equations with numeric element values\n\n\nH_preamp_num\nnumerator of the transfer function\n\n\nH_preamp_denom\ndenominator of the transfer function\n\n\npreamp_sys\nSciPy representation of the preamp system\n\n\npreamp_gain_1kHz\ngain of the preamp transfer function at 1kHz\n\n\nw_preamp\nradian frequncy of the preamp transfer function\n\n\nmag_preamp\nmagnitude of the preamp transfer function\n\n\nphase_preamp\nphase of the preamp transfer function",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "href": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.2 RIAA pre-emphasis curve",
    "text": "20.2 RIAA pre-emphasis curve\nThe RIAA equalization curve was established in 1954. The equalization is defined by time constants, T1, T2 and T3. During the Phonograph record manufacturing process, a pre-emphsis is applied to the signal, which allows for longer playback times on phonograph records by decreasing the average width of the groove cut into vinyl phonograph disks. The curve attenuates low frequencies and amplifies high frequencies, relative to 1 kHz. Since low frequencies cause wide undulations in the record groove, they must be attenuated to keep the grove within its bounds. Above 1 kHz, the frequencies are amplified which helps overcome the inherent noise produced by the phonograph needle during play-back.\nThe RIAA disc recording/reproduction standard specifies the time constants of, \\(T1 = 75 \\mu s\\), \\(T2 = 318 \\mu s\\) and \\(T3 = 3180 \\mu s\\) and the pre-emphasis transfer function:\n\\(RIAA(s)=\\frac {(sT_{1}+1)(sT_{3}+1)}{(sT_{2}+1)}\\)\nThe three time constants correspond to the frequencies calculated below.\n\nT1 = 75e-6\nT2 = 318e-6\nT3 = 3180e-6\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T1*1e6,1/(T1*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T2*1e6,1/(T2*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T3*1e6,1/(T3*2*np.pi)))\n\n75 μs corresponds to 2,122.1 Hz\n318 μs corresponds to 500.5 Hz\n3180 μs corresponds to 50.0 Hz\n\n\nThe time constants are put in polynominal form using s as the Laplace variable. The numerator and denominator of the pre-emphasis transfer function is defined below.\n\ns = symbols('s')\nRIAA_num = Eq(((s*T3+1)*(s*T1+1)),0)\nRIAA_denom = Eq(s*T2+1,0)\n\nSolve for the poles and zeros of the pre-emphasis transfer function and plot the locations on the complex s-plane. The zeros of the transfer function are the roots of the numerator polinominal. The poles of the transfer function are the roots of the denominal polinominal.\n\nRIAA_zeros = solve(RIAA_num,s)\nRIAA_poles = solve(RIAA_denom,s)\n\n\nplt.plot(np.real(RIAA_zeros), np.imag(RIAA_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(RIAA_poles), np.imag(RIAA_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(RIAA_zeros)))\nfor i in RIAA_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n-2,122.07 Hz\n-50.05 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(RIAA_poles)))\nfor i in RIAA_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-500.49 Hz\n\n\nAs shown in the plot above, the poles and zeros lay on the negative real axis. The de-emphisis transfer function of the phono pre-amplifier should have poles at the zero locations and a zero in the pole location in the plot above.\nThe code below is used to convert SymPy symbolic equations to a numpy polynomial representation. The SciPy function, TransferFunction, represents the system as the continuous-time transfer function. The Numpy function, logspace, is used to generate data points on a log scale for plotting. The SciPy function, bode, is used to generate the magnitude and phase data of a continuous-time system.\n\na = np.array(Poly(RIAA_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(RIAA_denom, s).all_coeffs(), dtype=float)\nRIAA_sys = signal.TransferFunction(a,b)\n\nx_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\nw_RIAA, mag_RIAA, phase_RIAA = RIAA_sys.bode(w=x_axis_range) # returns: rad/s, mag in dB, phase in deg\n\nFind the gain at 1kHz so the plots can be normalized for 0 dB at 1 kHz.\n\nRIAA_gain_1kHz = get_gain(1000,RIAA_sys)\n\n\nprint('The RIAA gain at 1kHz: {:.3f} dB'.format(RIAA_gain_1kHz))\n\nThe RIAA gain at 1kHz: 19.911 dB\n\n\nPlot the magnitude and phase of the RIAA curve.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_RIAA/(2*np.pi), mag_RIAA-RIAA_gain_1kHz,'-k')    # Bode magnitude plot, normalized to 0 at 1kHz\n\n# mark individual points\np3 = np.where(w_RIAA &gt; 49.9*(2*np.pi))[0][0]\np2 = np.where(w_RIAA &gt; 499.9*(2*np.pi))[0][0]\np1 = np.where(w_RIAA &gt; 2122*(2*np.pi))[0][0]\n\nplt.semilogx(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-RIAA_gain_1kHz,'^k')\n\nplt.text(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-25,'T1')\nplt.text(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-25,'T2')\nplt.text(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-25,'T3')\n\n# hightlight the audio band, 20 to 20kHz\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w_RIAA/(2*np.pi), phase_RIAA,':',color='b',label='phase')  # Bode phase plot\n\n# mark individual points\nplt.semilogx(w_RIAA[p1]/(2*np.pi), phase_RIAA[p1],'xb')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), phase_RIAA[p2],'xb')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), phase_RIAA[p3],'xb')\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\nax2.set_ylim((0,100))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('RIAA pre-emphasis magnitude and frequency plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the frequence response of the RIAA curve. The frequencies coresponsing to the time constants T1, T2 and T3 are plotted on the magnitude and phase curves. The audio band of 20Hz to 20kHz is highlighted. One thing to notice about this curve is that the amplitdue is increasing as the frequency increases. This is not a realistic function, real circuits do not have and inifinite gain at as the frequency goes tio infinity. Also, there is no zero at \\(j\\omega=0\\), so the pre-emphisis transfer function does not block DC.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "href": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.3 Phono Preamplifier Design Procedure",
    "text": "20.3 Phono Preamplifier Design Procedure\nThe following notebook cells walk through the design procedure given in the application note, starting on page 5.\nA design procedure is shown below with an illustrative example using 1% tolerance E96 components for close conformance to the ideal RIAA curve. Since 1% tolerance capacitors are often difficult to find except in 5% or 10% standard values, the design procedure calls for re-calculation of a few component values so that standard capacitor values can be used.\n\nChoose \\(R_o\\). \\(R_o\\) should be small for minimum noise contribution, but not so small that the feedback network excessively loads the amplifier. Example: Choose \\(R_o = 500\\)\nChoose 1 kHz gain, A1 of first amplifier. This will typically be around 20 dB to 30 dB. Example: Choose A1 = 26 dB = 20\nCalculate \\(R_11 = 8.058 \\times R_o \\times A_1\\)\n\n\nA1 = 20\nRo = 500\nR1 = 8.058 * Ro * A1\nprint('R1={:,.0f}'.format(R1))\n\nR1=80,580\n\n\n\nCalculate C1\n\n\\(C_1 = \\frac {3.18 \\times 10^{-3}}{R_1}\\)\n\nC1 = 3.18e-3/R1\nprint('C1={:.4e}'.format(C1))\n\nC1=3.9464e-08\n\n\nThe calculated value for capacitor C1 is not a standard value, so step 5 takes care of this.\n\nIf C1 is not a convenient value, choose the nearest convenient value and calculate a new R1 from:\n\n\\(R_1 = \\frac {3.18 \\times 10^{-3}}{3.9 \\times 10^{-8}}\\)\nChoose C1 to be 0.039\\(\\mu\\), which is a standard capacitor value.\n\nC1 = 0.039e-6\nR1 = 3.18e-3/C1\nprint('R1={:,.0f}'.format(R1))\n\nR1=81,538\n\n\nNow choose a standard resistor value close to the the calculated value, which is 80.6k.\nE96 resistor values are a set of perfered values for 1% resistors. When doing the calculations to determin the resistor values, the closest standandard value is chosen from the E96 series. The E series of preferred numbers derived for use in electronic components. It consists of the E3, E6, E12, E24, E48, E96 and E192 series, where the number after the ‘E’ designates the quantity of logarithmic value “steps” per decade.\n\nR1 = 80.6e3\n\nCalculate a new value for Ro.\n\\(R_o=\\frac {R_1}{8.058A_1}\\)\n\nRo = R1/(8.058*A1)\nprint('R1={:,.0f}'.format(Ro))\n\nR1=500\n\n\nChoose a standard value close to this value, which is 499.\n\nRo = 499\n\n\nCaluclate R2\n\\(R_2=\\frac {R_1}{9} - R_o\\)\n\n\nR2 = R1/9-Ro\nprint('R1={:,.0f}'.format(R2))\n\nR1=8,457\n\n\nChoose a standard value close to this value, which is 8.45k.\n\nR2 = 8.45e3\n\n\nChoose a convenient value for C3 in the range from 0.01 \\(\\mu\\)F to 0.05 \\(\\mu\\)F.\nExample: C3 = 0.033 \\(\\mu\\)F\n\n\nC3 = 0.033e-6\nprint('C3={:,.3f}\\u03BC'.format(C3*1e6))\n\nC3=0.033μ\n\n\n\nCalculate Rp\n\\(R_p=\\frac {75 \\mu s }{C_3}\\)\n\n\\(75 \\mu s\\) is one of the RIAA time constants.\n\nRp = 75e-6/C3\nprint('Rp={:,.0f}'.format(Rp))\n\nRp=2,273\n\n\n\nChoose a standard value for R3 that is slightly larger than Rp.\nExample: R3 = 2.37k, which is a standard resistor value.\n\n\nR3 = 2.37e3\n\n\nCalculate R6 from \\(1/R_6 = 1/R_P − 1/R_3\\)\n\n\nR6 = 1/(1/Rp-1/R3)\nprint('R6={:,.0f}'.format(R6))\n\nR6=55,374\n\n\n54.9k is the closest standard value.\n\nR6 = 54.9e3\n\n\nCalculate \\(C_4\\) for low-frequency rolloff below 1 Hz from design Equation 5.\n\n\\(C_4=\\frac{1}{2\\pi f_L(R_3+R_6)}\\)\nWhere \\(f_L\\) is the low frequency -3dB corner of the second stage.\nIn the application note, there is a comment on page 4:\n&gt; If the preamplifier is to follow the IEC recommendation (IEC Publication 98, Amendment #4), fL should equal 20.2 Hz.\nThe calculations in the app note use 1 Hz.\n\nf_L = 1.0 # Hz\nC4 = 1/(2*np.pi*f_L*(R3+R6))\nprint('C4={:,.3f}\\u03BC'.format(C4*1e6))\n\nC4=2.779μ\n\n\n2\\(\\mu\\)F is a standard value close to the calculated value.\nExample: C4 = 2 \\(\\mu\\)F.\n\nChoose gain of second amplifier.\nExample: The 1 kHz gain up to the input of the second amplifier is about 26 dB for this example. For an overall 1 kHz gain equal to about 36 dB we choose:\n\\(A_2 = 10 dB = 3.16\\)\nChoose value for R4.\nExample: R4 = 2k\n\n\nR4 = 2e3\n\n\nCalculate \\(R_5 = (A_2 − 1) R_4\\)\n\n\nA2 = 3.16\nR5 = (A2-1)*R4\nprint('R5={:,.0f}'.format(R5))\n\nR5=4,320\n\n\n4.3k is a standard value close to the calculated value.\n\nR5 = 4.3e3\n\n\nCalculate Co for low-frequency rolloff below 1 Hz from design Equation 7.\n\n\\(C_o=\\frac {1}{2\\pi f_o R_o}\\)\nwhere fo is the low-frequency −3 dB corner of the first amplifier. fo is chosen to be 1Hz for the calculations since this frequency is well below the audible frequency range.\n\nfo = 1 # 1 Hz\nCo = 1/(2*np.pi*fo*Ro)\nprint('Co={:,.3f}\\u03BC'.format(Co*1e6))\n\nCo=318.948μ\n\n\nThe value chosen in the app note for this component is 200\\(\\mu\\)F.\n\nCo = 200e-6\n\n\nprint('resonant frequency of Ro and Co: {:.2f}Hz'.format(1/(Co*Ro*2*np.pi)))\n\nresonant frequency of Ro and Co: 1.59Hz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "href": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.4 Analysis of AN-346 phono preamplifier circuit",
    "text": "20.4 Analysis of AN-346 phono preamplifier circuit\nThe schematic of the preamp was entered into LTSpice and the netlist was generated. Starting with a schematic and then using LTSpice to generate the net list eliminates errors that would occure if these circuits were analyised by hand. For small circuits with a handful of components, symbolic solutions of the node equations can be of interest, but for larger circuits, not so much. This is because the number of symbols and equations is too large to offer in insight with out some simplicication.\nIn this section the modified nodal analysis method will be used to generate the circuit equations. The modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. The Python code that generates the circuits equations is located here.\n\n20.4.1 Modified nodal analysis\nThe preamp circuit has 15 branches, 9 nodes, 3 unknown currents, 14 passive components and 2 op amps. The net list generated by LTSpice and some edits were made to put the component values into scientific notation with units of Ohms, Farads and Henerys and the opamp statements were fixed. The edited netlist is:\nV1 1 0 5e-3m\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\nThis netlist is read into the Symbolic Modified Nodal Analysis Jupyter notebook and the following circuit equations were generated.\n\\(I_{V1} + v_{1} \\left(Cp s + \\frac{1}{R_{20}}\\right) = 0\\)\n\\(v_{2} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{4} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{Ro} = 0\\)\n\\(v_{3} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{2}}{Ro} = 0\\)\n\\(v_{2} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\n\\(I_{O1} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{3}} - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(- C_{4} s v_{7} + v_{6} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\n\\(- C_{4} s v_{6} + v_{7} \\left(C_{4} s + \\frac{1}{R_{6}}\\right) = 0\\)\n\\(v_{8} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{9}}{R_{5}} = 0\\)\n\\(I_{O2} + v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{8}}{R_{5}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{1} + v_{2} = 0\\)\n\\(- v_{7} + v_{8} = 0\\)\nThe symbols and matrices generated by the modified nodal analysis code are copied here so that the circuit equations can be solved symbilically and later numerically. All the symboles that SymPy needs defined are delared. The A matrix describs the connectivity of the resistors, capacitors and G type (VCCS) circuit elements. The X matrix contains the unknown node voltages and unknown currents. The Z matrix contains the known voltages and currents sources, e.g. V1.\n\nRp, v6, Co, C4, v2, C3, s, I_V1, R6, Ro, R4, C1, R3, I_O2, R5, v3, I_O1, v4, v8, v7, V1, Cp, v1, R1, R2, v5, v9 = symbols(' Rp  v6  Co  C4  v2  C3  s  I_V1  R6  Ro  R4  C1  R3  I_O2  R5  v3  I_O1  v4  v8  v7  V1  Cp  v1  R1  R2  v5  v9 ')\nA = Matrix([[Cp*s + 1/Rp, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1/R5, 0, 0, 0, 0, 0, 0, -1/R5, 0, 0, 1], [0, 0, C1*s + 1/Ro + 1/R1, -1/Ro, -C1*s - 1/R1, 0, 0, 0, 0, 0, 0, 0], [0, 0, -1/Ro, Co*s + 1/Ro, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, -C1*s - 1/R1, 0, C1*s + 1/R2 + 1/R1, -1/R2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1/R2, 1/R3 + 1/R2, -1/R3, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, -1/R3, C3*s + C4*s + 1/R3, -C4*s, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, -C4*s, C4*s + 1/R6, 0, 0, 0, 0], [0, -1/R5, 0, 0, 0, 0, 0, 0, 1/R5 + 1/R4, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0]])\nX = Matrix( [v1, v2, v3, v4, v5, v6, v7, v8, v9, I_V1, I_O1, I_O2] )\nZ = Matrix( [0, 0, 0, 0, 0, 0, 0, 0, 0, V1, 0, 0] )\n\nThe equations are displayed in maxtrix form below.\n\npreamp_equ_sym = Eq(A*X,Z)\npreamp_equ_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\left(Cp s + \\frac{1}{Rp}\\right)\\\\I_{O2} + \\frac{v_{2}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\v_{3} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Ro}\\\\v_{4} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{3}}{Ro}\\\\v_{3} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{5} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{6}}{R_{2}}\\\\I_{O1} + v_{6} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{7}}{R_{3}} - \\frac{v_{5}}{R_{2}}\\\\- C_{4} s v_{8} + v_{7} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{3}}\\\\- C_{4} s v_{7} + v_{8} \\left(C_{4} s + \\frac{1}{R_{6}}\\right)\\\\v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}}\\\\v_{1}\\\\- v_{1} + v_{3}\\\\- v_{8} + v_{9}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThese equations can be solved in thier symbolic form using the solve function from SymPy. The solution time takes about 3 seconds on my i3 laptop.\n\nU_preamp_sym = solve(preamp_equ_sym,X)\n\nThe transfer function for the preamp is the equation for the output node, 2, divided by the equation for the input node 1.\n\nH_preamp_sym = U_preamp_sym[v2]/U_preamp_sym[v1]\n\nThe symbolic solution obtained by SymPy, while not being very interesting since they are unweildly, they illustrate the power of SymPy to easily obtain symbolic solutions that would be very difficult to obtain by hand.\n\nH_preamp_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{V_{1} \\left(C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}\\right)}\\)\n\n\nThe SymPy function, cancel(), can be used to put the preamp transfunction in to standard canonical form, where the polynomials are expanded with no common factors and the leading coefficients do not have denominators (i.e., are integers).\n\ncancel(H_preamp_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} C_{4} R_{1} R_{5} R_{6} + C_{4} Co R_{1} R_{4} R_{6} + C_{4} Co R_{1} R_{5} R_{6} + C_{4} Co R_{2} R_{4} R_{6} + C_{4} Co R_{2} R_{5} R_{6} + C_{4} Co R_{4} R_{6} Ro + C_{4} Co R_{5} R_{6} Ro\\right) + s \\left(C_{4} R_{4} R_{6} + C_{4} R_{5} R_{6}\\right)}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + R_{4} + s^{3} \\left(C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} Co R_{1} R_{4} Ro + C_{3} C_{4} R_{3} R_{4} R_{6} + C_{3} Co R_{3} R_{4} Ro + C_{4} Co R_{3} R_{4} Ro + C_{4} Co R_{4} R_{6} Ro\\right) + s \\left(C_{1} R_{1} R_{4} + C_{3} R_{3} R_{4} + C_{4} R_{3} R_{4} + C_{4} R_{4} R_{6} + Co R_{4} Ro\\right)}\\)\n\n\nThe Sympy function, factor(), can be used to factor the polynominals it into irreducible factors over the rational numbers.\n\nH_preamp_sym.factor()\n\n\\(\\displaystyle \\frac{C_{4} R_{6} s \\left(R_{4} + R_{5}\\right) \\left(C_{1} Co R_{1} R_{2} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co R_{1} s + Co R_{2} s + Co Ro s + 1\\right)}{R_{4} \\left(C_{1} R_{1} s + 1\\right) \\left(Co Ro s + 1\\right) \\left(C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} R_{3} s + C_{4} R_{3} s + C_{4} R_{6} s + 1\\right)}\\)\n\n\nThe symbolic solutions obtained above will be used later when the sinsitivity analysis of the preamp is performed. Otherwise the roots in symbolic form don’t seem to be particulary insightful, but are easily obtained by SymPy.\n\n20.4.1.1 Numerical solution\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {V1:5.0000e-03, C1:3.9000e-08, Co:2.0000e-04, Ro:4.9900e+02, R3:2.3700e+03, R1:8.0600e+04, \n    R2:8.4500e+03, Cp:1.0000e-10, Rp:4.7000e+04, C3:3.3000e-08, C4:2.0000e-06, R6:5.4900e+04, R4:2.0000e+03, R5:4.3000e+03}\n\n# put the element values into the equations\npreamp_equ = preamp_equ_sym.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instear of symbols.\n\npreamp_equ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-10} s + 2.12765957446809 \\cdot 10^{-5}\\right)\\\\I_{O2} + 0.000232558139534884 v_{2} - 0.000232558139534884 v_{9}\\\\v_{3} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.00201641496392288\\right) - 0.00200400801603206 v_{4} + v_{5} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right)\\\\- 0.00200400801603206 v_{3} + v_{4} \\cdot \\left(0.0002 s + 0.00200400801603206\\right)\\\\v_{3} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right) + v_{5} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.000130750143157091\\right) - 0.000118343195266272 v_{6}\\\\I_{O1} - 0.000118343195266272 v_{5} + 0.000540284123536314 v_{6} - 0.000421940928270042 v_{7}\\\\- 2.0 \\cdot 10^{-6} s v_{8} - 0.000421940928270042 v_{6} + v_{7} \\cdot \\left(2.033 \\cdot 10^{-6} s + 0.000421940928270042\\right)\\\\- 2.0 \\cdot 10^{-6} s v_{7} + v_{8} \\cdot \\left(2.0 \\cdot 10^{-6} s + 1.82149362477231 \\cdot 10^{-5}\\right)\\\\- 0.000232558139534884 v_{2} + 0.000732558139534884 v_{9}\\\\v_{1}\\\\- v_{1} + v_{3}\\\\- v_{8} + v_{9}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0.005\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU_preamp = solve(preamp_equ,X)\n\nThe values of the exponents are very large in the solution. The numerator and denominator for v2 could be normalized. Another option for avoiding large exponents is to 1st normalize the component values by frequency scaling. I suppose that large exponents don’t become a problem as long as they remain under two digits.\nAlmost all platforms map Python floats to the IEEE754 double precision - 64 total bits. The float information using the sys package can be as shown as follows:\n\ntemp = str(sys.float_info)\ntemp = temp[temp.find(\"(\")+1:temp.find(\")\")]\nsys_float_info = temp.split(',')\n\nfor i in sys_float_info:\n    print(i)\n\nmax=1.7976931348623157e+308\n max_exp=1024\n max_10_exp=308\n min=2.2250738585072014e-308\n min_exp=-1021\n min_10_exp=-307\n dig=15\n mant_dig=53\n epsilon=2.220446049250313e-16\n radix=2\n rounds=1\n\n\nThe maximum exponent that Python can use is 308.\nLetting SciPy do the math and not worrying about the size of the exponents. The transfer function can be obtained by divideing the equation for node 2 by the equation for node 1. The system transfer function, is \\(H(s) = \\frac {v2}{V1}\\)\n\nH_preamp = U_preamp[v2]/U_preamp[v1]\nH_preamp\n\n\\(\\displaystyle \\frac{200.0 \\cdot \\left(2.76499422921242 \\cdot 10^{69} s^{3} + 8.80353368479522 \\cdot 10^{72} s^{2} + 4.91462150480132 \\cdot 10^{71} s\\right)}{7.65600122987477 \\cdot 10^{65} s^{4} + 1.0469819689888 \\cdot 10^{70} s^{3} + 3.44479259637884 \\cdot 10^{72} s^{2} + 6.18286042227129 \\cdot 10^{73} s + 2.84188944100537 \\cdot 10^{74}}\\)\n\n\nfactor() takes a polynomial and factors it into irreducible factors over the rational numbers. For example:\n\nH_preamp.factor()\n\n\\(\\displaystyle \\frac{6.19554973375798 s \\left(0.000314077770155853 s^{2} + 1.0 s + 0.0558255546098434\\right)}{2.69398278462456 \\cdot 10^{-9} s^{4} + 3.68410520790143 \\cdot 10^{-5} s^{3} + 0.012121487017314 s^{2} + 0.21756161 s + 1.0}\\)\n\n\n\n\n20.4.1.2 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_preamp_num, H_preamp_denom = fraction(H_preamp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na2 = np.array(Poly(H_preamp_num, s).all_coeffs(), dtype=float)\nb2 = np.array(Poly(H_preamp_denom, s).all_coeffs(), dtype=float)\npreamp_sys = signal.TransferFunction(a2,b2)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\npreamp_sys_zeros = np.roots(preamp_sys.num)\npreamp_sys_poles = np.roots(preamp_sys.den)\n\n\n\n\n20.4.2 Pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(preamp_sys_zeros), np.imag(preamp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(preamp_sys_poles), np.imag(preamp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(preamp_sys_zeros)))\nfor i in preamp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-506.73 Hz\n-0.01 Hz\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(preamp_sys_poles)))\nfor i in preamp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-2,122.88 Hz\n-50.63 Hz\n-1.59 Hz\n-1.39 Hz\n\n\nWe can see that the RIAA time constants, displayed in terms of frequency are present, althought the values diffeer by a few Hz. There are two zeros and two poles at nearly zero hz and these cancel each other.\n\n\n20.4.3 Stability\nBy inspecting the plot above, we can tell the preamplifier is stable since the phase shift at 0 dB of gain is less than 180 degrees. Additionally, all the poles of the transfer function are in the left hand plane.\nNow we can find the preamp gain at 1 kHz, so that the bode plots can be normailized.\n\npreamp_gain_1kHz = get_gain(1000, preamp_sys)\nprint('preamp gain at 1kHz: {:f} dB'.format(preamp_gain_1kHz))\n\npreamp gain at 1kHz: 34.783614 dB\n\n\n\n\n20.4.4 Bode plot, Frequency and phase response\nUse the SciPy function bode to plot the magnitude and phase of the filter.\nIn electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\nremove comments about Bode, since the plots are not strict Bode plots.\n\nextended_x_axis_range = np.logspace(-2, 8, 5000, endpoint=True)*2*np.pi\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=extended_x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b' #'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color=color,label='phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude')\n\nplt.legend(loc=0)\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe magnitude and phase plot for the preamplifier is plotted from 0.01 Hz to 100 MHz. The preamplifier circuit blocks DC because C4 in in series with the audio path.\n\n\n20.4.5 Impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n20.4.6 Group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=x_axis_range)\n\nplt.title('AN-346 phono preamplifier group delay')\nplt.semilogx(w_preamp/(2*np.pi), -np.gradient(phase_preamp*np.pi/180)/np.gradient(w_preamp),'-',label='group delay')\n\n#plt.semilogx(w_c1/(2*np.pi), -np.gradient(phase_c1)/w_c1/1e-3,'-',label='phase delay')\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies below 100 Hz, the group delay is as much as 4 ms in the audio band. According to paper, Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe preamp group delay in the low end of the audio band is of concern and some re-design should be implemented if this preamp was to be implemented. The group delay plotted above agrees with the group delay results obtained from LTSpice simulation of the preamp circuit.\n\n\n\n20.4.7 Preamplifier deviation from RIAA response\nThe plot below shows the deviation of the preamplifier from the RIAA response. The TI app note says conformance to the RIAA curve is within 0.1 dB from 20 Hz to 20 kHz. The series response of the RIAA curve with that of the preamp response curve can be obtained by adding the maggitude quanties. If the preamp rrsponse is the exact invers of the RIAA curve, the result will be flat line.\nThe deviation is calculated by adding the RIAA response curve to the preamp response curve. The quantities are in decabells so addition in logorthims is like multiplication which is what a series connection would be.\nThe plot need to be fixed, convert to linear, then back to log before taking the difference since quantities are in dB. maybe not since they are in series. Add dB is like multipling.\nadd gains in dB or yes I think you add dBs in series.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.2,0.1))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_RIAA+phase_preamp,':',color=color,label='phase of S2')  # Bode phase plot\n\nax2.set_ylabel('phase differencepreamplifier, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude of S1')\nplt.legend(loc=0)\n\nplt.title('Preamp deviation from RIAA response')\nplt.show()\n\n\n\n\n\n\n\n\nThe calculations below will find the minimum and maximunation deviation of the amplitude response from the RIAA curve.\n\nidx_low = np.where(w_preamp/(2*np.pi) &gt; 20)[0][0]\nidx_high = np.where(w_preamp/(2*np.pi) &gt; 20e3)[0][0]\nprint('preamp deviation from RIAA curve: {:.3f} to {:.3f} dB'.format(((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].min(),((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].max()))\n\npreamp deviation from RIAA curve: -0.045 to 0.066 dB\n\n\nThe calculations above show that within the audio range the deviation of the preamp amplitude response from the RIAA curve varies from -0.044 to 0.066 dB when the nominal component values are used.\n\n\n20.4.8 Sensitivity analysis\nAll circuits have characteristics that dependent on the values of the component. The sensitivity of a circuit’s performance is a measure of how much a particular circuit characteristic changes as a particular component value varies. In this analysis i’ll look at the changes of each pole or zero relative to the compenents value.\nThe root sensitivity function \\(S_x^y\\) gives the change occuring in filter characteristic per \\(\\delta y/ \\delta x\\).\n\\(S_x^y\\) is read as the sensitivity of the characteristic (i.e. y = \\(\\omega_n,\\) or Q or some other characteristic) with respect to the element x.\n\\(S_x^y = \\frac {x}{y} \\frac{\\delta y}{\\delta x}\\)\nWhere x is the filter component that is varied and y is the filter characteristic (\\(\\omega_n,\\) or Q etc.) that we wish to evaluate as x is varied.\nThe preamp transfer function is symbolic form is, H_preamp_sym, and we can get the numerator and denominator with the SymPy fraction function.\n\nH_sym_num, H_sym_denom = fraction(H_preamp_sym)\n\nThe Sympy solve function is used to find the root of the numerator and denimator polynominals.\n\nH_sym_zeros = solve(H_sym_num,s)\nH_sym_poles = solve(H_sym_denom,s)\n\n\n20.4.8.1 Zeros\nHow many roots are there for the numerator polynominial?\n\nprint('there are {:d} zeros'.format(len(H_sym_zeros)))\n\nthere are 3 zeros\n\n\n\n\n20.4.8.2 Z0\nThe first zero is at DC.\n\nH_sym_Z0 = H_sym_zeros[0]\nH_sym_Z0\n\n\\(\\displaystyle 0\\)\n\n\n\n\n20.4.8.3 Z1\nThe second zero is given symbolically by the expression:\n\nH_sym_Z1 = H_sym_zeros[1]\nH_sym_Z1\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\nWhat are the compenets that determine Z1?\n\nprint('the compenets that determine Z1 are: {:s} '.format(str(H_sym_Z1.free_symbols)))\n\nthe compenets that determine Z1 are: {Co, Ro, C1, R1, R2} \n\n\nWhat is the locations of Z1?\n\nprint('location of zero: {:.2f} Hz'.format(N(H_sym_Z1.subs(nominal_component_value))/(2*np.pi)))\n\nlocation of zero: -506.73 Hz\n\n\nZ1 is the zero at 500 Hz and is one of the RIAA time constants.\nWe can fine the sensitivity of Z1 to C1 with the following operation.\n\nS_C1_H_sym_Z1 = (C1/H_sym_Z1)*(H_sym_Z1.diff(C1))\nS_C1_H_sym_Z1\n\n\\(\\displaystyle \\frac{C_{1} \\left(- \\frac{1}{2 C_{1} Co \\left(R_{2} + Ro\\right)} - \\frac{C_{1} R_{1}^{2} + Co R_{1}^{2} - Co R_{1} R_{2} - Co R_{1} Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right) \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}} + \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)}\\right)}{- \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}}\\)\n\n\nEvaluating this numerically with the component values, we get get the sensitivity of Z1 to C1.\n\nprint('the sensitivity of Z1 to C1 is: {:.2f}'.format(N(S_C1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to C1 is: -1.00\n\n\nDoing the math with SymPy, we can get the sensitivity of Z1 to the other components.\n\nS_R1_H_sym_Z1 = (R1/H_sym_Z1)*(H_sym_Z1.diff(R1))\nprint('the sensitivity of Z1 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R1 is: -0.10\n\n\n\nS_R2_H_sym_Z1 = (R2/H_sym_Z1)*(H_sym_Z1.diff(R2))\nprint('the sensitivity of Z1 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R2 is: -0.85\n\n\n\nS_Co_H_sym_Z1 = (Co/H_sym_Z1)*(H_sym_Z1.diff(Co))\nprint('the sensitivity of Z1 to Co is: {:.4f}'.format(N(S_Co_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Co is: -0.0002\n\n\n\nS_Ro_H_sym_Z1 = (Ro/H_sym_Z1)*(H_sym_Z1.diff(Ro))\nprint('the sensitivity of Z1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Ro is: -0.05\n\n\nLater, we we are doing the worst case analsys, we can ignore Co. \n\n\n20.4.8.4 Z2\nThe third zero of the transfer function is Z2.\n\nH_sym_Z2 = H_sym_zeros[2]\nH_sym_Z2\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\n\nprint('the compenets that determine Z2 are: {:s} '.format(str(H_sym_Z2.free_symbols)))\n\nthe compenets that determine Z2 are: {Co, Ro, C1, R1, R2} \n\n\n\nprint('Z2: {:.3e} Hz'.format(N(H_sym_Z2.subs(nominal_component_value))/(2*np.pi)))\n\nZ2: -8.885e-3 Hz\n\n\nThe zero Z2, evaluates to a system zero at DC and is not one the of RIAA time constants.\n\nS_C1_H_sym_Z2 = (C1/H_sym_Z2)*(H_sym_Z2.diff(C1))\nprint('the sensitivity of Z2 to C1 is: {:.3e}'.format(N(S_C1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to C1 is: -1.580e-4\n\n\n\nS_Co_H_sym_Z2 = (Co/H_sym_Z2)*(H_sym_Z2.diff(Co))\nprint('the sensitivity of Z2 to Co is: {:.2f}'.format(N(S_Co_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Co is: -1.00\n\n\n\nS_R1_H_sym_Z2 = (R1/H_sym_Z2)*(H_sym_Z2.diff(R1))\nprint('the sensitivity of Z2 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R1 is: -0.90\n\n\n\nS_R2_H_sym_Z2 = (R2/H_sym_Z2)*(H_sym_Z2.diff(R2))\nprint('the sensitivity of Z2 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R2 is: -0.09\n\n\n\nS_Ro_H_sym_Z2 = (Ro/H_sym_Z2)*(H_sym_Z2.diff(Ro))\nprint('the sensitivity of Z2 to Ro is: {:.3f}'.format(N(S_Ro_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Ro is: -0.006\n\n\n\n\n20.4.8.5 Poles\nHow many poles are there in the preamp transfer function?\n\nprint('there are {:d} poles in the transfer function'.format(len(H_sym_poles)))\n\nthere are 4 poles in the transfer function\n\n\n\n\n20.4.8.6 P0\nThe first pole is:\n\nH_sym_P0 = H_sym_poles[0]\nH_sym_P0\n\n\\(\\displaystyle - \\frac{1}{C_{1} R_{1}}\\)\n\n\nThe pole P0 evaluates to one of the RIAA time constants.\n\nprint('P0: {:.2f}Hz'.format(N(H_sym_P0.subs(nominal_component_value))/(2*np.pi)))\n\nP0: -50.63Hz\n\n\n\nS_C1_H_sym_P0 = (C1/H_sym_P0)*(H_sym_P0.diff(C1))\nprint('the sensitivity of P0 to C1 is: {:.2f}'.format(N(S_C1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to C1 is: -1.00\n\n\n\nS_R1_H_sym_P0 = (R1/H_sym_P0)*(H_sym_P0.diff(R1))\nprint('the sensitivity of P0 to R1 is: {:.2f}'.format(N(S_R1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to R1 is: -1.00\n\n\n\n\n20.4.8.7 P1\nThe second pole is:\n\nH_sym_P1 = H_sym_poles[1]\nH_sym_P1\n\n\\(\\displaystyle - \\frac{1}{Co Ro}\\)\n\n\nThe pole P1 evaluates to a frequency near DC.\n\nprint('P1: {:.2f}Hz'.format(N(H_sym_P1.subs(nominal_component_value))/(2*np.pi)))\n\nP1: -1.59Hz\n\n\n\nS_Co_H_sym_P1 = (Co/H_sym_P1)*(H_sym_P1.diff(Co))\nprint('the sensitivity of P1 to Co is: {:.2f}'.format(N(S_Co_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Co is: -1.00\n\n\n\nS_Ro_H_sym_P1 = (Ro/H_sym_P1)*(H_sym_P1.diff(Ro))\nprint('the sensitivity of P1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Ro is: -1.00\n\n\n\n\n20.4.8.8 P2\nThe 3rd pole is:\n\nH_sym_P2 = H_sym_poles[2]\nH_sym_P2\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} - \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the compenets that determine P2 are: {:s} '.format(str(H_sym_P2.free_symbols)))\n\nthe compenets that determine P2 are: {C4, R6, C3, R3} \n\n\n\nprint('P2: {:.2f}Hz'.format(N(H_sym_P2.subs(nominal_component_value))/(2*np.pi)))\n\nP2: -2122.88Hz\n\n\n\nS_C3_H_sym_P2 = (C3/H_sym_P2)*(H_sym_P2.diff(C3))\nprint('the sensitivity of P2 to C3 is: {:.2f}'.format(N(S_C3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C3 is: -1.00\n\n\n\nS_C4_H_sym_P2 = (C4/H_sym_P2)*(H_sym_P2.diff(C4))\nprint('the sensitivity of P2 to C4 is: {:.3e}'.format(N(S_C4_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C4 is: -2.829e-5\n\n\n\nS_R3_H_sym_P2 = (R3/H_sym_P2)*(H_sym_P2.diff(R3))\nprint('the sensitivity of P2 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R3 is: -0.96\n\n\n\nS_R6_H_sym_P2 = (R6/H_sym_P2)*(H_sym_P2.diff(R6))\nprint('the sensitivity of P2 to R6 is: {:.3f}'.format(N(S_R6_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R6 is: -0.041\n\n\n\n\n20.4.8.9 P3\nThe 4th pole is:\n\nH_sym_P3 = H_sym_poles[3]\nH_sym_P3\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} + \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the compenets that determine P3 are: {:s} '.format(str(H_sym_P3.free_symbols)))\n\nthe compenets that determine P3 are: {C4, R6, C3, R3} \n\n\n\nprint('P3: {:.2f}Hz'.format(N(H_sym_P3.subs(nominal_component_value))/(2*np.pi)))\n\nP3: -1.39Hz\n\n\n\nS_C3_H_sym_P3 = (C3/H_sym_P3)*(H_sym_P3.diff(C3))\nprint('the sensitivity of P3 to C3 is: {:.2e}'.format(N(S_C3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C3 is: -2.83e-5\n\n\n\nS_C4_H_sym_P3 = (C4/H_sym_P3)*(H_sym_P3.diff(C4))\nprint('the sensitivity of P3 to C5 is: {:.2f}'.format(N(S_C4_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C5 is: -1.00\n\n\n\nS_R3_H_sym_P3 = (R3/H_sym_P3)*(H_sym_P3.diff(R3))\nprint('the sensitivity of P3 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R3 is: -0.04\n\n\n\nS_R6_H_sym_P3 = (R6/H_sym_P3)*(H_sym_P3.diff(R6))\nprint('the sensitivity of P3 to R6 is: {:.2f}'.format(N(S_R6_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R6 is: -0.96\n\n\nIn the worst case analysis below, the componets that have sensitivites greater than 0.05 are the ones that factor into the worst case analysis.\n\n\n\n20.4.9 Component selection\nThe table below list each of the components used in the preamp along with a link to the Digikey pages for each of the components in the preamp. Digikey is a larger distributor of electronic components in the US. All the components have operating temperature ranges that exceed the normal household envirment.\nThe resistors chosen are all 1% Metal film type resistors. Metal film resistors possess good noise characteristics and low non-linearity due to a low voltage coefficient. They are also beneficial due to long-term stability.\nThe capacitors are all polypropylene Film capacitor types. Polystyrene or polypropylene are considered the best for audio applications.\nThe Op Amp, LM833N, is a dual bipolar low noise (\\(\\frac {4.5nV}{\\sqrt{Hz}}\\)), wide bandwidth (16 MHz) audio operational amplifier from Texas Instrments.\n\n\n\nRef\nValue\nDescription\nDigikey PN\n\n\n\n\nRo\n499\n±1% 1/4W Metal Film\nRNF14FTD499RCT-ND\n\n\nRp\n47k\n±1% 1/4W Metal Film\n13-MFR-25FTE52-47KTB-ND\n\n\nR1\n80.6k\n±1% 1/4W Metal Film\n80.6KXBK-ND\n\n\nR2\n58.45k\n±1% 1/4W Metal Film\nRNF14FTD8K45CT-ND\n\n\nR3\n2.37k\n±1% 1/4W Metal Film\n13-MFR-25FBF52-2K37-ND\n\n\nR4\n2k\n±1% 1/4W Metal Film\n13-MFR-25FRF52-2KCT-ND\n\n\nR5\n4.3k\n±1% 1/4W Metal Film\nS4.3KCACT-ND\n\n\nR6\n54.9k\n±1% 1/4W Metal Film\nRNF14FTD54K9CT-ND\n\n\nCo\n200\\(\\mu\\)\n10% Film Capacitor 450V Polypropylene\n283-EFDKS45K207F064DH-ND\n\n\nCp\n100p\n10% Film Capacitor 250V Polypropylene\n399-RSBEC0100ZA00M-ND\n\n\nC1\n0.039\\(\\mu\\)\n2% Film Capacitor 25V 63V Polypropylene\nBC2066-ND\n\n\nC3\n0.033\\(\\mu\\)\n1% Film Capacitor 63V 100V Polypropylene\n399-PHE426DJ5330FR17T0CT-ND\n\n\nC4\n2\\(\\mu\\)\n10% Film Capacitor 305V 630V Polypropylene\n495-B32923P3205K000-ND\n\n\nU1, U2\nLM833N\nAudio op amp\n296-44419-5-ND\n\n\n\nThe parts in this list are considered good choices for a first pass at the bill of materials. The size of the production run and the piece part cost are also a factors which must be considered if the preamp is going to be built. One thing to notice is that Co, the 200 \\(\\mu\\) F capacitor is expensive. The use of a polypropylene film capacitor for this component is consistent with the advice of keeping all capacitors in the audio path polystyrene or polypropylene.\n\n\n20.4.10 Monte Carlo simulation\nIn this analysis the circuit equations are solved after assigning random element values from within the tolerance band to the components. This simulates building a large number of circuits with components chosen at random from bins or reals of components during the board stuffing process. All the components are required to met their specifications, but are allowed to have some varaition accorting to theier tolerance. For example a 1% 2k resistor can range from 1980 to 2020 \\(\\Omega\\). In addition to the components initial tolerance, the temperature coefficient and aging of paramters can also be included.\nIn this simulation, I’m only including the initial tolerances of parameters and I’m assuming the distritution is uniform. The Numpy function random.uniform is used to generate the random values within the tolerance range, however, for this function, the hight end-point value may or may not be included in the range depending on floating-point rounding, so if this is important, some adjustments to the code are required. The Numpy function random.seed is used to re-seed the random number generator.\n\nnum = 20 # number of simulations to run\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to the hold the results of each run\nmag_ans = np.zeros(shape=(num,len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(num,len(new_x_axis_range)))\n\ncomponent_values_tol = nominal_component_value.copy() # makde a copy\n\nrandom.seed(a=None, version=2) # re-seed the random number generator\n\nThe following takes about 15 seconds to run on for num=20 on an i3 machine.\n\nfor i in range(0,num):\n\n    component_values_tol[Ro] = random.uniform(nominal_component_value[Ro]-nominal_component_value[Ro]*0.01,nominal_component_value[Ro]+nominal_component_value[Ro]*0.01)\n    component_values_tol[Rp] = random.uniform(nominal_component_value[Rp]-nominal_component_value[Rp]*0.01,nominal_component_value[Rp]+nominal_component_value[Ro]*0.01)\n\n    component_values_tol[R1] = random.uniform(nominal_component_value[R1]-nominal_component_value[R1]*0.01,nominal_component_value[R1]+nominal_component_value[R1]*0.01)\n    component_values_tol[R2] = random.uniform(nominal_component_value[R2]-nominal_component_value[R2]*0.01,nominal_component_value[R2]+nominal_component_value[R2]*0.01)    \n    component_values_tol[R3] = random.uniform(nominal_component_value[R3]-nominal_component_value[R3]*0.01,nominal_component_value[R3]+nominal_component_value[R3]*0.01)\n    component_values_tol[R4] = random.uniform(nominal_component_value[R4]-nominal_component_value[R4]*0.01,nominal_component_value[R4]+nominal_component_value[R4]*0.01)    \n    component_values_tol[R5] = random.uniform(nominal_component_value[R5]-nominal_component_value[R5]*0.01,nominal_component_value[R5]+nominal_component_value[R5]*0.01)\n    component_values_tol[R6] = random.uniform(nominal_component_value[R6]-nominal_component_value[R6]*0.01,nominal_component_value[R6]+nominal_component_value[R6]*0.01)    \n\n    component_values_tol[Co] = random.uniform(nominal_component_value[Co]-nominal_component_value[Co]*0.1,nominal_component_value[Co]+nominal_component_value[Co]*0.1)\n    component_values_tol[Cp] = random.uniform(nominal_component_value[Cp]-nominal_component_value[Cp]*0.1,nominal_component_value[Cp]+nominal_component_value[Cp]*0.1)\n    component_values_tol[C1] = random.uniform(nominal_component_value[C1]-nominal_component_value[C1]*0.02,nominal_component_value[C1]+nominal_component_value[C1]*0.02)\n    component_values_tol[C3] = random.uniform(nominal_component_value[C3]-nominal_component_value[C3]*0.01,nominal_component_value[C3]+nominal_component_value[C3]*0.01)\n    component_values_tol[C4] = random.uniform(nominal_component_value[C4]-nominal_component_value[C4]*0.1,nominal_component_value[C4]+nominal_component_value[C4]*0.1)\n\n    # enter the element values\n    preamp_equ_tol = preamp_equ_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    \n    # save the results from each run\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\n\n20.4.11 Preamplifier deviation from RIAA response\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.3))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Monte Carlo runs showing deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe Monte Carlo simulation shows that the preamp amplitude response deviatin from the RIAA curve can very from -0.2 to 0.3 dB over the audio band. If the performance requirement for this preamp was to be within \\(\\pm\\) 0.1 dB of the RIAA curve, then some redesign or tighter component tolerancing is required.\n\n\n20.4.12 Worst case analysis\nIn a worst case analysis, we would look at:\n\nminimum and maximum values of the initial component tolerance\n\nmaximum or minumum temperature coefficients of the parameters\n\nmaximum aging or drift of parameter values\n\nSince we usually can’t tell by inspection which combination of minimum and maximum values will give the worst case, we can run a number of simulations in which all combination of minum and maximium variations are included. From the family of results we can look for the worst case.\nHow resistors and capactors in the preamp circuit?\n\nprint('number of components: {:d}'.format(len(nominal_component_value)))\n\nnumber of components: 14\n\n\nHow many combinations min and max combinations?\n\nprint('number of min and max combinations: {:,d}'.format(2**14))\n\nnumber of min and max combinations: 16,384\n\n\n16 thousand simulation runs to too many. From the sensitivity analysis above, only R1, R2, R3, R6, Ro, C1 and C3 are sensitive. Running all combinations of the min and max tolerance for this set is reasonable and is \\(2^7=128\\) combinations.\nThe tolerances for each of the componts is defined below:\n\nTol = {Ro:0.01,R1:0.01,R2:0.01,R3:0.01,R6:0.01,C1:0.02,C3:0.01}\n\nOnly C1 has a tolerance other than 1%.\nThe array ‘run’ is created that consists of a binary count, with leading zeros from 0 to 127. Then the zero values are replaced with -1.\n\nrun = []\nfor i in range(0,2**(len(Tol))):\n    temp = list('{:07b}'.format(i)) # include leading zeros\n    for j in range(len(temp)):\n        temp[j] = int(temp[j])\n    run.append(temp)\n\nrun = np.asarray(run)\nrun = np.where(run == 0, -1, run)\n\nThe first row of run is:\n\nrun[0]\n\narray([-1, -1, -1, -1, -1, -1, -1])\n\n\nIn the for loop below, at i = 0, run[0] would be all -1’s and this could apply the low tolerance range to the nominal component values.\n\nrun[-1]\n\narray([1, 1, 1, 1, 1, 1, 1])\n\n\nThe last time through the for loop, where i = 127, run[-1] is all 1’s and this would apply the high tolerance range to the nominal component values. Between i = 0 and i = 127, all combinations of minumum and maximum tolerance is appled.\n\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to hold the results\nmag_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\n\nThe following cell takes about 90 seconds to run on an i3 machine. i3-8130U CPU @ 2.20GHz\n\nfor i in range(len(run)):\n    component_values_tol[Ro] = nominal_component_value[Ro]*(1+run[i][0]*Tol[Ro])\n    component_values_tol[Rp] = nominal_component_value[Rp]\n\n    component_values_tol[R1] = nominal_component_value[R1]*(1+run[i][1]*Tol[R1])\n    component_values_tol[R2] = nominal_component_value[R2]*(1+run[i][2]*Tol[R2]) \n    component_values_tol[R3] = nominal_component_value[R3]*(1+run[i][3]*Tol[R3])\n\n    component_values_tol[R4] = nominal_component_value[R4] \n    component_values_tol[R5] = nominal_component_value[R5]\n    component_values_tol[R6] = nominal_component_value[R6]*(1+run[i][4]*Tol[R6])\n\n    component_values_tol[Co] = nominal_component_value[Co]\n    component_values_tol[Cp] = nominal_component_value[Cp]\n    component_values_tol[C1] = nominal_component_value[C1]*(1+run[i][5]*Tol[C1])\n    component_values_tol[C3] = nominal_component_value[C3]*(1+run[i][6]*Tol[C3])\n    component_values_tol[C4] = nominal_component_value[C4]\n    \n    # enter the element values\n    preamp_equ_tol = preamp_equ_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.4))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Worst Case deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe results above show that the worst case tolerance conditions yeild deviations of -0.19 to 0.3 dB from the RIAA curve.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#summary",
    "href": "Two amplifier RIAA Phono Preamp.html#summary",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.5 Summary",
    "text": "20.5 Summary\nThe circuit presented in this analysis is just one example of many circuits that can be found on line. For each design to be evaluated, some type of side by side analysis should be used used to down select. This notebook can be used as template for any compartivite analysis.\nThe circuit in the app note appears to have low frequency group delay that might be an issue. Also the deviation from the RIAA curve using normal component tolerances does not meet the 0.1 dB requirement. The worst case analysis also confirms this. The circuit employs an expesive 200\\(\\mu\\) Farad film capacitor. The circuit is missing a subsonic filter.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html",
    "href": "Two port parameters.html",
    "title": "21  Two port parameters",
    "section": "",
    "text": "21.1 Introduction\nThis notebook describes the calculation of two port parameters derived from the circuit’s netlist. A Two-port network is a circuit that has two pairs of ports or terminals and the circuit is characterized by the currents and voltages at the ports by a 2 by 2 matrix. From a two port matrix the response of the network to signals applied to the ports can be calculated easily, without solving for all the internal voltages and currents in the network. For example filters, matching networks, transmission lines, and transistors are characterized by two port parameters.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#circuit-description",
    "href": "Two port parameters.html#circuit-description",
    "title": "21  Two port parameters",
    "section": "21.2 Circuit description",
    "text": "21.2 Circuit description\nThe first circuit is an attenuator, which could be easily analyzed by hand with a pencil, paper and a calculator, but here I’m using python to step through the calculations. These same steps can be applied to larger, more complex circuits which would be difficult to analyze by hand. The Sympy and SciPy libraries can be used to obtain symbolic and numerical results, however as is shown below, when the circuit is large, symbolic results are not that useful nor do they provide much insight.\nThe procedure starts by first drawing a schematic of the circuit with a schematic capture program such as EasyEDA (links to the schematics are provided below) then the netlist is generated and exported as a text file. The netlist is used to generate modified nodal equations with the python program described here. The equations are solved for voltages and currents at the port terminals by using SymPy to generate the z-paramters. Z-parameters are also known as open-circuit impedance parameters as they are calculated under open circuit conditions. Once the z-parameters are obtained, these can be converted into other parameters, such as Y, H, S or others.\nThe second circuit is a band pass filter. The filter is designed from a low pass prototype by using normalized values from a filter design handbook. Z and s-parameters are calculated and the results are plotted using Matplotlib.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n21.2.1 Pi-attenuator\nThe pi-attenuator is formed by three resistors with R1 and R3 as the shunt resistors on the input and output ports and R2 as the series resistor in a circuit topology in the shape of the greek letter pi. For R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms, the attenuation is 10 dB and the port impedance is 50 ohms. Pasternack’s Pi Attenuator Calculator (Pi pad attenuator) was used to design the attenuator.\nThe selection of which type a network parameter is somewhat a matter of convenience. However, some circuits can’t have their ports shorted or left open for proper operation, so s-parameters are the appropriate choice in this situation. Solving for the z-parameters is convenient since all we need to do is apply a voltage source to the input port, with the output port unterminated, and solve for the voltage and currents at each port. Since the output port is unterminated, the current into this port is zero and we can find z11 and z21. To find z21 and z22, the voltage source is applied to port 2 with port 1 unterminated.\nTo find Z-parameters attach voltage sources to both ports and find the node equations. EasyEDA was used to draw the schematic and generate the netlist. A link to the schematic is here.\n\n\n\nschematic\n\n\nThe netlist for the circuit:\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\nV2 2 0 1\n\n21.2.1.1 Find z11 & z21\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\n\nnet_list = '''\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}}\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\V_{1}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  R_{1}, \\  R_{2}, \\  R_{3}, \\  I_{V1}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p1 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p1.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p1[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{3} V_{1}}{R_{2} + R_{3}}\\)\\(I_{V1} = \\frac{- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}}{R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\nA negative sign was placed in the equation to make the direction of the current flow match the definition of the two port parameters.\n\nz11 = -U_sym_p1[v1]/U_sym_p1[I_V1]\nz11.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{2} + R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = -U_sym_p1[v2]/U_sym_p1[I_V1]\nz21.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\n\n\n21.2.1.2 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the net list.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\n\nnet_list = '''\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V2} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{2} = V_{2}\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\I_{V2} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}}\\\\v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\V_{2}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  R_{1}, \\  R_{2}, \\  I_{V2}, \\  R_{3}, \\  V_{2}, \\  v_{1}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p2 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p2.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p2[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{R_{1} V_{2}}{R_{1} + R_{2}}\\)\\(v_{2} = V_{2}\\)\\(I_{V2} = \\frac{- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}}{R_{1} R_{3} + R_{2} R_{3}}\\)\n\n\n\n\\(z_{12}=\\frac{V_1}{I_2}\\text{  when  }I_1=0\\)\n\nz12 = -U_sym_p2[v1]/U_sym_p2[I_V2]\nz12.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\\(z_{22}=\\frac{V_2}{I_2}\\text{  when  }I_1=0\\)\n\nz22 = -U_sym_p2[v2]/U_sym_p2[I_V2]\nz22.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3} + R_{2} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\nThe common names for the z-parameters are:\nz11: input driving point impedance\nz12: reverse transfer impedance\nz21: forward transfer impedance\nz22: output driving point impedance\nThe elements of the matrix can be displayed:\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\frac{V_{1} \\left(R_{1} R_{2} + R_{1} R_{3}\\right)}{- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}} & - \\frac{R_{3} V_{1} \\left(R_{1} R_{2} + R_{1} R_{3}\\right)}{\\left(R_{2} + R_{3}\\right) \\left(- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}\\right)}\\\\- \\frac{R_{1} V_{2} \\left(R_{1} R_{3} + R_{2} R_{3}\\right)}{\\left(R_{1} + R_{2}\\right) \\left(- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}\\right)} & - \\frac{V_{2} \\left(R_{1} R_{3} + R_{2} R_{3}\\right)}{- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}}\\end{matrix}\\right]\\)\n\n\nActual values for each of the components can be substituted for the symbols with R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms\n\natten_values = {R1:96.25,R2:71.15,R3:96.25}\n\n\nz11_val = z11.subs(atten_values)\nz12_val = z12.subs(atten_values)\nz21_val = z21.subs(atten_values)\nz22_val = z22.subs(atten_values)\n\nThe numeric values of the impedance matrix\n\nnp.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=float)\n\narray([[61.11227005, 35.13772995],\n       [35.13772995, 61.11227005]])\n\n\n\n\n21.2.1.3 Calculate Z in and Z out, ki and kv\nA two-port circuit is typically driven at port 1 and loaded at port 2, and four equations needed to solve the four unknowns. The link here has a nice explnation of two port analysis.\n\\(\\begin{align*}\n\\begin{bmatrix} -1 & 0 & z11 & z12 \\\\\\ 0 & -1 & z21 & z22 \\\\\\ 1 & 0 & Z_S & 0 \\\\\\ 0 & 1 & 0 & Z_L\n\\end{bmatrix}\n\\begin{bmatrix}\n  V_1  \\\\\n  V_2  \\\\\n  I_1 \\\\\n  I_2\n\\end{bmatrix}\n{} &= \\begin{bmatrix}\n  0  \\\\\n  0  \\\\\n  V_g \\\\\n  0\n\\end{bmatrix}\n\\end{align*}\\)\nPutting into SymPy\n\nZ11, Z12, Z21, Z22 = symbols('Z11 Z12 Z21 Z22')\nZ_s, Z_l, Vg = symbols('Z_s Z_l Vg')\n\neqZ = Eq(Matrix([[-1,0,Z11,Z12],[0,-1,Z21,Z22],[1,0,Z_s,0],[0,1,0,Z_l]])*Matrix([V1,V2,I_V1,I_V2]),Matrix([0,0,Vg,0]))\neqZ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} Z_{11} + I_{V2} Z_{12} - V_{1}\\\\I_{V1} Z_{21} + I_{V2} Z_{22} - V_{2}\\\\I_{V1} Z_{s} + V_{1}\\\\I_{V2} Z_{l} + V_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\Vg\\\\0\\end{matrix}\\right]\\)\n\n\n\nansZ = solve(eqZ,[V1, V2, I_V1,I_V2])\nansZ\n\n\\(\\displaystyle \\left\\{ I_{V1} : \\frac{Vg Z_{22} + Vg Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  I_{V2} : - \\frac{Vg Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  V_{1} : \\frac{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  V_{2} : \\frac{Vg Z_{21} Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}\\right\\}\\)\n\n\n\n# current gain\nansZ[I_V2]/ansZ[I_V1]\n\n\\(\\displaystyle - \\frac{Vg Z_{21}}{Vg Z_{22} + Vg Z_{l}}\\)\n\n\n\n# voltage gain\nansZ[V2]/ansZ[V1]\n\n\\(\\displaystyle \\frac{Vg Z_{21} Z_{l}}{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}\\)\n\n\n\n# Z input\nansZ[V1]/ansZ[I_V1]\n\n\\(\\displaystyle \\frac{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}{Vg Z_{22} + Vg Z_{l}}\\)\n\n\n\n# Z out\nansZ[V2]/ansZ[I_V2]\n\n\\(\\displaystyle - Z_{l}\\)\n\n\nSympy returns the output impedance as simply \\(-Z_l\\), since this is the algebraic simplification of the equations. Most textbooks will give the output impedance in terms of the z-parameters and the source impedance: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\)\n\n\n21.2.1.4 Calculate input and output impedance for the attenuator\nThe input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\)\nTextbook equation: \\(Z_{in}=Z_{11}-\\frac{Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\) where \\(Z_{L}\\) is the impedance of the load connected to port two.\nThe output impedance from textbooks is: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\), where \\(Z_{S}\\) is the impedance of the source connected to port one.\n\n# Zin\nZl = 50 # load impedance\nprint('input impedance of network from z-parameters: {:.2f}'.format(np.abs((z11_val*z22_val+z11_val*Zl-z12_val*z21_val)/(z22_val+Zl))))\n\ninput impedance of network from z-parameters: 50.00\n\n\n\n# Zout\nZs = 50 # source impedance\nprint('output impedance of network from z-parameters: {:.2f}'.format(np.abs(z22_val-(z12_val*z21_val)/(z11_val+Zs))))\n\noutput impedance of network from z-parameters: 50.00\n\n\n\n\n21.2.1.5 Calculate the voltage gain for the attenuator\nVoltage gain: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), from text books: \\(K_v=\\frac{Z_{21}Z_{L}}{\\Delta _Z+Z_{11}Z_L}\\)\n\n#Kv\nprint('voltage gain of network from z-parameters: {:.2f} dB'.format(20*np.log10(float((z21_val*Zl)/(z11_val*z22_val + z11_val*Zl - z12_val*z21_val)))))\n\nvoltage gain of network from z-parameters: -10.00 dB\n\n\n\n\n21.2.1.6 Convert z-parameters to y-parameters\nThe z-parameters can be converted to admittance or y-parameters with the following code:\nFind the determinant of the z-parameter matrix:\n\ndet_z = np.linalg.det(np.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=float))\nprint('determinant = {:.2f}'.format(det_z))\n\ndeterminant = 2500.05\n\n\nDisplay the y-parameter matrix.\n\nnp.array([[z22_val/det_z,-z12_val/det_z],[-z21_val/det_z,z11_val/det_z]],dtype=float)\n\narray([[ 0.02444442, -0.01405481],\n       [-0.01405481,  0.02444442]])\n\n\n\n\n21.2.1.7 Convert z-parameters to s-parameters\nThe 2-port S-parameters have the following generic descriptions:\n\\(S_{11} \\text{ is the input port voltage reflection coefficient}\\)\n\\(S_{12} \\text{ is the reverse voltage gain}\\)\n\\(S_{21} \\text{ is the forward voltage gain}\\)\n\\(S_{22} \\text{ is the output port voltage reflection coefficient}\\)\nThe z-parameter can be converted to scattering or s-parameters with the following:\n\\(s_{11} = \\frac {(Z_{11}-Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\n\\(s_{12} = \\frac {2Z_{12}Z_o} {\\Delta Z}\\)\n\\(s_{21} = \\frac {2Z_{21}Z_o} {\\Delta Z}\\)\n\\(s_{22} = \\frac {(Z_{11}+Z_o)(Z_{22}-Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\nwhere: \\(\\Delta Z = (Z_{11}+Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}\\) and \\(Z_o\\) is the characteristic impedance.\n\nZ_o = 50 # characteristic impedance\ndel_z = (z11_val+Z_o)*(z22_val+Z_o)-z12_val*z21_val\n\nS = np.array([[((z11_val-Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z,(2*z12_val*Z_o)/del_z],\n              [(2*z21_val*Z_o)/del_z,((z11_val+Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z]],dtype=float)\nS # display the s-parameter matrix\n\narray([[-1.00004488e-01,  3.16234863e-01],\n       [ 3.16234863e-01,  4.45363654e-06]])\n\n\n\n\n21.2.1.8 Input return loss\nInput return loss \\(RL_{in}\\) indicates impedance match of the port to the source. A number of 10 dB or greater, indicates that the match is probably acceptable.\n\\(RL_{in} =-20\\log_{10}\\left|S_{11}\\right|\\)\n\nprint('Input return loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[0,0]))))\n\nInput return loss = 20.00 dB\n\n\n\n\n21.2.1.9 Insertion loss\nInsertion loss \\(IL\\) is the reciprocal of the magnitude of the transmission coefficient, S21, expressed in decibels.\n\\(IL=-20\\log _{10} \\left|S_{21} \\right|\\)\n\nprint('Insertion loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[1,0]))))\n\nInsertion loss = 10.00 dB\n\n\nThis value agrees with the design of the attenuator as being a 10 dB attenuator.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#band-pass-filter",
    "href": "Two port parameters.html#band-pass-filter",
    "title": "21  Two port parameters",
    "section": "21.3 Band Pass Filter",
    "text": "21.3 Band Pass Filter\nThe circuit below is a band pass filter designed from normalized filter design tables. The third order low pass filter prototype was transformed into a bandpass filter as shown in the figure below. Butterworth filter coefficients were chosen for this design. A Butterworth filter is a type of signal processing filter that has a flat passband response.\n\n\n\nschematic\n\n\nThe link to the schematic in EasyEDA is here. The low pass to bandpass transformation calculations are shown below. The filter was designed to have a center frequency of 10 MHz and a 3 dB bandwidth of 1 MHz. The normalized filter values were obtained from Williams and Taylor (1995):\n3rd order Butterworth LPF prototype\nRs/Rl = 1\nC1 = 1\nL2 = 2\nC1 = 1\nThe bandpass filter has the following design parameters: The source and load impedance is 50 ohms, the filter bandwidth is 1 MHz and the center frequency is 10 MHz. Following the example from Williams and Taylor (1995) (example 5-2), but with the following changes:\n\ncenter freq = 10MHz\n\nbandwidth 1MHz\n\nRs=Rl=50\n\n\nf_center = 10e6\nf_3dB_BW = 1e6 # 3dB bandwidth\nfo = np.sqrt((f_center-f_3dB_BW/2)*(f_center+f_3dB_BW/2)) # geometric center frequency\nprint('geometric center frequency = {:.3f}MHz'.format(fo/1e6))\n\ngeometric center frequency = 9.987MHz\n\n\n\nZ = 50 # load and source resistance\nFSF = 2*np.pi*f_3dB_BW\nprint('frequency scaling factor = {:.3f}'.format(FSF))\n\nfrequency scaling factor = 6283185.307\n\n\nThe first element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled.\n\n# C1 is 1st shunt capacitor\nC1n = 1 # normalized value from the tables in the filter handbook\nC1p = C1n/(FSF*Z)\nprint('capacitor = {:.3f}nF'.format(C1p*1e9))\n\nwo = 2*np.pi*fo\nL1p = 1/(wo**2*C1p) # calculate the value of the inductor that resonates with the capacitor at the center frequency\nprint('inductor = {:.3f}nH'.format(L1p*1e9))\n\ncapacitor = 3.183nF\ninductor = 79.777nH\n\n\nThe second element in the lowpass prototype is a series capacitor and for the lowpass to bandpass transformation the capacitor is replaced by a capacitor and inductor in series with the same normalized value. The normalized values are then frequency scaled.\n\n# L2 is the 2nd series inductor\nL2n = 2 # normalized value from the tables in the filter handbook\nL2p = L2n*Z/FSF\nprint('inductor = {:.3f}uH'.format(L2p*1e6))\n\nC2p = 1/(wo**2*L2p) # calculate the value of the capacitor that resonates with the inductor at the center frequency\nprint('capacitor = {:.3f}pF'.format(C2p*1e12))\n\ninductor = 15.915uH\ncapacitor = 15.955pF\n\n\nThe last element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled. The values for this branch of the circuit are the same as for the first shunt element.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z11-and-z12",
    "href": "Two port parameters.html#find-z11-and-z12",
    "title": "21  Two port parameters",
    "section": "21.4 Find z11 and z12",
    "text": "21.4 Find z11 and z12\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations. The component values in the netlist have all been set to one. Later, the actual component values will be used.\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n\nnet_list = '''\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1} = 0\\)\\(- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s - v_{1} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{2} = 0\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1}\\\\- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right)\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2}\\\\v_{1}\\\\- I_{L1} L_{1} s - v_{1}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\\\- I_{L3} L_{3} s - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  I_{L3}, \\  I_{V1}, \\  L_{2}, \\  V_{1}, \\  L_{1}, \\  v_{1}, \\  C_{2}, \\  L_{3}, \\  I_{L2}, \\  s, \\  C_{1}, \\  v_{3}, \\  I_{L1}, \\  C_{3}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p1 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p1.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p1[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} L_{3} V_{1} s^{2}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(v_{3} = \\frac{C_{2} L_{3} V_{1} s^{2} + C_{3} L_{3} V_{1} s^{2} + V_{1}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} V_{1} s^{6} - C_{1} C_{2} L_{1} L_{2} V_{1} s^{4} - C_{1} C_{2} L_{1} L_{3} V_{1} s^{4} - C_{1} C_{3} L_{1} L_{3} V_{1} s^{4} - C_{1} L_{1} V_{1} s^{2} - C_{2} C_{3} L_{1} L_{3} V_{1} s^{4} - C_{2} C_{3} L_{2} L_{3} V_{1} s^{4} - C_{2} L_{1} V_{1} s^{2} - C_{2} L_{2} V_{1} s^{2} - C_{2} L_{3} V_{1} s^{2} - C_{3} L_{3} V_{1} s^{2} - V_{1}}{C_{2} C_{3} L_{1} L_{2} L_{3} s^{5} + C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{3} L_{1} L_{3} s^{3} + L_{1} s}\\)\\(I_{L1} = - \\frac{V_{1}}{L_{1} s}\\)\\(I_{L2} = \\frac{C_{2} C_{3} L_{3} V_{1} s^{3} + C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(I_{L3} = - \\frac{C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\n\n\n\n\nelement_values = {L1:L1p,C1:C1p,C2:C2p,L2:L2p,L3:L1p,C3:C1p}\n\n\nU_p1 = solve(NE_sym.subs(element_values),X)\n\nSubstituting actual values for the circuit elements, we get:\n\nU_p1\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{12534954.6878233 V_{1}}{s}, \\  I_{L2} : \\frac{6.33074196165529 \\cdot 10^{60} V_{1} s^{3} + 2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  I_{L3} : - \\frac{2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  I_{V1} : \\frac{- 6.39649568809606 \\cdot 10^{83} V_{1} s^{6} - 7.58201892757332 \\cdot 10^{99} V_{1} s^{4} - 2.98577794233115 \\cdot 10^{115} V_{1} s^{2} - 3.90625 \\cdot 10^{130} V_{1}}{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{1.98886124385089 \\cdot 10^{69} V_{1} s^{2}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  v_{3} : \\frac{3.98766679392103 \\cdot 10^{71} V_{1} s^{2} + 1.5625 \\cdot 10^{87} V_{1}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}\\right\\}\\)\n\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\n\nz11 = (-U_p1[v1]/U_p1[I_V1]).cancel()\nz11 #.simplify()\n\n\\(\\displaystyle \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\)\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = (-U_p1[v2]/U_p1[I_V1]).cancel()\nz21 #.simplify()\n\n\\(\\displaystyle \\frac{3.99665323720675 \\cdot 10^{161} s^{7} + 3.1556309103651 \\cdot 10^{177} s^{5} + 6.19785984654536 \\cdot 10^{192} s^{3}}{6.44490997486657 \\cdot 10^{139} s^{10} + 1.27281032416988 \\cdot 10^{156} s^{8} + 1.00396628165841 \\cdot 10^{172} s^{6} + 3.95359126276846 \\cdot 10^{187} s^{4} + 7.77287372840943 \\cdot 10^{202} s^{2} + 6.103515625 \\cdot 10^{217}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z12-z22-1",
    "href": "Two port parameters.html#find-z12-z22-1",
    "title": "21  Two port parameters",
    "section": "21.5 Find z12 & z22",
    "text": "21.5 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the netlist.\n\nnet_list = '''\n*V1 1 0 1\nV2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - I_{L1} + I_{L2} = 0\\)\\(- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\)\\(v_{2} = V_{2}\\)\\(- I_{L1} L_{1} s - v_{1} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{2} = 0\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2}\\\\- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right)\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2}\\\\v_{2}\\\\- I_{L1} L_{1} s - v_{1}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\\\- I_{L3} L_{3} s - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  I_{L3}, \\  I_{V2}, \\  L_{2}, \\  L_{1}, \\  v_{1}, \\  C_{2}, \\  L_{3}, \\  I_{L2}, \\  s, \\  C_{1}, \\  v_{3}, \\  I_{L1}, \\  C_{3}, \\  V_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p2 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p2.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p2[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{2} L_{1} V_{2} s^{2}}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(v_{2} = V_{2}\\)\\(v_{3} = \\frac{C_{1} C_{2} L_{1} L_{2} V_{2} s^{4} + C_{2} L_{1} V_{2} s^{2} + C_{2} L_{2} V_{2} s^{2}}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{V2} = \\frac{- C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} V_{2} s^{6} - C_{1} C_{2} L_{1} L_{2} V_{2} s^{4} - C_{1} C_{2} L_{1} L_{3} V_{2} s^{4} - C_{1} C_{3} L_{1} L_{3} V_{2} s^{4} - C_{1} L_{1} V_{2} s^{2} - C_{2} C_{3} L_{1} L_{3} V_{2} s^{4} - C_{2} C_{3} L_{2} L_{3} V_{2} s^{4} - C_{2} L_{1} V_{2} s^{2} - C_{2} L_{2} V_{2} s^{2} - C_{2} L_{3} V_{2} s^{2} - C_{3} L_{3} V_{2} s^{2} - V_{2}}{C_{1} C_{2} L_{1} L_{2} L_{3} s^{5} + C_{1} L_{1} L_{3} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{2} L_{3} s^{3} + L_{3} s}\\)\\(I_{L1} = - \\frac{C_{2} V_{2} s}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{L2} = \\frac{- C_{1} C_{2} L_{1} V_{2} s^{3} - C_{2} V_{2} s}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{L3} = - \\frac{V_{2}}{L_{3} s}\\)\n\n\n\n\nU_p2 = solve(NE_sym.subs(element_values),X)\nU_p2\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  I_{L2} : \\frac{- 2.53229678466212 \\cdot 10^{59} V_{2} s^{3} - 9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  I_{L3} : - \\frac{12534954.6878233 V_{2}}{s}, \\  I_{V2} : \\frac{- 6.39649568809606 \\cdot 10^{83} V_{2} s^{6} - 7.58201892757332 \\cdot 10^{99} V_{2} s^{4} - 2.98577794233115 \\cdot 10^{115} V_{2} s^{2} - 3.90625 \\cdot 10^{130} V_{2}}{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}, \\  v_{1} : \\frac{7.95544497540356 \\cdot 10^{67} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  v_{2} : V_{2}, \\  v_{3} : \\frac{4.03027550654688 \\cdot 10^{54} V_{2} s^{4} + 1.59506671756841 \\cdot 10^{70} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}\\right\\}\\)\n\n\n\\(z_{12} = \\frac {V_1}{I_2} \\text{  when  } I_1=0\\)\n\nz12 = (-U_p2[v1]/U_p2[I_V2]).cancel()\nz12 #.simplify()\n\n\\(\\displaystyle \\frac{1.5986612948827 \\cdot 10^{160} s^{7} + 1.26225236414604 \\cdot 10^{176} s^{5} + 2.47914393861815 \\cdot 10^{191} s^{3}}{2.57796398994663 \\cdot 10^{138} s^{10} + 5.09124129667954 \\cdot 10^{154} s^{8} + 4.01586512663364 \\cdot 10^{170} s^{6} + 1.58143650510738 \\cdot 10^{186} s^{4} + 3.10914949136377 \\cdot 10^{201} s^{2} + 2.44140625 \\cdot 10^{216}}\\)\n\n\n\\(z_{22} = \\frac {V_2}{I_2} \\text{  when  } I_1=0\\)\n\nz22 = (-U_p2[v2]/U_p2[I_V2]).cancel()\nz22 #.simplify()\n\n\\(\\displaystyle \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\)\n\n\ndisplaying the z-parameter matrix\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}} & \\frac{3.99665323720675 \\cdot 10^{161} s^{7} + 3.1556309103651 \\cdot 10^{177} s^{5} + 6.19785984654536 \\cdot 10^{192} s^{3}}{6.44490997486657 \\cdot 10^{139} s^{10} + 1.27281032416988 \\cdot 10^{156} s^{8} + 1.00396628165841 \\cdot 10^{172} s^{6} + 3.95359126276846 \\cdot 10^{187} s^{4} + 7.77287372840943 \\cdot 10^{202} s^{2} + 6.103515625 \\cdot 10^{217}}\\\\\\frac{1.5986612948827 \\cdot 10^{160} s^{7} + 1.26225236414604 \\cdot 10^{176} s^{5} + 2.47914393861815 \\cdot 10^{191} s^{3}}{2.57796398994663 \\cdot 10^{138} s^{10} + 5.09124129667954 \\cdot 10^{154} s^{8} + 4.01586512663364 \\cdot 10^{170} s^{6} + 1.58143650510738 \\cdot 10^{186} s^{4} + 3.10914949136377 \\cdot 10^{201} s^{2} + 2.44140625 \\cdot 10^{216}} & \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\end{matrix}\\right]\\)\n\n\nThe complete z-parameter matrix is shown above. It’s kind of interesting that the exponents on many of the coefficients are so large. Using the SymPy function lambdify to turn the symbolic expression into a function.\n\nfunc_z11_s = lambdify(s, z11)\nfunc_z12_s = lambdify(s, z12) \nfunc_z21_s = lambdify(s, z21) \nfunc_z22_s = lambdify(s, z22) \n\nUsing the results from above, the input impedance of a two-port network is given by: The input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\), where \\(Z_{L}\\) is the impedance of the load connected to port two.\n\n# set the source and load impedance\nZl = Zs = 50\n\nw = np.linspace(9e6*2*np.pi, 11e6*2*np.pi, 1000, endpoint=True)\n\nplt.title('Input impedance')\n\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='|Zin|')\nplt.plot(w/(2*np.pi)/1e6, np.real((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Re Zin')\nplt.plot(w/(2*np.pi)/1e6, np.imag((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Im Zin')\n\nplt.ylabel('impedance, ohms')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitude of the input impedance (in blue), the real part of the input impedance (in orange) and the imaginary part of the input impedance (in green). Near 10Hz, the magnitude and real part of the input impedance is 50 ohms and the imaginary part is about zero. This shows that the design equations produced the desired results. The input impedance bandwidth of the filter is about 1 MHz.\nThe voltage gain of the filter calculated from the z-parameters is: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), which is plotted below:\n\nplt.title('Voltage gain')\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z21_s(1j*w)*Zl)/(func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))),'-',label='|Kv|')\nplt.ylabel('Kv')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the voltage gain of the filter (in blue) plotted from the z-parameters. The filter is centered at 10MHz and the bandwidth appears to be 1 MHz.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "href": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "title": "21  Two port parameters",
    "section": "21.6 Convert z-parameters to s-parameters",
    "text": "21.6 Convert z-parameters to s-parameters\nAlthough applicable at any frequency, s-parameters are mostly used for networks operating at radio frequency (RF) and microwave frequencies. The s-parameters can be calculated from the z-parameters with the following formulas:\n\nZ_o = 50 # characteristic impedance\n\nw = np.linspace(8e6*2*np.pi, 12e6*2*np.pi, 2000, endpoint=True)\ns11 = np.zeros(len(w),dtype=complex)\ns12 = np.zeros(len(w),dtype=complex)\ns21 = np.zeros(len(w),dtype=complex)\ns22 = np.zeros(len(w),dtype=complex)\n\nfor i in range(len(w)):\n    del_z = (func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i])\n    s11[i] = ((func_z11_s(1j*w[i])-Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n    s12[i] = (2*func_z12_s(1j*w[i])*Z_o)/del_z\n    s21[i] = (2*func_z21_s(1j*w[i])*Z_o)/del_z\n    s22[i] = ((func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])-Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n\nplt.title('S-parameters')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s11)),'-',label='|s11|dB')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s21)),'-',label='|s21|dB')\nplt.ylabel('|S11| & |S21|, dB')\nplt.xlabel('Frequency, MHz')\nplt.ylim((-20,1))\nplt.yticks(np.arange(-20, 1, 5))\n#plt.xlim((-1,20))\n#plt.xticks(np.arange(0, 20+1, 2.0))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitudes in dB of the input reflection coefficient (in blue) and the forward voltage gain (in orange).\nThe magnitude of the input reflection coefficient indicates the amount of energy reflected back to the source due to the impedance mismatch. The smaller the reflection coefficient the better the match, and in dB, large negative values are very small small numbers. A rule of thumb is that |S11| less than about -9.5 dB is a reasonable match, since this corresponds to about a 2:1 VSWR or a mismatch loss of about 0.5 dB. The frequency range over which this match occurs is called the impedance bandwidth.\nThe plot of |S21| shows the forward voltage gain of the filter in dB. The filter was designed to be a band pass filter with a center frequency of 10 MHz, which is clearly shown in the plot. The plot is similar to what would be seen on a network analyzer.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#summary",
    "href": "Two port parameters.html#summary",
    "title": "21  Two port parameters",
    "section": "21.7 Summary",
    "text": "21.7 Summary\nIn this notebook the parameters for two port networks were generated from the circuit’s netlist. Using python, the circuit equations were automatically generated by using modified nodal analysis, then SymPy was used to solve for the network currents and voltages. Z-parameters were calculated for the circuits, from which y and s parameters were generated. The z-parameters were used to generate input impedance and transfer functions.\nThis notebook has demonstrated that two port parameters can easily be generated from a circuit’s netlist with python.\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html",
    "href": "Thevenin equivalent circuit.html",
    "title": "22  Thevenin equivalent circuit",
    "section": "",
    "text": "22.1 Introduction\nThe Thevenin equivalent circuit is the reduction of a linear one port circuit to a single source and impedance and is based on Thevenin’s Theorem. This notebook describes solving problem 11.25, given in chapter 11 of Johnson, Hilburn, and Johnson (1978). The Python libraries of SimPy and NumPy are used to perform the math in the proposed solution. The problem asks the student to replace the circuit to the left of terminals a-b by its Thevenin equivalent and find V. The schematic was drawn using LTspice and the nodes were numbered. Terminals a-b are across the resistor R3. The circuit given in the textbook does not include a reference node, however the node at the bottom of the schematic was chosen as the reference node, ground.\nHaving drawn the circuit in LTspice, the following netlist was exported as a text file.\nThe component values for the inductors and capacitors are complex as well as the value of the current source. It is assumed that the impedance of the inductors and capacitors are at a frequency of 1 radian per second. So accordingly, the values in the net list used by the Python code to generate the network equations has been adjusted as follows:\nThe component values are not used when the symbolic network equations are generated, only the reference designators, R1, C1, L1 etc. are used.\n#import os\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#introduction",
    "href": "Thevenin equivalent circuit.html#introduction",
    "title": "22  Thevenin equivalent circuit",
    "section": "",
    "text": "Figure 22.1: Circuit for problem 11.25 of Johnson, Hilburn, and Johnson (1978)\n\n\n\n\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 j2\nL2 1 3 j3\nC1 1 2 -j3\nC2 3 0 -j2\nI1 0 1 -1-j1\n\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nI1 0 1 1",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "href": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.2 Find the open circuit voltage, Voc",
    "text": "22.2 Find the open circuit voltage, Voc\nRemoving R3 and C2 from the netlist, this gives Voc = V3. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\n*C2 3 0 0.5\nLoad the net list\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.3333333333\n*C2 3 0 0.5\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}}\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  s, \\  v_{2}, \\  I_{L2}, \\  v_{3}, \\  R_{2}\\right)\\)\n\n\nGenerate the symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} L_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} L_{2} R_{1} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\)\\(v_{2} = \\frac{I_{1} L_{1} R_{1} s}{L_{1} s + R_{1}}\\)\\(v_{3} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} R_{1}}{L_{1} s + R_{1}}\\)\\(I_{L2} = \\frac{I_{1}}{C_{1} L_{2} s^{2} + C_{1} R_{2} s + 1}\\)\n\n\nConstruct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.3333333333, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0\\right\\}\\)\n\n\nTo solve numerically, replace symbols with the element values and the Laplace variable, s, with \\(j\\omega\\) where \\(\\omega=1\\).\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.3333333333 i v_{1} - 0.3333333333 i v_{2}\\\\I_{L1} - 0.3333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.3333333333 i\\right) - 0.166666666666667 v_{3}\\\\- I_{L2} - 0.166666666666667 v_{2} + 0.166666666666667 v_{3}\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving the system of equations for the open circuit voltage at node v3.\n\nVoc = solve(NE,X)[v3]\nVoc\n\n\\(\\displaystyle -1.8 + 0.6 i\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "href": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.3 Find the short circuit current, Isc",
    "text": "22.3 Find the short circuit current, Isc\nRemove C2 and R3, set node 3 to zero, find current in L2 and R2. New net list:\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33333333333333\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right)\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  s, \\  v_{2}, \\  I_{L2}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + I_{1} L_{1} L_{2} R_{1} s^{2} + I_{1} L_{1} L_{2} R_{2} s^{2} + I_{1} L_{2} R_{1} R_{2} s}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(v_{2} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(I_{L1} = \\frac{C_{1} I_{1} L_{2} R_{1} R_{2} s^{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(I_{L2} = \\frac{C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\n\n\n\nU_sym[v2]/R2 + U_sym[I_L2]\n\n\\(\\displaystyle \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}} + \\frac{C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\n\n\nConstruct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.33333333333333, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0\\right\\}\\)\n\n\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.33333333333333 i v_{1} - 0.33333333333333 i v_{2}\\\\I_{L1} - 0.33333333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.33333333333333 i\\right)\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\nU\n\n\\(\\displaystyle \\left\\{ I_{L1} : -1.5 - 1.5 i, \\  I_{L2} : -0.5 + 1.5 i, \\  v_{1} : -4.5 - 1.5 i, \\  v_{2} : 3.0 - 3.0 i\\right\\}\\)\n\n\n\nIsc = U[v2]/6 + U[I_L2]\nIsc\n\n\\(\\displaystyle 1.0 i\\)\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\(\\displaystyle 0.6 + 1.8 i\\)\n\n\n\nCurrent in I_R2 = V2/R2\n\nIsc = U[v2]/6 + U[I_L2]\nIsc\n\n\\(\\displaystyle 1.0 i\\)\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\(\\displaystyle 0.6 + 1.8 i\\)\n\n\nVoc along with Zth are the values to the Thevenin equivalent circuit.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.4 Find V3 using the Thevenin equivalent circuit",
    "text": "22.4 Find V3 using the Thevenin equivalent circuit\nThe load attached to the Thevenin equivalent circuit is the parallel of the resistor and capacitor.\n\\(Z = \\frac{1}{\\frac{1}{R}+\\frac{1}{C}}\\)\nThe load \\(Z\\) is the parallel combination of R = 6 and C = -j2.\n\nZ = (1)/(1/(6)+1/(-2j))\nZ\n\n(0.6-1.7999999999999998j)\n\n\nUsing the values for \\(V_{oc}\\) and \\(Z_{th}\\) obtained above, we write the equation for V3 as a voltage divider and have SymPy simplify the result.\n\nsimplify(Z*Voc/(Zth+Z))\n\n\\(\\displaystyle 4.62592926927148 \\cdot 10^{-16} + 3.0 i\\)\n\n\nWe can get SymPy to ignore small numbers by using the round function set to 3 digits.\n\nsimplify(Z*Voc/(Zth+Z)).round(3)\n\n\\(\\displaystyle 3.0 i\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.5 Find V3 using the complete circuit",
    "text": "22.5 Find V3 using the complete circuit\nChecking the answer for V3, by solving the equations for the complete circuit. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nDeclare the symbols and equations for the complete circuit.\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.333333333333333\nC2 3 0 0.5\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  R_{3}, \\  s, \\  v_{2}, \\  I_{L2}, \\  v_{3}, \\  R_{2}, \\  C_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} C_{2} I_{1} L_{1} L_{2} R_{1} R_{2} R_{3} s^{4} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + C_{2} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{2} I_{1} L_{1} L_{2} R_{2} R_{3} s^{3} + C_{2} I_{1} L_{2} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} L_{2} R_{1} s^{2} + I_{1} L_{1} L_{2} R_{2} s^{2} + I_{1} L_{1} L_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} L_{2} R_{1} R_{2} s + I_{1} L_{2} R_{1} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{2} = \\frac{C_{1} C_{2} I_{1} L_{1} L_{2} R_{1} R_{2} R_{3} s^{4} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{3} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L1} = \\frac{C_{1} C_{2} I_{1} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} I_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} I_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} I_{1} R_{1} R_{2} R_{3} s + I_{1} R_{1} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L2} = \\frac{C_{1} C_{2} I_{1} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + C_{2} I_{1} L_{1} R_{1} R_{3} s^{2} + C_{2} I_{1} L_{1} R_{2} R_{3} s^{2} + C_{2} I_{1} R_{1} R_{2} R_{3} s + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} L_{1} R_{3} s + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\n\nU_sym[v3]\n\n\\(\\displaystyle \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\nConstruct a dictionary of element values\nelement_values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.333333333333333, \\  C_{2} : 0.5, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0, \\  R_{3} : 6.0\\right\\}\\)\n\n\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.333333333333333 i v_{1} - 0.333333333333333 i v_{2}\\\\I_{L1} - 0.333333333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.333333333333333 i\\right) - 0.166666666666667 v_{3}\\\\- I_{L2} - 0.166666666666667 v_{2} + v_{3} \\cdot \\left(0.333333333333333 + 0.5 i\\right)\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving the system of equations for v3 using the SymPy solve function.\n\nU = solve(NE,X)\nU[v3]\n\n\\(\\displaystyle 3.0 i\\)\n\n\n\nThe value obtained by solving the system equations for the complete network agrees with the Thevenin equivalent circuit solution.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html",
    "href": "State-variable-filter.html",
    "title": "23  State Variable Filter",
    "section": "",
    "text": "Abstract\nThis notebook analyzes a state variable filter by solving the network equations in symbolic form. The filter uses three OpAmps, seven resistors and two capacitors.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#introduction",
    "href": "State-variable-filter.html#introduction",
    "title": "23  State Variable Filter",
    "section": "23.1 Introduction",
    "text": "23.1 Introduction\nA state variable filter using opamps was first described by Tow (1968). The filter shown in the schematic below has low pass (LP), high pass (HP) and band pass (BP) outputs. For certain combinations of resistors and capacitors, the natural frequency and Q of filter can be independently determined. All the element values are assigned a value of 1, since they will be assigned as part of the filter design process.\n\nThe net list for the filter is:\n* state_variable_filter.asc\nR3 3 1 1\nR6 6 4 1\nR7 8 7 1\nR5 4 3 1\nR2 7 5 1\nC1 7 6 1\nC2 2 8 1\nO1 3 5 4 \nO2 6 0 7 \nV1 1 0 1\nO3 8 0 2 \nR1 5 0 1\nR4 2 3 1\nThe following network equations were generated with the MNA code:\n\\(I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}} = 0\\)\n\\(- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}} = 0\\)\n\\(v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}} = 0\\)\n\\(I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}} = 0\\)\n\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}} = 0\\)\n\\(- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}} = 0\\)\n\\(- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}} = 0\\)\n\\(- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(v_{3} - v_{5} = 0\\)\n\\(v_{6} = 0\\)\n\\(v_{8} = 0\\)\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\ninit_printing()\n\nCopy the text strings generated by the Symbolic Modified Nodal Analysis Jupyter notebook to the cell below.\n\nv3, C1, R4, I_O1, R3, I_O2, I_V1, R2, v4, R6, R5, v5, V1, v2, v1, v6, s, v7, I_O3, C2, v8, R1, R7 = symbols(' v3  C1  R4  I_O1  R3  I_O2  I_V1  R2  v4  R6  R5  v5  V1  v2  v1  v6  s  v7  I_O3  C2  v8  R1  R7 ')\nA = Matrix([[1/R3, 0, -1/R3, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, C2*s + 1/R4, -1/R4, 0, 0, 0, 0, -C2*s, 0, 0, 0, 1], [-1/R3, -1/R4, 1/R5 + 1/R4 + 1/R3, -1/R5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, -1/R5, 1/R6 + 1/R5, 0, -1/R6, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1/R2 + 1/R1, 0, -1/R2, 0, 0, 0, 0, 0], [0, 0, 0, -1/R6, 0, C1*s + 1/R6, -C1*s, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1/R2, -C1*s, C1*s + 1/R7 + 1/R2, -1/R7, 0, 0, 1, 0], [0, -C2*s, 0, 0, 0, 0, -1/R7, C2*s + 1/R7, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]])\nX = Matrix( [v1, v2, v3, v4, v5, v6, v7, v8, I_V1, I_O1, I_O2, I_O3] )\nZ = Matrix( [0, 0, 0, 0, 0, 0, 0, 0, V1, 0, 0, 0] )\n\nequ = Eq(A*X,Z)\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}}\\\\- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}}\\\\v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}}\\\\I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}}\\\\- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}}\\\\- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}}\\\\- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}}\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nTakes about 50 seconds to solve\ni3-8130U CPU @ 2.20GHz\n\nU_sym = solve(equ,X)\n\nThe symbolic solution to the network equations:\n\nU_sym\n\n\\(\\displaystyle \\left\\{ I_{O1} : \\frac{C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{2} R_{1} R_{4} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  I_{O2} : \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{5} V_{1} s - C_{2} R_{2} R_{4} R_{5} V_{1} s - C_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  I_{O3} : \\frac{C_{2} R_{1} R_{4} R_{5} V_{1} s + C_{2} R_{1} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} V_{1} s + R_{1} R_{5} V_{1} + R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  I_{V1} : \\frac{- C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{7} V_{1} s - C_{2} R_{1} R_{5} R_{7} V_{1} s - R_{1} R_{5} V_{1} - R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{- R_{1} R_{4} R_{5} V_{1} - R_{2} R_{4} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{3} : \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{4} : \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{5} : \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{6} : 0, \\  v_{7} : \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{8} : 0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#low-pass",
    "href": "State-variable-filter.html#low-pass",
    "title": "23  State Variable Filter",
    "section": "23.2 Low Pass",
    "text": "23.2 Low Pass\nThe low pass transfer function.\n\nH_sym_lp = cancel(U_sym[v2]/V1,s)\nH_sym_lp\n\n\\(\\displaystyle \\frac{- R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}}{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)}\\)\n\n\n\nsym_num, sym_denom = fraction(H_sym_lp,s) #returns numerator and denominator\n\n\nsym_num\n\n\\(\\displaystyle - R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}\\)\n\n\n\n23.2.1 Characteristic equation\n\nsym_denom\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)\\)\n\n\nGet the coefficients of the Laplace variable, s, from the quadratic equation:\n\\(as^{2}+bs+c=0\\)\n\na = sym_denom.coeff(s**2)\na\n\n\\(\\displaystyle C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\)\n\n\n\nb = sym_denom.coeff(s)\nb\n\n\\(\\displaystyle C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\)\n\n\nTo find the c coefficient just subract off \\(bs\\) and \\(cs^2\\) from the quadratic equation.\n\nc = sym_denom - b*s - a*s**2\nc\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#natural-frequency-and-q-factor",
    "href": "State-variable-filter.html#natural-frequency-and-q-factor",
    "title": "23  State Variable Filter",
    "section": "23.3 Natural frequency and Q factor",
    "text": "23.3 Natural frequency and Q factor\nThe expressions for the natural frequency and Q factor are shown below:\n\\(\\omega _n = \\sqrt {\\frac {c}{a}}\\)\n\\(Q = \\omega _n \\frac {a}{b}\\)\nThese xpressions have their orgin in classical mechanics describing harmonic oscillators and are applicable to 2nd order electrical systems.\nThe damping ratio is defined by the equation:\n\\(\\zeta = \\frac {1}{2Q}\\)\n\nomega_n = sqrt(c/a)\nomega_n\n\n\\(\\displaystyle \\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}}\\)\n\n\n\nQ = (a/b)*omega_n\nQ\n\n\\(\\displaystyle \\frac{\\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right)}{C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}}\\)\n\n\nSimply the expressions for Q and \\(\\omega _n\\) by letting R = R1 = R3 = R4 = R5 = R6 = R7 and C = C1 = C2.\n\nR, C = symbols('R C')\n\n\nsimplify = {\n    R1:R,\n    R3:R,\n    R4:R,\n    R5:R,\n    R6:R,\n    R7:R,\n    C1:C,\n    C2:C}\n\n\nomega_n_simp = omega_n.subs(simplify).factor()\nomega_n_simp\n\n\\(\\displaystyle \\sqrt{\\frac{1}{C^{2} R^{2}}}\\)\n\n\n\nQ_simp = Q.subs(simplify).factor()\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nBy inspection Q could be simplified more, because C cancels out, but we will leave it.\nLet C = 0.1\\(\\mu\\)F, solve for R to get a natural frequency of 1kHz.\n\nomega_n_simp = omega_n_simp.subs({C:0.1e-6})\nomega_n_simp\n\n\\(\\displaystyle 10000000.0 \\sqrt{\\frac{1}{R^{2}}}\\)\n\n\n\nRnew = solve(Eq(omega_n_simp,1000*2*np.pi),R)\nRnew\n\n\\(\\displaystyle \\left[ -1591.54943091895, \\  1591.54943091895\\right]\\)\n\n\n\nRnew = float(Rnew[1])\nRnew\n\n\\(\\displaystyle 1591.54943091895\\)\n\n\nWith R and C chosen,\n\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nSubstituting C=0.1\\(\\mu\\)F and R = Rnew into Q_simp\n\nQ_simp = Q_simp.subs({C:0.1e-6,R:Rnew})\nQ_simp\n\n\\(\\displaystyle 0.00020943951023932 R_{2} + 0.333333333333333\\)\n\n\nSolve for R2 for the desired Q=3.\n\nR2new = solve(Eq(Q_simp,3),R2)\nR2new = R2new[0]\nR2new\n\n\\(\\displaystyle 12732.3954473516\\)\n\n\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {\n    V1:1,\n    R3:Rnew,\n    R6:Rnew,\n    R7:Rnew,\n    R5:Rnew,\n    R2:R2new,\n    C1:0.1e-6,\n    C2:0.1e-6,\n    R1:Rnew,\n    R4:Rnew}\n\n\nQ.subs(nominal_component_value)\n\n\\(\\displaystyle 3.0\\)\n\n\n\nomega_n.subs(nominal_component_value)/(2*np.pi)\n\n\\(\\displaystyle 1000.0\\)\n\n\n\ndamping_ratio = 1/(2*Q.subs(nominal_component_value))\ndamping_ratio\n\n\\(\\displaystyle 0.166666666666667\\)\n\n\n\n23.3.1 Numerical solution\n\n# put the element values into the equations\nequ1 = equ.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instead of symbols.\n\nequ1\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.000628318530717959 v_{1} - 0.000628318530717959 v_{3}\\\\I_{O3} - 1.0 \\cdot 10^{-7} s v_{8} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right) - 0.000628318530717959 v_{3}\\\\- 0.000628318530717959 v_{1} - 0.000628318530717959 v_{2} + 0.00188495559215388 v_{3} - 0.000628318530717959 v_{4}\\\\I_{O1} - 0.000628318530717959 v_{3} + 0.00125663706143592 v_{4} - 0.000628318530717959 v_{6}\\\\0.000706858347057704 v_{5} - 7.8539816339745 \\cdot 10^{-5} v_{7}\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000628318530717959 v_{4} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-7} s v_{6} - 7.8539816339745 \\cdot 10^{-5} v_{5} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000706858347057704\\right) - 0.000628318530717959 v_{8}\\\\- 1.0 \\cdot 10^{-7} s v_{2} - 0.000628318530717959 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU = solve(equ1,X)\n\n\n\n23.3.2 Low pass filter transfer function\n\nH_lp = U[v2]/U[v1]\nH_lp.factor()\n\n\\(\\displaystyle - \\frac{1.0}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\nThe SymPy function, factor(), takes a polynomial and factors it into irreducible factors over the rational numbers. Notice that the value is negative, indicating that the filter configuration is inverting.\n\n23.3.2.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_lp_num, H_lp_denom = fraction(H_lp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\nlp_a = np.array(Poly(H_lp_num, s).all_coeffs(), dtype=float)\nlp_b = np.array(Poly(H_lp_denom, s).all_coeffs(), dtype=float)\nlp_sys = signal.TransferFunction(lp_a,lp_b)\n\n\n\n\n23.3.3 High pass filter transfer function\n\nH_hp = U[v4]/U[v1]\nH_hp.factor()\n\n\\(\\displaystyle - \\frac{2.53302959105844 \\cdot 10^{-8} s^{2}}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_hp_num, H_hp_denom = fraction(H_hp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nhp_a = np.array(Poly(H_hp_num, s).all_coeffs(), dtype=float)\nhp_b = np.array(Poly(H_hp_denom, s).all_coeffs(), dtype=float)\nhp_sys = signal.TransferFunction(hp_a,hp_b)\n\n\n\n23.3.4 Band pass filter transfer function\n\nH_bp = U[v7]/U[v1]\nH_bp.factor()\n\n\\(\\displaystyle \\frac{0.000159154943091895 s}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_bp_num, H_bp_denom = fraction(H_bp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nbp_a = np.array(Poly(H_bp_num, s).all_coeffs(), dtype=float)\nbp_b = np.array(Poly(H_bp_denom, s).all_coeffs(), dtype=float)\nbp_sys = signal.TransferFunction(bp_a,bp_b)\n\n\n\n23.3.5 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nlp_sys_zeros = np.roots(lp_sys.num)\nlp_sys_poles = np.roots(lp_sys.den)\n\n\n23.3.5.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(lp_sys_zeros), np.imag(lp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(lp_sys_poles), np.imag(lp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(lp_sys_zeros)))\nfor i in lp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(lp_sys_poles)))\nfor i in lp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-166.67+986.01j Hz\n-166.67-986.01j Hz\n\n\n\n\n\n23.3.6 Stability\nBy inspecting the plot above, we can tell the filter is stable since all the poles of the transfer function are in the left hand plane.\n\n\n23.3.7 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nx_axis_range = np.logspace(2, 4, 5000, endpoint=True)*2*np.pi\nw, lp_mag, lp_phase = lp_sys.bode(w=x_axis_range)\nw, hp_mag, hp_phase = hp_sys.bode(w=x_axis_range)\nw, bp_mag, bp_phase = bp_sys.bode(w=x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# Bode magnitude plot\nplt.semilogx(w/(2*np.pi), lp_mag,'-r')\nplt.semilogx(w/(2*np.pi), hp_mag,'-b')\nplt.semilogx(w/(2*np.pi), bp_mag,'-g')\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k' #'tab:blue'\n\n# Bode phase plot\nplt.semilogx(w/(2*np.pi), lp_phase,':r',label='LP phase')\nplt.semilogx(w/(2*np.pi), hp_phase,':b',label='HP phase')\nplt.semilogx(w/(2*np.pi), bp_phase,':g',label='BP phase')\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='r', label='LP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='b', label='HP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='g', label='BP magnitude')\n\nplt.legend(loc=0)\nplt.title('Filter Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe Bode plot for the preamplifier is plotted from 100 Hz to 1 kHz.\n\n\n23.3.8 Low pass filter impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n23.3.9 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\n#w_preamp, mag_preamp, phase_preamp = bp_sys.bode(w=x_axis_range)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(lp_phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#summary",
    "href": "State-variable-filter.html#summary",
    "title": "23  State Variable Filter",
    "section": "23.4 Summary",
    "text": "23.4 Summary\n\n\n\n\nTow, J. 1968. “Active RC Filters—a State-Space Realization.” Proceedings of the IEEE 56 (6): 1137–39. https://doi.org/10.1109/PROC.1968.6502.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "Superposition.html",
    "href": "Superposition.html",
    "title": "24  Superposition",
    "section": "",
    "text": "24.1 Introduction\nThe circuit shown above is a large non-planar circuit designed to look at the problem of multiple sources with different phases and frequencies.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#circuit-description",
    "href": "Superposition.html#circuit-description",
    "title": "24  Superposition",
    "section": "24.2 Circuit description",
    "text": "24.2 Circuit description\nThe circuit in Figure 24.1 is has 23 branches and 14 nodes. There are two dependent sources. V1 is a voltage source with a DC value of 5 volts and an AC value of 7 volts which has a phase of 135 degrees with a frequency of 3 Hz. I1 is a current source with a DC value of 2 amps and an AC value of 3 amps which has a phase of 300 degrees and a frequency of 7 Hz, as shaown in Table 24.1. There are two dependent sources. H1 is a current controlled voltage source with a gain of 2 and the controlling current is the current through V2. The voltage source V2, set to a value of zero volts, was included in the circuit to provide a monitoring point for the current in R9. The other dependednt source, G1, is a voltage controlled voltage source which has a gain of 2 and is controlled by the votages on nodes 2 and 8. The circuit also has a pair of coupled inductors, two inductors, three capacitors and 11 resistors.\n\n\n\nTable 24.1: Dependent sources\n\n\n\n\n\nsource\nDC\nMagnitude @ angle\nfrequency, Hz\n\n\n\n\nV1\n5\n7 @ 135\n3\n\n\nI1\n2\n3 @ 300\n7",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#circuit-analysis",
    "href": "Superposition.html#circuit-analysis",
    "title": "24  Superposition",
    "section": "24.3 Circuit analysis",
    "text": "24.3 Circuit analysis\nThe MNA technique will be used analyze the circuit using the componet values shown in the schematic since the circuit is too large for meaninful symbolic analysis. The analysis will cover the four areas listed below.\n\nDC operating point with \\(s=j \\omega\\) set to zero and the circuit driven by the DC values of the independent sources.\nAC analysis with V1 having a frequency of 3 Hz and I1 having a frequency of 7 Hz.\nTotal response of the DC and AC sources at the respective frequencies.\n\nThe results obtained from MNA will be compared to those obtained from LTSpice.\nThe netlist generated by LTSpice is listed below:\nV1 6 1 5 AC 7 135\nV2 10 12 0 AC 0 0\nI1 3 4 2 AC 3 300\nL3 11 14 3 Rser=0\nL1 1 5 5 Rser=0\nL4 14 13 2 Rser=0\nL2 4 8 7 Rser=0\nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\nThe following Python modules are used in this analysis.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\nIn electrical engineering, a time invarient sinusudial signals can be represented either by polar or rectangular notation. The function polar converts the polar representation, also called a phasor to rectangular notation and the second function converts rectangular notation to magnitude and phase.\n\ndef polar2rec(mag, ang, units='deg'):\n    ''' polar to rectangular conversion\n        mag: float\n            magnitude of the time invarient sinusudial signal\n        ang: float\n            the angle of the time invarient sinusudial signal\n        units: string\n            if units is set to deg, and is in degrees not radians\n        returns: complex\n            rectangular corrdinates of voltage vector\n    '''\n    if units == 'deg':\n        ang = ang * np.pi / 180\n    return mag * np.exp(1j * ang)\n\ndef rec2polar(value):\n    '''rectangular to polar conversion\n    value: complex float\n        \n    returns:\n        magnitude, phase (in degrees)\n    '''\n    return float(abs(value)), float(arg(value)*180/np.pi)\n\n\n24.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 6 1 5 \nV2 10 12 0 \nI1 3 4 2 \nL3 11 14 3 \nL1 1 5 5 \nL4 14 13 2 \nL2 4 8 7 \nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}} = - I_{1}\\)\\(- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}} = I_{1}\\)\\(- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}} = 0\\)\\(I_{H1} + \\frac{v_{7}}{R_{6}} = 0\\)\\(- I_{L2} + \\frac{v_{8}}{R_{7}} = 0\\)\\(v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}} = 0\\)\\(I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}} = 0\\)\\(I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}} = 0\\)\\(- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}} = 0\\)\\(- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}} = 0\\)\\(- v_{1} + v_{6} = V_{1}\\)\\(v_{10} - v_{12} = V_{2}\\)\\(- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14} = 0\\)\\(- I_{L2} L_{2} s + v_{4} - v_{8} = 0\\)\\(- I_{V2} h_{1} - v_{3} + v_{7} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}}\\\\- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}}\\\\- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}}\\\\I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\I_{H1} + \\frac{v_{7}}{R_{6}}\\\\- I_{L2} + \\frac{v_{8}}{R_{7}}\\\\v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}}\\\\I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}}\\\\I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}}\\\\- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}}\\\\- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right)\\\\- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14}\\\\- I_{L1} L_{1} s + v_{1} - v_{5}\\\\- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14}\\\\- I_{L2} L_{2} s + v_{4} - v_{8}\\\\- I_{V2} h_{1} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{1}\\\\I_{1}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{1}, \\  I_{H1}, \\  v_{10}, \\  v_{8}, \\  v_{1}, \\  R_{11}, \\  C_{2}, \\  R_{1}, \\  M_{1}, \\  v_{5}, \\  C_{3}, \\  g_{1}, \\  I_{L2}, \\  R_{10}, \\  I_{V2}, \\  v_{7}, \\  I_{L1}, \\  R_{7}, \\  v_{11}, \\  L_{1}, \\  R_{4}, \\  v_{9}, \\  L_{3}, \\  v_{3}, \\  R_{9}, \\  v_{13}, \\  v_{12}, \\  R_{5}, \\  s, \\  I_{L3}, \\  R_{8}, \\  C_{1}, \\  R_{2}, \\  I_{V1}, \\  V_{1}, \\  v_{4}, \\  h_{1}, \\  L_{2}, \\  V_{2}, \\  R_{3}, \\  v_{6}, \\  I_{L4}, \\  v_{2}, \\  R_{6}, \\  v_{14}, \\  L_{4}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#dc-operating-point",
    "href": "Superposition.html#dc-operating-point",
    "title": "24  Superposition",
    "section": "24.4 DC operating point",
    "text": "24.4 DC operating point\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\nK1 = symbols('K1')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.979795897\n\n\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + 0.01 v_{1} - 0.01 v_{2}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.05 v_{12} + 0.0633333333333333 v_{3} - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.0133333333333333 v_{3} + 0.0133333333333333 v_{4}\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + 0.15 v_{12} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\v_{11} - v_{14}\\\\v_{1} - v_{5}\\\\- v_{13} + v_{14}\\\\v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_dc = solve(NE_dc,X)\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown             mag\n---------  ------------\nv1         -1444.606764\nv2           701.805800\nv3           626.530983\nv4           564.749806\nv5         -1444.606764\nv6         -1439.606764\nv7           583.602732\nv8           564.749806\nv9         -1449.580366\nv10          916.447056\nv11        -1465.073530\nv12          916.447056\nv13        -1465.073530\nv14        -1465.073530\nI_V1          -0.997360\nI_V2         -21.464126\nI_L3          15.493164\nI_L1          20.466765\nI_L4           0.000000\nI_L2           2.823749\nI_H1         -11.672055\n\n\nLTSpice results:\n       --- Operating Point ---\n\nV(6):    -1439.61    voltage\nV(1):    -1444.61    voltage\nV(10):   916.447     voltage\nV(12):   916.447     voltage\nV(3):    626.531     voltage\nV(4):    564.75  voltage\nV(11):   -1465.07    voltage\nV(14):   -1465.07    voltage\nV(5):    -1444.61    voltage\nV(13):   -1465.07    voltage\nV(8):    564.75  voltage\nV(7):    583.603     voltage\nV(2):    701.806     voltage\nV(9):    -1449.58    voltage\nI(C1):   4.72012e-11     device_current\nI(C2):   1.71378e-11     device_current\nI(C3):   -3.015e-11  device_current\nI(H1):   -11.6721    device_current\nI(L3):   15.4932     device_current\nI(L1):   20.4668     device_current\nI(L4):   -4.72875e-11    device_current\nI(L2):   2.82375     device_current\nI(I1):   2   device_current\nI(R9):   -21.4641    device_current\nI(R6):   11.6721     device_current\nI(R4):   20.4668     device_current\nI(R1):   -21.4641    device_current\nI(R3):   0.823749    device_current\nI(R7):   -2.82375    device_current\nI(R11):  -238.152    device_current\nI(R5):   0.99736     device_current\nI(R10):  15.4932     device_current\nI(R8):   -14.4958    device_current\nI(R2):   -14.4958    device_current\nI(G1):   -274.112    device_current\nI(V1):   -0.99736    device_current\nI(V2):   -21.4641    device_current\nStore the results in a Pandas dataframe.\n\nsolutions = pd.DataFrame(U_dc.items(), columns=['unk', 'w=DC'])\nsolutions = solutions.set_index('unk')\nsolutions['w=DC'] = solutions['w=DC'].astype(float)\n#solutions",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#independent-sources-each-with-a-different-frequency",
    "href": "Superposition.html#independent-sources-each-with-a-different-frequency",
    "title": "24  Superposition",
    "section": "24.5 Independent sources each with a different frequency",
    "text": "24.5 Independent sources each with a different frequency\nThe independent sources V1 and I1 each have different amplitudes, phases and frequencies. First we will solve the network equations for when V1 is active and I1 is set to zero. The following code set I1 to zero and calls the function polar2rec to convert the amplitude and phase to rectangular notation.\n\nelement_values[I1] = 0\nelement_values[V1] = polar2rec(7, 135, units='deg')\n\nSolve equations for \\(\\omega\\) equal to 3 Hz. The value for \\(\\omega\\) is calculated by: \\(\\omega = 2 \\pi 3\\), then use the substitute function to set \\(s = 2 \\pi 3j\\). Then display the network equations with numerical values.\n\nomega = 2*np.pi*3\nNE_w1 = NE_sym.subs(element_values)\nNE_w1 = NE_w1.subs({s:omega*1j})\nNE_w1\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 0.429581379451868 i\\right) - 0.01 v_{2} - 0.429581379451868 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.429581379451868 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 0.429581379451868 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.159146800645552 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.159146800645552 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.238635377966681 i\\right) - 0.238635377966681 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.238635377966681 i v_{12} + 0.397782178612232 i v_{13} - 0.159146800645552 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 56.5486677646163 i I_{L3} - 18.4687175543308 i I_{L4} + v_{11} - v_{14}\\\\- 94.2477796076938 i I_{L1} + v_{1} - v_{5}\\\\- 18.4687175543308 i I_{L3} - 37.6991118430775 i I_{L4} - v_{13} + v_{14}\\\\- 131.946891450771 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\-4.94974746830583 + 4.94974746830583 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_w1 = solve(NE_w1,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.214165    -42.658172\nv2         5.054599     39.141345\nv3         1.983213    -32.248064\nv4         5.501867     67.083943\nv5         7.598113    -22.913101\nv6         5.787062    134.508799\nv7         1.977375    -35.152486\nv8         4.592470     33.669731\nv9         5.241567    168.957875\nv10        5.544043     40.383410\nv11        5.350944    172.465292\nv12        5.544043     40.383410\nv13        5.619390     60.869229\nv14        7.602773    -23.429285\nI_V1       0.330707   -109.201912\nI_V2       0.050272   -127.028107\nI_L3       0.342104     62.074687\nI_L1       0.068631     70.722730\nI_L4       0.389029   -137.950576\nI_L2       0.022962     33.669731\nI_H1       0.039547    144.847514\n\n\nThe results from LTSpice as shown below and they agree with the Python results. The DC values for the sources, V1 and I1, are set to zero.\n       --- AC Analysis ---\n\nfrequency:  3   Hz\nV(6):   mag:    5.78706 phase:    134.509°  voltage\nV(1):   mag:    1.21416 phase:   -42.6582°  voltage\nV(10):  mag:    5.54404 phase:    40.3834°  voltage\nV(12):  mag:    5.54404 phase:    40.3834°  voltage\nV(3):   mag:    1.98321 phase:   -32.2481°  voltage\nV(4):   mag:    5.50187 phase:    67.0839°  voltage\nV(11):  mag:    5.35094 phase:    172.465°  voltage\nV(14):  mag:    7.60277 phase:   -23.4293°  voltage\nV(5):   mag:    7.59811 phase:   -22.9131°  voltage\nV(13):  mag:    5.61939 phase:    60.8692°  voltage\nV(8):   mag:    4.59247 phase:    33.6697°  voltage\nV(7):   mag:    1.97737 phase:   -35.1525°  voltage\nV(2):   mag:     5.0546 phase:    39.1413°  voltage\nV(9):   mag:    5.24157 phase:    168.958°  voltage\nI(C1):  mag:   0.351813 phase:    73.2905°  device_current\nI(C2):  mag:  0.0977425 phase:   -105.008°  device_current\nI(C3):  mag:   0.474046 phase:   -131.513°  device_current\nI(H1):  mag:  0.0395475 phase:    144.848°  device_current\nI(L3):  mag:   0.342104 phase:    62.0747°  device_current\nI(L1):  mag:  0.0686314 phase:    70.7227°  device_current\nI(L4):  mag:   0.389029 phase:   -137.951°  device_current\nI(L2):  mag:  0.0229624 phase:    33.6697°  device_current\nI(I1):  mag:          0 phase:         -0°  device_current\nI(R9):  mag:  0.0502717 phase:   -127.028°  device_current\nI(R6):  mag:  0.0395475 phase:   -35.1525°  device_current\nI(R4):  mag:  0.0686314 phase:    70.7227°  device_current\nI(R1):  mag:  0.0502717 phase:   -127.028°  device_current\nI(R3):  mag:  0.0819131 phase:   -94.3412°  device_current\nI(R7):  mag:  0.0229624 phase:    -146.33°  device_current\nI(R11): mag:   0.716494 phase:   -67.4048°  device_current\nI(R5):  mag:   0.330707 phase:    70.7981°  device_current\nI(R10): mag:   0.342104 phase:    62.0747°  device_current\nI(R8):  mag:  0.0524157 phase:    168.958°  device_current\nI(R2):  mag:   0.265071 phase:   -118.698°  device_current\nI(G1):  mag:      1.304 phase:   -98.6653°  device_current\nI(V1):  mag:   0.330707 phase:   -109.202°  device_current\nI(V2):  mag:  0.0502717 phase:   -127.028°  device_current\n\nw1 = pd.DataFrame(U_w1.items(), columns=['unk', 'w=3Hz'])\nw1 = w1.set_index('unk')\nw1['w=3Hz'] = w1['w=3Hz'].astype(complex)\nsolutions['w=3Hz'] = w1['w=3Hz']\n#solutions\n\nSolve the network equations with V1 set to zero and I1 active with a frequency of 7 Hz, an amplitude of 3 at a phase angle of 300.\n\nelement_values[I1] = polar2rec(3, 300, units='deg')\nelement_values[V1] = 0 #polar2rec(7, 135, units='deg')\n\nSolve equations for \\(\\omega\\) equal to 3 Hz. The value for \\(\\omega\\) is calculated by: \\(\\omega = 2 \\pi 7\\)\n\nomega = 2*np.pi*7\nNE_w2 = NE_sym.subs(element_values)\nNE_w2 = NE_w2.subs({s:omega*1j})\nNE_w2\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 1.00235655205436 i\\right) - 0.01 v_{2} - 1.00235655205436 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 1.00235655205436 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 1.00235655205436 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.371342534839621 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.371342534839621 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.556815881922255 i\\right) - 0.556815881922255 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.556815881922255 i v_{12} + 0.928158416761876 i v_{13} - 0.371342534839621 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 131.946891450771 i I_{L3} - 43.0936742934386 i I_{L4} + v_{11} - v_{14}\\\\- 219.911485751286 i I_{L1} + v_{1} - v_{5}\\\\- 43.0936742934386 i I_{L3} - 87.9645943005142 i I_{L4} - v_{13} + v_{14}\\\\- 307.8760800518 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-1.5 + 2.59807621135332 i\\\\1.5 - 2.59807621135332 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_w2 = solve(NE_w2,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w2.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown           mag    phase, deg\n---------  ----------  ------------\nv1           9.005916    163.707427\nv2          32.516027    143.867055\nv3           7.786210    133.896662\nv4          47.805605    173.317623\nv5         269.759059     42.448864\nv6           9.005916    163.707427\nv7           7.302031    133.715779\nv8          26.042563    116.325861\nv9          27.308899    -54.477160\nv10         34.921833    143.365554\nv11         31.025759    -53.448958\nv12         34.921833    143.365554\nv13         41.722434    164.330384\nv14        269.726939     42.183778\nI_V1         3.483553    -45.280685\nI_V2         0.242382    -43.377657\nI_L3         3.753386    134.053052\nI_L1         1.248412    130.841984\nI_L4         5.167787    -51.606488\nI_L2         0.130213    116.325861\nI_H1         0.146041    -46.284221\n\n\nThe results from LTSpice as shown below and they agree with the Python results.\n       --- AC Analysis ---\n\nfrequency:  7   Hz\nV(6):   mag:    9.00592 phase:    163.707°  voltage\nV(1):   mag:    9.00592 phase:    163.707°  voltage\nV(10):  mag:    34.9218 phase:    143.366°  voltage\nV(12):  mag:    34.9218 phase:    143.366°  voltage\nV(3):   mag:    7.78621 phase:    133.897°  voltage\nV(4):   mag:    47.8056 phase:    173.318°  voltage\nV(11):  mag:    31.0258 phase:    -53.449°  voltage\nV(14):  mag:    269.727 phase:    42.1838°  voltage\nV(5):   mag:    269.759 phase:    42.4489°  voltage\nV(13):  mag:    41.7224 phase:     164.33°  voltage\nV(8):   mag:    26.0426 phase:    116.326°  voltage\nV(7):   mag:    7.30203 phase:    133.716°  voltage\nV(2):   mag:     32.516 phase:    143.867°  voltage\nV(9):   mag:    27.3089 phase:   -54.4772°  voltage\nI(C1):  mag:    4.48781 phase:    133.539°  device_current\nI(C2):  mag:    3.44327 phase:   -52.0221°  device_current\nI(C3):  mag:      8.611 phase:   -51.7727°  device_current\nI(H1):  mag:   0.146041 phase:   -46.2842°  device_current\nI(L3):  mag:    3.75339 phase:    134.053°  device_current\nI(L1):  mag:    1.24841 phase:    130.842°  device_current\nI(L4):  mag:    5.16779 phase:   -51.6065°  device_current\nI(L2):  mag:   0.130213 phase:    116.326°  device_current\nI(I1):  mag:          3 phase:        -60°  device_current\nI(R9):  mag:   0.242382 phase:   -43.3777°  device_current\nI(R6):  mag:   0.146041 phase:    133.716°  device_current\nI(R4):  mag:    1.24841 phase:    130.842°  device_current\nI(R1):  mag:   0.242382 phase:   -43.3777°  device_current\nI(R3):  mag:   0.561096 phase:  0.0650338°  device_current\nI(R7):  mag:   0.130213 phase:   -63.6741°  device_current\nI(R11): mag:    27.8613 phase:    35.1207°  device_current\nI(R5):  mag:    3.48355 phase:    134.719°  device_current\nI(R10): mag:    3.75339 phase:    134.053°  device_current\nI(R8):  mag:   0.273089 phase:   -54.4772°  device_current\nI(R2):  mag:    1.36359 phase:   -33.9423°  device_current\nI(G1):  mag:    30.5828 phase:     15.818°  device_current\nI(V1):  mag:    3.48355 phase:   -45.2807°  device_current\nI(V2):  mag:   0.242382 phase:   -43.3777°  device_current\nStore the Python results in a dataframe.\n\nw2 = pd.DataFrame(U_w2.items(), columns=['unk', 'w=7Hz'])\nw2 = w2.set_index('unk')\nw2['w=7Hz'] = w2['w=7Hz'].astype(complex)\nsolutions['w=7Hz'] = w2['w=7Hz']\n#solutions\n\n\n24.5.1 Superposition solution\nUsing the principle of superposition, we can add the results obtained above to get the solution for the unknown node voltages and inductor and source currents.\n\nsolutions['w1+w2'] = solutions['w=3Hz'] + solutions['w=7Hz']\nsolutions['dc+w1+w2'] = solutions['w1+w2'] + solutions['w=DC']\nsolutions\n\n\n\n\n\n\n\n\nw=DC\nw=3Hz\nw=7Hz\nw1+w2\ndc+w1+w2\n\n\nunk\n\n\n\n\n\n\n\n\n\nv1\n-1444.606764\n0.892908-0.822746j\n-8.64425300+2.52654000j\n-7.75134500+1.70379400j\n-1452.3581009+1.7037940j\n\n\nv2\n701.805800\n3.920302+3.190643j\n-26.2616000+19.1734280j\n-22.3412980+22.3640710j\n679.4645010+22.3640710j\n\n\nv3\n626.530983\n1.677294-1.058215j\n-5.39864500+5.61067700j\n-3.72135100+4.55246200j\n622.8096302+4.5524620j\n\n\nv4\n564.749806\n2.142328+5.067639j\n-47.4808370+5.5629110j\n-45.3385090+10.6305500j\n519.4112970+10.6305500j\n\n\nv5\n-1444.606764\n6.998594-2.958208j\n199.049815+182.069001j\n206.048410+179.110793j\n-1238.558355+179.110793j\n\n\nv6\n-1439.606764\n-4.056839+4.127001j\n-8.64425300+2.52654000j\n-12.7010930+6.6535420j\n-1452.3078507+6.6535420j\n\n\nv7\n583.602732\n1.616746-1.138482j\n-5.04629800+5.27773900j\n-3.42955200+4.13925700j\n580.1731709+4.1392570j\n\n\nv8\n564.749806\n3.822070+2.546088j\n-11.5492460+23.3415940j\n-7.727175+025.8876810j\n557.0226300+25.8876810j\n\n\nv9\n-1449.580366\n-5.144528+1.003921j\n15.8672200-22.2262750j\n10.7226920-21.2223540j\n-1438.857674-21.222354j\n\n\nv10\n916.447056\n4.223041+3.591982j\n-28.0233350+20.8381170j\n-23.8002940+24.4300990j\n892.6467620+24.4300990j\n\n\nv11\n-1465.073530\n-5.304742+0.701652j\n18.4770390-24.9238190j\n13.1722970-24.2221670j\n-1451.901233-24.222167j\n\n\nv12\n916.447056\n4.223041+3.591982j\n-28.0233350+20.8381170j\n-23.8002940+24.4300990j\n892.6467620+24.4300990j\n\n\nv13\n-1465.073530\n2.735545+4.908599j\n-40.1718250+11.2688080j\n-37.4362800+16.1774060j\n-1502.509810+16.177406j\n\n\nv14\n-1465.073530\n6.975936-3.022991j\n199.866246+181.124557j\n206.842182+178.101566j\n-1258.231348+178.101566j\n\n\nI_V1\n-0.997360\n-0.108769-0.312308j\n2.45114700-2.47528100j\n2.34237800-2.78759000j\n1.34501800-2.78759000j\n\n\nI_V2\n-21.464126\n-0.030274-0.040134j\n0.17617300-0.16646900j\n0.14590000-0.20660300j\n-21.31822600-0.20660300j\n\n\nI_L3\n15.493164\n0.160214+0.302269j\n-2.60981900+2.69754400j\n-2.44960500+2.99981300j\n13.04355800+2.99981300j\n\n\nI_L1\n20.466765\n0.022658+0.064783j\n-0.81643100+0.94444400j\n-0.79377300+1.00922700j\n19.67299300+1.00922700j\n\n\nI_L4\n0.000000\n-0.288881-0.260561j\n3.20950100-4.05032500j\n2.92062100-4.31088500j\n2.92062100-4.31088500j\n\n\nI_L2\n2.823749\n0.019110+0.012730j\n-0.05774600+0.11670800j\n-0.03863600+0.12943800j\n2.78511300+0.12943800j\n\n\nI_H1\n-11.672055\n-0.032335+0.022770j\n0.10092600-0.10555500j\n0.06859100-0.08278500j\n-11.60346400-0.08278500j\n\n\n\n\n\n\n\nDisplay the superposition results in polar form.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in solutions['dc+w1+w2'].items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown            mag    phase, deg\n---------  -----------  ------------\nv1         1452.359109    179.932785\nv2          679.832450      1.885168\nv3          622.826270      0.418799\nv4          519.520071      1.172482\nv5         1251.442158    171.771369\nv6         1452.323098    179.737509\nv7          580.187945      0.408771\nv8          557.623872      2.660912\nv9         1439.014175   -179.154980\nv10         892.981003      1.567689\nv11        1452.103269   -179.044219\nv12         892.981003      1.567689\nv13        1502.596898    179.383125\nv14        1270.773895    171.943355\nI_V1          3.095114    -64.242586\nI_V2         21.319227   -179.444743\nI_L3         13.384069     12.951908\nI_L1         19.698863      2.936707\nI_L4          5.207087    -55.882399\nI_L2          2.788119      2.660912\nI_H1         11.603759   -179.591229",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#summary",
    "href": "Superposition.html#summary",
    "title": "24  Superposition",
    "section": "24.6 Summary",
    "text": "24.6 Summary\nIn this notebook a large non-planar circuit having independent sources with different DC values, different AC amplitudes, phases and frequencies was analyzed. The results were summed to obtain a total solution by applying the superposition thereom.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html",
    "href": "2nd_order_BRF.html",
    "title": "25  2nd Order BRF",
    "section": "",
    "text": "Abstract",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#introduction",
    "href": "2nd_order_BRF.html#introduction",
    "title": "25  2nd Order BRF",
    "section": "25.1 Introduction",
    "text": "25.1 Introduction\nThis notebook walks through the Python code used to generate and solve the circuit network equations. The example starts with a net list for the circuit shown below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#circuit-description",
    "href": "2nd_order_BRF.html#circuit-description",
    "title": "25  2nd Order BRF",
    "section": "25.2 Circuit description",
    "text": "25.2 Circuit description\nThe circuit below is a 2nd order band reject filter, problem 13-20 from Budak (1974). The schematic of the circuit is shown below with each node explicity annotated. The problem asks to obtain: \\(\\frac {V_o} {V_i}\\), which according to the way I have labled the nodes, is \\(\\frac {V_2} {V_1}\\).\n\nThe net list for this circuit is:\n* 2nd order BRF\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\nReference:\n1. Aram Budak, Passive and Active Network Analysis and Synthesis, Houghton Mifflin Comp. 1974\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#load-the-net-list",
    "href": "2nd_order_BRF.html#load-the-net-list",
    "title": "25  2nd Order BRF",
    "section": "25.3 Load the net list",
    "text": "25.3 Load the net list\nindependent sources have their values set to the DC value.\n\nexample_net_list = '''\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\n'''\n\n\nreport, df, df2, A, X, Z = SymMNA.smna(example_net_list)\n\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 8\nnumber of branches: 7\nnumber of nodes: 5\nnumber of unknown currents: 2\nnumber of RLC (passive components): 6\nnumber of inductors: 0\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 1\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\\\I_{V1}\\\\I_{O1}\\end{matrix}\\right]\\)\n\n\n\nZ\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\n\nequ = Eq(A*X,Z)\n\n\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{4} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}}\\\\I_{O1} + \\frac{v_{2}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\\\v_{3} \\left(C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\- C_{1} s v_{1} - C_{2} s v_{5} + v_{4} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  v_{4}, \\  v_{5}, \\  v_{2}, \\  I_{O1}, \\  V_{1}, \\  R_{2}, \\  R_{1}, \\  C_{3}, \\  I_{V1}, \\  R_{3}, \\  v_{1}, \\  C_{1}, \\  C_{2}, \\  v_{3}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#symbolic-mna-code",
    "href": "2nd_order_BRF.html#symbolic-mna-code",
    "title": "25  2nd Order BRF",
    "section": "25.4 Symbolic MNA code",
    "text": "25.4 Symbolic MNA code\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#read-the-net-list-and-preprocess-it",
    "href": "2nd_order_BRF.html#read-the-net-list-and-preprocess-it",
    "title": "25  2nd Order BRF",
    "section": "25.5 Read the net list and preprocess it",
    "text": "25.5 Read the net list and preprocess it\nThe following steps are performed:\n\nremove blank lines and comments\n\nconvert first letter of element name to upper case\n\nremoves extra spaces between entries\n\ncount number of entries on each line, make sure the count is correct, count each element type\n\n\nexample_net_list = '''O1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1'''\n\n\ncontent = example_net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove spice directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\nfor i in content:\n    print(i)\n\nO1 2 5 2\nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\n\n\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#parser",
    "href": "2nd_order_BRF.html#parser",
    "title": "25  2nd Order BRF",
    "section": "25.6 Parser",
    "text": "25.6 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTspice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: opamp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n25.6.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n25.6.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n# Check for position of voltages sources in the dataframe.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # re-order the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#print-net-list-report",
    "href": "2nd_order_BRF.html#print-net-list-report",
    "title": "25  2nd Order BRF",
    "section": "25.7 Print net list report",
    "text": "25.7 Print net list report\n\n# print a report\nprint('Net list report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNet list report\nnumber of lines in netlist: 8\nnumber of branches: 7\nnumber of nodes: 5\nnumber of unknown currents: 2\nnumber of RLC (passive components): 6\nnumber of inductors: 0\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 1\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\ndf\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nO1\n2\n5\nNaN\nNaN\n2\nNaN\nNaN\nNaN\nNaN\n\n\n2\nC3\n3\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nC1\n4\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n4\nC2\n5\n4\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n5\nR1\n2\n4\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n6\nR2\n3\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n7\nR3\n5\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nO1\n2\n5\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed\n\n\n# initialize some symbolic matrix with zeros\n# A is formed by [[G, C] [B, D]]\n# Z = [I,E]\n# X = [V, J]\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\n\n25.7.0.1 some debugging notes:\nIs it possible to have i_unk == 0 ?, what about a network with only current sources? This would make B = 0 for example. Did one test, need to run others\nIs there a valid op amp case where B is n by 1?",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#g-matrix",
    "href": "2nd_order_BRF.html#g-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.8 G matrix",
    "text": "25.8 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & - C_{1} s & 0\\\\0 & \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0\\\\- \\frac{1}{R_{2}} & 0 & C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{3}}\\\\- C_{1} s & - \\frac{1}{R_{1}} & 0 & C_{1} s + C_{2} s + \\frac{1}{R_{1}} & - C_{2} s\\\\0 & 0 & - \\frac{1}{R_{3}} & - C_{2} s & C_{2} s + \\frac{1}{R_{3}}\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#b-matrix",
    "href": "2nd_order_BRF.html#b-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.9 B Matrix",
    "text": "25.9 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The code loop through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0\\\\0 & 1\\\\0 & 0\\\\0 & 0\\\\0 & 0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#c-matrix",
    "href": "2nd_order_BRF.html#c-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.10 C matrix",
    "text": "25.10 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\n25.10.1 Op Amp elements\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results likely will be erroneous.\nReferences use in the debugging of the opamp stamp:\n\nDesign of Analog Circuits Through Symbolic Analysis, edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fernández\n\nComputer Aided Design and Design Automation, edited by Wai-Kai Chen\n\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & -1\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#d-matrix",
    "href": "2nd_order_BRF.html#d-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.11 D matrix",
    "text": "25.11 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n&gt; m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes:\nCan the K statement be anywhere in the net list, even before Lx and Ly?\n12/6/2017 doing some debugging on with coupled inductors\nLTspice seems to put the phasing dot on the neg node when it generates the netlist\nThis code uses M for mutual inductance, LTspice uses k for the coupling coefficient.\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0\\\\0 & 0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#v-matrix",
    "href": "2nd_order_BRF.html#v-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.12 V matrix",
    "text": "25.12 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#j-matrix",
    "href": "2nd_order_BRF.html#j-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.13 J matrix",
    "text": "25.13 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{O1}\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#i-matrix",
    "href": "2nd_order_BRF.html#i-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.14 I matrix",
    "text": "25.14 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#ev-matrix",
    "href": "2nd_order_BRF.html#ev-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.15 Ev matrix",
    "text": "25.15 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#z-matrix",
    "href": "2nd_order_BRF.html#z-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.16 Z matrix",
    "text": "25.16 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#x-matrix",
    "href": "2nd_order_BRF.html#x-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.17 X matrix",
    "text": "25.17 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{O1}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#a-matrix",
    "href": "2nd_order_BRF.html#a-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.18 A matrix",
    "text": "25.18 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n    A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & - C_{1} s & 0 & 1 & 0\\\\0 & \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1\\\\- \\frac{1}{R_{2}} & 0 & C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{3}} & 0 & 0\\\\- C_{1} s & - \\frac{1}{R_{1}} & 0 & C_{1} s + C_{2} s + \\frac{1}{R_{1}} & - C_{2} s & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{3}} & - C_{2} s & C_{2} s + \\frac{1}{R_{3}} & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & -1 & 0 & 0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#generate-the-circuit-equations",
    "href": "2nd_order_BRF.html#generate-the-circuit-equations",
    "title": "25  2nd Order BRF",
    "section": "25.19 generate the circuit equations",
    "text": "25.19 generate the circuit equations\n\nequ = Eq(A*Matrix(X),Matrix(Z))\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{4} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}}\\\\I_{O1} + \\frac{v_{2}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\\\v_{3} \\left(C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\- C_{1} s v_{1} - C_{2} s v_{5} + v_{4} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#symbolic-solution",
    "href": "2nd_order_BRF.html#symbolic-solution",
    "title": "25  2nd Order BRF",
    "section": "25.20 Symbolic solution",
    "text": "25.20 Symbolic solution\n\nv1, v2, v3, v4, v5, I_V1, I_O = symbols('v1 v2 v3 v4 v5 I_V1 I_O')\n\n\nsymbolic_solution = solve(equ,X)\n\n\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{O1} : \\frac{C_{1} C_{3} R_{2} V_{1} s^{2}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  I_{V1} : \\frac{- C_{1} C_{2} C_{3} R_{1} R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} V_{1} s^{3} - C_{1} C_{3} R_{1} V_{1} s^{2} - C_{1} C_{3} R_{2} V_{1} s^{2} - C_{2} C_{3} R_{1} V_{1} s^{2} - C_{3} V_{1} s}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{3} : \\frac{C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{4} : \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} C_{3} R_{1} R_{2} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{5} : \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\right\\}\\)\n\n\nThe symbolic solution for \\(\\frac {V_o}{V_i}\\):\n\n(symbolic_solution[v2]/symbolic_solution[v1]).factor()\n\n\\(\\displaystyle \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + 1}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\n\n\nBuilt a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:f},'.format(df.iloc[i]['element'].lower(),df.iloc[i]['value']))\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:.4e},'.format(df.iloc[i]['element'],df.iloc[i]['value']))\n\nelement_values = dict(zip(element_value_keys, element_value_values))",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#numeric-solution",
    "href": "2nd_order_BRF.html#numeric-solution",
    "title": "25  2nd Order BRF",
    "section": "25.21 Numeric solution",
    "text": "25.21 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ1a = equ.subs(element_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 1.0 s v_{4} + v_{1} \\cdot \\left(1.0 s + 1.0\\right) - 1.0 v_{3}\\\\I_{O1} + 2.0 v_{2} - 2.0 v_{4}\\\\- 1.0 v_{1} + v_{3} \\cdot \\left(2.0 s + 2.0\\right) - 1.0 v_{5}\\\\- 1.0 s v_{1} - 1.0 s v_{5} - 2.0 v_{2} + v_{4} \\cdot \\left(2.0 s + 2.0\\right)\\\\- 1.0 s v_{4} - 1.0 v_{3} + v_{5} \\cdot \\left(1.0 s + 1.0\\right)\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{O1} : \\frac{2.0 s^{2}}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}, \\  I_{V1} : - \\frac{2.0 s}{s + 1.0}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}, \\  v_{3} : \\frac{s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}, \\  v_{4} : \\frac{s^{3} + 2.0 s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}, \\  v_{5} : \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#ac-analysis",
    "href": "2nd_order_BRF.html#ac-analysis",
    "title": "25  2nd Order BRF",
    "section": "25.22 AC analysis",
    "text": "25.22 AC analysis\nSolve the equations at a frequency of 0.159154 mHz or \\(\\omega\\) equal to 1 radians per second, s = 1.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(1.0 + 1.0 i\\right) - 1.0 v_{3} - 1.0 i v_{4}\\\\I_{O1} + 2.0 v_{2} - 2.0 v_{4}\\\\- 1.0 v_{1} + v_{3} \\cdot \\left(2.0 + 2.0 i\\right) - 1.0 v_{5}\\\\- 1.0 i v_{1} - 2.0 v_{2} + v_{4} \\cdot \\left(2.0 + 2.0 i\\right) - 1.0 i v_{5}\\\\- 1.0 v_{3} - 1.0 i v_{4} + v_{5} \\cdot \\left(1.0 + 1.0 i\\right)\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{O1} : 0.5 + 0.5 i, \\  I_{V1} : -1.0 - 1.0 i, \\  v_{1} : 1.0, \\  v_{2} : 0.0, \\  v_{3} : 0.25 - 0.25 i, \\  v_{4} : 0.25 + 0.25 i, \\  v_{5} : 0.0\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.000000 phase:     0.00000 deg\nv2   : mag:   0.000000 phase:         nan deg\nv3   : mag:   0.353553 phase:   -45.00000 deg\nv4   : mag:   0.353553 phase:    45.00000 deg\nv5   : mag:   0.000000 phase:         nan deg\nI_V1 : mag:   1.414214 phase:  -135.00000 deg\nI_O1 : mag:   0.707107 phase:    45.00000 deg",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#ac-sweep",
    "href": "2nd_order_BRF.html#ac-sweep",
    "title": "25  2nd Order BRF",
    "section": "25.23 AC Sweep",
    "text": "25.23 AC Sweep\nLooking at node 2 voltage.\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\n\nx = np.logspace(-1, 0, 500, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('null: {:.2f} dB at {:.3f} Hz'.format(mag.min(),w[np.argmin(mag)]/(2*np.pi)))\n\nnull: -57.42 dB at 0.159 Hz\n\n\n\n\n\n\nBudak, A. 1974. Passive and Active Network Analysis and Synthesis. Houghton Mifflin.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html",
    "href": "Elliptic-function-LPF.html",
    "title": "26  Elliptic Function LPF",
    "section": "",
    "text": "26.1 Introduction\nThe circuit shown above is an elliptic function low pass filter. The design of elliptic filters is somewhat complex and usually involves the use of tables found in filter design handbooks. The symbolic solution of the network equations takes about 2 hours on a i3 machine. Initially I was thinking that a symbolic solution of the equations and the use of SciPy’s filter functions, I could derive the element values for active elliptic filters. But since the subject of this book is MNA and not filter design, only the analysis of the filter is described.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#circuit-description",
    "href": "Elliptic-function-LPF.html#circuit-description",
    "title": "26  Elliptic Function LPF",
    "section": "26.2 Circuit description",
    "text": "26.2 Circuit description\nThe circuit in Figure 26.1 has 13 branches and 7 nodes. There are 12 passive components and one OpAmp. The circuit is from Williams and Taylor (1995), example 3-26, and is an elliptic function low pass filter with a cutoff frequency of 100 Hz. The schematic for the filter was entered into LTSpice and an the following netlist was obtained.\nR3 3 0 4750\nR4 5 0 73.2k\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10k\nC1 3 1 0.05µ\nC2 5 3 0.05µ\nC3 7 4 0.1µ\nC4 5 0 0.22µ\nC5 2 0 0.18µ\nXU1 6 5 7 opamp Aol=100K GBW=10Meg\nV1 1 0 AC 1\nR6 7 6 44.2k\nR5 6 0 10k\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n26.2.1 Network equations\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to fix up the formating of the component values and the OpAmp declaration.\n\nexample_net_list = '''\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7 \nV1 1 0 1\nR6 7 6 44.2e3\nR5 6 0 10e3\n'''\n\nCallin smna() to generate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(example_net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nequ = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\\(- C_{3} s v_{4} + I_{O1} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} + v_{6} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}}\\\\v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}}\\\\- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right)\\\\- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\\\- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}}\\\\v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}}\\\\- C_{3} s v_{4} + I_{O1} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}}\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  R_{3}, \\  s, \\  R_{5}, \\  v_{7}, \\  V_{1}, \\  C_{3}, \\  R_{6}, \\  v_{5}, \\  I_{O1}, \\  C_{2}, \\  C_{1}, \\  v_{1}, \\  C_{5}, \\  I_{V1}, \\  C_{4}, \\  v_{6}, \\  R_{4}, \\  v_{4}, \\  v_{3}, \\  R_{1}, \\  R_{2}, \\  R_{7}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 5.0 \\cdot 10^{-8}, \\  C_{2} : 5.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-7}, \\  C_{4} : 2.2 \\cdot 10^{-7}, \\  C_{5} : 1.8 \\cdot 10^{-7}, \\  O_{1} : \\text{NaN}, \\  R_{1} : 9530.0, \\  R_{2} : 9530.0, \\  R_{3} : 4750.0, \\  R_{4} : 73200.0, \\  R_{5} : 10000.0, \\  R_{6} : 44200.0, \\  R_{7} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#symbolic-solution",
    "href": "Elliptic-function-LPF.html#symbolic-solution",
    "title": "26  Elliptic Function LPF",
    "section": "26.3 Symbolic solution",
    "text": "26.3 Symbolic solution\nThe symbolic solution take a long time, 2 hours, on my laptop. Going to write some code to save off the results to a pickle file.\n\n#U_sym = solve(equ,X)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#numerical-solution",
    "href": "Elliptic-function-LPF.html#numerical-solution",
    "title": "26  Elliptic Function LPF",
    "section": "26.4 Numerical solution",
    "text": "26.4 Numerical solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ_N = equ.subs(element_values)\nequ_N\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 5.0 \\cdot 10^{-8} s v_{3} + v_{1} \\cdot \\left(5.0 \\cdot 10^{-8} s + 0.000104931794333683\\right) - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(1.8 \\cdot 10^{-7} s + 0.0001\\right) - 0.0001 v_{7}\\\\- 5.0 \\cdot 10^{-8} s v_{1} - 5.0 \\cdot 10^{-8} s v_{5} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000210526315789474\\right)\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000209863588667366\\right) - 0.000104931794333683 v_{5}\\\\- 5.0 \\cdot 10^{-8} s v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(2.7 \\cdot 10^{-7} s + 0.000118592996519475\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 1.0 \\cdot 10^{-7} s v_{4} - 0.0001 v_{2} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.00012262443438914\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nU = solve(equ_N,X)\n\n\n26.4.1 Find the network transfer function \\(\\frac {v_2(s)}{v_1(s)}\\)\n\nH = (U[v2]/U[v1]).cancel()\nH\n\n\\(\\displaystyle \\frac{7.66402714932125 \\cdot 10^{50} s^{3} + 1.60840024120068 \\cdot 10^{54} s^{2} + 3.37544646631832 \\cdot 10^{57} s + 7.10620308698594 \\cdot 10^{60}}{2.49434389140272 \\cdot 10^{48} s^{4} + 7.82471226796141 \\cdot 10^{51} s^{3} + 7.48699036699101 \\cdot 10^{54} s^{2} + 5.1465987346903 \\cdot 10^{57} s + 1.65249706814803 \\cdot 10^{60}}\\)\n\n\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n26.4.2 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n26.4.2.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-334.53+0.00j Hz\n0.26+334.27j Hz\n0.26-334.27j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-335.18+0.00j Hz\n-37.83+113.63j Hz\n-37.83-113.63j Hz\n-88.42+0.00j Hz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-analysis",
    "href": "Elliptic-function-LPF.html#ac-analysis",
    "title": "26  Elliptic Function LPF",
    "section": "26.5 AC analysis",
    "text": "26.5 AC analysis\nSolve the network equations at a frequency of 100 Hz or \\(\\omega\\) equal to 628.318 radians per second, s = 628.318j.\nLoad numerical values into the network equations.\n\nfreq_Hz = 100 #Hz\nw = 2*np.pi*freq_Hz\n\nequ_Nw = equ.subs(element_values)\nequ_Nw = equ_Nw.subs({s:1j*w})\nequ_Nw  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.000104931794333683 + 3.14159265358979 \\cdot 10^{-5} i\\right) - 3.14159265358979 \\cdot 10^{-5} i v_{3} - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(0.0001 + 0.000113097335529233 i\\right) - 0.0001 v_{7}\\\\- 3.14159265358979 \\cdot 10^{-5} i v_{1} + v_{3} \\cdot \\left(0.000210526315789474 + 6.28318530717959 \\cdot 10^{-5} i\\right) - 3.14159265358979 \\cdot 10^{-5} i v_{5}\\\\- 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(0.000209863588667366 + 6.28318530717959 \\cdot 10^{-5} i\\right) - 0.000104931794333683 v_{5} - 6.28318530717959 \\cdot 10^{-5} i v_{7}\\\\- 3.14159265358979 \\cdot 10^{-5} i v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(0.000118592996519475 + 0.000169646003293849 i\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 0.0001 v_{2} - 6.28318530717959 \\cdot 10^{-5} i v_{4} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(0.00012262443438914 + 6.28318530717959 \\cdot 10^{-5} i\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the newtork equations and list the node voltages and unknown currents.\n\nU_Nw = solve(equ_Nw,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_Nw .items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         4.264586   -108.662048\nv3         0.271069     40.463593\nv4         2.401757     -6.456457\nv5         1.187844    -60.144973\nv6         1.187844    -60.144973\nv7         6.438113    -60.144973\nI_V1       0.000150    -20.838911\nI_O1       0.000875    166.380500",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-sweep",
    "href": "Elliptic-function-LPF.html#ac-sweep",
    "title": "26  Elliptic Function LPF",
    "section": "26.6 AC Sweep",
    "text": "26.6 AC Sweep\nPlot the magnitude and phase of the filter’s transfer function.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit 1\n\nx = np.logspace(1, 3, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Magnitude and phase plot')\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#summary",
    "href": "Elliptic-function-LPF.html#summary",
    "title": "26  Elliptic Function LPF",
    "section": "26.7 Summary",
    "text": "26.7 Summary\nAn elliptic filter was analyized and a symbolic solution of the network equations takes a long time. Numerical solutions using component values are easily obtained.\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html",
    "href": "Initial_conditions.html",
    "title": "27  Initial conditions",
    "section": "",
    "text": "27.1 Introduction\nA circuit with initial conditions consisting of a capacitor with an inital voltage and an inductor with initial current is analysed.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#circuit-description",
    "href": "Initial_conditions.html#circuit-description",
    "title": "27  Initial conditions",
    "section": "27.2 Circuit description",
    "text": "27.2 Circuit description\nThe circuit in Figure 27.1 has seven branches and four nodes. Capacitor, C1, has an initial voltage at t(0) and the inductor, L1, has an initial current at t(0). The voltage source V2 represents the initial voltage on the capacitor and current source, I1, represents the initial current flowing in the inductor. The circuit has a DC voltage source, V1. There a current controlled current source, F1, that is controlled by the current in V1.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#circuit-analysis",
    "href": "Initial_conditions.html#circuit-analysis",
    "title": "27  Initial conditions",
    "section": "27.3 Circuit analysis",
    "text": "27.3 Circuit analysis\nThe circuit was drawn using LTSpice and the netlist was pasted into the code. The Heaviside function is used to define the initial current and voltage on the inductor and capacitor. The Heaviside function is named after Oliver Heaviside, who made significant contributions to electrical engineering.\nThe following Python modules are used.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\n27.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nR2 3 2 5\nC1 3 4 1\nV2 4 0 1\nL1 1 2 3 \nI1 1 2 1\nF1 2 0 V1 2\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + I_{V1} = - I_{1}\\)\\(I_{F1} - I_{L1} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}} = I_{1}\\)\\(- C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C_{1} s v_{3} + C_{1} s v_{4} + I_{V2} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{4} = V_{2}\\)\\(- I_{L1} L_{1} s + v_{1} - v_{2} = 0\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1}\\\\I_{F1} - I_{L1} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}}\\\\- C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\\\- C_{1} s v_{3} + C_{1} s v_{4} + I_{V2}\\\\v_{1}\\\\v_{4}\\\\- I_{L1} L_{1} s + v_{1} - v_{2}\\\\I_{F1} - I_{V1} f_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1}\\\\I_{1}\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  I_{F1}, \\  s, \\  I_{L1}, \\  I_{V2}, \\  v_{3}, \\  L_{1}, \\  v_{1}, \\  V_{2}, \\  v_{2}, \\  f_{1}, \\  R_{2}, \\  I_{V1}, \\  V_{1}, \\  I_{1}, \\  v_{4}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  I_{1} : 1.0, \\  L_{1} : 3.0, \\  R_{2} : 5.0, \\  V_{1} : 1.0, \\  V_{2} : 1.0, \\  f_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#initial-conditions",
    "href": "Initial_conditions.html#initial-conditions",
    "title": "27  Initial conditions",
    "section": "27.4 Initial conditions",
    "text": "27.4 Initial conditions\nThe SymPy Heaviside function is used to define the initial current and voltage on the inductor and capacitor.\n\nelement_values[V1] = laplace_transform(Heaviside(t), t, s)[0]\nelement_values[V2] = laplace_transform(-0.2*Heaviside(t), t, s)[0]\nelement_values[I1] = laplace_transform(0.1*Heaviside(t), t, s)[0]\nNE_ic = NE_sym.subs(element_values)\nNE_ic\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1}\\\\I_{F1} - I_{L1} + 0.2 v_{2} - 0.2 v_{3}\\\\- 1.0 s v_{4} - 0.2 v_{2} + v_{3} \\cdot \\left(1.0 s + 0.2\\right)\\\\I_{V2} - 1.0 s v_{3} + 1.0 s v_{4}\\\\v_{1}\\\\v_{4}\\\\- 3.0 I_{L1} s + v_{1} - v_{2}\\\\I_{F1} - 2.0 I_{V1}\\end{matrix}\\right] = \\left[\\begin{matrix}- \\frac{0.1}{s}\\\\\\frac{0.1}{s}\\\\0\\\\0\\\\\\frac{1}{s}\\\\- \\frac{0.2}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{13.0 s^{2} + 53.0 s + 10.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(v_{3} = \\frac{- 2.0 s^{2} - 7.0 s + 10.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(v_{4} = - \\frac{0.2}{s}\\)\\(I_{V1} = \\frac{- s - 4.0}{10.0 s^{2} + 50.0 s + 10.0}\\)\\(I_{V2} = \\frac{3.0 s + 12.0}{10.0 s^{2} + 50.0 s + 10.0}\\)\\(I_{L1} = \\frac{- s - 1.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(I_{F1} = \\frac{- s - 4.0}{5.0 s^{2} + 25.0 s + 5.0}\\)\n\n\nThe voltage on node 2 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\ntemp = U_ic[v2].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{13 s^{2} + 53 s + 10}{10 s \\left(s^{2} + 5 s + 1\\right)}\\)\n\n\n\nnode_2_voltage = inverse_laplace_transform(temp, s, t)\nnode_2_voltage\n\n\\(\\displaystyle \\left(\\frac{\\sqrt{21} \\cdot \\left(3 e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} + \\sqrt{21} e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} - 3 e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}} + \\sqrt{21} e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}}\\right)}{140} + e^{5 t}\\right) e^{- 5 t}\\)\n\n\n\nfunc_node_2_voltage = lambdify(t, node_2_voltage) \n\nThe voltage on node 3 is obtained in a sumular way.\n\ntemp = U_ic[v3].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{- 2 s^{2} - 7 s + 10}{10 s \\left(s^{2} + 5 s + 1\\right)}\\)\n\n\n\nnode_3_voltage = inverse_laplace_transform(temp, s, t)\nnode_3_voltage\n\n\\(\\displaystyle \\left(\\frac{\\sqrt{21} \\left(- 2 \\sqrt{21} e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} + 9 e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} - 2 \\sqrt{21} e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}} - 9 e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}}\\right)}{70} + e^{5 t}\\right) e^{- 5 t}\\)\n\n\n\nfunc_node_3_voltage = lambdify(t, node_3_voltage) \n\nThe plot below shows the node voltages versus time.\n\nx = np.linspace(0, 10, 2000, endpoint=True)\n\nplt.title('Node voltages vs time')\n\nplt.plot(x, func_node_2_voltage(x),label='v2(t)')\nplt.plot(x, func_node_3_voltage(x),label='v3(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#summary",
    "href": "Initial_conditions.html#summary",
    "title": "27  Initial conditions",
    "section": "27.5 Summary",
    "text": "27.5 Summary\nIn this notebook, newtork equations were solved which had initial conditions, which were included in the network equations with their Laplace equilivents.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html",
    "href": "Transient_circuit.html",
    "title": "28  Transient circuit",
    "section": "",
    "text": "28.1 Introduction\nThe circuit above is a filter designed to explore transient analysis of a circuit using Python. The dependent source, V1, will be a time varying signal described below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#circuit-description",
    "href": "Transient_circuit.html#circuit-description",
    "title": "28  Transient circuit",
    "section": "28.2 Circuit description",
    "text": "28.2 Circuit description\nThe circuit in Figure 28.1 is an elliptic low pass filter with a 1 Hz cut off and 3 dB of ripple in the pass band and 40 dB of attenuation in the stop band. The filter design tool linked here was used to design the filter.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#circuit-analysis",
    "href": "Transient_circuit.html#circuit-analysis",
    "title": "28  Transient circuit",
    "section": "28.3 Circuit analysis",
    "text": "28.3 Circuit analysis\nThe circuit analysis follows the steps listed below.\n\nDraw circuit in LTSpice, export netlist\nGenerate network equations\nSymbolic solution\nAC sweep and plot the frequency response at the output\nTransient analysis\n\nGenerate input signal for transient analysis\nMostly following the procedure outlined here\ndisplay the results\n\n\nTransient analysis is somewhat more involved than the other types of circuit analysis, primarily because SymPy’s inverse Laplace transform is not very robust and can’t handle complicated expressions. The output equation needs to be simplified by writing some code to put the equation into forms that SymPy can deal with.\nLoad the following Python modules.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n28.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent source, V1, is set to a value of one.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1\nR2 2 0 1\nL1 3 4 0.4925\nL2 5 0 0.05081\nC2 4 5 0.09876\nL3 4 2 0.4925\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L3} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(C_{2} s v_{4} - C_{2} s v_{5} - I_{L1} + I_{L3} = 0\\)\\(- C_{2} s v_{4} + C_{2} s v_{5} + I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{3} - v_{4} = 0\\)\\(- I_{L2} L_{2} s + v_{5} = 0\\)\\(- I_{L3} L_{3} s - v_{2} + v_{4} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displade in matrix notation below.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\\\- I_{L3} + \\frac{v_{2}}{R_{2}}\\\\I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}}\\\\C_{2} s v_{4} - C_{2} s v_{5} - I_{L1} + I_{L3}\\\\- C_{2} s v_{4} + C_{2} s v_{5} + I_{L2}\\\\v_{1}\\\\- I_{L1} L_{1} s + v_{3} - v_{4}\\\\- I_{L2} L_{2} s + v_{5}\\\\- I_{L3} L_{3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{1}, \\  I_{L1}, \\  L_{1}, \\  R_{2}, \\  v_{5}, \\  C_{2}, \\  L_{3}, \\  I_{L3}, \\  I_{L2}, \\  V_{1}, \\  v_{1}, \\  v_{4}, \\  v_{2}, \\  v_{3}, \\  I_{V1}, \\  L_{2}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{2} : 0.09876, \\  L_{1} : 0.4925, \\  L_{2} : 0.05081, \\  L_{3} : 0.4925, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#symbolic-solution",
    "href": "Transient_circuit.html#symbolic-solution",
    "title": "28  Transient circuit",
    "section": "28.4 Symbolic solution",
    "text": "28.4 Symbolic solution\nSince the circuit is not too large, a symbolic solution can be easily obtained.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} L_{2} R_{2} V_{1} s^{2} + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C_{2} L_{1} L_{2} V_{1} s^{3} + C_{2} L_{1} L_{3} V_{1} s^{3} + C_{2} L_{1} R_{2} V_{1} s^{2} + C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2} + L_{1} V_{1} s + L_{3} V_{1} s + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{4} = \\frac{C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2} + L_{3} V_{1} s + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{5} = \\frac{C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C_{2} L_{2} V_{1} s^{2} - C_{2} L_{3} V_{1} s^{2} - C_{2} R_{2} V_{1} s - V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{C_{2} L_{2} V_{1} s^{2} + C_{2} L_{3} V_{1} s^{2} + C_{2} R_{2} V_{1} s + V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L2} = \\frac{C_{2} L_{3} V_{1} s^{2} + C_{2} R_{2} V_{1} s}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L3} = \\frac{C_{2} L_{2} V_{1} s^{2} + V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\n\n\n\n28.4.1 AC Sweep\nAfter substituting the numeric component values for the elements, a numerical solution for the note voltages can be obtained.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\\\- I_{L3} + 1.0 v_{2}\\\\I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\\\- I_{L1} + I_{L3} + 0.09876 s v_{4} - 0.09876 s v_{5}\\\\I_{L2} - 0.09876 s v_{4} + 0.09876 s v_{5}\\\\v_{1}\\\\- 0.4925 I_{L1} s + v_{3} - v_{4}\\\\- 0.05081 I_{L2} s + v_{5}\\\\- 0.4925 I_{L3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n28.4.2 Plot the frequency response at node 2\n\nH = U_ac[v2]\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\nx = np.logspace(-1, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n28.4.3 Low pass filter impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(system,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(system,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe results obtained from SciPy’s step2 function can be compared to the transient response results obtained below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#transient-analysis",
    "href": "Transient_circuit.html#transient-analysis",
    "title": "28  Transient circuit",
    "section": "28.5 Transient Analysis",
    "text": "28.5 Transient Analysis\nThe input signal for the filter circuit is defined by using SymPy’s Heaveside function. The signal has a positive step at t=0, followed by a return to zero amplitude at t=5.\nDeclare SymPy symbols needed during the analysis.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nV1_t = 1*Heaviside(t)*(1-Heaviside(t-5))\nV1_t\n\n\\(\\displaystyle 1 - \\theta\\left(t - 5\\right)\\)\n\n\nUse the lambdify function to convert the input signal to a function for plotting.\n\nfunc_V1_t = lambdify(t, V1_t) \n\nThe time domain description of the input signal is comvertered to the frequency domain with SymPy’s Laplace transform function.\n\nV1_s = laplace_transform(V1_t, t, s, noconds=True)\nV1_s\n\n\\(\\displaystyle \\frac{1}{s} - \\frac{e^{- 5 s}}{s}\\)\n\n\nPut the component values into the network equations and set V1 equal to the Laplace of the input signal.\n\nelement_values[V1] = V1_s\nNE_trans = NE_sym.subs(element_values)\nNE_trans\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\\\- I_{L3} + 1.0 v_{2}\\\\I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\\\- I_{L1} + I_{L3} + 0.09876 s v_{4} - 0.09876 s v_{5}\\\\I_{L2} - 0.09876 s v_{4} + 0.09876 s v_{5}\\\\v_{1}\\\\- 0.4925 I_{L1} s + v_{3} - v_{4}\\\\- 0.05081 I_{L2} s + v_{5}\\\\- 0.4925 I_{L3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s} - \\frac{e^{- 5 s}}{s}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the newtork equations for the transient input and display the results.\n\nU_trans = solve(NE_trans,X)\n\ntemp = ''\nfor i in U_trans.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_trans[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s} - \\frac{e^{- 5.0 s}}{s}\\)\\(v_{2} = \\frac{1254498900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{1254498900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(v_{3} = \\frac{7224395229.0 s^{3} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{7224395229.0 s^{3}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{246250000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{246250000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(v_{4} = \\frac{12544989.0 s^{2} e^{5.0 s}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} - \\frac{12544989.0 s^{2}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} + \\frac{2500000000.0 e^{5.0 s}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} - \\frac{2500000000.0}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}}\\)\\(v_{5} = \\frac{12544989.0 s e^{5.0 s}}{146688228.0 s^{2} e^{5.0 s} + 246900000.0 s e^{5.0 s} + 5000000000.0 e^{5.0 s}} - \\frac{12544989.0 s}{146688228.0 s^{2} e^{5.0 s} + 246900000.0 s e^{5.0 s} + 5000000000.0 e^{5.0 s}}\\)\\(I_{V1} = - \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{24690000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{24690000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(I_{L1} = \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{24690000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{24690000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(I_{L2} = \\frac{61725000.0 e^{5.0 s}}{36672057.0 s^{2} e^{5.0 s} + 61725000.0 s e^{5.0 s} + 1250000000.0 e^{5.0 s}} - \\frac{61725000.0}{36672057.0 s^{2} e^{5.0 s} + 61725000.0 s e^{5.0 s} + 1250000000.0 e^{5.0 s}}\\)\\(I_{L3} = \\frac{1254498900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{1254498900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\n\n\nThe equations for the solution are complex and long, but are easy to obtain and display.\nThe voltage on node 2 is the output of the filter. The expression is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together().\n\nH = U_trans[v2].nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{100 \\cdot \\left(12544989 s^{2} e^{5 s} - 12544989 s^{2} + 2500000000 e^{5 s} - 2500000000\\right) e^{- 5 s}}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}\\)\n\n\nAll the time dealy terms are in the numerator.\nExtract the numerator and denominator and display.\n\nn, d = fraction(H)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle 1254498900 s^{2} e^{5 s} - 1254498900 s^{2} + 250000000000 e^{5 s} - 250000000000\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right) e^{5 s}\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ - \\frac{250000000000 e^{- 5 s}}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}, \\  - \\frac{1254498900 s e^{- 5 s}}{7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000}, \\  \\frac{250000000000}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}, \\  \\frac{1254498900 s}{7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nThe time delay operator \\(e^{-ts}\\) is removed from the xpression and the value of the time delay is saved in a list.\nuse the SciPy residue function to get the partial-fraction expansion residues and poles\nbuild the partial expansion terms and find the inverse Laplace of each one and save\n\n\ntime_delay = []\ndelay = []\nN = []\n\nfor i in terms:\n    # look for and remove the time delay\n    if len(i.find(exp)) == 1:\n        delay = i.find(exp).pop()\n        time_delay.append(list(delay.atoms())[0])\n        ans = i/i.find(exp).pop()\n    else:\n        ans = i\n        time_delay.append(0)\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(ans)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n    \n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i])) #.nsimplify()\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nThe time delays associated with each term are:\n\ntime_delay\n\n\\(\\displaystyle \\left[ -5, \\  -5, \\  0, \\  0\\right]\\)\n\n\nThe time domain version of each of the terms is displayed below.\n\nN\n\n\\(\\displaystyle \\left[ 1.0 \\left(\\left(0.0868202525095611 - 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(\\left(0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561563 - 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} - 0.5 + 0.489865675268769 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(-0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} - \\left(0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(- \\left(0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(-0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 0.0101343247312312 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(-0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} - \\left(0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(- \\left(0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(-0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 0.5 - 0.489865675268769 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(0.0139856047826648 - 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(\\left(0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561562 - 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} - 0.0101343247312312 e^{- 2.03045685279188 t}\\right]\\)\n\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\n\nout0 = lambdify(t, N[0])\nout1 = lambdify(t, N[1])\nout2 = lambdify(t, N[2])\nout3 = lambdify(t, N[3])\n\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 10, 2000, endpoint=True)\n\nout0a = out0(x)\nout1a = out1(x)\nout2a = out2(x)\nout3a = out3(x)\n\nThe arrays, out2a and out3a, do not have any delay so they can be summed and used to create the final array for plotting.\n\nout = out2a + out3a\n\nThe arrays, out0a and out1a, have a delay associated with them, so and offset in the time is included by shifting right by the corrrect amount.\n\noffset = 1000\nout[offset:] = out[offset:] + (out0a[0:-offset] + out1a[0:-offset])\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(out),label='v2(t)')\nplt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#summary",
    "href": "Transient_circuit.html#summary",
    "title": "28  Transient circuit",
    "section": "28.6 Summary",
    "text": "28.6 Summary\nThe inverse Laplace transform of complicated expressions requires that they be reduced to a set of simple terms by particial fraction expansion. I’ve not yet figured a way to easily code the delay terms, so these are handled manually by a offset shift in the finaly plot output.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "References",
    "section": "",
    "text": "Budak, A. 1974. Passive and Active Network Analysis and\nSynthesis. Houghton Mifflin.\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The\nCircuits and Filters Handbook, 3rd Edition. CRC Press.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of\nAnalog Circuits Through Symbolic Analysis.\n\n\nHayes, M. 2022. “Lcapy: Symbolic Linear Circuit Analysis with\nPython.” https://doi.org/10.7717/peerj-cs.875.\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd\nEdition. McGraw-Hill.\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal\nApproach to Network Analysis.” IEEE Transactions on Circuits\nand Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric\nCircuit Analysis. Prentice-Hall, Inc.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit\nEquations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific\nComputing. Numerical Recipes in c Book Set. Cambridge University\nPress.\n\n\nTow, J. 1968. “Active RC Filters—a State-Space\nRealization.” Proceedings of the IEEE 56 (6): 1137–39.\nhttps://doi.org/10.1109/PROC.1968.6502.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design\nHandbook, Third Edition. McGraw-Hill Education.\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley &\nSons.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "SymMNA_py.html",
    "href": "SymMNA_py.html",
    "title": "Appendix A — SymMNA.py",
    "section": "",
    "text": "\"\"\"Symbolic modified nodal analysis\nLast update: 30 Jan 2024\n\nDescription:\nThe modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear \ncircuit analysis.\n\nMy code started initially by following Erik Cheever's Analysis of Resistive Circuits [1], which used Matlab code \nto generate modified nodal equations. I somewhat followed his MATLAB file for resistors, capacitors, opamps and independent sources. \nThe naming of the matrices follows his convention. The preprocessor and parser code was converted from my old C code. \nThe use of pandas for a data frame is new and sympy is used to do the math and the use of element \nstamps is from [2].\n\nInductors are being addressed in the D matrix. Erik's code puts inductors into the G matrix as 1/s/L.  \nMy code puts the inductor contribution into the D matrix and the unknown current from the inductor into \nthe B and C matrices.  Coupled inductors also affect the D matrix, so it makes sense to allow the inductors \nto be in the D matrix rather than the G matrix.\n\nReferences:\n1. [Analysis of  Resistive Circuits](http://www.swarthmore.edu/NatSci/echeeve1/Ref/mna/MNA1.html), retrieved October 6, 2017  \n2. [ECE 570 Session 3](http://www2.engr.arizona.edu/~ece570/session3.pdf), Computer Aided Engineering for Integrated Circuits, retreived November 13, 2023  \n\nUsage:  See SMNA_func_test.py\n\"\"\"\n\nfrom sympy import *\nimport numpy as np\nimport pandas as pd\n\ndef get_part_values(net_df):\n    \"\"\" construct a dictionary of element values from the netlist dataframe: value_dict, get_part_values\n    Parameters\n    ----------\n    net_df: pandas dataframe\n        the network dataframe returned by the smna function below\n    Returns\n    -------\n    element values: Python dictionary\n        the element values from the netlist\n    \"\"\"\n\n    # initialize variables\n    element_value_keys = []\n    element_value_values = []\n\n    for i in range(len(net_df)):\n        if net_df.iloc[i]['element'][0] == 'F' or net_df.iloc[i]['element'][0] == 'E' or net_df.iloc[i]['element'][0] == 'G' or net_df.iloc[i]['element'][0] == 'H':\n            element_value_keys.append(var(net_df.iloc[i]['element'].lower()))\n            element_value_values.append(net_df.iloc[i]['value'])\n        else:\n            element_value_keys.append(var(net_df.iloc[i]['element']))\n            element_value_values.append(net_df.iloc[i]['value'])\n\n    return dict(zip(element_value_keys, element_value_values))\n\ndef smna(net_list):\n    \"\"\"Symbolic modified nodal analysis\n    Parameters\n    ----------\n    net_list: str\n        The circuit net list, needs a \\n at the end of each line\n    Returns\n    -------\n    report: text string\n            The net list report.\n    df: pandas dataframe\n            circuit net list info loaded into a dataframe\n    df2: pandas dataframe\n            branches with unknown currents\n    A: sympy matrix\n            The A matrix is (m+n) by (m+n) and is the combination of 4 smaller matrices, G, B, C, and D.\n            The G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections\n            between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, \n            where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage \n            sources, current controlling elements, etc. In python row and columns are: G[row, column]\n            The B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes\n            and m is the number of current unknowns, i_unk. There is one column for each unknown current.\n            The code loop through all the branches and process elements that have stamps for the B matrix: \n            The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).\n            The code is similar to the B matrix code, except the indices are swapped. The code loops through \n            all the branches and process elements that have stamps for the C matrix: \n            The D matrix is an m by m matrix, where m is the number of unknown currents. \n    X: list\n            The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages \n            and the currents through the independent voltage sources). The top n elements are the n node \n            voltages. The bottom m elements represent the currents through the m independent voltage \n            sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix \n            is m by 1 and holds the unknown currents through the voltage sources\n    Z: list\n            The Z matrix holds the independent voltage and current sources and is the combination\n            of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, \n            and m is the number of independent voltage sources. The I matrix is n by 1 and contains \n            the sum of the currents through the passive elements into the corresponding node (either \n            zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the \n            values of the independent voltage sources.\n    \"\"\"\n\n    # initialize variables\n    num_rlc = 0 # number of passive elements\n    num_ind = 0 # number of inductors\n    num_v = 0    # number of independent voltage sources\n    num_i = 0    # number of independent current sources\n    i_unk = 0  # number of current unknowns\n    num_opamps = 0   # number of op amps\n    num_vcvs = 0     # number of controlled sources of various types\n    num_vccs = 0\n    num_cccs = 0\n    num_ccvs = 0\n    num_cpld_ind = 0 # number of coupled inductors\n\n    content = net_list.splitlines()\n\n    content = [x.strip() for x in content]  #remove leading and trailing white space\n    # remove empty lines\n    while '' in content:\n        content.pop(content.index(''))\n\n    # remove comment lines, these start with a asterisk *\n    content = [n for n in content if not n.startswith('*')]\n    # remove other comment lines, these start with a semicolon ;\n    content = [n for n in content if not n.startswith(';')]\n    # remove spice directives, these start with a period, .\n    content = [n for n in content if not n.startswith('.')]\n    # converts 1st letter to upper case\n    #content = [x.upper() for x in content] &lt;- this converts all to upper case\n    content = [x.capitalize() for x in content]\n    # removes extra spaces between entries\n    content = [' '.join(x.split()) for x in content]\n\n    line_cnt = len(content) # number of lines in the netlist\n    branch_cnt = 0  # number of branches in the netlist\n    # check number of entries on each line, count each element type\n    for i in range(line_cnt):\n        x = content[i][0]\n        tk_cnt = len(content[i].split()) # split the line into a list of words\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_rlc += 1\n            branch_cnt += 1\n            if x == 'L':\n                num_ind += 1\n        elif x == 'V':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_v += 1\n            branch_cnt += 1\n        elif x == 'I':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_i += 1\n            branch_cnt += 1\n        elif x == 'O':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_opamps += 1\n        elif x == 'E':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vcvs += 1\n            branch_cnt += 1\n        elif x == 'G':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vccs += 1\n            branch_cnt += 1\n        elif x == 'F':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_cccs += 1\n            branch_cnt += 1\n        elif x == 'H':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_ccvs += 1\n            branch_cnt += 1\n        elif x == 'K':\n            if (tk_cnt != 4):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_cpld_ind += 1\n        else:\n            raise Exception(\"unknown element type in branch {:d}: {:s}\".format(i,content[i]))\n\n\n    ''' The parser performs the following operations.\n     1. puts branch elements into data frame  \n     2. counts number of nodes  \n\n     data frame labels:\n     - element: type of element  \n     - p node: positive node  \n     - n node: negative node, for a current source, the arrow point terminal, LTspice \n     puts the inductor phasing dot on this terminal  \n     - cp node: controlling positive node of branch  \n     - cn node: controlling negative node of branch  \n     - Vout: opamp output node  \n     - value: value of element or voltage  \n     - Vname: voltage source through which the controlling current flows. Need to \n     add a zero volt voltage source to the controlling branch.  \n     - Lname1: name of coupled inductor 1  \n     - Lname2: name of coupled inductor 2'''  \n\n    # build the pandas data frame\n    df = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n        'Vout','value','Vname','Lname1','Lname2'])\n\n    # this data frame is for branches with unknown currents\n    df2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n    # ### Functions to load branch elements into data frame and check for gaps in node numbering\n\n    # loads voltage or current sources into branch structure\n    def indep_source(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads passive elements into branch structure\n    def rlc_element(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads multi-terminal elements into branch structure\n    # O - Op Amps\n    def opamp_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vout'] = int(tk[3])\n\n    # G - VCCS\n    def vccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # E - VCVS\n    # in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\n    def vcvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # F - CCCS\n    def cccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # H - CCVS\n    def ccvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # K - Coupled inductors\n    def cpld_ind_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n        df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # function to scan df and get largest node number\n    def count_nodes():\n        # need to check that nodes are consecutive\n        # fill array with node numbers\n        p = np.zeros(line_cnt+1)\n        for i in range(line_cnt):\n            # need to skip coupled inductor 'K' statements\n            if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n                p[df['p node'][i]] = df['p node'][i]\n                p[df['n node'][i]] = df['n node'][i]\n\n        # find the largest node number\n        if df['n node'].max() &gt; df['p node'].max():\n            largest = df['n node'].max()\n        else:\n            largest =  df['p node'].max()\n\n        largest = int(largest)\n        # check for unfilled elements, skip node 0\n        for i in range(1,largest):\n            if p[i] == 0:\n                raise Exception('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n        return largest\n\n    # load branch info into data frame\n    for i in range(line_cnt):\n        x = content[i][0]\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            rlc_element(i)\n        elif (x == 'V') or (x == 'I'):\n            indep_source(i)\n        elif x == 'O':\n            opamp_sub_network(i)\n        elif x == 'E':\n            vcvs_sub_network(i)\n        elif x == 'G':\n            vccs_sub_network(i)\n        elif x == 'F':\n            cccs_sub_network(i)\n        elif x == 'H':\n            ccvs_sub_network(i)\n        elif x == 'K':\n            cpld_ind_sub_network(i)\n        else:\n            raise Exception(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n    '''29 Nov 2023:  When the D matrix is built, independent voltage sources are processed\n    in the data frame order when building the D matrix. If the voltage source followed element\n    L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different\n    row in relation to its position in the Ev matrix. This would cause the node attached to \n    the terminal of the voltage source to be zero volts.  \n    Solution - The following block of code was added to move voltage source types to the \n    beginning of the net list dataframe before any calculations are performed.''' \n\n    # Check for position of voltages sources in the dataframe.\n    source_index = [] # keep track of voltage source row number\n    other_index = [] # make a list of all other types\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V'):\n            source_index.append(i)\n        else:\n            other_index.append(i)\n\n    df = df.reindex(source_index+other_index,copy=True) # re-order the data frame\n    df.reset_index(drop=True, inplace=True) # renumber the index\n\n    # count number of nodes\n    num_nodes = count_nodes()\n\n    # Build df2: consists of branches with current unknowns, used for C & D matrices\n    # walk through data frame and find these parameters\n    count = 0\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n            df2.loc[count,'element'] = df.loc[i,'element']\n            df2.loc[count,'p node'] = df.loc[i,'p node']\n            df2.loc[count,'n node'] = df.loc[i,'n node']\n            count += 1\n\n    # print the netlist report\n    report = 'Net list report\\n'\n    report = report+('number of lines in netlist: {:d}\\n'.format(line_cnt))\n    report = report+'number of branches: {:d}\\n'.format(branch_cnt)\n    report = report+'number of nodes: {:d}\\n'.format(num_nodes)\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are current unknows\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\n    report = report+'number of unknown currents: {:d}\\n'.format(i_unk)\n    report = report+'number of RLC (passive components): {:d}\\n'.format(num_rlc)\n    report = report+'number of inductors: {:d}\\n'.format(num_ind)\n    report = report+'number of independent voltage sources: {:d}\\n'.format(num_v)\n    report = report+'number of independent current sources: {:d}\\n'.format(num_i)\n    report = report+'number of op amps: {:d}\\n'.format(num_opamps)\n    report = report+'number of E - VCVS: {:d}\\n'.format(num_vcvs)\n    report = report+'number of G - VCCS: {:d}\\n'.format(num_vccs)\n    report = report+'number of F - CCCS: {:d}\\n'.format(num_cccs)\n    report = report+'number of H - CCVS: {:d}\\n'.format(num_ccvs)\n    report = report+'number of K - Coupled inductors: {:d}\\n'.format(num_cpld_ind)\n\n    # initialize some symbolic matrix with zeros\n    # A is formed by [[G, C] [B, D]]\n    # Z = [I,E]\n    # X = [V, J]\n    V = zeros(num_nodes,1)\n    I = zeros(num_nodes,1)\n    G = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\n    s = Symbol('s')  # the Laplace variable\n\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are element types that have unknown currents\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    # if i_unk == 0, just generate empty arrays\n    B = zeros(num_nodes,i_unk)\n    C = zeros(i_unk,num_nodes)\n    D = zeros(i_unk,i_unk)\n    Ev = zeros(i_unk,1)\n    J = zeros(i_unk,1)\n\n    ''' The G matrix is n by n, where n is the number of nodes. \n    The matrix is formed by the interconnections between the resistors, \n    capacitors and VCCS type elements.  In the original paper G is called Yr, \n    where Yr is a reduced form of the nodal matrix excluding the contributions \n    due to voltage sources, current controlling elements, etc.  In python row \n    and columns are: G[row, column]'''\n    for i in range(len(df)):  # process each row in the data frame\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node']\n        cn2 = df.loc[i,'cn node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'R':\n            g = 1/sympify(df.loc[i,'element'])\n        if x == 'C':\n            g = s*sympify(df.loc[i,'element'])\n        if x == 'G':   #vccs type element\n            g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n        if (x == 'R') or (x == 'C'):\n            # If neither side of the element is connected to ground\n            # then subtract it from the appropriate location in the matrix.\n            if (n1 != 0) and (n2 != 0):\n                G[n1-1,n2-1] += -g\n                G[n2-1,n1-1] += -g\n\n            # If node 1 is connected to ground, add element to diagonal of matrix\n            if n1 != 0:\n                G[n1-1,n1-1] += g\n\n            # same for for node 2\n            if n2 != 0:\n                G[n2-1,n2-1] += g\n\n        if x == 'G':    #vccs type element\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0 and cn1 != 0:\n                G[n1-1,cn1-1] += g\n\n            if n2 != 0 and cn2 != 0:\n                G[n2-1,cn2-1] += g\n\n            if n1 != 0 and cn2 != 0:\n                G[n1-1,cn2-1] -= g\n\n            if n2 != 0 and cn1 != 0:\n                G[n2-1,cn1-1] -= g\n\n    '''The B matrix is an n by m matrix with only 0, 1 and -1 elements, where \n    n = number of nodes and m is the number of current unknowns, i_unk. There is \n    one column for each unknown current. The code loop through all the branches \n    and process elements that have stamps for the B matrix:  \n     - Voltage sources (V)  \n     - Opamps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)    \n\n    The order of the columns is as they appear in the netlist.  CCCS (F) does not get\n    its own column because the controlling current is through a zero volt voltage source,\n    called Vname and is already in the net list.'''\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n            B[n_vout-1,sn] = 1\n            sn += 1   # increment source count\n        if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\n    ''' The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).  \n    The code is similar to the B matrix code, except the indices are swapped.   The code loops through \n    all the branches and process elements that have stamps for the C matrix:  \n     - Voltage sources (V)  \n     - Opamps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)  \n\n     Op Amp elements\n     The op amp element is assumed to be an ideal op amp and use of this component is valid only when \n     used in circuits with a DC path (a short or a resistor) from the output terminal to the negative \n     input terminal of the op amp. No error checking is provided and if the condition is violated, \n     the results likely will be erroneous.   \n\n     References use in the debugging of the opamp stamp:   \n     1. Design of Analog Circuits Through Symbolic Analysis, edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fernández   \n     2. Computer Aided Design and Design Automation, edited by Wai-Kai Chen  \n\n     find the the column position in the C and D matrix for controlled sources\n     needs to return the node numbers and branch number of controlling branch'''\n    def find_vname(name):\n        # need to walk through data frame and find these parameters\n        for i in range(len(df2)):\n            # process all the elements creating unknown currents\n            if name == df2.loc[i,'element']:\n                n1 = df2.loc[i,'p node']\n                n2 = df2.loc[i,'n node']\n                return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n        raise Exception('failed to find matching branch element in find_vname')\n\n    # generate the C Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        cn2 = df.loc[i,'cn node']\n        n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n        if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n            # C[sn,n_vout-1] = 1\n            if i_unk &gt; 1:  #is B greater than 1 by n?, O\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   # increment source count\n\n        if x == 'F':  # need to count F (cccs) types\n            sn += 1   #increment source count\n        if x == 'H':  # H: ccvs\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n                # add entry for cp and cn of the controlling voltage\n                if cn1 != 0:\n                    C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n                if cn2 != 0:\n                    C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n                vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n                if vn1 != 0:\n                    C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n                if vn2 != 0:\n                    C[vn2-1] = sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\n    ''' The D matrix is an m by m matrix, where m is the number of unknown currents.  \n    m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n    Stamps that affect the D matrix are: inductor, ccvs and cccs  \n    inductors: minus sign added to keep current flow convention consistent  \n\n    Coupled inductors notes:  \n    Can the K statement be anywhere in the net list, even before Lx and Ly?   \n    12/6/2017 doing some debugging on with coupled inductors  \n    LTspice seems to put the phasing dot on the neg node when it generates the netlist   \n    This code uses M for mutual inductance, LTspice uses k for the coupling coefficient.'''  \n\n    # generate the D Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        #cn2 = df.loc[i,'cn node']\n        #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n        # process elements with input to D matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is D greater than 1 by 1?\n                D[sn,sn] += -s*sympify(df.loc[i,'element'])\n            else:\n                D[sn] += -s*sympify(df.loc[i,'element'])\n            sn += 1   #increment source count\n\n        if x == 'H':  # H: ccvs\n            # if there is a H type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'F':  # F: cccs\n            # if there is a F type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            D[sn,sn] = 1\n            sn += 1   #increment source count\n\n        if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n            # if there is a K type, D is m by m\n            vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n            vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n            # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n            D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n            D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n    ''' The V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.  \n    Maybe make small v's v_1 so as not to confuse v1 with V1.'''\n    # generate the V matrix\n    for i in range(num_nodes):\n        V[i] = sympify('v{:d}'.format(i+1))\n\n    ''' The J matrix is an m by 1 matrix, where m is the number of unknown currents.\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    The J matrix is an m by 1 matrix, with one entry for each i_unk from a source'''\n    for i in range(len(df2)):\n        # process all the unknown currents\n        J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\n    ''' The I matrix is an n by 1 matrix, where n is the number of nodes. The value\n    of each element of I is determined by the sum of current sources into the \n    corresponding node. If there are no current sources connected to the node, the value is zero.'''\n\n    # generate the I matrix, current sources have n2 = arrow end of the element\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'I':\n            g = sympify(df.loc[i,'element'])\n            # sum the current into each node\n            if n1 != 0:\n                I[n1-1] -= g\n            if n2 != 0:\n                I[n2-1] += g\n\n    # The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n    sn = 0   # count source number\n    for i in range(len(df)):\n        # process all the passive elements\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            Ev[sn] = sympify(df.loc[i,'element'])\n            sn += 1\n\n\n    ''' The Z matrix holds the independent voltage and current sources and is the combination of 2\n    smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the\n    number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents\n    through the passive elements into the corresponding node (either zero, or the sum of independent\n    current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.'''\n    Z = I[:] + Ev[:]  # the + operator in python concatenates the lists\n\n\n    ''' The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through\n    the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the\n    currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages.\n    The J matrix is m by 1 and holds the unknown currents through the voltage sources '''\n    X = V[:] + J[:]  # the + operator in python concatenates the lists\n\n    # The A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n    n = num_nodes\n    m = i_unk\n    A = zeros(m+n,m+n)\n    for i in range(n):\n        for j in range(n):\n            A[i,j] = G[i,j]\n\n    if i_unk &gt; 1:\n        for i in range(n):\n            for j in range(m):\n                A[i,n+j] = B[i,j]\n                A[n+j,i] = C[j,i]\n\n        for i in range(m):\n            for j in range(m):\n                A[n+i,n+j] = D[i,j]\n\n    if i_unk == 1:\n        for i in range(n):\n            A[i,n] = B[i]\n            A[n,i] = C[i]\n        A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\n    return report, df, df2, A, X, Z",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>SymMNA.py</span>"
    ]
  },
  {
    "objectID": "Change-log.html",
    "href": "Change-log.html",
    "title": "Appendix B — Change Log",
    "section": "",
    "text": "The following table is a history of the code development.\n\n\n\nTable B.1: Change log\n\n\n\n\n\n\n\n\n\nDate\nEvent\n\n\n\n\n7/1/2015\nVer 1 - coding started, derived from my network.c code\n\n\n8/18/2017\nchanged approach, now implementing a modified nodal analysis\n\n\n8/19/2017\nWrote some code to generate symbolic matrices, works ok, so heading down the sympy path. Basic debugging finished, but still need to verify some circuits using Ls and Cs.\n\n\n8/30/2017\nStarted to add code for op amps\n\n\n9/1/2017\nCode added to process op amps\n\n\n9/3/2017\nAdded code to remove spice directives. Fixed orientation of current sources in I matrix. N2 is the arrow end of the current source.\n\n\n9/5/2017\nAfter doing some verification testing with inductors and capacitors, it seems that inductors are not being treated correctly. According to some research, inductor stamp affects the B,C and D arrays. Erik Cheever’s code puts inductors into the G matrix as 1/s/L. LTspice results are different than the python code. Capacitors seem to work OK. Plan is to add controlled sources, then get inductors working.\n\n\n9/6/2017\nopamp_test_circuit_426 is not working. Results not the same as LTspice Chebyshev_LPF_1dB_4pole: cut off frequency not correct, other features look OK still need to debug opamps and inductors Adding: VCCS = G type branch element: G needs to be modified CCVS = H type branch element: B, C and D need to be modified\n\n\n9/10/2017\nresearching formulation of B matrix what about a network with only 1 current source? The B, C and D matrix would be 0 by 0. Think about changing the name of the G matrix to Yr, to keep same as Ho’s IEEE paper.CCVS = H type branch element: B, C and D need to be modifiedCCCS = F type branch element: B, C and D need to be modifiedVCCS = G type branch element: G needs to be modifiedVCVS = E type branch element: B and C need to be modifiedFor CCCS = F type branch elements and CCVS = H type branch elements, need to add a zero volt voltage source to the net list through which the current flows. It is necessary to add to the net list one extra voltage source for every F and H type element.\n\n\n9/12/2017\nstill working on the B matrix\n\n\n9/18/2017\nstill debugging B matrix, looks like we don’t need find_vname() or df2. This is because a zero volt voltage source is add to the netlist in spice. need to add cccs type to the list of i_unk. Filled out some B matrices by hand and got the same answer as the code.\n\n\n9/30/2017\ndebugging B, C & D matricesvcvs is a E type element and sympy didn’t like it, fixed problem in parser by changing the lable E to Ea. Also changed the E matrix name to Ev. Code seems to run, just need to verify it. Need to find a new name for func1.\n\n\n10/1/2017\nCleaning up comments and notes.\n\n\n10/4/2017\nFixed incrementing of sn in D matrix. D matrix needs to count all i_unks. In find_vnam() fixed col_num to return just the row number in df2.\n\n\n10/5/2017\nFixed E type in matrix C. Added cccs to i_unk count. Fixed E type in D. Fixed J matrix. need to look at the equations next, they don’t look correct.\n\n\n10/7/2017\nUpdates to the comments. Verifying equations with hand generated KCL equations. Fixed H type in D.\n\n\n10/9/2017\nStill verifying code. Fixed F type in C. Still need to verify op amps, inductors and capacitors.\n\n\n11/19/2017\nFixing some documentation.\n\n\n11/30/2017\nFixing C matrix for op amps, one test case ran OKChen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the opamp stamp.\n\n\n12/2/2017\nAdded code for coupled inductors, not tested yet.\n\n\n12/6/2017\nTesting code for coupled inductors. Changes made to D matrix code. test_circuit_9 seems to give the correct results.\n\n\n18 Feb 2022\nNoticed a bug when independent voltage source is last line in net list, moving to 1st line in netlist generated what seems like correct equations. Investigation continues. For now, ordering the net list with sources first seems to work. Problem is with generation of the Ev and J matrices. In this version, I corrected some grammer and spelling errors.\n\n\n11/14/2023\nNew version of Sympy does not support non-Expr objects in a Matrix. Code to generate the circuit equations towards the end of the notebook produced an error. This line generated the error: \\(equ[i] = Eq(eq\\_temp,Z[i])\\). See the note here for details. In SymPy 1.8 and earlier versions it was possible to put non-Expr elements in a Matrix and the matrix elements could be any arbitrary Python object. Corrections have been made in this notebook. At the time of dubugging this issue, I’m running sympy.__version__ = ‘1.11.1’\n\n\n29 Nov 2023\nProblem - When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.Solution - added code to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n\n1/9/2024\nCode for building matrix A was not including matrix D if i_unk == 1. The following line of code is new: \\(A[n,n] = D[0]\\) also with a comment. Added verification tests test_14 and test_15 for the case of i_unk == 1 and 0.\n\n\n1/16/2024\ncreated a function to implement smna, replaced warning print statements with raise Exception()\n\n\n\n\n\n\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  }
]