[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "About this book\nThis is the website is an online version of my book - Symbolic Modified Nodal Analysis using Python. Symbolic circuit analysis is a circuit analysis method that derives network equations with the circuit elements represented by symbols and the topology of the circuit described by a netlist.\nThis book was written in R Mark Down using plain text files and JupyterLab notebooks. The source files were rendered into a book using Quarto.\nSource code is available here.",
    "crumbs": [
      "About this book"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "Python module verions\nThe following verions were used in this book.\n\n\n\nTable 1: Python packages\n\n\n\n\n\n\n\n\n\nPackage\nversion\n\n\n\n\npython\n3.10.9\n\n\nJupyterLab notebook\n3.5.3\n\n\nNumPy\n1.23.5\n\n\nSymPy\n1.11.1\n\n\nSciPy\n1.10.0\n\n\nPandas\n1.5.3\n\n\nTabulate\n0.8.10\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8\n\n\n\n\n\n\n\n\nUpdate History\nThis book will be updated occasionally to fix typos, spelling and grammer mistakes. Additionally, new content will be added as new chapters are written.\n\n\n\ndate\ndescription\n\n\n\n\n29 Dec 2023\ntest version\n\n\n30 Dec 2023\nanother test update\n\n\n\n\n\nProject ToDo List\nSince this project is still under construction, I have a list of to dos.\n\nfinish comments in SymMNA.py code\nfix spelling of netlist\nchange usage of spice to SPICE and define\nfinish chapter 4\nadd summary to end of example notebook\nhave SymMNA return the netlist report\nuse N for network equations (N_sym, N), U for solved equations and H for system functions\nIn chapter 3, include the schematic capture procedure to generate the netlist\nthink about removing netlist file load, just embed the netlist\nupdate status in /Quarto_projects/Symbolic-Modified-Nodal-Analysis-using-Python/draft_docs/To Do List.odt\nrewrite tests and problems using smna()\n\nclean up narrative on all the tests\nadd comment to each test about generating a symbolic solution\nreview each schematic and remove spice directives\n\ntest 14 and 15 need writeups\n\nremove double spaces at end of sentences, except for md lists\nrewrite Two amplifier RIAA phono preamp\nupdate two port notebook\nupdate Thevenin notebook\nCreate new example problems\n\nSuperposition, polyphase and phasors\nLaplace transforms\nTransient circuit\nnon linear circuits, see YouTube MNA Introduction\n\nfinish Summary in state variable notebook\nadd narritave to Appendices chapter\nwhy is 2nd order BRF in appendix?\nmake change log a table\nspell and grammer check all files\n\n\n\nLinks to other projects\nSolving Engineering Problems using Python\n\n\nLicense\nThis work (includes python code, documentation, test circuits, etc.) is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\nShare — copy and redistribute the material in any medium or format\nAdapt — remix, transform, and build upon the material for any purpose, even commercially.\nhttps://creativecommons.org/licenses/by-sa/4.0/",
    "crumbs": [
      "About this book"
    ]
  },
  {
    "objectID": "Preface.html",
    "href": "Preface.html",
    "title": "Preface",
    "section": "",
    "text": "Survey of other symbolic circuit analysis code\nThe python code presented in this notebook is somewhat unique since python is open source, free and runs on a variety of platforms, the code presented in this ipython notebook is portable. As described in the About this book, this code is made available under a public domain licence and archived in a github repository.\nThere are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, TINA and Maple.\nSLiCAP is a symbolic linear analysis tool. SLiCAP runs in MATLAB.\nTINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some symbolic analysis capability.\nMaple is a mathematical package and there is an application note available describing it use in symbolic circuit analysis. The application note presents an method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.\nSymbolic Circuit Analysis is a web page devoted to symbolic circuit analysis.\nSAPWIN is a windows program package for symbolic and numerical simulation of analog circuits.\nLcapy is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Preface.html#chapter-contents",
    "href": "Preface.html#chapter-contents",
    "title": "Preface",
    "section": "Chapter contents",
    "text": "Chapter contents\nAfter the introduction, this book is organized into several parts. Chapter 2 describes the theory behind Modified Nodal Analysis. Chapter 3 walks through a circuit analysis problem from net list generation to AC analysis and generation of a Bode plot of the frequency response of the circuit. Chapter 4 provides a description of the Python function that implements the symbolic modified nodal analysis procedure. There are 13 circuits that were used to validate the Python code. These circuits range from simple circuits that you would find in text books, to complex circuits that would be very difficult to analyze if not for computers. There are also a couple of test circuits designed to generate sub-matrices of all zeros during the solution. The last part of the book is a collection of interesting circuits (at least to me) that showcase the power and ease which the Python code can solve circuit analysis problems. The appendices contain a code listing for the smna function and a change log of the history of the projects code development.\n\n\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific Computing. Numerical Recipes in c Book Set. Cambridge University Press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 JupyterLab\nAll the Python code is presented in JupyterLab notebooks.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#practical-network-size-for-symbolic-solutions",
    "href": "Introduction.html#practical-network-size-for-symbolic-solutions",
    "title": "1  Introduction",
    "section": "1.2 Practical network size for symbolic solutions",
    "text": "1.2 Practical network size for symbolic solutions\nTest circuit number 4, Chapter 8, has 26 branches, 13 nodes, 18 resistors, 4 independent sources and 4 dependent sources. A symbolic solution for this problem was taking too long on my i3 computer, so I interrupted the kernel, and proceeded with a numerical solution, which can be solved quite quickly.\nother comments to add\n\nwhy symbolic vs spice? because you want the network equations.\nif circuit is too large can still put in element values and get Laplace circuit equations\nother reasons\n\nAnother circuit, shown below, that needed to be interrupted during the symbolic solution was the 100 Hz low pass elliptic function filter which contains zeros and poles, see Chapter 26 for this circuit’s notebook.\n\n\n\nElliptic function low pass filter\n\n\nThe net list for this circuit is:\n* Elliptic function VCVS LPF\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7\nV1 1 0 1\nR5 6 0 10e3\nR6 7 6 44.2e3\nThe following circuit equations were generated by the MNA code in less than one second:\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\n\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\n\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\n\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\n\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\n\\(- C_{3} s v_{4} + I_{O} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{5} + v_{6} = 0\\)\nAfter about two hours running on an i3 machine a symbolic solution was obtained, but it’s too long to display and doesn’t offer too much insight into the function of the circuit.\nAfter substituting numerical values for the components, the following solution for the voltage at node 2 was obtained in less than one second.\n\\(\\frac{4.30028181226968 \\cdot \\left(1.0784981875 \\cdot 10^{-10} s^{3} + 2.263375 \\cdot 10^{-7} s^{2} + 0.000474999999999999 s + 1.0\\right)}{1.50943922351291 \\cdot 10^{-12} s^{4} + 4.7350839034956 \\cdot 10^{-9} s^{3} + 4.53071325287237 \\cdot 10^{-6} s^{2} + 0.00311443743767615 s + 1.0}\\)\nSee Chapter 25 for a reduced complexity version of the schematic above, for which a symbolic solution was obtained in less than one second.\nPython together with SymPy has enabled the ability to explore circuit analysis problems without having to resort to pages and pages of hand calculations and then to display the results with good looking graphics and equations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Theory.html",
    "href": "Theory.html",
    "title": "2  Theory",
    "section": "",
    "text": "2.1 Network equations\nThe network equations are a set of independent equations expressed in this code in matrix form. There is an equation for each node based on Kirchhoff’s current law and an equation for each current unknown. The current unknowns are the currents from the voltages sources, op amps, voltage controlled voltage sources, current controlled voltage sources, current controlled current sources and inductors.\nEquation 2.1 are the network equations in matrix form.\n\\[A\\cdot X = Z \\tag{2.1}\\]\nMatrix \\(A\\) describes the connectivity of the resistors, capacitors and G type (VCCS) circuit elements. The column vector \\(X\\) are the unknown node voltages and unknown currents terms from the voltage sources and inductors. The column vector \\(Z\\) is made of the known voltages and currents. The \\(A\\) matrix is formed by four sub matrices, \\(G\\), \\(B\\), \\(C\\) and \\(D\\), which are described below.\n\\[A = \\begin{bmatrix}G B\\\\C D\\end{bmatrix} \\tag{2.2}\\]\nThe matrix \\(G\\) is formed from the coefficients representing the KCL equations for each node. The positive diagonal of \\(G_{k,k}\\) are the conductance terms of the resistor and capacitor elements connected to node k. The off diagonal terms of \\(G_{k,j}\\) are the resistors and capacitor conductances connecting node k to node j. G type elements (VCCS) have input to the G matrix at the connection and controlling node positions.\nThe \\(B\\) matrix describes the connectivity of the unknown branch currents. Independent voltage sources, opamps, H, F and E type elements as well as inductors have inputs to the B matrix.\nThe \\(C\\) matrix describes the connectivity of the unknown branch currents and is mainly the transpose of \\(B\\) matrix, with the exception of the F type elements (CCCS) and includes the E type value.\nThe \\(D\\) matrix describes also connectivity of the unknown currents. The \\(D\\) matrix is composed of zeros unless there are controlled sources and inductors in the network.\nThe \\(X\\) vector is comprised of the \\(V\\) and \\(J\\) vectors as shown in Equation 2.3.\n\\[X = \\begin{bmatrix}V\\\\J\\end{bmatrix} \\tag{2.3}\\]\nThe \\(V\\) vector contains the node voltages which are the voltage unknowns to be solved for. The \\(J\\) vector contains the unknown currents from each voltage source.\nThe \\(Z\\) vector is comprised of the I and Ev vectors as shown Equation 2.4.\n\\[Z = \\begin{bmatrix}I\\\\Ev\\end{bmatrix} \\tag{2.4}\\]\nThe I vector contains the known currents and the Ev vector contains the known voltages. The name Ev is used because sympy uses e and E sometimes for the constant 2.71, sometimes called Euler’s number. The use of E or e as a symbol was causing some errors when the code was run.\nPutting all the parts together:\n\\[\\begin{bmatrix}G B\\\\C D\\end{bmatrix} \\cdot \\begin{bmatrix}V\\\\J\\end{bmatrix} = \\begin{bmatrix}I\\\\Ev\\end{bmatrix} \\tag{2.5}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#network-equations",
    "href": "Theory.html#network-equations",
    "title": "2  Theory",
    "section": "",
    "text": "2.1.1 Stamps\nStamps are templates for modifying the \\(B\\), \\(C\\) and \\(D\\) matrices and facilitate the construction of the matrices. The stamps used in this implementation of the MNA allow the circuit connections of the components to be used to directly populate the various matrices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#code-description",
    "href": "Theory.html#code-description",
    "title": "2  Theory",
    "section": "2.2 Code description",
    "text": "2.2 Code description\nThe code is divided in the following sections.\nPreprocessor: The preprocessor reads in the netlist text file and removes comments, extra spaces and blank lines. The first letter of the element type is capitalized to make subsequent parsing of the file easier. The number of lines are counted and the number of entries on each line are checked to make sure the count is consistent with the element type.\nParser: The parser code loads the preprocessed netlist into a data frame. A report is generated which consists of a count of the element types in the netlist.\nMatrix formulation: Each of the matrices and vectors are generated.\nCircuit equation generation: The circuit equations are generated in a loop. Sympy automatically does some simplification according to its default settings. Two for loops perform the matrix multiplication on the equation: \\(A\\cdot X = Z\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#netlist-file-format",
    "href": "Theory.html#netlist-file-format",
    "title": "2  Theory",
    "section": "2.3 Netlist file format",
    "text": "2.3 Netlist file format\nThe input file which describs the circuit is a text file called the net list. A netlist consists of a statements defining each circuit element and its connection to circuit nodes. A node is a any point on a circuit where two or more circuit elements meet. The nodes are numbered from 1 to N in any order and node 0 is the ground node or circuit common. A ground node is required. Choose a ground or reference node, which usually is taken to be at a potential of zero volts. All other node voltages constitute n unknowns. The nodes should be numbered in consecutive order. Each line in the netlist are either comments, spice directives or circuit elements.\nSpice directives are commands to spice and the first character on the line is a period. Comment lines start with a * or ;. The default file extension is ‘.net’. The python code does some preprocessing of the netlist to check the basic formatting of the netlist is correct.\nThe preprocessor performs the following steps:\n\nremove blank lines and comments\n\nconvert first letter of element name to uppercase\n\nremoves extra spaces between entries\n\ncounts number of entries on each line to make sure the count is correct and counts each element type\n\nThe element types that are supported are resistors, capacitors, inductors, independent sources and controlled sources. Each line in the netlist file contains a circuit element.\nThe format for the element description is\nletterXXX n1 n2 value\nWhere\nletter signifies the element type, i.e. R, L, C, V, I, O, E, F, G, H or K\nXXX is a string of letters or numbers that uniquely identify the element.\nThe element types are described in the following sections.\n\n2.3.1 Resistors, capacitors and inductors\nThe resistors, capacitors and inductors are described by the following line:\nR/L/CXXXXXXX N1 N2 value\nWhere:\nXXX = the name of the component, can be any length\nN1 = the first terminal\nN2 = the second terminal\nValue = component value in ohms, Farads or Henrys.\nFor example, a resistor named R1 connected between nodes 1 and 2 with a value of 3000 ohms.\nR1 2 4 3000\nSpice supports other parameters, but these are not allowed in this python implementation.\n\n\n2.3.2 Coupled inductors\nTwo coupled inductors are described by the following line.\nKXX LYY LZZ VALUE\nThe parameters are:\nLYY = the name of the first coupled inductor\nLZZ = the name of the second coupled inductor\nVALUE = the coefficient of coupling, K, where 0 &lt; K\nThe orientation of the inductors is determined by the first node, which is considered to be the dotted node. When LTspice generates a net list the phasing dot gets assocated with the negative node. This does not seem to affect the equations generated by the python code. LTspice uses the coupling coefficient, k. The symbolic equations use the mutual inductance, M as shown in Equation 2.6.\n\\[M = k\\sqrt{L_1L_2} \\tag{2.6}\\]\n\n\n2.3.3 Independent sources\nA voltage source is described by the following line.\nVXX N+ N- VALUE\nThe parameters are:\nN+ = the name of the positive terminal\nN- = the name of the negative terminal\nVALUE = the value of the DC voltage\nA current source is described by the following line.\nIXX N+ N- VALUE\nThe parameters are:\nN+= the name of the positive terminal, current leaves this terminal (pointy end of the arrow)\nN- = the name of the negative terminal\nVALUE = the value of the DC current\n\n\n2.3.4 Controlled sources\nThe voltage-controlled dependent sources are defined using statements of the form\nG/EXX nout+ nout- nc+ nc- gain\nwhere E is a voltage-controlled voltage source, G is a voltage-controlled current source, the output voltage is connected between nodes nout+ and nout-, and the control voltage is measured at node nc+ with respect to node nc-.\nExamples:\nE1 5 1 4 3 10 defines a voltage source that makes node 5 a voltage 10 times (v4 − v3) above the voltage at node 1.\nG1 2 1 5 8 50 defines a current source connected between node 2 (the + node) and node 1 and supplying a current 50 times (v5 − v8).\nThe current-controlled dependent sources are defined by statements of the form\nF/HXX nout+ nout- vcontrol gain\nwhere F is a current-controlled current source, H is a current-controlled voltage source, and the output current source is connected between nodes nout+ and nout-, with positive current flowing through the source from node nout+ to nout-. The control current flows from the positive node of the source vcontrol through the source and out the negative node.\nExamples:\nFds 11 9 Vsens 1.25 defines a current source connected from node 11 to node 9 that generates a current 1.25 times the current flowing through the source Vsens.\nH1 30 20 V5 100 defines a voltage source connected from node 30 to node 20 and supplying a voltage 100 times the current through the source V5. It is frequently necessary to add a voltage source with value 0 V to the circuit to sense the control current for these sources.\nThe direction of positive controlling current flow is from the positive node, through the source, to the negative node of VNAM. VALUE is the current gain.\n\n\n2.3.5 Op Amps\nAn opamp component is described by the following line.\nOXX N+ N- Vout\nThe output of the opamp is a voltage source. Two input terminals are at the same potential.\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results will be likely erroneous. Need to work on implementing a better opamp model.\nExample procedure:\n1. Draw the circuit to be analyzed in LTSpice or some other schematic capture program. Label the nodes. The Symbolic Modified Network Analysis code will provide warnings for netlist formatting errors and non consecutive node numbering, but will still generate nodal equations which may be erroneous. Users should verify the results.\n2. Export the netlist of the circuit and convert component values to units of Ohms, Farads and Henrys. Use scientific notation, for example, replace component values such as 2k with 2e3 and 2u with 2e-6.\n3. Change Op Amp reference designators, for example U1 to O1 (capitol letter O, not zero).\n4. Voltage sources and current sources need to be set to zero in some cases. See test circuits and problem circuits for examples.\n5. Modify the nodal analysis Jupyter notebook code to read the net list. Run all the cells in the notebook.\n6. Copy the symbol list, the A, X and Z matrices, and the element values in dictionary format to a new notebook. See end of the nodal analysis Jupyter notebook where these items are displayed.\n7. Follow the test and problem circuits for examples on how to do additional circuit analysis.\n\n\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html",
    "href": "SMNA_example.html",
    "title": "3  SMNA Example",
    "section": "",
    "text": "3.1 Introduction\nThis chapter walks through the Python code used to generate and solve the circuit network equations. Figure 3.1 is the schematic for the circuit used in this example. The analysis procedure first requires a circuit net list, which can be gernerated by hand with a text editor. For small circuits, such as those found in circuit analysis text books, this is not to difficult since the number of nodes and components is small. College Text book problems are usually ment by the authors to be solved with pencil and paper by hand. In this example LTSpice was used to draw the schematic and label the components and nodes. Most schematic caputure programs had the ability to export a Spice net list, which then can be pasted in to the procedure outlined here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#circuit-description",
    "href": "SMNA_example.html#circuit-description",
    "title": "3  SMNA Example",
    "section": "3.2 Circuit description",
    "text": "3.2 Circuit description\nThe circuit in Figure 3.1 is a 2nd order band pass filter with magnetic coupling. The netlist generated by LTSpice is shown below.\nV1 1 0 AC 1\nR1 3 1 1k\nR4 2 0 10k\nC1 3 0 0.01µ\nC2 2 0 0.01µ\nL1 4 0 1µ\nL2 5 0 1µ\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe LTSpice net list requires some editing. The line that defines the independent AC source, V1, needs to be formated as it it were a DC source. For symbolic analysis we are only concerned with the label for the source at this time. Later, in the example an AC analysis will be performed and \\(j \\omega\\) will be sustituted for the Laplace variable, \\(s\\). Also, the suffixes that SPICE allows in the compent values e.g., k and \\(\\mu\\), need to be replaced by their corresponding multiplication factors as shown below.\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe following Python modules are used:\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom tabulate import tabulate\ninit_printing()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#symbolic-mna-code",
    "href": "SMNA_example.html#symbolic-mna-code",
    "title": "3  SMNA Example",
    "section": "3.3 Symbolic MNA code",
    "text": "3.3 Symbolic MNA code\nA count of the component types are initialized to zero.\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "href": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "title": "3  SMNA Example",
    "section": "3.4 Read the net list and preprocess it",
    "text": "3.4 Read the net list and preprocess it\nThe circuit netlist is paseted into the code cell below. A new line character is required at the end of each line and the tripple quotes in the code cell below preserve the line breaks.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\n'''\n\nThe code cell below peformes the following operations:\n\nsplit the net list into a list of lines at the line breaks\nremove blank lines and comments\n\nconvert first letter of element name to upper case\n\nremoves extra spaces between entries\n\n\ncontent = net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove spice directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\n# display the cleaned up netlist\nfor i in content:\n    print(i)\n\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 l1 l2 0.15\n\n\n\n3.4.1 Process each line in the netlist\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#parser",
    "href": "SMNA_example.html#parser",
    "title": "3  SMNA Example",
    "section": "3.5 Parser",
    "text": "3.5 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTspice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: opamp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n3.5.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n3.5.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n# Check for position of voltages sources in the dataframe.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # re-order the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#print-net-list-report",
    "href": "SMNA_example.html#print-net-list-report",
    "title": "3  SMNA Example",
    "section": "3.6 Print net list report",
    "text": "3.6 Print net list report\n\n# print a report\nprint('Net list report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 3\nnumber of RLC (passive components): 8\nnumber of inductors: 2\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 1\n\n\n\ndf\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n3\n1\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n2\nR4\n2\n0\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n3\nC1\n3\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n4\nC2\n2\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nL1\n4\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n6\nL2\n5\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n7\nR2\n4\n3\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nR3\n2\n5\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n9\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.15\nNaN\nL1\nL2\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nL1\n4\n0\n\n\n2\nL2\n5\n0\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed\n\n\n# initialize some symbolic matrix with zeros\n# A is formed by [[G, C] [B, D]]\n# Z = [I,E]\n# X = [V, J]\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\nDebugging notes: Is it possible to have i_unk == 0 ?, what about a network with only current sources? This would make B = 0 for example. Did one test, need to run others\nIs there a valid op amp case where B is n by 1? See test_14 and test_15.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#g-matrix",
    "href": "SMNA_example.html#g-matrix",
    "title": "3  SMNA Example",
    "section": "3.7 G matrix",
    "text": "3.7 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}}\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#b-matrix",
    "href": "SMNA_example.html#b-matrix",
    "title": "3  SMNA Example",
    "section": "3.8 B Matrix",
    "text": "3.8 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The code loop through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & 0\\\\0 & 1 & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#c-matrix",
    "href": "SMNA_example.html#c-matrix",
    "title": "3  SMNA Example",
    "section": "3.9 C matrix",
    "text": "3.9 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\n3.9.1 Op Amp elements\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results likely will be erroneous. Chen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the opamp stamp.\n\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#d-matrix",
    "href": "SMNA_example.html#d-matrix",
    "title": "3  SMNA Example",
    "section": "3.10 D matrix",
    "text": "3.10 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n\nm = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes: 12/6/2017 doing some debugging on with coupled inductors; LTspice seems to put the phasing dot on the neg node when it generates the netlist. This code uses M for mutual inductance, LTspice uses k for the coupling coefficient.\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0\\\\0 & - L_{1} s & - M_{1} s\\\\0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#v-matrix",
    "href": "SMNA_example.html#v-matrix",
    "title": "3  SMNA Example",
    "section": "3.11 V matrix",
    "text": "3.11 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#j-matrix",
    "href": "SMNA_example.html#j-matrix",
    "title": "3  SMNA Example",
    "section": "3.12 J matrix",
    "text": "3.12 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{L1}\\\\I_{L2}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#i-matrix",
    "href": "SMNA_example.html#i-matrix",
    "title": "3  SMNA Example",
    "section": "3.13 I matrix",
    "text": "3.13 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ev-matrix",
    "href": "SMNA_example.html#ev-matrix",
    "title": "3  SMNA Example",
    "section": "3.14 Ev matrix",
    "text": "3.14 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#z-matrix",
    "href": "SMNA_example.html#z-matrix",
    "title": "3  SMNA Example",
    "section": "3.15 Z matrix",
    "text": "3.15 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#x-matrix",
    "href": "SMNA_example.html#x-matrix",
    "title": "3  SMNA Example",
    "section": "3.16 X matrix",
    "text": "3.16 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#a-matrix",
    "href": "SMNA_example.html#a-matrix",
    "title": "3  SMNA Example",
    "section": "3.17 A matrix",
    "text": "3.17 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n    A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}} & 0 & 0 & 0\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0 & 0 & 1 & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 1\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & - L_{1} s & - M_{1} s\\\\0 & 0 & 0 & 0 & 1 & 0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#generate-the-circuit-equations",
    "href": "SMNA_example.html#generate-the-circuit-equations",
    "title": "3  SMNA Example",
    "section": "3.18 generate the circuit equations",
    "text": "3.18 generate the circuit equations\n\nequ = Eq(A*Matrix(X),Matrix(Z))\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\\\v_{2} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}}\\\\v_{3} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\\\I_{L1} - \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}}\\\\I_{L2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{5}}{R_{3}}\\\\v_{1}\\\\- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{4}\\\\- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#symbolic-solution",
    "href": "SMNA_example.html#symbolic-solution",
    "title": "3  SMNA Example",
    "section": "3.19 Symbolic solution",
    "text": "3.19 Symbolic solution\n\n# turn the free symbols into SymPy variables\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{4}, \\  v_{1}, \\  v_{2}, \\  C_{2}, \\  R_{2}, \\  v_{5}, \\  M_{1}, \\  L_{1}, \\  V_{1}, \\  I_{L2}, \\  I_{L1}, \\  L_{2}, \\  v_{3}, \\  R_{3}, \\  s, \\  R_{1}, \\  I_{V1}, \\  v_{4}, \\  C_{1}\\right)\\)\n\n\n\nsymbolic_solution = solve(equ,X) # solve the equations\n\nThe transfer function at node 2 is:\n\nH_sym = symbolic_solution[v2]/symbolic_solution[v1]\nH_sym\n\n\\(\\displaystyle \\frac{M_{1} R_{4} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\n\n\nThe transfer function can be cleaned up with the help of SymPy. The coefficients of the Laplace term can be collected.\n\nH_sym.collect(s)\n\n\\(\\displaystyle \\frac{M_{1} R_{4} s}{R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)}\\)\n\n\nThe numerator and denominator can be extraxed from the expression.\n\nnum_sym, denom_sym = fraction(H_sym)\n\n\nnum_sym\n\n\\(\\displaystyle M_{1} R_{4} s\\)\n\n\n\ndenom_sym\n\n\\(\\displaystyle C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}\\)\n\n\nThe terms in the denominator can be collected by power of \\(s\\).\n\ndenom_sym.collect(s)\n\n\\(\\displaystyle R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)\\)\n\n\n\n#solve(denom_sym,s)\n\nThe code above was taking a long time, so it was interrupted and commented out.\n\n3.19.1 Built a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:f},'.format(df.iloc[i]['element'].lower(),df.iloc[i]['value']))\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:.4e},'.format(df.iloc[i]['element'],df.iloc[i]['value']))\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nThe mutual inductance between L1 and L2 is calculated from the coupling coeeficient.\n\\(M = k\\sqrt{L_1L_2}\\)\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.000000150\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  K_{1} : 0.15, \\  L_{1} : 1.0 \\cdot 10^{-6}, \\  L_{2} : 1.0 \\cdot 10^{-6}, \\  M_{1} : 1.5 \\cdot 10^{-7}, \\  R_{1} : 1000.0, \\  R_{2} : 0.5, \\  R_{3} : 0.5, \\  R_{4} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#numeric-solution",
    "href": "SMNA_example.html#numeric-solution",
    "title": "3  SMNA Example",
    "section": "3.20 Numeric solution",
    "text": "3.20 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ1a = equ.subs(element_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.0001\\right) - 2.0 v_{5}\\\\- 0.001 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.001\\right) - 2.0 v_{4}\\\\I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\\\I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\\\v_{1}\\\\- 1.0 \\cdot 10^{-6} I_{L1} s - 1.5 \\cdot 10^{-7} I_{L2} s + v_{4}\\\\- 1.5 \\cdot 10^{-7} I_{L1} s - 1.0 \\cdot 10^{-6} I_{L2} s + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s and displaying the transfer function.\n\nU = solve(equ1a,X)\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\nThe numerator and denominator can be extraxed from the expression.\n\nnum, denom = fraction(H)\n\n\nnum\n\n\\(\\displaystyle 6.0 \\cdot 10^{20} s\\)\n\n\n\ndenom\n\n\\(\\displaystyle 391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}\\)\n\n\nThe roots of the denominator can be obtained with the solve function.\n\nsolve(denom,s)\n\n\\(\\displaystyle \\left[ -321649.557914015 - 10842889.0903087 i, \\  -321649.557914015 + 10842889.0903087 i, \\  -244859.393492634 - 9323420.66838014 i, \\  -244859.393492634 + 9323420.66838014 i\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ac-analysis",
    "href": "SMNA_example.html#ac-analysis",
    "title": "3  SMNA Example",
    "section": "3.21 AC analysis",
    "text": "3.21 AC analysis\nSolve equations a frequency of 1.491MHz or \\(\\omega\\) equal to 9.3682292e6 radians per second, s = 9.3682292e6j.\n\nequ1a_1rad_per_s = equ1a.subs({s:9.3682292e6j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\v_{2} \\cdot \\left(2.0001 + 0.093682292 i\\right) - 2.0 v_{5}\\\\- 0.001 v_{1} + v_{3} \\cdot \\left(2.001 + 0.093682292 i\\right) - 2.0 v_{4}\\\\I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\\\I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\\\v_{1}\\\\- 9.3682292 i I_{L1} - 1.40523438 i I_{L2} + v_{4}\\\\- 1.40523438 i I_{L1} - 9.3682292 i I_{L2} + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in ans1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.101262    -21.012442\nv3         0.101577     -5.111761\nv4         0.101240     -2.443264\nv5         0.101378    -18.330736\nI_V1       0.000899   -179.423099\nI_L1       0.009469    -89.691641\nI_L2       0.009486   -111.073602",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ac-sweep",
    "href": "SMNA_example.html#ac-sweep",
    "title": "3  SMNA Example",
    "section": "3.22 AC Sweep",
    "text": "3.22 AC Sweep\nLooking at node 2 voltage.\n\nH = u1[v2]/u1[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\n\nx = np.logspace(6, 6.5, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w/(2*np.pi), phase,':',color='b')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('peak: {:.2f} dB at {:.3f} MHz'.format(mag.max(),w[np.argmax(mag)]/(2*np.pi)/1e6,))\n\npeak: -19.89 dB at 1.490 MHz",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#summary",
    "href": "SMNA_example.html#summary",
    "title": "3  SMNA Example",
    "section": "3.23 Summary",
    "text": "3.23 Summary\nIn this chapter a walk through of the Python code that implements the symbolic MNA procedure was presented. The network equations in symbolic form were solved and the filter’s symbolic transfer function was obtained. Then the component values were substitued into the network equations and solved again. The node voltages were obtained at a descreat frequency and then an AC sweep was done for the transfer function.\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA-function.html",
    "href": "SMNA-function.html",
    "title": "4  SMNA function",
    "section": "",
    "text": "4.1 AC analysis\nAn AC analysis of the circuit can also be performed by substituting \\(j \\omega\\) for \\(s\\) in the network equations and solving for the voltage at any desired node. The independent voltage source can be adjusted to a different amplitude and phase.\nFor example, we can change the independent voltage source, V1, to have an an amplitude of 10 at a frequency of 10 Hz with a phase of shift of 30 degrees.\nsource_amp = 10\nsource_phase = 30 # phase in degrees\nnew_V1 = source_amp*np.exp(1j*(source_phase*np.pi/180))\n\nfreq_Hz = 10 #Hz\nw = 2*np.pi*freq_Hz # radian frequency\n\nelement_values[V1] = new_V1\nequ_Nw = equ.subs(element_values)\nequ_Nw = equ_Nw.subs({s:1j*w})\nequ_Nw  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.00166666666666667 v_{1} - 0.00166666666666667 v_{2}\\\\I_{L1} - 0.00166666666666667 v_{1} + v_{2} \\cdot \\left(0.00166666666666667 + 2.38761041672824 \\cdot 10^{-5} i\\right)\\\\- I_{L1} + v_{3} \\cdot \\left(0.00166666666666667 + 2.38761041672824 \\cdot 10^{-5} i\\right)\\\\v_{1}\\\\- 9.55044166691297 i I_{L1} + v_{2} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\8.66025403784439 + 5.0 i\\\\0\\end{matrix}\\right]\\)\nAgain, we can use the SymPy function, solve, to get a solution for \\(V_1 = 10 sin(2 \\pi 10 t + 30)\\) and print the unknown voltages and currents.\nU_Nw = solve(equ_Nw,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_Nw .items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1         10.000000     30.000000\nv2          4.999392     29.635345\nv3          4.999899     28.723214\nI_V1        0.008335   -149.635448\nI_L1        0.008334     29.543958\nThe values obtained from the Python code agree with the results from LTSpice.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SMNA function</span>"
    ]
  },
  {
    "objectID": "SMNA-function.html#summary",
    "href": "SMNA-function.html#summary",
    "title": "4  SMNA function",
    "section": "4.2 Summary",
    "text": "4.2 Summary\nIn this chapter the use of the function smna(net_list) was described and an example circuit was analyzed.\n\n\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SMNA function</span>"
    ]
  },
  {
    "objectID": "Validation-tests.html",
    "href": "Validation-tests.html",
    "title": "Validation tests",
    "section": "",
    "text": "Basic validation of the Python code consisted of analyzing simple networks and examining the results. A more comprehensive evaluation of the code was performed by solving test circuits and comparing the results to LTSpice. Table Validation circuits lists the circuits that were used for validation. The validation circuits are a collection of problems from text books or large and complex circuits that I made up that include various elements or unique combinations of elements or topologies. The circuits range from simple to large and complex. The largest circuit consist of 32 nodes, 59 branches and multiple instances all of the supported element types.\nIn LTSpice the series resistance for inductors defaults to 1e-3 Ohms unless set to zero. Leaving the default series inductance at 1e-3 Ohms will cause small numerical differences in the solution obtained by LTSpice.\nCode verification often looks at requirements or specifications versus what was implemented. This project didn’t have a formal set of requirements, only a general goal of implementing symbolic MNA using the Python libraries. No formal software or code verification is included.\nAlso see Table Test circuit files\n\n\n\nTable 1: Validation circuits\n\n\n\n\n\n\n\n\n\n\nTest file\nCircuit Description\nnotes\n\n\n\n\ntest_1\nResistors, independent and dependent sources\nDC analysis\n\n\ntest_2\nResistors and independent sources\nDC analysis\n\n\ntest_3\nSame as test_1, with R2 replaced with C2 and R3 replaced with L1\nAC analysis\n\n\ntest_4\nResistors and one of each type of source\nAC analysis\n\n\ntest_5\nRLC and one of each type of source\nAC analysis\n\n\ntest_6\nRLC, coupled inductors and one of each type of source\nAC analysis\n\n\ntest_7\nLarge circuit and two or more of each element type w/o Op Amps\nAC analysis\n\n\ntest_8\nTest_7 w/ op amps included\nAC analysis\n\n\ntest_9\nCurrent sources only dependent and independent\nDC analysis\n\n\ntest_10\nCurrent and voltage sources only, no LRCs\nDC analysis\n\n\ntest_11\nThree coupled inductors\nAC analysis\n\n\ntest_12\nLC ladder low pass filter\nAC analysis\n\n\ntest_13\nRing of current sources and inductors\nAC analysis\n\n\ntest_14\nA circuit with one unknown current\nAC analysis\n\n\ntest_15\nA circuit with no unknown currents\nAC analysis\n\n\n\n\n\n\n \nThe following file types are in each github folder located here:\n\n\n\nTable 2: Test circuit files\n\n\n\n\n\n\n\n\n\nfile name\nDescription\n\n\n\n\ntest_*.asc\nLTSpice circuit schematic\n\n\nreadme.md\na description of the circuit\n\n\ntest_*.ipynb\ntest report Jupyter notebook\n\n\ntest_*.net\nSpice net list\n\n\ntest_*.png\nimage of the schematic for display in the notebook\n\n\ntest_*.csv\ncsv data exported from LTSpice",
    "crumbs": [
      "Validation tests"
    ]
  },
  {
    "objectID": "test_1.html",
    "href": "test_1.html",
    "title": "5  test_1",
    "section": "",
    "text": "5.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- I_{1} R_{1} R_{2} ea_{1} f_{1} + I_{1} R_{1} R_{2} ea_{1} - I_{1} R_{1} R_{2} f_{1} + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{4} ea_{1} + I_{1} R_{1} R_{4} + R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} f_{1} + R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} f_{1} + R_{2} V_{1} f_{1} - R_{2} V_{1} + R_{3} V_{1} f_{1} + R_{3} V_{2} f_{1} - R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}, \\  I_{F1} : \\frac{V_{1} f_{1} + V_{2} f_{1}}{R_{2} f_{1} - R_{2} - R_{4}}, \\  I_{V1} : \\frac{- I_{1} R_{2} R_{3} f_{1} + I_{1} R_{2} R_{3} + I_{1} R_{3} R_{4} - R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} ea_{1} - R_{1} V_{1} f_{1} + R_{1} V_{1} - R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} ea_{1} - R_{1} V_{2} f_{1} + R_{1} V_{2} - R_{2} V_{1} f_{1} + R_{2} V_{1} - R_{3} V_{1} f_{1} + R_{3} V_{1} - R_{3} V_{2} f_{1} + R_{3} V_{2} + R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}, \\  I_{V2} : \\frac{V_{1} + V_{2}}{R_{2} f_{1} - R_{2} - R_{4}}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{- R_{2} V_{2} f_{1} + R_{2} V_{2} - R_{4} V_{1}}{R_{2} f_{1} - R_{2} - R_{4}}, \\  v_{3} : \\frac{I_{1} R_{1} R_{3} ea_{1} + R_{1} V_{1} ea_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}, \\  v_{4} : \\frac{- I_{1} R_{1} R_{3} + R_{1} V_{1} ea_{1} + R_{3} V_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}, \\  v_{5} : - V_{2}\\right\\}\\)\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\nv₁ = V₁\n     -R₂⋅V₂⋅f₁ + R₂⋅V₂ - R₄⋅V₁\nv₂ = ─────────────────────────\n          R₂⋅f₁ - R₂ - R₄     \n     I₁⋅R₁⋅R₃⋅ea₁ + R₁⋅V₁⋅ea₁\nv₃ = ────────────────────────\n         R₁⋅ea₁ + R₁ + R₃    \n     -I₁⋅R₁⋅R₃ + R₁⋅V₁⋅ea₁ + R₃⋅V₁\nv₄ = ─────────────────────────────\n            R₁⋅ea₁ + R₁ + R₃      \nv₅ = -V₂\n       -I₁⋅R₂⋅R₃⋅f₁ + I₁⋅R₂⋅R₃ + I₁⋅R₃⋅R₄ - R₁⋅V₁⋅ea₁⋅f₁ + R₁⋅V₁⋅ea₁ - R₁⋅V₁⋅f\nI_V1 = ───────────────────────────────────────────────────────────────────────\n                                                          R₁⋅R₂⋅ea₁⋅f₁ - R₁⋅R₂\n\n₁ + R₁⋅V₁ - R₁⋅V₂⋅ea₁⋅f₁ + R₁⋅V₂⋅ea₁ - R₁⋅V₂⋅f₁ + R₁⋅V₂ - R₂⋅V₁⋅f₁ + R₂⋅V₁ - R\n──────────────────────────────────────────────────────────────────────────────\n⋅ea₁ + R₁⋅R₂⋅f₁ - R₁⋅R₂ - R₁⋅R₄⋅ea₁ - R₁⋅R₄ + R₂⋅R₃⋅f₁ - R₂⋅R₃ - R₃⋅R₄        \n\n₃⋅V₁⋅f₁ + R₃⋅V₁ - R₃⋅V₂⋅f₁ + R₃⋅V₂ + R₄⋅V₁\n──────────────────────────────────────────\n                                          \n           V₁ + V₂    \nI_V2 = ───────────────\n       R₂⋅f₁ - R₂ - R₄\n        -I₁⋅R₁⋅R₂⋅ea₁⋅f₁ + I₁⋅R₁⋅R₂⋅ea₁ - I₁⋅R₁⋅R₂⋅f₁ + I₁⋅R₁⋅R₂ + I₁⋅R₁⋅R₄⋅ea\nI_Ea1 = ──────────────────────────────────────────────────────────────────────\n                                                       R₁⋅R₂⋅ea₁⋅f₁ - R₁⋅R₂⋅ea\n\n₁ + I₁⋅R₁⋅R₄ + R₁⋅V₁⋅ea₁⋅f₁ + R₁⋅V₁⋅f₁ + R₁⋅V₂⋅ea₁⋅f₁ + R₁⋅V₂⋅f₁ + R₂⋅V₁⋅f₁ - \n──────────────────────────────────────────────────────────────────────────────\n₁ + R₁⋅R₂⋅f₁ - R₁⋅R₂ - R₁⋅R₄⋅ea₁ - R₁⋅R₄ + R₂⋅R₃⋅f₁ - R₂⋅R₃ - R₃⋅R₄           \n\nR₂⋅V₁ + R₃⋅V₁⋅f₁ + R₃⋅V₂⋅f₁ - R₄⋅V₁\n───────────────────────────────────\n                                   \n        V₁⋅f₁ + V₂⋅f₁ \nI_F1 = ───────────────\n       R₂⋅f₁ - R₂ - R₄",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>test_1</span>"
    ]
  },
  {
    "objectID": "test_1.html#numeric-solution",
    "href": "test_1.html#numeric-solution",
    "title": "5  test_1",
    "section": "5.2 Numeric solution",
    "text": "5.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nelement_values = {R1:2,R2:1,R3:1,R4:2,V1:2,V2:0,I1:9,f1:2,ea1:2}\nequ1a = equ.subs(element_values)\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{3 v_{1}}{2} - v_{2} - \\frac{v_{4}}{2}\\\\I_{F1} - v_{1} + \\frac{3 v_{2}}{2} - \\frac{v_{5}}{2}\\\\I_{Ea1} - I_{F1} + v_{3} - v_{4}\\\\- \\frac{v_{1}}{2} - v_{3} + \\frac{3 v_{4}}{2}\\\\- I_{V2} - \\frac{v_{2}}{2} + \\frac{v_{5}}{2}\\\\v_{1}\\\\- v_{5}\\\\- 2 v_{1} + v_{3} + 2 v_{4}\\\\I_{F1} - 2 I_{V2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\-9\\\\0\\\\2\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations for voltages and currents.\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : - \\frac{80}{7}, \\  I_{F1} : -4, \\  I_{V1} : \\frac{3}{7}, \\  I_{V2} : -2, \\  v_{1} : 2, \\  v_{2} : 4, \\  v_{3} : \\frac{44}{7}, \\  v_{4} : - \\frac{8}{7}, \\  v_{5} : 0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:s}: {:f}'.format(str(name),float(value)))\n    #print(name,value)\n\nv1: 2.000000\nv2: 4.000000\nv3: 6.285714\nv4: -1.142857\nv5: 0.000000\nI_V1: 0.428571\nI_V2: -2.000000\nI_Ea1: -11.428571\nI_F1: -4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\nCurrents through the resistors must be calculated by hand. For example:\n\nprint('I(R1): {:f}'.format(float((ans[v1]-ans[v4])/element_values[R1])))\n\nI(R1): 1.571429\n\n\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>test_1</span>"
    ]
  },
  {
    "objectID": "test_2.html",
    "href": "test_2.html",
    "title": "6  test_2",
    "section": "",
    "text": "6.1 Symbolic solution\nSymbolic solution for this test case takes too long.\nans = solve(equ,X) ans\nleft_side = list(ans.keys()) right_side = list(ans.values())\nfor i in range(len(ans)): pprint(Eq(left_side[i],right_side[i]))",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>test_2</span>"
    ]
  },
  {
    "objectID": "test_2.html#numeric-solution",
    "href": "test_2.html#numeric-solution",
    "title": "6  test_2",
    "section": "6.2 Numeric solution",
    "text": "6.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nequ1a = equ.subs({\n    R1:5.000000,\n    R2:2.000000,\n    R5:3.000000,\n    R6:5.000000,\n    R8:8.000000,\n    R10:9.000000,\n    R11:4.000000,\n    R12:2.000000,\n    R14:10.000000,\n    R15:5.000000,\n    V1:10.000000,\n    V2:2.000000,\n    V3:3.000000,\n    V4:5.000000,\n    I1:3.000000,\n    I2:1.000000,\n    I3:2.000000,\n    I4:2.000000,\n    R7:10.000000,\n    R16:6.000000,\n    R3:10.000000,\n    R4:3.000000})\n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{5}\\\\- 0.5 v_{1} + 1.03333333333333 v_{2} - 0.333333333333333 v_{6}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\- 0.333333333333333 v_{3} + 0.433333333333333 v_{4} - 0.1 v_{8}\\\\- 0.5 v_{1} + 0.95 v_{5} - 0.25 v_{6} - 0.2 v_{9}\\\\- 0.333333333333333 v_{2} - 0.25 v_{5} + 0.683333333333333 v_{6} - 0.1 v_{7}\\\\I_{V3} + I_{V4} - 0.1 v_{6} + 0.225 v_{7} - 0.125 v_{8}\\\\- 0.1 v_{4} - 0.125 v_{7} + 0.225 v_{8}\\\\I_{V1} - 0.111111111111111 v_{10} - 0.2 v_{5} + 0.311111111111111 v_{9}\\\\0.311111111111111 v_{10} - 0.2 v_{11} - 0.111111111111111 v_{9}\\\\- I_{V4} - 0.2 v_{10} + 0.3 v_{11} - 0.1 v_{12}\\\\- 0.1 v_{11} + 0.1 v_{12}\\\\v_{9}\\\\v_{1}\\\\- v_{3} + v_{7}\\\\- v_{11} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\-1.0\\\\1.0\\\\-3.0\\\\0\\\\2.0\\\\0\\\\-2.0\\\\0\\\\-2.0\\\\0\\\\2.0\\\\10.0\\\\2.0\\\\3.0\\\\5.0\\end{matrix}\\right]\\)\n\n\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{V1} : -3.16590349152627, \\  I_{V2} : 0.970285941816191, \\  I_{V3} : 1.07959596749632, \\  I_{V4} : -2.0475200955628, \\  v_{1} : 2.0, \\  v_{10} : -8.4276808600652, \\  v_{11} : -8.6652813378792, \\  v_{12} : 11.3347186621208, \\  v_{2} : 1.53248886344972, \\  v_{3} : -6.6652813378792, \\  v_{4} : -16.2367099093078, \\  v_{5} : 4.40808302018266, \\  v_{6} : 4.75071547669412, \\  v_{7} : -3.6652813378792, \\  v_{8} : -18.1414718140697, \\  v_{9} : 10.0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:5s}: {:11.5f}'.format(str(name),float(value)))\n    #print(name,value)\n\nv1   :     2.00000\nv2   :     1.53249\nv3   :    -6.66528\nv4   :   -16.23671\nv5   :     4.40808\nv6   :     4.75072\nv7   :    -3.66528\nv8   :   -18.14147\nv9   :    10.00000\nv10  :    -8.42768\nv11  :    -8.66528\nv12  :    11.33472\nI_V1 :    -3.16590\nI_V2 :     0.97029\nI_V3 :     1.07960\nI_V4 :    -2.04752\n\n\nThe results agree with the LTSpice answers.\n       --- Operating Point ---\n\nV(9):    10  voltage\nV(5):    4.40808     voltage\nV(1):    2   voltage\nV(6):    4.75072     voltage\nV(2):    1.53249     voltage\nV(8):    -18.1415    voltage\nV(7):    -3.66528    voltage\nV(10):   -8.42768    voltage\nV(11):   -8.66528    voltage\nV(3):    -6.66528    voltage\nV(4):    -16.2367    voltage\nV(12):   11.3347     voltage\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   1.11838     device_current\nI(R2):   1.20404     device_current\nI(R5):   1.07274     device_current\nI(R6):   0.306498    device_current\nI(R8):   -1.80952    device_current\nI(R10):  -2.04752    device_current\nI(R11):  0.0856581   device_current\nI(R12):  -0.233756   device_current\nI(R14):  -0.8416     device_current\nI(R15):  -0.0475201  device_current\nI(R7):   -0.190476   device_current\nI(R16):  -1.11088    device_current\nI(R3):   2   device_current\nI(R4):   -3.19048    device_current\nI(V1):   -3.1659     device_current\nI(V2):   0.970286    device_current\nI(V3):   1.0796  device_current\nI(V4):   -2.04752    device_current",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>test_2</span>"
    ]
  },
  {
    "objectID": "test_3.html",
    "href": "test_3.html",
    "title": "7  test_3",
    "section": "",
    "text": "7.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- C_{1} I_{1} R_{1} R_{2} ea_{1} s - C_{1} I_{1} R_{1} R_{2} s - C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} f_{1} s + C_{1} R_{2} V_{1} s + I_{1} R_{1} ea_{1} f_{1} - I_{1} R_{1} ea_{1} + I_{1} R_{1} f_{1} - I_{1} R_{1} - V_{1} f_{1} + V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}, \\  I_{F1} : \\frac{- C_{1} V_{1} f_{1} s - C_{1} V_{2} f_{1} s}{C_{1} R_{2} s - f_{1} + 1}, \\  I_{L1} : \\frac{- I_{1} R_{1} ea_{1} - I_{1} R_{1} + V_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  I_{V1} : \\frac{- C_{1} I_{1} L_{1} R_{2} s^{2} + C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{1} s^{2} + C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} L_{1} V_{2} s^{2} + C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} ea_{1} s + C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{1} s + C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} s + C_{1} R_{1} V_{2} f_{1} s - C_{1} R_{1} V_{2} s - C_{1} R_{2} V_{1} s + I_{1} L_{1} f_{1} s - I_{1} L_{1} s + V_{1} f_{1} - V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}, \\  I_{V2} : \\frac{- C_{1} V_{1} s - C_{1} V_{2} s}{C_{1} R_{2} s - f_{1} + 1}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{C_{1} R_{2} V_{1} s + V_{2} f_{1} - V_{2}}{C_{1} R_{2} s - f_{1} + 1}, \\  v_{3} : \\frac{I_{1} L_{1} R_{1} ea_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  v_{4} : \\frac{- I_{1} L_{1} R_{1} s + L_{1} V_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  v_{5} : - V_{2}\\right\\}\\)\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\nv₁ = V₁\n     C₁⋅R₂⋅V₁⋅s + V₂⋅f₁ - V₂\nv₂ = ───────────────────────\n         C₁⋅R₂⋅s - f₁ + 1   \n     I₁⋅L₁⋅R₁⋅ea₁⋅s + R₁⋅V₁⋅ea₁\nv₃ = ──────────────────────────\n         L₁⋅s + R₁⋅ea₁ + R₁    \n     -I₁⋅L₁⋅R₁⋅s + L₁⋅V₁⋅s + R₁⋅V₁⋅ea₁\nv₄ = ─────────────────────────────────\n             L₁⋅s + R₁⋅ea₁ + R₁       \nv₅ = -V₂\n                      2                2             2                2       \n       - C₁⋅I₁⋅L₁⋅R₂⋅s  + C₁⋅L₁⋅V₁⋅f₁⋅s  - C₁⋅L₁⋅V₁⋅s  + C₁⋅L₁⋅V₂⋅f₁⋅s  - C₁⋅L\nI_V1 = ───────────────────────────────────────────────────────────────────────\n                                                                              \n                                                                              \n\n      2                                                                       \n₁⋅V₂⋅s  + C₁⋅R₁⋅V₁⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₁⋅ea₁⋅s + C₁⋅R₁⋅V₁⋅f₁⋅s - C₁⋅R₁⋅V₁⋅s + C₁\n──────────────────────────────────────────────────────────────────────────────\n                       2                                                      \n             C₁⋅L₁⋅R₂⋅s  + C₁⋅R₁⋅R₂⋅ea₁⋅s + C₁⋅R₁⋅R₂⋅s - L₁⋅f₁⋅s + L₁⋅s - R₁⋅e\n\n                                                                              \n⋅R₁⋅V₂⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₂⋅ea₁⋅s + C₁⋅R₁⋅V₂⋅f₁⋅s - C₁⋅R₁⋅V₂⋅s - C₁⋅R₂⋅V₁⋅s + I\n──────────────────────────────────────────────────────────────────────────────\n                                                                              \na₁⋅f₁ + R₁⋅ea₁ - R₁⋅f₁ + R₁                                                   \n\n                                \n₁⋅L₁⋅f₁⋅s - I₁⋅L₁⋅s + V₁⋅f₁ - V₁\n────────────────────────────────\n                                \n                                \n       -C₁⋅V₁⋅s - C₁⋅V₂⋅s\nI_V2 = ──────────────────\n        C₁⋅R₂⋅s - f₁ + 1 \n                                                          2                2  \n        -C₁⋅I₁⋅R₁⋅R₂⋅ea₁⋅s - C₁⋅I₁⋅R₁⋅R₂⋅s - C₁⋅L₁⋅V₁⋅f₁⋅s  - C₁⋅L₁⋅V₂⋅f₁⋅s  -\nI_Ea1 = ──────────────────────────────────────────────────────────────────────\n                                                                              \n                                                                    C₁⋅L₁⋅R₂⋅s\n\n                                                                              \n C₁⋅R₁⋅V₁⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₁⋅f₁⋅s - C₁⋅R₁⋅V₂⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₂⋅f₁⋅s + C₁⋅R₂\n──────────────────────────────────────────────────────────────────────────────\n2                                                                             \n  + C₁⋅R₁⋅R₂⋅ea₁⋅s + C₁⋅R₁⋅R₂⋅s - L₁⋅f₁⋅s + L₁⋅s - R₁⋅ea₁⋅f₁ + R₁⋅ea₁ - R₁⋅f₁ \n\n                                                                \n⋅V₁⋅s + I₁⋅R₁⋅ea₁⋅f₁ - I₁⋅R₁⋅ea₁ + I₁⋅R₁⋅f₁ - I₁⋅R₁ - V₁⋅f₁ + V₁\n────────────────────────────────────────────────────────────────\n                                                                \n+ R₁                                                            \n       -C₁⋅V₁⋅f₁⋅s - C₁⋅V₂⋅f₁⋅s\nI_F1 = ────────────────────────\n           C₁⋅R₂⋅s - f₁ + 1    \n       -I₁⋅R₁⋅ea₁ - I₁⋅R₁ + V₁\nI_L1 = ───────────────────────\n          L₁⋅s + R₁⋅ea₁ + R₁",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>test_3</span>"
    ]
  },
  {
    "objectID": "test_3.html#numeric-solution",
    "href": "test_3.html#numeric-solution",
    "title": "7  test_3",
    "section": "7.2 Numeric solution",
    "text": "7.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\n# enter the element values\nequ1a = equ.subs({    \nR2:2.000000,\nV1:1.000000,\nI1:0.000000,\nV2:0.000000,\nea1:2.000000,\nf1:2.000000,\nR1:2.000000,\nC1:1.000000,\nL1:1.000000})\n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 1.0 s v_{2} + v_{1} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{4}\\\\I_{F1} - 1.0 s v_{1} + v_{2} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 I_{L1} s - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- 2.0 s^{2} - 10.0 s - 1.0}{2.0 s^{2} + 11.0 s - 6.0}, \\  I_{F1} : - \\frac{2.0 s}{2.0 s - 1.0}, \\  I_{L1} : \\frac{1}{s + 6.0}, \\  I_{V1} : \\frac{s^{2} + 4.0 s + 1.0}{2.0 s^{2} + 11.0 s - 6.0}, \\  I_{V2} : - \\frac{s}{2.0 s - 1.0}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{2.0 s}{2.0 s - 1.0}, \\  v_{3} : \\frac{4.0}{s + 6.0}, \\  v_{4} : \\frac{s + 4.0}{s + 6.0}, \\  v_{5} : 0.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>test_3</span>"
    ]
  },
  {
    "objectID": "test_3.html#ac-analysis",
    "href": "test_3.html#ac-analysis",
    "title": "7  test_3",
    "section": "7.3 AC analysis",
    "text": "7.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.5 + 1.0 i\\right) - 1.0 i v_{2} - 0.5 v_{4}\\\\I_{F1} - 1.0 i v_{1} + v_{2} \\cdot \\left(0.5 + 1.0 i\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 i I_{L1} - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -0.637837837837838 + 0.372972972972973 i, \\  I_{F1} : -0.8 + 0.4 i, \\  I_{L1} : 0.162162162162162 - 0.027027027027027 i, \\  I_{V1} : 0.237837837837838 - 0.172972972972973 i, \\  I_{V2} : -0.4 + 0.2 i, \\  v_{1} : 1.0, \\  v_{2} : 0.8 - 0.4 i, \\  v_{3} : 0.648648648648649 - 0.108108108108108 i, \\  v_{4} : 0.675675675675676 + 0.0540540540540541 i, \\  v_{5} : 0.0\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.000000 phase:     0.00000 deg\nv2   : mag:   0.894427 phase:   -26.56505 deg\nv3   : mag:   0.657596 phase:    -9.46232 deg\nv4   : mag:   0.677834 phase:     4.57392 deg\nv5   : mag:   0.000000 phase:         nan deg\nI_V1 : mag:   0.294086 phase:   -36.02737 deg\nI_V2 : mag:   0.447214 phase:   153.43495 deg\nI_Ea1: mag:   0.738882 phase:   149.68322 deg\nI_F1 : mag:   0.894427 phase:   153.43495 deg\nI_L1 : mag:   0.164399 phase:    -9.46232 deg\n\n\nThe solution obtained from LTSpice at a frequency of 0.159155 Hz is shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:   0.894427 phase:   -26.5651°  voltage\nV(5):   mag:          0 phase:          0°  voltage\nV(1):   mag:          1 phase:          0°  voltage\nV(4):   mag:   0.677834 phase:    4.57392°  voltage\nV(3):   mag:   0.657596 phase:   -9.46232°  voltage\nI(C1):  mag:   0.447214 phase:    153.435°  device_current\nI(F1):  mag:   0.894427 phase:    153.435°  device_current\nI(L1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(R2):  mag:   0.447214 phase:   -26.5651°  device_current\nI(R1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(E1):  mag:   0.738882 phase:    149.683°  device_current\nI(V1):  mag:   0.294086 phase:   -36.0274°  device_current\nI(V2):  mag:   0.447214 phase:    153.435°  device_current\nThe LTSpice results are the same.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>test_3</span>"
    ]
  },
  {
    "objectID": "test_3.html#ac-sweep",
    "href": "test_3.html#ac-sweep",
    "title": "7  test_3",
    "section": "7.4 AC Sweep",
    "text": "7.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. Thr frequenct weep is from 0.01 Hz to 1 Hz.\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{2.0 s}{2.0 s - 1.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_3/') # change directory to net list location\n\nfn = 'test_3.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>test_3</span>"
    ]
  },
  {
    "objectID": "test_4.html",
    "href": "test_4.html",
    "title": "8  test_4",
    "section": "",
    "text": "8.1 Symbolic solution\nTakes too long, cells converted to raw.\nans = solve(equ,X) ans\nleft_side = list(ans.keys()) right_side = list(ans.values())\nfor i in range(len(ans)): pprint(Eq(left_side[i],right_side[i]))",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>test_4</span>"
    ]
  },
  {
    "objectID": "test_4.html#numeric-solution",
    "href": "test_4.html#numeric-solution",
    "title": "8  test_4",
    "section": "8.2 Numeric solution",
    "text": "8.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nequ1a = equ.subs({\n    V4:10.000000,\n    I2:5.000000,\n    f1:5.000000,\n    ea1:3.000000,\n    g1:2.000000,\n    h1:2.000000,\n    R3:10.000000,\n    R4:1.000000,\n    R5:5.000000,\n    R9:9.000000,\n    R1:3.000000,\n    R10:10.000000,\n    R13:7.000000,\n    R14:10.000000,\n    R15:3.000000,\n    R2:5.000000,\n    R6:2.000000,\n    R7:6.000000,\n    R11:5.000000,\n    R12:9.000000,\n    R16:10.000000,\n    R8:5.000000,\n    R17:8.000000,\n    V1:0.000000,\n    V2:0.000000,\n    R18:4.000000})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V4} + 1.04444444444444 v_{1} - 0.433333333333333 v_{5} - 0.5 v_{7} - 0.111111111111111 v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.2 v_{4} - 0.2 v_{8}\\\\I_{F1} - I_{V2} - 0.433333333333333 v_{1} - 0.2 v_{3} + 0.633333333333333 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 0.5 v_{1} - 1.0 v_{3} - 2.0 v_{4} + 1.66666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.2 v_{4} - 0.166666666666667 v_{7} + 0.666666666666667 v_{8}\\\\- I_{F1} - 0.111111111111111 v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.553968253968254 v_{9}\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\0.576190476190476 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-5.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -14.0210168779779, \\  I_{F1} : 8.95375840852359, \\  I_{H1} : -14.1681115305374, \\  I_{V1} : 1.79075168170472, \\  I_{V2} : 1.55950578456621, \\  I_{V4} : -12.3773598488327, \\  v_{1} : -2.52814763743623, \\  v_{10} : 1.20751965739888, \\  v_{11} : 1.41884516468896, \\  v_{12} : -15.6471592065687, \\  v_{13} : -21.8851823448335, \\  v_{2} : -12.5281476374362, \\  v_{3} : -26.854161091074, \\  v_{4} : 18.9288276094825, \\  v_{5} : -21.8851823448335, \\  v_{6} : -26.854161091074, \\  v_{7} : -14.7742893841602, \\  v_{8} : -6.0711723905175, \\  v_{9} : 16.6756869421768\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:5s}: {:11.5f}'.format(str(name),float(value)))\n\nv1   :    -2.52815\nv2   :   -12.52815\nv3   :   -26.85416\nv4   :    18.92883\nv5   :   -21.88518\nv6   :   -26.85416\nv7   :   -14.77429\nv8   :    -6.07117\nv9   :    16.67569\nv10  :     1.20752\nv11  :     1.41885\nv12  :   -15.64716\nv13  :   -21.88518\nI_V4 :   -12.37736\nI_F1 :     8.95376\nI_Ea1:   -14.02102\nI_H1 :   -14.16811\nI_V1 :     1.79075\nI_V2 :     1.55951\n\n\nThe results agree with the LTSpice answers.\n       --- Operating Point ---\n\nV(1):    -2.52815    voltage\nV(2):    -12.5281    voltage\nV(3):    -26.8542    voltage\nV(4):    18.9288     voltage\nV(5):    -21.8852    voltage\nV(9):    16.6757     voltage\nV(12):   -15.6472    voltage\nV(10):   1.20752     voltage\nV(7):    -14.7743    voltage\nV(8):    -6.07117    voltage\nV(11):   1.41885     voltage\nV(6):    -26.8542    voltage\nV(13):   -21.8852    voltage\nI(F1):   8.95376     device_current\nI(H1):   -14.1681    device_current\nI(I2):   5   device_current\nI(R3):   -1.9357     device_current\nI(R4):   -12.0799    device_current\nI(R5):   5   device_current\nI(R9):   -2.13376    device_current\nI(R1):   6.45234     device_current\nI(R10):  -0.607117   device_current\nI(R13):  2.17955     device_current\nI(R14):  -1.54682    device_current\nI(R15):  -0.472948   device_current\nI(R2):   -0.993796   device_current\nI(R6):   -6.12307    device_current\nI(R7):   1.45052     device_current\nI(R11):  -3.09363    device_current\nI(R12):  -0.134169   device_current\nI(R16):  -1.7066     device_current\nI(R8):   -4.1566     device_current\nI(R17):  1.79075     device_current\nI(R18):  1.55951     device_current\nI(G1):   -4.50628    device_current\nI(E1):   -14.021     device_current\nI(V4):   -12.3774    device_current\nI(V1):   1.79075     device_current\nI(V2):   1.55951     device_current",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>test_4</span>"
    ]
  },
  {
    "objectID": "test_5.html",
    "href": "test_5.html",
    "title": "9  test_5",
    "section": "",
    "text": "9.1 Numeric solution\n# enter the element values, set I2=0\nequ1a = equ.subs({\n    V4:20.000000,\n    I2:0.000000,\n    f1:5.000000,\n    ea1:3.000000,\n    g1:2.000000,\n    h1:2.000000,\n    R3:10.000000,\n    R4:1.000000,\n    R9:9.000000,\n    R10:10.000000,\n    R13:7.000000,\n    R14:10.000000,\n    R2:5.000000,\n    R7:6.000000,\n    R11:5.000000,\n    R12:9.000000,\n    R16:10.000000,\n    R8:5.000000,\n    R17:8.000000,\n    V1:0.000000,\n    V2:0.000000,\n    R18:4.000000,\n    C1:2.000000,\n    C2:5.000000,\n    L1:3.000000,\n    L2:8.000000})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 5.0 s v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(5.0 s + 0.442857142857143\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 I_{L1} s + v_{1} - v_{5}\\\\- 8.0 I_{L2} s - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{484516320.0 s^{4} - 7013459176.0 s^{3} - 14876492386.0 s^{2} - 6753210350.0 s + 701248900.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{F1} : \\frac{- 18729852000.0 s^{4} - 55151203400.0 s^{3} - 54295631150.0 s^{2} - 19257377500.0 s - 1182340000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{H1} : \\frac{- 9813782880.0 s^{4} - 34791104416.0 s^{3} - 40120646726.0 s^{2} - 15835630125.0 s - 404170350.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{L1} : \\frac{- 10390318400.0 s^{3} - 20644756880.0 s^{2} - 9214475380.0 s + 640638350.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{L2} : \\frac{228057000.0 s^{3} + 1149868000.0 s^{2} + 1056127000.0 s + 196789500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{V1} : \\frac{- 3745970400.0 s^{4} - 11030240680.0 s^{3} - 10859126230.0 s^{2} - 3851475500.0 s - 236468000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{V2} : \\frac{- 9821049600.0 s^{4} - 25552655920.0 s^{3} - 21936878920.0 s^{2} - 7453388375.0 s - 1000603250.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{V4} : \\frac{- 13559753280.0 s^{4} - 45821345096.0 s^{3} - 50979772956.0 s^{2} - 19687105625.0 s - 640638350.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{1} : \\frac{1516291200.0 s^{4} + 8827515840.0 s^{3} + 18582319340.0 s^{2} + 13870838550.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{10} : \\frac{- 641865600.0 s^{4} - 1183785120.0 s^{3} + 1416411780.0 s^{2} + 2856387600.0 s + 996913500.0}{462589040.0 s^{4} + 1523027748.0 s^{3} + 1732964123.0 s^{2} + 777370755.0 s + 100060325.0}, \\  v_{11} : \\frac{- 1824456000.0 s^{4} - 9198944000.0 s^{3} - 8449016000.0 s^{2} - 1574316000.0 s}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{12} : \\frac{- 6596952000.0 s^{4} - 31448837200.0 s^{3} - 41521770200.0 s^{2} - 17864630000.0 s - 1048160000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{13} : \\frac{32687246400.0 s^{4} + 70761786480.0 s^{3} + 46225745480.0 s^{2} + 11948923500.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{2} : \\frac{- 26239051200.0 s^{4} - 82554149040.0 s^{3} - 85395528040.0 s^{2} - 32771406750.0 s - 3049366500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{3} : \\frac{3728712000.0 s^{4} + 5687776400.0 s^{3} + 1477481800.0 s^{2} - 1959602750.0 s - 1157622500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{4} : \\frac{2139552000.0 s^{4} + 6226520400.0 s^{3} + 6777307400.0 s^{2} + 1039978000.0 s - 1355150000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{5} : \\frac{32687246400.0 s^{4} + 70761786480.0 s^{3} + 46225745480.0 s^{2} + 11948923500.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{6} : \\frac{3728712000.0 s^{4} + 5687776400.0 s^{3} + 1477481800.0 s^{2} - 1959602750.0 s - 1157622500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{7} : \\frac{1516291200.0 s^{4} + 10608925440.0 s^{3} + 17203482560.0 s^{2} + 5263461700.0 s - 2405273000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{8} : \\frac{2139552000.0 s^{4} + 6226520400.0 s^{3} + 6777307400.0 s^{2} + 1039978000.0 s - 1355150000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{9} : \\frac{1516291200.0 s^{4} + 4779582240.0 s^{3} + 6652835940.0 s^{2} + 2436014800.0 s - 643814500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>test_5</span>"
    ]
  },
  {
    "objectID": "test_5.html#ac-analysis",
    "href": "test_5.html#ac-analysis",
    "title": "9  test_5",
    "section": "9.2 AC analysis",
    "text": "9.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 5.0 i v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(0.442857142857143 + 5.0 i\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 i I_{L1} + v_{1} - v_{5}\\\\- 8.0 i I_{L2} - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -3.28755526738118 + 2.02051537859022 i, \\  I_{F1} : -11.5985498010872 - 2.83348461841226 i, \\  I_{H1} : -8.50450073009283 + 0.0196092639839988 i, \\  I_{L1} : -4.46386215504314 + 2.50920732075621 i, \\  I_{L2} : 0.086195653296013 - 0.290772822143382 i, \\  I_{V1} : -2.31970996021745 - 0.566696923682452 i, \\  I_{V2} : -4.58793699371144 - 2.23193107752157 i, \\  I_{V4} : -10.8242106903103 - 0.547087659698453 i, \\  v_{1} : 2.20785874542791 - 2.84317775225776 i, \\  v_{10} : -0.919409819344333 - 2.86641549706325 i, \\  v_{11} : -2.32618257714705 - 0.689565226368104 i, \\  v_{12} : -8.61626726714921 + 1.62068440278538 i, \\  v_{13} : 9.73548070769654 + 10.5484087128717 i, \\  v_{2} : -17.7921412545721 - 2.84317775225776 i, \\  v_{3} : 0.765538427167506 + 1.69039763720186 i, \\  v_{4} : 1.88352299889828 + 0.277177886414242 i, \\  v_{5} : 9.73548070769654 + 10.5484087128717 i, \\  v_{6} : 0.765538427167506 + 1.69039763720186 i, \\  v_{7} : 4.35521828431417 - 1.25237908268235 i, \\  v_{8} : 1.88352299889828 + 0.277177886414242 i, \\  v_{9} : 1.47350713278237 - 0.271330211771869 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   3.599764 phase:   -52.16901 deg\nv2   : mag:  18.017879 phase:  -170.92092 deg\nv3   : mag:   1.855665 phase:    65.63543 deg\nv4   : mag:   1.903808 phase:     8.37152 deg\nv5   : mag:  14.354390 phase:    47.29504 deg\nv6   : mag:   1.855665 phase:    65.63543 deg\nv7   : mag:   4.531708 phase:   -16.04303 deg\nv8   : mag:   1.903808 phase:     8.37152 deg\nv9   : mag:   1.498280 phase:   -10.43351 deg\nv10  : mag:   3.010258 phase:  -107.78377 deg\nv11  : mag:   2.426237 phase:  -163.48826 deg\nv12  : mag:   8.767364 phase:   169.34737 deg\nv13  : mag:  14.354390 phase:    47.29504 deg\nI_V4 : mag:  10.838028 phase:  -177.10656 deg\nI_F1 : mag:  11.939640 phase:  -166.27173 deg\nI_Ea1: mag:   3.858821 phase:   148.42532 deg\nI_H1 : mag:   8.504523 phase:   179.86789 deg\nI_V1 : mag:   2.387928 phase:  -166.27173 deg\nI_V2 : mag:   5.102027 phase:  -154.05809 deg\nI_L1 : mag:   5.120760 phase:   150.65897 deg\nI_L2 : mag:   0.303280 phase:   -73.48826 deg\n\n\nThe following results were obtained from LTSpice.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    3.59976 phase:    -52.169°  voltage\nV(2):   mag:    18.0179 phase:   -170.921°  voltage\nV(3):   mag:    1.85567 phase:    65.6354°  voltage\nV(4):   mag:    1.90381 phase:    8.37152°  voltage\nV(5):   mag:    14.3544 phase:     47.295°  voltage\nV(9):   mag:    1.49828 phase:   -10.4335°  voltage\nV(12):  mag:    8.76736 phase:    169.347°  voltage\nV(10):  mag:    3.01026 phase:   -107.784°  voltage\nV(7):   mag:    4.53171 phase:    -16.043°  voltage\nV(8):   mag:    1.90381 phase:    8.37152°  voltage\nV(11):  mag:    2.42624 phase:   -163.488°  voltage\nV(6):   mag:    1.85567 phase:    65.6354°  voltage\nV(13):  mag:    14.3544 phase:     47.295°  voltage\nI(C1):  mag:    5.34483 phase:    126.532°  device_current\nI(C2):  mag:    13.3732 phase:    15.9359°  device_current\nI(F1):  mag:    11.9396 phase:   -166.272°  device_current\nI(H1):  mag:    8.50452 phase:    179.868°  device_current\nI(L1):  mag:    5.12076 phase:    150.659°  device_current\nI(L2):  mag:    0.30328 phase:   -73.4883°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:    1.53623 phase:     60.659°  device_current\nI(R4):  mag:    4.64174 phase:    140.656°  device_current\nI(R9):  mag:          0 phase:          0°  device_current\nI(R10): mag:   0.190381 phase:    8.37152°  device_current\nI(R13): mag:   0.546091 phase:    6.28131°  device_current\nI(R14): mag:   0.352995 phase:   -132.679°  device_current\nI(R2):  mag:     2.5213 phase:    -135.36°  device_current\nI(R7):  mag:   0.484448 phase:     148.25°  device_current\nI(R11): mag:   0.705989 phase:   -132.679°  device_current\nI(R12): mag:   0.334473 phase:    72.2162°  device_current\nI(R16): mag:   0.670093 phase:    159.833°  device_current\nI(R8):  mag:   0.360393 phase:    128.347°  device_current\nI(R17): mag:    2.38793 phase:   -166.272°  device_current\nI(R18): mag:    5.10203 phase:   -154.058°  device_current\nI(G1):  mag:    1.36963 phase:   -126.779°  device_current\nI(E1):  mag:    3.85882 phase:    148.425°  device_current\nI(V4):  mag:     10.838 phase:   -177.107°  device_current\nI(V1):  mag:    2.38793 phase:   -166.272°  device_current\nI(V2):  mag:    5.10203 phase:   -154.058°  device_current\n\nThe LTSpice results are the same.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>test_5</span>"
    ]
  },
  {
    "objectID": "test_5.html#ac-sweep",
    "href": "test_5.html#ac-sweep",
    "title": "9  test_5",
    "section": "9.3 AC Sweep",
    "text": "9.3 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. Thr frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_5/') # change directory to net list location\n\nfn = 'test_5.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 5\n\nH = u1[v5]\nH\n\n\\(\\displaystyle \\frac{32687246400.0 s^{4} + 70761786480.0 s^{3} + 46225745480.0 s^{2} + 11948923500.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>test_5</span>"
    ]
  },
  {
    "objectID": "test_6.html",
    "href": "test_6.html",
    "title": "10  test_6",
    "section": "",
    "text": "10.1 Numeric solution\nIn LTSpice the line:\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nThis needs to be converted to mutual inductance.\nWith:\nL3 = 8\nL4 = 10\nk = 0.5\nand:\n\\(k = \\frac {M}{\\sqrt{L1 \\times L2}}\\)\nNeed to solve for M\n\\(M = k \\times {\\sqrt{L1 \\times L2}}\\)\n# calculate the coupling constant from the mutual inductance\nprint('mutual inductance, M = {:.9f}'.format(0.5*np.sqrt(8*10)))\n\nmutual inductance, M = 4.472135955\n# enter the element values, set I2=0, K1 changed to M1\nequ1a = equ.subs({\n    V4:10.000000,\n    I2:0.000000,\n    f1:5.000000,\n    ea1:3.000000,\n    g1:2.000000,\n    h1:2.000000,\n    R3:10.000000,\n    R4:1.000000,\n    R10:10.000000,\n    R14:10.000000,\n    R2:5.000000,\n    R7:6.000000,\n    R11:5.000000,\n    R12:9.000000,\n    R16:10.000000,\n    R8:5.000000,\n    R17:8.000000,\n    V1:0.000000,\n    V2:0.000000,\n    R18:4.000000,\n    C1:2.000000,\n    C2:5.000000,\n    L1:3.000000,\n    L2:8.000000,\n    L3:8.000000,\n    L4:10.000000,\n    M1:4.472135955})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 5.0 s v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(5.0 s + 0.3\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 I_{L1} s + v_{1} - v_{5}\\\\- 8.0 I_{L2} s - v_{11}\\\\- 8.0 I_{L3} s - 4.472135955 I_{L4} s - v_{11} + v_{9}\\\\- 4.472135955 I_{L3} s - 10.0 I_{L4} s + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\nThe equations above are using the component values and the Laplace variable.\n# solve the equations.\nu1 = solve(equ1a,X)\n#u1 # the solution is too long to display correctly\n# trying pprint for a fwe of the nodes\npprint(u1[v1])\n\n                     5                         4                         3    \n2.2325166790056e+16⋅s  + 1.89060165810445e+17⋅s  + 4.32070251698074e+17⋅s  + 3\n──────────────────────────────────────────────────────────────────────────────\n                       5                       4                       3      \n  7.2576938804988e+15⋅s  + 1.298012194946e+17⋅s  + 2.444740209787e+17⋅s  + 1.6\n\n                     2                                         \n.44523980198078e+17⋅s  + 1.21346542780886e+17⋅s + 2.9930625e+16\n───────────────────────────────────────────────────────────────\n                   2                                           \n9584751982685e+17⋅s  + 4.81277812834983e+16⋅s + 5.0601675e+15\npprint(u1[v2])\n\n                       5                         4                         3  \n- 5.0251772014932e+16⋅s  - 1.10895202913556e+18⋅s  - 2.01266995808892e+18⋅s  -\n──────────────────────────────────────────────────────────────────────────────\n                       5                       4                       3      \n  7.2576938804988e+15⋅s  + 1.298012194946e+17⋅s  + 2.444740209787e+17⋅s  + 1.6\n\n                       2                                        \n 1.35132353962877e+18⋅s  - 3.59931270054097e+17⋅s - 2.067105e+16\n────────────────────────────────────────────────────────────────\n                   2                                            \n9584751982685e+17⋅s  + 4.81277812834983e+16⋅s + 5.0601675e+15",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>test_6</span>"
    ]
  },
  {
    "objectID": "test_6.html#numeric-solution",
    "href": "test_6.html#numeric-solution",
    "title": "10  test_6",
    "section": "",
    "text": "K1 L3 L4 0.5",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>test_6</span>"
    ]
  },
  {
    "objectID": "test_6.html#ac-analysis",
    "href": "test_6.html#ac-analysis",
    "title": "10  test_6",
    "section": "10.2 AC analysis",
    "text": "10.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 5.0 i v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(0.3 + 5.0 i\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 i I_{L1} + v_{1} - v_{5}\\\\- 8.0 i I_{L2} - v_{11}\\\\- 8.0 i I_{L3} - 4.472135955 i I_{L4} - v_{11} + v_{9}\\\\- 4.472135955 i I_{L3} - 10.0 i I_{L4} + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -1.22523336908514 - 0.840765512512539 i, \\  I_{F1} : -5.62023309737683 - 0.209106198605548 i, \\  I_{H1} : -4.07088397910677 - 1.34550926279174 i, \\  I_{L1} : -1.39813151246412 + 1.68136393529045 i, \\  I_{L2} : 0.114546545119793 - 0.0011123043384594 i, \\  I_{L3} : 0.223755430589947 - 0.193209701614398 i, \\  I_{L4} : 0.0, \\  I_{V1} : -1.12404661947537 - 0.0418212397211095 i, \\  I_{V2} : -2.50734863431189 - 0.699065756232061 i, \\  I_{V4} : -5.19493059858214 - 1.38733050251285 i, \\  v_{1} : 1.59338453957114 - 0.371283813893891 i, \\  v_{10} : 0.267492643844761 - 0.0167632823288092 i, \\  v_{11} : -0.00889843470767521 - 0.916372360958346 i, \\  v_{12} : -3.39191819180508 + 1.02684769857023 i, \\  v_{13} : 6.63747634544249 + 3.82311072349847 i, \\  v_{2} : -8.40661546042886 - 0.371283813893891 i, \\  v_{3} : 0.585757495374071 - 0.0367138961250149 i, \\  v_{4} : 1.7123114559261 + 1.00816753213745 i, \\  v_{5} : 6.63747634544249 + 3.82311072349847 i, \\  v_{6} : 0.585757495374071 - 0.0367138961250149 i, \\  v_{7} : 1.6721949324994 + 0.0650645877850054 i, \\  v_{8} : 0.848251402481531 + 0.0075028258696384 i, \\  v_{9} : 1.53677917820751 + 0.873671083761229 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.636070 phase:   -13.11677 deg\nv2   : mag:   8.414810 phase:  -177.47114 deg\nv3   : mag:   0.586907 phase:    -3.58647 deg\nv4   : mag:   1.987061 phase:    30.48855 deg\nv5   : mag:   7.659782 phase:    29.94145 deg\nv6   : mag:   0.586907 phase:    -3.58647 deg\nv7   : mag:   1.673460 phase:     2.22824 deg\nv8   : mag:   0.848285 phase:     0.50677 deg\nv9   : mag:   1.767765 phase:    29.61857 deg\nv10  : mag:   0.268017 phase:    -3.58593 deg\nv11  : mag:   0.916416 phase:   -90.55635 deg\nv12  : mag:   3.543942 phase:   163.15717 deg\nv13  : mag:   7.659782 phase:    29.94145 deg\nI_V4 : mag:   5.376987 phase:  -165.04783 deg\nI_F1 : mag:   5.624122 phase:  -177.86924 deg\nI_Ea1: mag:   1.485962 phase:  -145.54176 deg\nI_H1 : mag:   4.287481 phase:  -161.71024 deg\nI_V1 : mag:   1.124824 phase:  -177.86924 deg\nI_V2 : mag:   2.602977 phase:  -164.42117 deg\nI_L1 : mag:   2.186723 phase:   129.74508 deg\nI_L2 : mag:   0.114552 phase:    -0.55635 deg\nI_L3 : mag:   0.295629 phase:   -40.81015 deg\nI_L4 : mag:   0.000000 phase:         nan deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n--- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    1.63601 phase:   -13.1107°  voltage\nV(2):   mag:    8.41482 phase:   -177.472°  voltage\nV(3):   mag:   0.586932 phase:    -3.5698°  voltage\nV(4):   mag:    1.98715 phase:    30.4941°  voltage\nV(5):   mag:    7.65904 phase:    29.9359°  voltage\nV(9):   mag:    1.76784 phase:    29.6245°  voltage\nV(12):  mag:    3.54398 phase:    163.161°  voltage\nV(10):  mag:   0.267951 phase:   -3.57561°  voltage\nV(7):   mag:    1.67347 phase:    2.23357°  voltage\nV(8):   mag:   0.848303 phase:   0.515418°  voltage\nV(11):  mag:   0.916372 phase:   -90.5542°  voltage\nV(6):   mag:   0.586932 phase:    -3.5698°  voltage\nV(13):  mag:    7.65904 phase:    29.9359°  voltage\nI(C1):  mag:   0.886775 phase:    169.759°  device_current\nI(C2):  mag:    6.23127 phase:    2.60368°  device_current\nI(F1):  mag:    5.62415 phase:   -177.869°  device_current\nI(H1):  mag:    4.28722 phase:   -161.715°  device_current\nI(L1):  mag:     2.1864 phase:    129.758°  device_current\nI(L2):  mag:   0.114546 phase:  -0.547059°  device_current\nI(L3):  mag:   0.295638 phase:   -40.8067°  device_current\nI(L4):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:   0.655921 phase:    39.7384°  device_current\nI(R4):  mag:    1.09116 phase:   -174.649°  device_current\nI(R10): mag:  0.0848303 phase:   0.515418°  device_current\nI(R14): mag:   0.155058 phase:   -144.946°  device_current\nI(R2):  mag:    1.43539 phase:   -147.477°  device_current\nI(R7):  mag:   0.137657 phase:   -176.002°  device_current\nI(R11): mag:   0.310117 phase:   -144.946°  device_current\nI(R12): mag:  0.0297724 phase:    176.424°  device_current\nI(R16): mag:   0.390139 phase:    150.131°  device_current\nI(R8):  mag:  0.0532334 phase:   -170.446°  device_current\nI(R17): mag:    1.12483 phase:   -177.869°  device_current\nI(R18): mag:    2.60288 phase:   -164.425°  device_current\nI(G1):  mag:   0.442308 phase:   -142.538°  device_current\nI(E1):  mag:    1.48573 phase:   -145.548°  device_current\nI(V4):  mag:    5.37676 phase:   -165.052°  device_current\nI(V1):  mag:    1.12483 phase:   -177.869°  device_current\nI(V2):  mag:    2.60288 phase:   -164.425°  device_current\nThe LTSpice results are the same as those from the Python code.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>test_6</span>"
    ]
  },
  {
    "objectID": "test_6.html#ac-sweep",
    "href": "test_6.html#ac-sweep",
    "title": "10  test_6",
    "section": "10.3 AC Sweep",
    "text": "10.3 AC Sweep\nLooking at node 10 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_6/') # change directory to net list location\n\nfn = 'test_6.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 5\n\nH = u1[v10]\nH\n\n\\(\\displaystyle \\frac{1.0190497760676 \\cdot 10^{16} s^{5} + 3.30689652719137 \\cdot 10^{16} s^{4} + 5.41568605911396 \\cdot 10^{16} s^{3} + 4.70856283994088 \\cdot 10^{16} s^{2} + 2.73004570071188 \\cdot 10^{16} s + 9.864 \\cdot 10^{15}}{2.4192312934996 \\cdot 10^{15} s^{5} + 4.32670731648667 \\cdot 10^{16} s^{4} + 8.14913403262333 \\cdot 10^{16} s^{3} + 5.6528250660895 \\cdot 10^{16} s^{2} + 1.60425937611661 \\cdot 10^{16} s + 1.6867225 \\cdot 10^{15}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>test_6</span>"
    ]
  },
  {
    "objectID": "test_7.html",
    "href": "test_7.html",
    "title": "11  test_7",
    "section": "",
    "text": "11.1 Numeric solution\nFrom the LTSpice netlist:\nK1 and K2 identify the mutual inductance between two inductors. k is the coefficient of coupling. These need to be converted to mutual inductance.\nNeed to solve for M1 and M2:\n\\(M_1 = k \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = k \\times {\\sqrt{L_3 \\times L_4}}\\)\n# calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]*np.sqrt(component_values[L1] *component_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M1]))\n\ncomponent_values[M2] = component_values[K2]*np.sqrt(component_values[L3] *component_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M2]))\n\nmutual inductance, M1 = 1.414000000\nmutual inductance, M1 = 2.235730306\nNeed to set the DC sources to zero.\ncomponent_values[V2] = 0\ncomponent_values[V3] = 0\ncomponent_values[V4] = 0\ncomponent_values[I1] = 0\ncomponent_values[I2] = 0\ncomponent_values[I3] = 0\ncomponent_values[I4] = 0\nequ1a = equ.subs(component_values)\nThe equations above are using the component values and the Laplace variable.\n# solve the equations.\nu1 = solve(equ1a,X)\n#u1 # the solution is too long to display correctly\n# trying pprint for a few of the nodes\npprint(u1[v2])\n\n                                     6                         5              \n             - 2.76669233552152e+57⋅s  + 2.25716104358934e+59⋅s  - 3.684332723\n──────────────────────────────────────────────────────────────────────────────\n                      7                         6                         5   \n1.28428134428291e+57⋅s  - 1.53271577641517e+59⋅s  - 7.47710915242496e+59⋅s  - \n\n           4                         3                         2              \n97733e+59⋅s  - 3.76516188957225e+60⋅s  + 4.56609467275371e+58⋅s  + 4.994308306\n──────────────────────────────────────────────────────────────────────────────\n                      4                         3                         2   \n2.32648746467081e+59⋅s  + 2.31716567174507e+60⋅s  + 8.76679773386848e+59⋅s  + \n\n                                             \n88774e+58⋅s + 1.1319642578125e+57            \n─────────────────────────────────────────────\n                                             \n1.32574719829542e+58⋅s - 4.53791250561523e+57\npprint(u1[v3])\n\n                        7                         6                        5  \n  7.64827226906654e+58⋅s  + 1.39655014482286e+60⋅s  + 8.3837841437292e+60⋅s  +\n──────────────────────────────────────────────────────────────────────────────\n                      7                         6                         5   \n1.28428134428291e+57⋅s  - 1.53271577641517e+59⋅s  - 7.47710915242496e+59⋅s  - \n\n                       4                        3                         2   \n 1.83805847739724e+61⋅s  + 1.2632626737557e+61⋅s  - 2.39533164939265e+59⋅s  - \n──────────────────────────────────────────────────────────────────────────────\n                      4                         3                         2   \n2.32648746467081e+59⋅s  + 2.31716567174507e+60⋅s  + 8.76679773386848e+59⋅s  + \n\n                                             \n2.12639054297542e+59⋅s - 7.064441015625e+57  \n─────────────────────────────────────────────\n                                             \n1.32574719829542e+58⋅s - 4.53791250561523e+57\npprint(u1[v4])\n\n                         7                         6                         5\n - 1.80079030269442e+58⋅s  - 4.27671690912086e+59⋅s  - 2.85592772872773e+60⋅s \n──────────────────────────────────────────────────────────────────────────────\n                      7                         6                         5   \n4.28093781427636e+56⋅s  - 5.10905258805058e+58⋅s  - 2.49236971747499e+59⋅s  - \n\n                         4                         3                        2 \n - 6.37974746477364e+60⋅s  - 3.88961540059031e+60⋅s  + 1.6081158206044e+59⋅s  \n──────────────────────────────────────────────────────────────────────────────\n                      4                         3                         2   \n7.75495821556937e+58⋅s  + 7.72388557248356e+59⋅s  + 2.92226591128949e+59⋅s  + \n\n                                            \n+ 6.16282933459488e+58⋅s + 1.4934828125e+57 \n────────────────────────────────────────────\n                                            \n4.4191573276514e+57⋅s - 1.51263750187174e+57",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>test_7</span>"
    ]
  },
  {
    "objectID": "test_7.html#numeric-solution",
    "href": "test_7.html#numeric-solution",
    "title": "11  test_7",
    "section": "",
    "text": "K1 L1 L2 0.707\nK2 L3 L4 0.707",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>test_7</span>"
    ]
  },
  {
    "objectID": "test_7.html#ac-analysis",
    "href": "test_7.html#ac-analysis",
    "title": "11  test_7",
    "section": "11.2 AC analysis",
    "text": "11.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\\\- 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\\\1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 i I_{L1} - 1.414 i I_{L2} + v_{16} - v_{23}\\\\- 1.414 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\- 2.0 i I_{L3} - 2.23573030573904 i I_{L4} - v_{21} + v_{22}\\\\- 2.23573030573904 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\\\- 1.0 i I_{L5} - v_{7}\\\\- 2.0 i I_{L6} - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : 0.504198444608253 + 0.898150393059927 i, \\  I_{Ea2} : -1.5795724647095 + 0.308307697889862 i, \\  I_{F1} : 0.48261496669065 - 3.85180556530855 i, \\  I_{F2} : 0.48261496669065 - 3.85180556530855 i, \\  I_{H1} : 1.24856140500647 + 3.82840673564216 i, \\  I_{H2} : 1.07647165039523 - 0.194994995143953 i, \\  I_{L1} : 0.379885428953428 - 3.63143009468308 i, \\  I_{L2} : -1.3645179529356 - 0.815603561354835 i, \\  I_{L3} : -0.504198444608253 - 0.898150393059927 i, \\  I_{L4} : 1.5795724647095 - 0.308307697889862 i, \\  I_{L5} : -0.48261496669065 + 3.85180556530855 i, \\  I_{L6} : -0.816125604923761 - 0.350847312085518 i, \\  I_{V1} : -0.733805219002842 - 4.81790027750145 i, \\  I_{V2} : 0.241307483345325 - 1.92590278265427 i, \\  I_{V3} : -0.372330023309102 + 4.70437003089402 i, \\  I_{V4} : 0.354469837968848 - 5.83190979816162 i, \\  I_{V5} : 0.726388403536697 - 6.44927697538188 i, \\  I_{V6} : 0.593856683704582 + 3.65681057016459 i, \\  I_{V7} : -0.861417138621336 - 0.928916264100745 i, \\  I_{V8} : -0.11233605948701 - 1.13532155850103 i, \\  v_{1} : 0.0, \\  v_{10} : -0.262045079927554 + 5.55693449647949 i, \\  v_{11} : -0.243203348872735 + 2.68893328006946 i, \\  v_{12} : -0.625263122105315 + 2.62760666315395 i, \\  v_{13} : 0.22467211897402 + 2.27064311700207 i, \\  v_{14} : -0.742608930512742 + 9.6914971547036 i, \\  v_{15} : -2.52099222304126 - 4.49075196529963 i, \\  v_{16} : 8.41066513948474 - 13.2484997478875 i, \\  v_{17} : 3.30635719345208 + 9.45954386089979 i, \\  v_{18} : 4.773031655484 - 11.3031994319571 i, \\  v_{19} : 2.39848749888701 - 4.42083915332865 i, \\  v_{2} : -1.16589372131966 - 0.501210445836454 i, \\  v_{20} : -0.262045079927554 + 5.55693449647949 i, \\  v_{21} : 7.51440635021515 - 2.52310114024543 i, \\  v_{22} : 10.0, \\  v_{23} : 3.62597160904592 - 11.69895679139 i, \\  v_{24} : 7.9330573021526 - 7.05437547088623 i, \\  v_{25} : 7.9330573021526 - 7.05437547088623 i, \\  v_{26} : 2.90204915900995 - 5.92124844342714 i, \\  v_{27} : 3.62597160904592 - 11.69895679139 i, \\  v_{28} : -0.262045079927554 + 5.55693449647949 i, \\  v_{3} : -0.262045079927554 + 5.55693449647949 i, \\  v_{4} : 0.723922450035974 - 5.77770834796282 i, \\  v_{5} : 0.601269216204948 - 5.01358880149766 i, \\  v_{6} : 0.0, \\  v_{7} : 3.85180556530855 + 0.48261496669065 i, \\  v_{8} : 1.64850868801031 - 3.35059511947209 i, \\  v_{9} : -0.464199097148623 - 2.13346165568398 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.000000 phase:         nan deg\nv2   : mag:   1.269063 phase:  -156.73743 deg\nv3   : mag:   5.563110 phase:    92.69986 deg\nv4   : mag:   5.822884 phase:   -82.85830 deg\nv5   : mag:   5.049515 phase:   -83.16130 deg\nv6   : mag:   0.000000 phase:         nan deg\nv7   : mag:   3.881923 phase:     7.14170 deg\nv8   : mag:   3.734176 phase:   -63.80260 deg\nv9   : mag:   2.183378 phase:  -102.27511 deg\nv10  : mag:   5.563110 phase:    92.69986 deg\nv11  : mag:   2.699909 phase:    95.16811 deg\nv12  : mag:   2.700976 phase:   103.38512 deg\nv13  : mag:   2.281731 phase:    84.34918 deg\nv14  : mag:   9.719907 phase:    94.38171 deg\nv15  : mag:   5.149976 phase:  -119.30873 deg\nv16  : mag:  15.692738 phase:   -57.59102 deg\nv17  : mag:  10.020727 phase:    70.73415 deg\nv18  : mag:  12.269643 phase:   -67.10700 deg\nv19  : mag:   5.029569 phase:   -61.51834 deg\nv20  : mag:   5.563110 phase:    92.69986 deg\nv21  : mag:   7.926685 phase:   -18.56043 deg\nv22  : mag:  10.000000 phase:     0.00000 deg\nv23  : mag:  12.247990 phase:   -72.77971 deg\nv24  : mag:  10.615913 phase:   -41.64471 deg\nv25  : mag:  10.615913 phase:   -41.64471 deg\nv26  : mag:   6.594170 phase:   -63.89017 deg\nv27  : mag:  12.247990 phase:   -72.77971 deg\nv28  : mag:   5.563110 phase:    92.69986 deg\nI_V1 : mag:   4.873462 phase:   -98.66006 deg\nI_V2 : mag:   1.940961 phase:   -82.85830 deg\nI_V3 : mag:   4.719081 phase:    94.52527 deg\nI_V4 : mag:   5.842672 phase:   -86.52178 deg\nI_F1 : mag:   3.881923 phase:   -82.85830 deg\nI_Ea1: mag:   1.029995 phase:    60.69127 deg\nI_H1 : mag:   4.026860 phase:    71.93726 deg\nI_L1 : mag:   3.651246 phase:   -84.02799 deg\nI_L2 : mag:   1.589691 phase:  -149.13227 deg\nI_V5 : mag:   6.490055 phase:   -83.57380 deg\nI_V6 : mag:   3.704717 phase:    80.77584 deg\nI_L3 : mag:   1.029995 phase:  -119.30873 deg\nI_L4 : mag:   1.609380 phase:   -11.04438 deg\nI_L5 : mag:   3.881923 phase:    97.14170 deg\nI_L6 : mag:   0.888344 phase:  -156.73743 deg\nI_F2 : mag:   3.881923 phase:   -82.85830 deg\nI_Ea2: mag:   1.609380 phase:   168.95562 deg\nI_H2 : mag:   1.093990 phase:   -10.26738 deg\nI_V7 : mag:   1.266856 phase:  -132.84086 deg\nI_V8 : mag:   1.140866 phase:   -95.65082 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    15.6927 phase:    -57.591°  voltage\nV(8):   mag:    3.73418 phase:   -63.8026°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:    1.26906 phase:   -156.737°  voltage\nV(11):  mag:    2.69991 phase:    95.1681°  voltage\nV(10):  mag:    5.56311 phase:    92.6999°  voltage\nV(23):  mag:     12.248 phase:   -72.7797°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:    2.18338 phase:   -102.275°  voltage\nV(24):  mag:    10.6159 phase:   -41.6447°  voltage\nV(3):   mag:    5.56311 phase:    92.6999°  voltage\nV(20):  mag:    5.56311 phase:    92.6999°  voltage\nV(5):   mag:    5.04951 phase:   -83.1613°  voltage\nV(12):  mag:    2.70098 phase:    103.385°  voltage\nV(18):  mag:    12.2696 phase:    -67.107°  voltage\nV(26):  mag:    6.59417 phase:   -63.8902°  voltage\nV(25):  mag:    10.6159 phase:   -41.6447°  voltage\nV(4):   mag:    5.82288 phase:   -82.8583°  voltage\nV(14):  mag:    9.71991 phase:    94.3817°  voltage\nV(7):   mag:    3.88192 phase:     7.1417°  voltage\nV(15):  mag:    5.14998 phase:   -119.309°  voltage\nV(21):  mag:    7.92669 phase:   -18.5604°  voltage\nV(13):  mag:    2.28173 phase:    84.3492°  voltage\nV(28):  mag:    5.56311 phase:    92.6999°  voltage\nV(27):  mag:     12.248 phase:   -72.7797°  voltage\nV(17):  mag:    10.0207 phase:    70.7341°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    5.02957 phase:   -61.5183°  voltage\nI(C1):  mag:    2.42683 phase:   -70.9646°  device_current\nI(C2):  mag:   0.773901 phase:   -80.8809°  device_current\nI(F1):  mag:    3.88192 phase:   -82.8583°  device_current\nI(F2):  mag:    3.88192 phase:   -82.8583°  device_current\nI(H1):  mag:    4.02686 phase:    71.9373°  device_current\nI(H2):  mag:    1.09399 phase:   -10.2674°  device_current\nI(L1):  mag:    3.65125 phase:    -84.028°  device_current\nI(L2):  mag:    1.58969 phase:   -149.132°  device_current\nI(L3):  mag:       1.03 phase:   -119.309°  device_current\nI(L4):  mag:    1.60938 phase:   -11.0444°  device_current\nI(L5):  mag:    3.88192 phase:    97.1417°  device_current\nI(L6):  mag:   0.888344 phase:   -156.737°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:    2.39746 phase:   -55.6595°  device_current\nI(R2):  mag:    1.86709 phase:   -63.8026°  device_current\nI(R6):  mag:   0.253813 phase:   -156.737°  device_current\nI(R8):  mag:   0.358508 phase:   -89.6236°  device_current\nI(R10): mag:     1.4803 phase:   -118.583°  device_current\nI(R11): mag:   0.609557 phase:    150.054°  device_current\nI(R12): mag:   0.634531 phase:   -156.737°  device_current\nI(R14): mag:   0.769305 phase:    88.4942°  device_current\nI(R15): mag:    1.26686 phase:    47.1591°  device_current\nI(R7):  mag:   0.773901 phase:    99.1191°  device_current\nI(R16): mag:   0.927185 phase:    92.6999°  device_current\nI(R3):  mag:   0.515704 phase:    167.307°  device_current\nI(R4):  mag:    3.79248 phase:   -85.0285°  device_current\nI(R9):  mag:    4.44783 phase:    83.1593°  device_current\nI(R13): mag:       1.03 phase:   -119.309°  device_current\nI(R17): mag:    1.40714 phase:   -72.0029°  device_current\nI(R18): mag:    1.14087 phase:    84.3492°  device_current\nI(R19): mag:    1.05441 phase:   -80.4269°  device_current\nI(R20): mag:    2.06528 phase:     104.93°  device_current\nI(R21): mag:    2.42683 phase:    109.035°  device_current\nI(R22): mag:    2.49454 phase:    97.4264°  device_current\nI(R23): mag:   0.773901 phase:    99.1191°  device_current\nI(R24): mag:    1.38747 phase:   -83.3702°  device_current\nI(R25): mag:    1.76885 phase:   -77.3024°  device_current\nI(R5):  mag:    1.85437 phase:    92.6999°  device_current\nI(G1):  mag:    1.84371 phase:   -22.7819°  device_current\nI(G2):  mag:     10.099 phase:    96.8387°  device_current\nI(E1):  mag:       1.03 phase:    60.6913°  device_current\nI(E2):  mag:    1.60938 phase:    168.956°  device_current\nI(V1):  mag:    4.87346 phase:   -98.6601°  device_current\nI(V2):  mag:    1.94096 phase:   -82.8583°  device_current\nI(V3):  mag:    4.71908 phase:    94.5253°  device_current\nI(V4):  mag:    5.84267 phase:   -86.5218°  device_current\nI(V5):  mag:    6.49005 phase:   -83.5738°  device_current\nI(V6):  mag:    3.70472 phase:    80.7758°  device_current\nI(V7):  mag:    1.26686 phase:   -132.841°  device_current\nI(V8):  mag:    1.14087 phase:   -95.6508°  device_current\nThe LTSpice results are the same as those from the Python code.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>test_7</span>"
    ]
  },
  {
    "objectID": "test_7.html#ac-sweep",
    "href": "test_7.html#ac-sweep",
    "title": "11  test_7",
    "section": "11.3 AC Sweep",
    "text": "11.3 AC Sweep\nLooking at node 17 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 17 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_7/') # change directory to net list location\n\nfn = 'test_7.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 17\n\nH = u1[v17]\nH\n\n\\(\\displaystyle \\frac{7.75372831979451 \\cdot 10^{59} s^{7} + 4.8993837334343 \\cdot 10^{60} s^{6} + 2.54067743417075 \\cdot 10^{61} s^{5} + 8.11163541343906 \\cdot 10^{61} s^{4} + 8.09087145235497 \\cdot 10^{61} s^{3} - 9.32472091368078 \\cdot 10^{59} s^{2} - 1.26502178475526 \\cdot 10^{60} s - 4.04308734375 \\cdot 10^{58}}{3.85284403284873 \\cdot 10^{57} s^{7} - 4.59814732924552 \\cdot 10^{59} s^{6} - 2.24313274572749 \\cdot 10^{60} s^{5} - 6.97946239401244 \\cdot 10^{59} s^{4} + 6.95149701523521 \\cdot 10^{60} s^{3} + 2.63003932016054 \\cdot 10^{60} s^{2} + 3.97724159488626 \\cdot 10^{58} s - 1.36137375168457 \\cdot 10^{58}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>test_7</span>"
    ]
  },
  {
    "objectID": "test_8.html",
    "href": "test_8.html",
    "title": "12  test_8",
    "section": "",
    "text": "12.1 Numeric solution\nFrom the LTSpice netlist:\nK1 and K2 identify the mutual inductance between two inductors. k is the coefficient of coupling. These need to be converted to mutual inductance.\nNeed to solve for M1 and M2:\n\\(M_1 = k \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = k \\times {\\sqrt{L_3 \\times L_4}}\\)\n# calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]*np.sqrt(component_values[L1] *component_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M1]))\n\ncomponent_values[M2] = component_values[K2]*np.sqrt(component_values[L3] *component_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M2]))\n\nmutual inductance, M1 = 1.600000000\nmutual inductance, M1 = 0.632455532\nNeed to set the DC sources to zero.\ncomponent_values[V2] = 0\ncomponent_values[V3] = 0\ncomponent_values[V4] = 0\ncomponent_values[I1] = 0\ncomponent_values[I2] = 0\ncomponent_values[I3] = 0\ncomponent_values[I4] = 0\nequ1a = equ.subs(component_values)\nThe equations above are using the component values and the Laplace variable.\n# solve the equations.\nu1 = solve(equ1a,X)\n#u1 # the solution is too long to display correctly\n# trying pprint for a few of the nodes\npprint(u1[v2])\n\n                                7                         6                   \n            - 3.5390069568e+62⋅s  - 4.64954632445963e+63⋅s  - 3.26358740395349\n──────────────────────────────────────────────────────────────────────────────\n                   8                         7                         6      \n9.90414000576e+62⋅s  + 1.41637532380814e+64⋅s  + 2.31172858420853e+65⋅s  + 1.1\n\n      5                         4                         3                   \ne+65⋅s  - 4.18855602017884e+65⋅s  + 7.22358803127554e+65⋅s  - 7.48482405611853\n──────────────────────────────────────────────────────────────────────────────\n                   5                         4                         3      \n7903952541104e+66⋅s  + 1.60667800064429e+66⋅s  - 2.26595141213756e+65⋅s  - 2.2\n\n      2                                                             \ne+64⋅s  - 1.98928837739837e+64⋅s - 5.43997955648437e+62             \n────────────────────────────────────────────────────────────────────\n                   2                                                \n4440876527127e+65⋅s  - 6.23366738041327e+63⋅s + 1.12523056632602e+63\npprint(u1[v3])\n\n                      8                         7                         6   \n- 5.202340226496e+63⋅s  - 2.83150657805778e+65⋅s  - 3.12300458619362e+66⋅s  - \n──────────────────────────────────────────────────────────────────────────────\n                     8                         7                         6    \n 2.971242001728e+63⋅s  + 4.24912597142442e+64⋅s  + 6.93518575262559e+65⋅s  + 3\n\n                      5                        4                         3    \n1.10562230053989e+67⋅s  - 1.4983958176291e+67⋅s  - 5.07790860193152e+66⋅s  + 1\n──────────────────────────────────────────────────────────────────────────────\n                     5                         4                         3    \n.53711857623313e+66⋅s  + 4.82003400193286e+66⋅s  - 6.79785423641268e+65⋅s  - 6\n\n                     2                                                \n.86721677831568e+66⋅s  + 3.41718868879397e+65⋅s + 1.05226672260527e+64\n──────────────────────────────────────────────────────────────────────\n                    2                                                 \n.7332262958138e+65⋅s  - 1.87010021412398e+64⋅s + 3.37569169897805e+63\npprint(u1[v4])\n\n                                 7                         6                  \n           1.69793472607621e+65⋅s  + 2.96555284913763e+66⋅s  + 1.2136984798616\n──────────────────────────────────────────────────────────────────────────────\n                    8                         7                         6     \n2.971242001728e+63⋅s  + 4.24912597142442e+64⋅s  + 6.93518575262559e+65⋅s  + 3.\n\n       5                         4                         3                  \n3e+67⋅s  + 1.66884617129846e+67⋅s  + 4.43947630710454e+66⋅s  - 1.9596618859036\n──────────────────────────────────────────────────────────────────────────────\n                    5                         4                         3     \n53711857623313e+66⋅s  + 4.82003400193286e+66⋅s  - 6.79785423641268e+65⋅s  - 6.\n\n       2                                                            \n5e+66⋅s  - 3.05907880853766e+65⋅s - 8.36540714026172e+63            \n────────────────────────────────────────────────────────────────────\n                   2                                                \n7332262958138e+65⋅s  - 1.87010021412398e+64⋅s + 3.37569169897805e+63",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>test_8</span>"
    ]
  },
  {
    "objectID": "test_8.html#numeric-solution",
    "href": "test_8.html#numeric-solution",
    "title": "12  test_8",
    "section": "",
    "text": "K1 L1 L2 0.8\nK2 L3 L4 0.2",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>test_8</span>"
    ]
  },
  {
    "objectID": "test_8.html#ac-analysis",
    "href": "test_8.html#ac-analysis",
    "title": "12  test_8",
    "section": "12.2 AC analysis",
    "text": "12.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\\\- 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\\\1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\- 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\\\I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\\\0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\\\I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 i I_{L1} - 1.6 i I_{L2} + v_{16} - v_{23}\\\\- 1.6 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\- 2.0 i I_{L3} - 0.632455532033676 i I_{L4} - v_{21} + v_{22}\\\\- 0.632455532033676 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\\\- 1.0 i I_{L5} - v_{7}\\\\- 2.0 i I_{L6} - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\v_{29}\\\\v_{31}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -1.05373431161195 + 1.24786796031362 i, \\  I_{Ea2} : -0.155959689544689 + 0.51824284400627 i, \\  I_{F1} : 1.73968399560092 - 0.502495662147359 i, \\  I_{F2} : 1.73968399560092 - 0.502495662147359 i, \\  I_{H1} : -1.48314322331905 - 0.0660513166239778 i, \\  I_{H2} : 0.323932696333347 - 0.640114247151401 i, \\  I_{L1} : 2.56990560967261 - 1.2618305380904 i, \\  I_{L2} : -0.667612122261301 - 0.532593445058889 i, \\  I_{L3} : 1.05409312550412 - 1.24797830150459 i, \\  I_{L4} : 0.155959689544689 - 0.51824284400627 i, \\  I_{L5} : -1.73968399560092 + 0.502495662147359 i, \\  I_{L6} : -0.315915236352704 - 0.193601796825927 i, \\  I_{O1} : 0.957467798516351 - 0.221993937824238 i, \\  I_{O2} : 1.69365544045516 + 0.0162079448126214 i, \\  I_{V1} : -1.07189763516873 + 1.10879303667281 i, \\  I_{V2} : 0.86984199780046 - 0.25124783107368 i, \\  I_{V3} : -1.96227871537947 + 0.638900336291395 i, \\  I_{V4} : 2.21532544022067 - 0.749779976982176 i, \\  I_{V5} : 2.60798193941531 - 0.703526705514992 i, \\  I_{V6} : -1.41575129926757 - 0.137618585004041 i, \\  I_{V7} : -0.835585129049959 - 0.410722041913759 i, \\  I_{V8} : 0.836960476216364 - 0.32982235822549 i, \\  v_{1} : 0.0, \\  v_{10} : -2.18487343515801 + 0.775305010435431 i, \\  v_{11} : -1.85711527507315 + 1.23523546779434 i, \\  v_{12} : -1.93812743151411 + 1.02852394848 i, \\  v_{13} : -1.67392095243273 + 0.659644716450981 i, \\  v_{14} : -4.53892318719675 + 1.47121835666425 i, \\  v_{15} : 5.26867155805975 - 6.23933980156809 i, \\  v_{16} : 10.4884348658008 + 0.0622647076421236 i, \\  v_{17} : 1.52338972560277 + 2.68170094402154 i, \\  v_{18} : 8.45673682322186 - 0.646976254910933 i, \\  v_{19} : 3.70182531421306 - 0.153284209276674 i, \\  v_{2} : -0.451307480503863 - 0.27657399546561 i, \\  v_{20} : -2.18487343515801 + 0.775305010435431 i, \\  v_{21} : 7.17627784336219 - 2.20682381943503 i, \\  v_{22} : 10.0, \\  v_{23} : 8.37445481561615 - 1.4394615064124 i, \\  v_{24} : 4.08519875432819 + 0.532996018259946 i, \\  v_{25} : 4.08519875432819 + 0.532996018259946 i, \\  v_{26} : 5.76492882221477 - 0.685718013191361 i, \\  v_{27} : 8.37445481561615 - 1.4394615064124 i, \\  v_{28} : -2.18487343515801 + 0.775305010435431 i, \\  v_{29} : 0.0, \\  v_{3} : -2.18487343515801 + 0.775305010435431 i, \\  v_{30} : -3.5881389216811 + 1.10341190971751 i, \\  v_{31} : 0.0, \\  v_{32} : -4.38198295220956 + 0.451843333363498 i, \\  v_{4} : 2.60952599340138 - 0.753743493221039 i, \\  v_{5} : 2.1961029547727 - 0.591719180339126 i, \\  v_{6} : 0.0, \\  v_{7} : 0.502495662147359 + 1.73968399560092 i, \\  v_{8} : 2.19099147610478 - 0.225921666681749 i, \\  v_{9} : -0.0641038868520081 - 0.908404468171018 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.000000 phase:         nan deg\nv2   : mag:   0.529312 phase:  -148.49885 deg\nv3   : mag:   2.318355 phase:   160.46271 deg\nv4   : mag:   2.716202 phase:   -16.11100 deg\nv5   : mag:   2.274423 phase:   -15.07969 deg\nv6   : mag:   0.000000 phase:         nan deg\nv7   : mag:   1.810802 phase:    73.88900 deg\nv8   : mag:   2.202609 phase:    -5.88718 deg\nv9   : mag:   0.910663 phase:   -94.03653 deg\nv10  : mag:   2.318355 phase:   160.46271 deg\nv11  : mag:   2.230400 phase:   146.37066 deg\nv12  : mag:   2.194128 phase:   152.04604 deg\nv13  : mag:   1.799206 phase:   158.49201 deg\nv14  : mag:   4.771405 phase:   162.04074 deg\nv15  : mag:   8.166288 phase:   -49.82133 deg\nv16  : mag:  10.488620 phase:     0.34013 deg\nv17  : mag:   3.084191 phase:    60.40046 deg\nv18  : mag:   8.481449 phase:    -4.37485 deg\nv19  : mag:   3.704998 phase:    -2.37113 deg\nv20  : mag:   2.318355 phase:   160.46271 deg\nv21  : mag:   7.507931 phase:   -17.09353 deg\nv22  : mag:  10.000000 phase:     0.00000 deg\nv23  : mag:   8.497267 phase:    -9.75310 deg\nv24  : mag:   4.119822 phase:     7.43339 deg\nv25  : mag:   4.119822 phase:     7.43339 deg\nv26  : mag:   5.805567 phase:    -6.78326 deg\nv27  : mag:   8.497267 phase:    -9.75310 deg\nv28  : mag:   2.318355 phase:   160.46271 deg\nv29  : mag:   0.000000 phase:         nan deg\nv30  : mag:   3.753966 phase:   162.90647 deg\nv31  : mag:   0.000000 phase:         nan deg\nv32  : mag:   4.405217 phase:   174.11282 deg\nI_V1 : mag:   1.542202 phase:   134.03070 deg\nI_V2 : mag:   0.905401 phase:   -16.11100 deg\nI_V3 : mag:   2.063669 phase:   161.96522 deg\nI_V4 : mag:   2.338768 phase:   -18.69846 deg\nI_F1 : mag:   1.810802 phase:   -16.11100 deg\nI_Ea1: mag:   1.633258 phase:   130.17867 deg\nI_H1 : mag:   1.484613 phase:  -177.45004 deg\nI_L1 : mag:   2.862976 phase:   -26.15116 deg\nI_L2 : mag:   0.854027 phase:  -141.41858 deg\nI_V5 : mag:   2.701207 phase:   -15.09671 deg\nI_V6 : mag:   1.422424 phase:  -174.44799 deg\nI_L3 : mag:   1.633573 phase:   -49.81421 deg\nI_L4 : mag:   0.541202 phase:   -73.25139 deg\nI_L5 : mag:   1.810802 phase:   163.88900 deg\nI_L6 : mag:   0.370519 phase:  -148.49885 deg\nI_F2 : mag:   1.810802 phase:   -16.11100 deg\nI_Ea2: mag:   0.541202 phase:   106.74861 deg\nI_H2 : mag:   0.717411 phase:   -63.15810 deg\nI_V7 : mag:   0.931072 phase:  -153.82412 deg\nI_V8 : mag:   0.899603 phase:   -21.50799 deg\nI_O1 : mag:   0.982866 phase:   -13.05368 deg\nI_O2 : mag:   1.693733 phase:     0.54829 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    10.4887 phase:   0.339452°  voltage\nV(8):   mag:    2.20263 phase:    -5.8879°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:   0.529319 phase:   -148.499°  voltage\nV(11):  mag:    2.23038 phase:    146.371°  voltage\nV(10):  mag:    2.31839 phase:    160.462°  voltage\nV(23):  mag:    8.49732 phase:   -9.75384°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:   0.910675 phase:   -94.0363°  voltage\nV(24):  mag:     4.1199 phase:    7.43283°  voltage\nV(3):   mag:    2.31839 phase:    160.462°  voltage\nV(20):  mag:    2.31839 phase:    160.462°  voltage\nV(5):   mag:    2.27445 phase:   -15.0807°  voltage\nV(12):  mag:    2.19411 phase:    152.046°  voltage\nV(18):  mag:     8.4815 phase:   -4.37559°  voltage\nV(26):  mag:    5.80559 phase:   -6.78388°  voltage\nV(25):  mag:     4.1199 phase:    7.43283°  voltage\nV(4):   mag:    2.71624 phase:   -16.1119°  voltage\nV(14):  mag:    4.77144 phase:     162.04°  voltage\nV(7):   mag:    1.81082 phase:    73.8881°  voltage\nV(15):  mag:    8.16625 phase:   -49.8218°  voltage\nV(21):  mag:    7.50792 phase:   -17.0934°  voltage\nV(13):  mag:    1.79919 phase:    158.492°  voltage\nV(28):  mag:    2.31839 phase:    160.462°  voltage\nV(27):  mag:    8.49732 phase:   -9.75384°  voltage\nV(17):  mag:    3.08423 phase:    60.4014°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    3.70502 phase:   -2.37192°  voltage\nV(32):  mag:    4.40507 phase:    174.112°  voltage\nV(31):  mag: 6.0913e-05 phase:   -4.03597°  voltage\nV(30):  mag:    3.75389 phase:    162.907°  voltage\nV(29):  mag: 4.73489e-05 phase:   -16.1831°     voltage\nI(C1):  mag:     1.5935 phase:   -5.92837°  device_current\nI(C2):  mag:   0.444041 phase:   -21.4012°  device_current\nI(F1):  mag:    1.81082 phase:   -16.1119°  device_current\nI(F2):  mag:    1.81082 phase:   -16.1119°  device_current\nI(H1):  mag:    1.48461 phase:   -177.452°  device_current\nI(H2):  mag:   0.717409 phase:   -63.1574°  device_current\nI(L1):  mag:    2.86299 phase:   -26.1518°  device_current\nI(L2):  mag:   0.854034 phase:   -141.418°  device_current\nI(L3):  mag:    1.63357 phase:   -49.8147°  device_current\nI(L4):  mag:   0.541197 phase:   -73.2497°  device_current\nI(L5):  mag:    1.81082 phase:    163.888°  device_current\nI(L6):  mag:   0.370523 phase:   -148.499°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:     1.6605 phase:    1.98853°  device_current\nI(R2):  mag:    1.10131 phase:    -5.8879°  device_current\nI(R6):  mag:   0.105864 phase:   -148.499°  device_current\nI(R8):  mag:  0.0705929 phase:    54.5194°  device_current\nI(R10): mag:   0.241259 phase:   -138.471°  device_current\nI(R11): mag:   0.589029 phase:   -163.163°  device_current\nI(R12): mag:    0.26466 phase:   -148.499°  device_current\nI(R14): mag:   0.270792 phase:    141.553°  device_current\nI(R15): mag:   0.944208 phase:    155.303°  device_current\nI(R7):  mag:   0.444041 phase:    158.599°  device_current\nI(R16): mag:   0.386398 phase:    160.462°  device_current\nI(R3):  mag:   0.207524 phase:   -35.9644°  device_current\nI(R4):  mag:    1.67746 phase:   -17.6897°  device_current\nI(R9):  mag:   0.164149 phase:   -172.751°  device_current\nI(R13): mag:    1.63325 phase:   -49.8218°  device_current\nI(R17): mag:    1.08737 phase:   -8.59974°  device_current\nI(R18): mag:   0.899593 phase:    158.492°  device_current\nI(R19): mag:   0.692348 phase:   -15.3907°  device_current\nI(R20): mag:    1.19191 phase:    171.035°  device_current\nI(R21): mag:     1.5935 phase:    174.072°  device_current\nI(R22): mag:   0.992596 phase:    164.183°  device_current\nI(R23): mag:   0.444041 phase:    158.599°  device_current\nI(R24): mag:   0.818256 phase:   -16.4696°  device_current\nI(R25): mag:    1.07892 phase:   -11.8466°  device_current\nI(R5):  mag:   0.772795 phase:    160.462°  device_current\nI(R26): mag: 0.000220257 phase:    174.112°     device_current\nI(R27): mag: 0.000375394 phase:    162.907°     device_current\nI(R28): mag:   0.982466 phase:   -13.0516°  device_current\nI(R29): mag:     1.6935 phase:   0.548618°  device_current\nI(R30): mag: 0.000375394 phase:    162.907°     device_current\nI(R31): mag: 0.000220257 phase:    174.112°     device_current\nI(G1):  mag:    0.90747 phase:   -54.3873°  device_current\nI(G2):  mag:    4.54891 phase:    164.919°  device_current\nI(E1):  mag:    1.63325 phase:    130.178°  device_current\nI(E2):  mag:   0.541197 phase:     106.75°  device_current\nI(V1):  mag:    1.54213 phase:    134.031°  device_current\nI(V2):  mag:   0.905412 phase:   -16.1119°  device_current\nI(V3):  mag:     2.0637 phase:    161.964°  device_current\nI(V4):  mag:     2.3388 phase:   -18.6996°  device_current\nI(V5):  mag:    2.70125 phase:   -15.0979°  device_current\nI(V6):  mag:    1.42243 phase:    -174.45°  device_current\nI(V7):  mag:   0.931071 phase:   -153.824°  device_current\nI(V8):  mag:   0.899593 phase:   -21.5082°  device_current\nIx(u1:3):   mag:    0.98284 phase:   -13.0531°  subckt_current\nIx(u2:3):   mag:    1.69372 phase:   0.547783°  subckt_current\nThere are some small numeric differences in some node voltages and phases.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>test_8</span>"
    ]
  },
  {
    "objectID": "test_8.html#ac-sweep",
    "href": "test_8.html#ac-sweep",
    "title": "12  test_8",
    "section": "12.3 AC Sweep",
    "text": "12.3 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 21 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_8/') # change directory to net list location\n\nfn = 'test_8.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 17\n\nH = u1[v21]\nH\n\n\\(\\displaystyle \\frac{6.79004139395635 \\cdot 10^{65} s^{8} + 1.0293431704604 \\cdot 10^{67} s^{7} + 2.49981109098941 \\cdot 10^{67} s^{6} + 5.93953469296071 \\cdot 10^{67} s^{5} + 1.35568791206657 \\cdot 10^{68} s^{4} - 9.16542835349853 \\cdot 10^{66} s^{3} - 1.96333723268553 \\cdot 10^{67} s^{2} - 6.18927920979722 \\cdot 10^{65} s + 1.01270750969341 \\cdot 10^{65}}{8.913726005184 \\cdot 10^{63} s^{8} + 1.27473779142732 \\cdot 10^{65} s^{7} + 2.08055572578768 \\cdot 10^{66} s^{6} + 1.06113557286994 \\cdot 10^{67} s^{5} + 1.44601020057986 \\cdot 10^{67} s^{4} - 2.0393562709238 \\cdot 10^{66} s^{3} - 2.01996788874414 \\cdot 10^{66} s^{2} - 5.61030064237194 \\cdot 10^{64} s + 1.01270750969341 \\cdot 10^{64}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 10*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>test_8</span>"
    ]
  },
  {
    "objectID": "test_9.html",
    "href": "test_9.html",
    "title": "13  test_9",
    "section": "",
    "text": "13.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ v_{1} : - \\frac{I_{1}}{g_{1} - g_{2}}\\right\\}\\)\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\n       -I₁  \nv₁ = ───────\n     g₁ - g₂",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>test_9</span>"
    ]
  },
  {
    "objectID": "test_9.html#numeric-solution",
    "href": "test_9.html#numeric-solution",
    "title": "13  test_9",
    "section": "13.2 Numeric solution",
    "text": "13.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nelement_values = {g1:0.600000,I1:1.0000e+01,g2:0.800000}\nequ1a = equ.subs(element_values)\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}10.0\\end{matrix}\\right]\\)\n\n\nSolve the equations for voltages and currents.\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ v_{1} : 50.0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:s}: {:f}'.format(str(name),float(value)))\n    #print(name,value)\n\nv1: 50.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(1):    50  voltage\nI(I1):   10  device_current\nI(R1):   5e-07   device_current\nI(G1):   30  device_current\nI(G2):   40  device_current\nThe results from LTSpice agree with the SymPy results.\nFind the power absorbed by each source in the circuit.\n\nelement_values[g1]*ans[v1]**2 # power through G1\n\n\\(\\displaystyle 1500.0\\)\n\n\n\nelement_values[g2]*ans[v1]**2 # power through G2\n\n\\(\\displaystyle 2000.0\\)\n\n\n\nelement_values[I1]*ans[v1] # power through I1\n\n\\(\\displaystyle 500.0\\)\n\n\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>test_9</span>"
    ]
  },
  {
    "objectID": "test_10.html",
    "href": "test_10.html",
    "title": "14  test_10",
    "section": "",
    "text": "14.1 Symbolic solution\nans = solve(equ,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{V1} : I_{1} + I_{3}, \\  I_{V2} : I_{2} - I_{3}, \\  I_{V3} : I_{3}, \\  I_{V4} : - I_{2}, \\  v_{1} : V_{2} - V_{4}, \\  v_{2} : V_{2}, \\  v_{3} : - V_{1} + V_{2}, \\  v_{4} : - V_{1} + V_{2} - V_{3}\\right\\}\\)\nleft_side = list(ans.keys())\nright_side = list(ans.values())\n\nfor i in range(len(ans)):\n    pprint(Eq(left_side[i],right_side[i]))\n\nI_V1 = I₁ + I₃\nI_V2 = I₂ - I₃\nI_V3 = I₃\nI_V4 = -I₂\nv₁ = V₂ - V₄\nv₂ = V₂\nv₃ = -V₁ + V₂\nv₄ = -V₁ + V₂ - V₃",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>test_10</span>"
    ]
  },
  {
    "objectID": "test_10.html#numeric-solution",
    "href": "test_10.html#numeric-solution",
    "title": "14  test_10",
    "section": "14.2 Numeric solution",
    "text": "14.2 Numeric solution\n\nelement_values = {\n    I1:2.0000e+00,\n    I2:-3.0000e+00,\n    I3:4.0000e+00,\n    V1:-5.0000e+00,\n    V2:3.0000e+00,\n    V3:4.0000e+00,\n    V4:1.2000e+01}\nequ1a = equ.subs(element_values)\n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{V4}\\\\I_{V1} + I_{V2} + I_{V4}\\\\- I_{V1} + I_{V3}\\\\- I_{V3}\\\\v_{2} - v_{3}\\\\v_{2}\\\\v_{3} - v_{4}\\\\- v_{1} + v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-3.0\\\\2.0\\\\-2.0\\\\-4.0\\\\-5.0\\\\3.0\\\\4.0\\\\12.0\\end{matrix}\\right]\\)\n\n\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{V1} : 6.0, \\  I_{V2} : -7.0, \\  I_{V3} : 4.0, \\  I_{V4} : 3.0, \\  v_{1} : -9.0, \\  v_{2} : 3.0, \\  v_{3} : 8.0, \\  v_{4} : 4.0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:5s}: {:11.5f}'.format(str(name),float(value)))\n    #print(name,value)\n\nI_V1 :     6.00000\nI_V2 :    -7.00000\nI_V3 :     4.00000\nI_V4 :     3.00000\nv1   :    -9.00000\nv2   :     3.00000\nv3   :     8.00000\nv4   :     4.00000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(3):    8   voltage\nV(2):    3   voltage\nV(1):    -9  voltage\nV(4):    4   voltage\nI(I1):   2   device_current\nI(I2):   -3  device_current\nI(I3):   4   device_current\nI(V1):   6   device_current\nI(V2):   -7  device_current\nI(V3):   4   device_current\nI(V4):   3   device_current\n\nFind the power supplied by the -5V source (V1)\n\n\nelement_values[V1]*ans[I_V1]\n\n\\(\\displaystyle -30.0\\)\n\n\n\nTo what value should the 4A source (I3) be changed to reduce the supply supplied by the -5V source (I_V1) to zero?\n\n\nI_V1 = I₁ + I₃\nI_V2 = I₂ - I₃\nI_V3 = I₃\nI_V4 = -I₂\nv₁ = V₂ - V₄\nv₂ = V₂\nv₃ = -V₁ + V₂\nv₄ = -V₁ + V₂ - V₃\nLooking at equation I_V1 = I₁ + I₃, set I_V1 to zero\n\nelement_values[I1] + element_values[I3] - 0\n\n\\(\\displaystyle 6.0\\)\n\n\nBy inspection a value of I3 = -2 will make I_V1 = 0\n\nelement_values[I1] + (-2) - 0\n\n\\(\\displaystyle 0.0\\)\n\n\nanswer is -2\nText book answers: (a) 30W; (b) -2A\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>test_10</span>"
    ]
  },
  {
    "objectID": "test_11.html",
    "href": "test_11.html",
    "title": "15  test_11",
    "section": "",
    "text": "15.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{L1} : \\frac{L_{2} L_{3} V_{1} s^{2} + L_{2} R_{3} V_{1} s + L_{3} R_{2} V_{1} s - M_{3}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  I_{L2} : \\frac{- L_{3} M_{1} V_{1} s^{2} - M_{1} R_{3} V_{1} s + M_{2} M_{3} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  I_{L3} : \\frac{- L_{2} M_{2} V_{1} s^{2} + M_{1} M_{3} V_{1} s^{2} - M_{2} R_{2} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  I_{V1} : \\frac{- L_{2} L_{3} V_{1} s^{2} - L_{2} R_{3} V_{1} s - L_{3} R_{2} V_{1} s + M_{3}^{2} V_{1} s^{2} - R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  v_{1} : \\frac{L_{1} L_{2} L_{3} V_{1} s^{3} + L_{1} L_{2} R_{3} V_{1} s^{2} + L_{1} L_{3} R_{2} V_{1} s^{2} - L_{1} M_{3}^{2} V_{1} s^{3} + L_{1} R_{2} R_{3} V_{1} s - L_{2} M_{2}^{2} V_{1} s^{3} - L_{3} M_{1}^{2} V_{1} s^{3} - M_{1}^{2} R_{3} V_{1} s^{2} + 2 M_{1} M_{2} M_{3} V_{1} s^{3} - M_{2}^{2} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  v_{2} : \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  v_{3} : V_{1}, \\  v_{4} : \\frac{L_{2} M_{2} R_{3} V_{1} s^{2} - M_{1} M_{3} R_{3} V_{1} s^{2} + M_{2} R_{2} R_{3} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\right\\}\\)\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\n                                   3                2                2        \n                      L₁⋅L₂⋅L₃⋅V₁⋅s  + L₁⋅L₂⋅R₃⋅V₁⋅s  + L₁⋅L₃⋅R₂⋅V₁⋅s  - L₁⋅M₃\nv₁ = ─────────────────────────────────────────────────────────────────────────\n               3             2             2        2  3                      \n     L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L₃⋅\n\n2     3                        2     3        2     3     2        2          \n ⋅V₁⋅s  + L₁⋅R₂⋅R₃⋅V₁⋅s - L₂⋅M₂ ⋅V₁⋅s  - L₃⋅M₁ ⋅V₁⋅s  - M₁ ⋅R₃⋅V₁⋅s  + 2⋅M₁⋅M₂\n──────────────────────────────────────────────────────────────────────────────\n    2        2  3                     2  3                  2     2           \nR₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M₂⋅\n\n        3     2        2                \n⋅M₃⋅V₁⋅s  - M₂ ⋅R₂⋅V₁⋅s                 \n────────────────────────────────────────\n    3     2     2     2     2           \nM₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                            - \nv₂ = ─────────────────────────────────────────────────────────────────────────\n               3             2             2        2  3                      \n     L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L₃⋅\n\n             2                                2                               \nL₃⋅M₁⋅R₂⋅V₁⋅s  - M₁⋅R₂⋅R₃⋅V₁⋅s + M₂⋅M₃⋅R₂⋅V₁⋅s                                \n──────────────────────────────────────────────────────────────────────────────\n    2        2  3                     2  3                  2     2           \nR₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M₂⋅\n\n                                        \n                                        \n────────────────────────────────────────\n    3     2     2     2     2           \nM₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\nv₃ = V₁\n                                                                              \n                                                                             L\nv₄ = ─────────────────────────────────────────────────────────────────────────\n               3             2             2        2  3                      \n     L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L₃⋅\n\n            2                2                                                \n₂⋅M₂⋅R₃⋅V₁⋅s  - M₁⋅M₃⋅R₃⋅V₁⋅s  + M₂⋅R₂⋅R₃⋅V₁⋅s                                \n──────────────────────────────────────────────────────────────────────────────\n    2        2  3                     2  3                  2     2           \nR₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M₂⋅\n\n                                        \n                                        \n────────────────────────────────────────\n    3     2     2     2     2           \nM₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                        - L₂⋅L\nI_V1 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n      2                               2     2                                 \n₃⋅V₁⋅s  - L₂⋅R₃⋅V₁⋅s - L₃⋅R₂⋅V₁⋅s + M₃ ⋅V₁⋅s  - R₂⋅R₃⋅V₁                      \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                         L₂⋅L₃\nI_L1 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n     2                               2     2                                  \n⋅V₁⋅s  + L₂⋅R₃⋅V₁⋅s + L₃⋅R₂⋅V₁⋅s - M₃ ⋅V₁⋅s  + R₂⋅R₃⋅V₁                       \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                              \nI_L2 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n                 2                          2                                 \n     - L₃⋅M₁⋅V₁⋅s  - M₁⋅R₃⋅V₁⋅s + M₂⋅M₃⋅V₁⋅s                                  \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                              \nI_L3 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n                 2             2                                              \n     - L₂⋅M₂⋅V₁⋅s  + M₁⋅M₃⋅V₁⋅s  - M₂⋅R₂⋅V₁⋅s                                 \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\nThe transfer function H(s)=V2(s)/V1\nsymbolic_solution[v2]/V1\n\n\\(\\displaystyle \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{V_{1} \\left(L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}\\right)}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>test_11</span>"
    ]
  },
  {
    "objectID": "test_11.html#numeric-solution",
    "href": "test_11.html#numeric-solution",
    "title": "15  test_11",
    "section": "15.2 Numeric solution",
    "text": "15.2 Numeric solution\n\n# put the component values into dictionary format\nK1, K2, K3 = symbols('K1 K2 K3') # initiate symbols for the inductor coupling coeff\ncomponent_values = {\n    V1:1.0000e+01,\n    L1:1.0000e+01,\n    L2:2.0000e+01,\n    L3:3.0000e+01,\n    R2:5.0000e+00,\n    R3:1.0000e+01,\n    R1:2.0000e+00,\n    K1:2.0000e-01,\n    K2:8.0000e-01,\n    K3:5.0000e-01}\n\nFrom the LTSpice netlist:\n\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n\nK1, K2 and K3 are the coefficient of coupling. These need to be converted to mutual inductance.\nNeed to solve for M1, M2 and M3:\n\\(M_1 = K1 \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = K2 \\times {\\sqrt{L_1 \\times L_3}}\\)\n\\(M_3 = K3 \\times {\\sqrt{L_2 \\times L_3}}\\)\n\n# calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]*np.sqrt(component_values[L1] *component_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M1]))\n\ncomponent_values[M2] = component_values[K2]*np.sqrt(component_values[L1] *component_values[L3])\nprint('mutual inductance, M2 = {:.9f}'.format(component_values[M2]))\n\ncomponent_values[M3] = component_values[K3]*np.sqrt(component_values[L2] *component_values[L3])\nprint('mutual inductance, M3 = {:.9f}'.format(component_values[M3]))\n\nmutual inductance, M1 = 2.828427125\nmutual inductance, M2 = 13.856406461\nmutual inductance, M3 = 12.247448714\n\n\n\ncomponent_values\n\n\\(\\displaystyle \\left\\{ K_{1} : 0.2, \\  K_{2} : 0.8, \\  K_{3} : 0.5, \\  L_{1} : 10.0, \\  L_{2} : 20.0, \\  L_{3} : 30.0, \\  M_{1} : 2.82842712474619, \\  M_{2} : 13.856406460551, \\  M_{3} : 12.2474487139159, \\  R_{1} : 2.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  V_{1} : 10.0\\right\\}\\)\n\n\n\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\- 10.0 I_{L1} s - 2.82842712474619 I_{L2} s - 13.856406460551 I_{L3} s + v_{1}\\\\- 2.82842712474619 I_{L1} s - 20.0 I_{L2} s - 12.2474487139159 I_{L3} s - v_{2}\\\\- 13.856406460551 I_{L1} s - 12.2474487139159 I_{L2} s - 30.0 I_{L3} s + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L1} : \\frac{2.25 \\cdot 10^{42} s^{2} + 1.75 \\cdot 10^{42} s + 2.5 \\cdot 10^{41}}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  I_{L2} : \\frac{4.24264068711928 \\cdot 10^{41} s^{2} - 1.4142135623731 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  I_{L3} : \\frac{- 1.21243556529821 \\cdot 10^{42} s^{2} - 3.46410161513775 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  I_{V1} : \\frac{- 2.25 \\cdot 10^{42} s^{2} - 1.75 \\cdot 10^{42} s - 2.5 \\cdot 10^{41}}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  v_{1} : \\frac{6.90000000000004 \\cdot 10^{42} s^{3} + 1.23 \\cdot 10^{43} s^{2} + 2.5 \\cdot 10^{42} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  v_{2} : \\frac{2.12132034355964 \\cdot 10^{42} s^{2} - 7.07106781186548 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  v_{3} : 10.0, \\  v_{4} : \\frac{1.21243556529821 \\cdot 10^{43} s^{2} + 3.46410161513775 \\cdot 10^{42} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}\\right\\}\\)\n\n\nThe transfer function H(s)=V2(s)/V1\n\nu1[v2]/component_values[V1]\n\n\\(\\displaystyle \\frac{0.1 \\cdot \\left(2.12132034355964 \\cdot 10^{42} s^{2} - 7.07106781186548 \\cdot 10^{41} s\\right)}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>test_11</span>"
    ]
  },
  {
    "objectID": "test_11.html#ac-analysis",
    "href": "test_11.html#ac-analysis",
    "title": "15  test_11",
    "section": "15.3 AC analysis",
    "text": "15.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\- 10.0 i I_{L1} - 2.82842712474619 i I_{L2} - 13.856406460551 i I_{L3} + v_{1}\\\\- 2.82842712474619 i I_{L1} - 20.0 i I_{L2} - 12.2474487139159 i I_{L3} - v_{2}\\\\- 13.856406460551 i I_{L1} - 12.2474487139159 i I_{L2} - 30.0 i I_{L3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L1} : 1.16416510318949 - 1.13789868667918 i, \\  I_{L2} : 0.264269551242702 + 0.0721699979297333 i, \\  I_{L3} : -0.729866062626583 + 0.252820924632006 i, \\  I_{V1} : -1.16416510318949 + 1.13789868667918 i, \\  v_{1} : 7.67166979362102 + 2.27579737335835 i, \\  v_{2} : 1.32134775621351 + 0.360849989648667 i, \\  v_{3} : 10.0, \\  v_{4} : 7.29866062626583 - 2.52820924632006 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   8.002110 phase:    16.52297 deg\nv2   : mag:   1.369735 phase:    15.27459 deg\nv3   : mag:  10.000000 phase:     0.00000 deg\nv4   : mag:   7.724137 phase:   -19.10576 deg\nI_V1 : mag:   1.627911 phase:   135.65371 deg\nI_L1 : mag:   1.627911 phase:   -44.34629 deg\nI_L2 : mag:   0.273947 phase:    15.27459 deg\nI_L3 : mag:   0.772414 phase:   160.89424 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\n\n\n\n--- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\nThere are some small numeric differences in some node voltages and phases.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>test_11</span>"
    ]
  },
  {
    "objectID": "test_11.html#ac-sweep",
    "href": "test_11.html#ac-sweep",
    "title": "15  test_11",
    "section": "15.4 AC Sweep",
    "text": "15.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 10 Hz.\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_11/') # change directory to net list location\n\nfn = 'test_11.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 2\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{2.12132034355964 \\cdot 10^{42} s^{2} - 7.07106781186548 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 10*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>test_11</span>"
    ]
  },
  {
    "objectID": "test_12.html",
    "href": "test_12.html",
    "title": "16  test_12",
    "section": "",
    "text": "16.1 Symbolic solution\nSymbolic equations are too long to display in a useful and meaningful way.\nsymbolic_solution = solve(equ,X)\n#symbolic_solution\nleft_side = list(symbolic_solution.keys()) right_side = list(symbolic_solution.values())\nfor i in range(len(symbolic_solution)): pprint(Eq(left_side[i],right_side[i]))\nThe transfer function H(s)=V4(s)/I1\n# display the transfer function\nH = symbolic_solution[v4]/I1\nH\n\n\\(\\displaystyle \\frac{Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\nGet the numerator and denominator of the transfer function.\nnum, denom = fraction(H) #returns numerator and denominator\nnum\n\n\\(\\displaystyle Rl Rs\\)\ndenom\n\n\\(\\displaystyle C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs\\)\ncollect((denom).expand(),s)\n\n\\(\\displaystyle C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + Rl + Rs + s^{6} \\left(C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl\\right) + s^{5} \\left(C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs + C_{3} C_{5} L_{2} L_{4} L_{6}\\right) + s^{4} \\left(C_{1} C_{3} L_{2} L_{4} Rs + C_{1} C_{3} L_{2} L_{6} Rs + C_{1} C_{5} L_{2} L_{6} Rs + C_{1} C_{5} L_{4} L_{6} Rs + C_{3} C_{5} L_{2} L_{4} Rl + C_{3} C_{5} L_{4} L_{6} Rs + C_{3} C_{7} L_{2} L_{4} Rl + C_{3} C_{7} L_{2} L_{6} Rl + C_{5} C_{7} L_{2} L_{6} Rl + C_{5} C_{7} L_{4} L_{6} Rl\\right) + s^{3} \\left(C_{1} C_{3} L_{2} Rl Rs + C_{1} C_{5} L_{2} Rl Rs + C_{1} C_{5} L_{4} Rl Rs + C_{1} C_{7} L_{2} Rl Rs + C_{1} C_{7} L_{4} Rl Rs + C_{1} C_{7} L_{6} Rl Rs + C_{3} C_{5} L_{4} Rl Rs + C_{3} C_{7} L_{4} Rl Rs + C_{3} C_{7} L_{6} Rl Rs + C_{3} L_{2} L_{4} + C_{3} L_{2} L_{6} + C_{5} C_{7} L_{6} Rl Rs + C_{5} L_{2} L_{6} + C_{5} L_{4} L_{6}\\right) + s^{2} \\left(C_{1} L_{2} Rs + C_{1} L_{4} Rs + C_{1} L_{6} Rs + C_{3} L_{2} Rl + C_{3} L_{4} Rs + C_{3} L_{6} Rs + C_{5} L_{2} Rl + C_{5} L_{4} Rl + C_{5} L_{6} Rs + C_{7} L_{2} Rl + C_{7} L_{4} Rl + C_{7} L_{6} Rl\\right) + s \\left(C_{1} Rl Rs + C_{3} Rl Rs + C_{5} Rl Rs + C_{7} Rl Rs + L_{2} + L_{4} + L_{6}\\right)\\)\nsolve(denom,s) #computes the symbolic roots of a univariate polynomial; will fail for most high-degree polynomials (five or greater)\n\n\\(\\displaystyle \\left[ \\right]\\)\nAs indicated by the comment above, the degree was too high for SymPy to extract the roots in symbolic form.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>test_12</span>"
    ]
  },
  {
    "objectID": "test_12.html#numeric-solution",
    "href": "test_12.html#numeric-solution",
    "title": "16  test_12",
    "section": "16.2 Numeric solution",
    "text": "16.2 Numeric solution\n\n# put the component values into dictionary format\ncomponent_values = {\n    C3:3.7642e+00,\n    I1:1.0000e+00,\n    C5:4.0150e+00,\n    C7:3.0182e+00,\n    L2:7.5290e-01,\n    L4:9.2760e-01,\n    L6:9.1420e-01,\n    Rs:5.0000e-01,\n    Rl:1.0000e+00,\n    C1:1.5948e+00}\n\n\ncomponent_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.5948, \\  C_{3} : 3.7642, \\  C_{5} : 4.015, \\  C_{7} : 3.0182, \\  I_{1} : 1.0, \\  L_{2} : 0.7529, \\  L_{4} : 0.9276, \\  L_{6} : 0.9142, \\  Rl : 1.0, \\  Rs : 0.5\\right\\}\\)\n\n\n\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\cdot \\left(1.5948 s + 2.0\\right)\\\\- I_{L2} + I_{L4} + 3.7642 s v_{2}\\\\- I_{L4} + I_{L6} + 4.015 s v_{3}\\\\- I_{L6} + v_{4} \\cdot \\left(3.0182 s + 1.0\\right)\\\\- 0.7529 I_{L2} s + v_{1} - v_{2}\\\\- 0.9276 I_{L4} s + v_{2} - v_{3}\\\\- 0.9142 I_{L6} s + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L2} : \\frac{6.04405263388334 \\cdot 10^{25} s^{5} + 2.00253549595234 \\cdot 10^{25} s^{4} + 7.190983534405 \\cdot 10^{25} s^{3} + 1.6567838375 \\cdot 10^{25} s^{2} + 1.68709375 \\cdot 10^{25} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  I_{L4} : \\frac{1.73099099009375 \\cdot 10^{25} s^{3} + 5.7351765625 \\cdot 10^{24} s^{2} + 1.0989375 \\cdot 10^{25} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  I_{L6} : \\frac{4.7159375 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{1} : \\frac{4.55056722805077 \\cdot 10^{25} s^{6} + 1.50770897490251 \\cdot 10^{25} s^{5} + 7.01975874546449 \\cdot 10^{25} s^{4} + 1.77938752919125 \\cdot 10^{25} s^{3} + 2.720718315625 \\cdot 10^{25} s^{2} + 4.05421875 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{2} : \\frac{1.60566724241096 \\cdot 10^{25} s^{4} + 5.319949779375 \\cdot 10^{24} s^{3} + 1.45050543125 \\cdot 10^{25} s^{2} + 2.8778125 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{3} : \\frac{4.3113100625 \\cdot 10^{24} s^{2} + 1.4284375 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{4} : \\frac{1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}\\right\\}\\)\n\n\nThe transfer function H(s)=V4(s)/I1\n\nTF = u1[v4]/component_values[I1]\nTF\n\n\\(\\displaystyle \\frac{1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}\\)\n\n\nThe large exponents can be removed by dividing throught by the numberator. First extract the numerator and denominator.\n\nnum, denom = fraction(TF) #returns numerator and denominator\n\n\nnum\n\n\\(\\displaystyle 1.5625 \\cdot 10^{24}\\)\n\n\n\ndenom\n\n\\(\\displaystyle 7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}\\)\n\n\nDivide both numerator and denominator by the numerator.\n\ndenom = denom/num\ndenom\n\n\\(\\displaystyle 46.4463655378904 s^{7} + 73.6360238673669 s^{6} + 129.629323718113 s^{5} + 120.830849397987 s^{4} + 96.568065040296 s^{3} + 49.56663856 s^{2} + 17.5816 s + 3.0\\)\n\n\n\nnum = num/num\nnum\n\n\\(\\displaystyle 1.0\\)\n\n\n\nPoly(denom, s).all_coeffs()\n\n\\(\\displaystyle \\left[ 46.4463655378904, \\  73.6360238673669, \\  129.629323718113, \\  120.830849397987, \\  96.568065040296, \\  49.56663856, \\  17.5816, \\  3.0\\right]\\)\n\n\n\nsolve(denom,s)\n\n\\(\\displaystyle \\left[ -0.35279422422017, \\  -0.31784520158577 - 0.434123823790121 i, \\  -0.31784520158577 + 0.434123823790121 i, \\  -0.219953275559662 - 0.782281046050157 i, \\  -0.219953275559662 + 0.782281046050157 i, \\  -0.0785039364726643 - 0.975486602515317 i, \\  -0.0785039364726643 + 0.975486602515317 i\\right]\\)\n\n\n\n## plot poles and zeros\ntf2 = TransferFunction(num, denom, s)\n\n#pole_zero_plot(tf1,show=False)\npole_zero_plot(tf2,show=True)\n\n\n\n\n\n\n\n\n\nbode_plot(tf2,initial_exp=-2, final_exp=0,freq_unit='Hz', phase_unit='deg')  \n\n\n\n\n\n\n\n\nAs shown above, SymPy can easily plot the poles and zeros as well as the Bode function.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>test_12</span>"
    ]
  },
  {
    "objectID": "test_12.html#ac-analysis",
    "href": "test_12.html#ac-analysis",
    "title": "16  test_12",
    "section": "16.3 AC analysis",
    "text": "16.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\cdot \\left(2.0 + 1.5948 i\\right)\\\\- I_{L2} + I_{L4} + 3.7642 i v_{2}\\\\- I_{L4} + I_{L6} + 4.015 i v_{3}\\\\- I_{L6} + v_{4} \\cdot \\left(1.0 + 3.0182 i\\right)\\\\- 0.7529 i I_{L2} + v_{1} - v_{2}\\\\- 0.9276 i I_{L4} + v_{2} - v_{3}\\\\- 0.9142 i I_{L6} + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L2} : 0.91783063115158 - 0.628201043697012 i, \\  I_{L4} : -1.03597965840028 + 0.48128854484449 i, \\  I_{L6} : 0.738345705661929 - 0.127768789322744 i, \\  v_{1} : 0.178224787110382 + 0.171984076606687 i, \\  v_{2} : -0.294747778689098 - 0.519050605587337 i, \\  v_{3} : 0.151695475508651 + 0.441924125544758 i, \\  v_{4} : 0.0348892483097982 - 0.233071518571377 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.247674 phase:    43.97910 deg\nv2   : mag:   0.596900 phase:  -119.59049 deg\nv3   : mag:   0.467235 phase:    71.05463 deg\nv4   : mag:   0.235668 phase:   -81.48642 deg\nI_L2 : mag:   1.112227 phase:   -34.38934 deg\nI_L4 : mag:   1.142319 phase:   155.08167 deg\nI_L6 : mag:   0.749319 phase:    -9.81766 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:     0.5969 phase:    -119.59°  voltage\nV(1):   mag:   0.247674 phase:    43.9791°  voltage\nV(3):   mag:   0.467235 phase:    71.0546°  voltage\nV(4):   mag:   0.235668 phase:   -81.4864°  voltage\nI(C3):  mag:    2.24685 phase:   -29.5905°  device_current\nI(C5):  mag:    1.87595 phase:    161.055°  device_current\nI(C7):  mag:   0.711294 phase:    8.51358°  device_current\nI(C1):  mag:   0.394991 phase:    133.979°  device_current\nI(L2):  mag:    1.11223 phase:   -34.3893°  device_current\nI(L4):  mag:    1.14232 phase:    155.082°  device_current\nI(L6):  mag:   0.749319 phase:   -9.81766°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(Rs):  mag:   0.495349 phase:    43.9791°  device_current\nI(Rl):  mag:   0.235668 phase:   -81.4864°  device_current\nThe python and LTspice results agree.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>test_12</span>"
    ]
  },
  {
    "objectID": "test_12.html#ac-sweep",
    "href": "test_12.html#ac-sweep",
    "title": "16  test_12",
    "section": "16.4 AC Sweep",
    "text": "16.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 4 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_12/') # change directory to net list location\n\nfn = 'test_12_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 2\n\nH = u1[v4]\nH\n\n\\(\\displaystyle \\frac{1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe data from python and LTSpice match.\n\n\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley & Sons.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>test_12</span>"
    ]
  },
  {
    "objectID": "test_13.html",
    "href": "test_13.html",
    "title": "17  test_13",
    "section": "",
    "text": "17.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\n#symbolic_solution\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\n     -I₁⋅L₃⋅L₄⋅s + I₂⋅L₁⋅L₄⋅s + I₂⋅L₂⋅L₄⋅s + I₂⋅L₃⋅L₄⋅s - I₃⋅L₂⋅L₄⋅s - I₄⋅L₁⋅L\nv₁ = ─────────────────────────────────────────────────────────────────────────\n                                  L₁ + L₂ + L₃ + L₄                           \n\n₄⋅s\n───\n   \n     I₁⋅L₁⋅L₃⋅s + I₁⋅L₂⋅L₃⋅s + I₂⋅L₁⋅L₄⋅s + I₂⋅L₂⋅L₄⋅s - I₃⋅L₂⋅L₃⋅s - I₃⋅L₂⋅L₄\nv₂ = ─────────────────────────────────────────────────────────────────────────\n                                               L₁ + L₂ + L₃ + L₄              \n\n⋅s - I₄⋅L₁⋅L₃⋅s - I₄⋅L₁⋅L₄⋅s\n────────────────────────────\n                            \n     I₁⋅L₂⋅L₃⋅s + I₂⋅L₂⋅L₄⋅s - I₃⋅L₁⋅L₂⋅s - I₃⋅L₂⋅L₃⋅s - I₃⋅L₂⋅L₄⋅s + I₄⋅L₁⋅L₂\nv₃ = ─────────────────────────────────────────────────────────────────────────\n                                  L₁ + L₂ + L₃ + L₄                           \n\n⋅s\n──\n  \n       I₁⋅L₃ + I₂⋅L₄ + I₃⋅L₂ - I₄⋅L₂ - I₄⋅L₃ - I₄⋅L₄\nI_L1 = ─────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄              \n       -I₁⋅L₃ - I₂⋅L₄ + I₃⋅L₁ + I₃⋅L₃ + I₃⋅L₄ - I₄⋅L₁\nI_L2 = ──────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄               \n       I₁⋅L₁ + I₁⋅L₂ + I₁⋅L₄ - I₂⋅L₄ - I₃⋅L₂ - I₄⋅L₁\nI_L3 = ─────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄              \n       -I₁⋅L₃ + I₂⋅L₁ + I₂⋅L₂ + I₂⋅L₃ - I₃⋅L₂ - I₄⋅L₁\nI_L4 = ──────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄\nThe transfer function H(s)=V2(s)/I1\nI1\n\n\\(\\displaystyle I_{1}\\)\nsymbolic_solution[v2]\n\n\\(\\displaystyle \\frac{I_{1} L_{1} L_{3} s + I_{1} L_{2} L_{3} s + I_{2} L_{1} L_{4} s + I_{2} L_{2} L_{4} s - I_{3} L_{2} L_{3} s - I_{3} L_{2} L_{4} s - I_{4} L_{1} L_{3} s - I_{4} L_{1} L_{4} s}{L_{1} + L_{2} + L_{3} + L_{4}}\\)\nsymbolic_solution[v2]/I1\n\n\\(\\displaystyle \\frac{I_{1} L_{1} L_{3} s + I_{1} L_{2} L_{3} s + I_{2} L_{1} L_{4} s + I_{2} L_{2} L_{4} s - I_{3} L_{2} L_{3} s - I_{3} L_{2} L_{4} s - I_{4} L_{1} L_{3} s - I_{4} L_{1} L_{4} s}{I_{1} \\left(L_{1} + L_{2} + L_{3} + L_{4}\\right)}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>test_13</span>"
    ]
  },
  {
    "objectID": "test_13.html#numeric-solution",
    "href": "test_13.html#numeric-solution",
    "title": "17  test_13",
    "section": "17.2 Numeric solution",
    "text": "17.2 Numeric solution\n\n# put the component values into dictionary format\ncomponent_values = {\n    L1:5.0000e+00,\n    I1:2.0000e+00,\n    L2:3.0000e+00,\n    L3:1.0000e+00,\n    L4:1.0000e+00,\n    I2:1.0000e+00,\n    I3:5.0000e+00,\n    I4:3.0000e+00}\n\nNeed to set the DC sources to zero.\n\ncomponent_values[I2] = 0\ncomponent_values[I3] = 0\ncomponent_values[I4] = 0\n\n\ncomponent_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 2.0, \\  I_{2} : 0, \\  I_{3} : 0, \\  I_{4} : 0, \\  L_{1} : 5.0, \\  L_{2} : 3.0, \\  L_{3} : 1.0, \\  L_{4} : 1.0\\right\\}\\)\n\n\n\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L1} - I_{L2}\\\\- 5.0 I_{L1} s + v_{2} - v_{3}\\\\- 3.0 I_{L2} s - v_{3}\\\\- 1.0 I_{L3} s - v_{1} + v_{2}\\\\- 1.0 I_{L4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L1} : 0.2, \\  I_{L2} : -0.2, \\  I_{L3} : 1.8, \\  I_{L4} : -0.2, \\  v_{1} : - 0.2 s, \\  v_{2} : 1.6 s, \\  v_{3} : 0.6 s\\right\\}\\)\n\n\nThe transfer function H(s)=V2(s)/I1\n\nu1[v2]/component_values[I1]\n\n\\(\\displaystyle 0.8 s\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>test_13</span>"
    ]
  },
  {
    "objectID": "test_13.html#ac-analysis",
    "href": "test_13.html#ac-analysis",
    "title": "17  test_13",
    "section": "17.3 AC analysis",
    "text": "17.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L1} - I_{L2}\\\\- 5.0 i I_{L1} + v_{2} - v_{3}\\\\- 3.0 i I_{L2} - v_{3}\\\\- 1.0 i I_{L3} - v_{1} + v_{2}\\\\- 1.0 i I_{L4} + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L1} : 0.2, \\  I_{L2} : -0.2, \\  I_{L3} : 1.8, \\  I_{L4} : -0.2, \\  v_{1} : - 0.2 i, \\  v_{2} : 1.6 i, \\  v_{3} : 0.6 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.200000 phase:   -90.00000 deg\nv2   : mag:   1.600000 phase:    90.00000 deg\nv3   : mag:   0.600000 phase:    90.00000 deg\nI_L1 : mag:   0.200000 phase:     0.00000 deg\nI_L2 : mag:   0.200000 phase:   180.00000 deg\nI_L3 : mag:   1.800000 phase:     0.00000 deg\nI_L4 : mag:   0.200000 phase:   180.00000 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: 5.72958e-12°     device_current\nI(L2):  mag:        0.2 phase:       -180°  device_current\nI(L3):  mag:        1.8 phase: -6.3662e-13°     device_current\nI(L4):  mag:        0.2 phase:       -180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nUsing the orginal circuit with the series resistance in L1 set to a small value, the phase of the currents in L2 and L4 didn’t agree with the Python results. So the netlist was modified to put the small series resistance in L3, which allowed the phase in L2 and L3 to agree.\nThe new LTSpice net list with Rser=1e-20 added to L3.\n* C:\\users\\jeff32\\My Documents\\Solving Electrical Engineering Problems with Python Blog\\MNA Test Circuits\\test_13\\test_13.asc\nL1 2 3 5 Rser=0\nI1 1 2 2 AC 2\nL2 0 3 3 Rser=0\nL3 2 1 1 Rser=1e-20\nL4 1 0 1 Rser=0\nI2 0 1 1\nI3 3 0 5\nI4 2 3 3\n;op\n* ;.ac list 0.159154943091895\n* ;K1 L3 L2 0.5\n.ac dec 100 0.1 10\n.backanno\n.end\nThe LTStresults now agree.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: -5.15662e-19°    device_current\nI(L2):  mag:        0.2 phase:        180°  device_current\nI(L3):  mag:        1.8 phase: 5.72958e-20°     device_current\nI(L4):  mag:        0.2 phase:        180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nThere are some small numeric differences in some node voltages and phases because of the series resistance. Also note the the phase of the current for L2 and L4 from LTSpice is -180 vs +180 as calculated by SymPy.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>test_13</span>"
    ]
  },
  {
    "objectID": "test_13.html#ac-sweep",
    "href": "test_13.html#ac-sweep",
    "title": "17  test_13",
    "section": "17.4 AC Sweep",
    "text": "17.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.1 Hz to 10 Hz.\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_13/') # change directory to net list location\n\nfn = 'test_13.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 2\n\nH = u1[v2]\nH\n\n\\(\\displaystyle 1.6 s\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.1*2*np.pi, 10*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>test_13</span>"
    ]
  },
  {
    "objectID": "test_14.html",
    "href": "test_14.html",
    "title": "18  test_14",
    "section": "",
    "text": "18.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{C_{1} I_{1} R_{1} s}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}, \\  v_{1} : \\frac{- C_{1} I_{1} L_{1} R_{1} s^{2} - I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}, \\  v_{2} : - \\frac{I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>test_14</span>"
    ]
  },
  {
    "objectID": "test_14.html#numeric-solution",
    "href": "test_14.html#numeric-solution",
    "title": "18  test_14",
    "section": "18.2 Numeric solution",
    "text": "18.2 Numeric solution\n\n# enter the element values, set I2=0\nequ1a = equ.subs({\nI1:1.0000e+00,\nR1:5.0000e-02,\nL1:2.5000e-02,\nC1:2.5000e-01\n})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 20.0 v_{1}\\\\- I_{L1} + 0.25 s v_{2}\\\\- 0.025 I_{L1} s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{2.0 s}{s^{2} + 2.0 s + 160.0}, \\  v_{1} : \\frac{- s^{2} - 160.0}{20.0 s^{2} + 40.0 s + 3200.0}, \\  v_{2} : - \\frac{8.0}{s^{2} + 2.0 s + 160.0}\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>test_14</span>"
    ]
  },
  {
    "objectID": "test_14.html#ac-analysis",
    "href": "test_14.html#ac-analysis",
    "title": "18  test_14",
    "section": "18.3 AC analysis",
    "text": "18.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\n1/(2*np.pi)\n\n\\(\\displaystyle 0.159154943091895\\)\n\n\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 20.0 v_{1}\\\\- I_{L1} + 0.25 i v_{2}\\\\- 0.025 i I_{L1} + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L1} : -0.000158196559224837 - 0.0125766264583745 i, \\  v_{1} : -0.0499920901720388 + 0.000628831322918727 i, \\  v_{2} : -0.0503065058334981 + 0.000632786236899347 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.049996 phase:   179.27934 deg\nv2   : mag:   0.050310 phase:   179.27934 deg\nI_L1 : mag:   0.012578 phase:   -90.72066 deg\n\n\nThe following results were obtained from LTSpice.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:  0.0499959 phase:    179.279°  voltage\nV(2):   mag:  0.0503103 phase:    179.265°  voltage\nI(C1):  mag:  0.0125776 phase:   -90.7351°  device_current\nI(L1):  mag:  0.0125776 phase:   -90.7351°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.999918 phase:    179.279°  device_current\n\nThe LTSpice results are the same.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>test_14</span>"
    ]
  },
  {
    "objectID": "test_14.html#ac-sweep",
    "href": "test_14.html#ac-sweep",
    "title": "18  test_14",
    "section": "18.4 AC Sweep",
    "text": "18.4 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. Thr frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_14/') # change directory to net list location\n\nfn = 'test_14.csv' # data from LTSpice\n#LTSpice_data = np.loadtxt(fn, delimiter='\\t',skiprows=1)\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n\nLoad the Laplace polyinominal for node 5\n\nH = u1[v2]\nH\n\n\\(\\displaystyle - \\frac{8.0}{s^{2} + 2.0 s + 160.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_v2 = (a, b) # system for circuit 1\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag_v2, phase_v2 = signal.bode(system_v2, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(V_2)),'-k')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag_v2,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(V_2)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase_v2,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2[0:-1]))-mag_v2,'-k')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_2[0:-1])*180/np.pi-phase_v2,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Mag and Phase difference')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfrequency[0:-1]-w/(2*np.pi)\n\narray([ 0.00000000e+00, -3.98986399e-17,  3.46944695e-18,  3.46944695e-17,\n       -5.03069808e-17, -3.46944695e-17, -2.94902991e-17,  1.73472348e-18,\n       -3.12250226e-17, -1.90819582e-17,  2.42861287e-17, -3.98986399e-17,\n        2.60208521e-17, -3.12250226e-17, -5.03069808e-17, -3.98986399e-17,\n        2.77555756e-17,  2.94902991e-17,  2.08166817e-17, -1.04083409e-17,\n       -3.46944695e-17,  0.00000000e+00, -6.93889390e-18, -4.16333634e-17,\n       -5.55111512e-17, -2.77555756e-17, -3.46944695e-17,  2.42861287e-17,\n        2.77555756e-17, -5.55111512e-17,  0.00000000e+00,  6.93889390e-18,\n        0.00000000e+00, -2.42861287e-17, -3.12250226e-17,  0.00000000e+00,\n       -2.77555756e-17, -2.77555756e-17,  3.46944695e-18, -1.04083409e-17,\n        3.46944695e-18, -4.16333634e-17, -1.73472348e-17, -5.20417043e-17,\n       -5.89805982e-17, -3.12250226e-17, -5.89805982e-17, -5.20417043e-17,\n       -5.89805982e-17, -3.46944695e-18, -9.02056208e-17, -2.77555756e-17,\n       -1.38777878e-17, -5.55111512e-17, -6.24500451e-17, -4.85722573e-17,\n       -4.16333634e-17, -6.24500451e-17, -2.77555756e-17, -4.85722573e-17,\n       -3.46944695e-17, -6.24500451e-17, -4.16333634e-17, -5.55111512e-17,\n       -1.11022302e-16, -9.71445147e-17, -1.11022302e-16, -1.11022302e-16,\n       -1.52655666e-16, -1.17961196e-16, -1.45716772e-16, -8.32667268e-17,\n       -1.59594560e-16, -6.93889390e-17, -1.52655666e-16, -1.11022302e-16,\n       -9.71445147e-17, -9.71445147e-17, -1.80411242e-16, -1.17961196e-16,\n       -1.24900090e-16, -1.66533454e-16, -2.08166817e-16, -1.80411242e-16,\n       -1.24900090e-16, -2.08166817e-16, -1.80411242e-16, -1.80411242e-16,\n       -1.52655666e-16, -1.94289029e-16, -2.35922393e-16, -2.35922393e-16,\n       -1.80411242e-16, -2.77555756e-16, -2.35922393e-16, -2.91433544e-16,\n       -2.63677968e-16, -2.91433544e-16, -2.91433544e-16, -2.63677968e-16,\n       -3.05311332e-16, -4.16333634e-16,  4.16333634e-17, -6.52256027e-16,\n       -5.13478149e-16, -3.60822483e-16, -2.91433544e-16,  2.77555756e-17,\n       -3.19189120e-16, -1.66533454e-16, -7.49400542e-16, -4.16333634e-16,\n       -7.21644966e-16, -3.88578059e-16, -5.27355937e-16, -4.71844785e-16,\n       -7.21644966e-16, -7.21644966e-16, -8.04911693e-16, -1.11022302e-16,\n       -3.33066907e-16, -9.71445147e-16, -1.02695630e-15, -4.16333634e-16,\n       -5.55111512e-16, -3.05311332e-16, -3.60822483e-16, -7.49400542e-16,\n       -7.49400542e-16, -5.82867088e-16, -9.99200722e-16, -9.43689571e-16,\n       -9.71445147e-16, -1.24900090e-15, -1.27675648e-15, -9.71445147e-16,\n       -1.36002321e-15, -1.30451205e-15, -1.11022302e-15, -1.11022302e-15,\n       -1.05471187e-15, -1.33226763e-15, -1.16573418e-15, -1.55431223e-15,\n       -1.60982339e-15, -1.38777878e-15, -1.55431223e-15, -1.55431223e-15,\n       -1.60982339e-15, -1.05471187e-15, -1.94289029e-15, -1.22124533e-15,\n       -1.11022302e-15, -1.55431223e-15, -1.66533454e-15, -1.49880108e-15,\n       -1.38777878e-15, -1.55431223e-15, -2.27595720e-15, -1.66533454e-15,\n       -2.33146835e-15, -1.83186799e-15, -2.55351296e-15, -1.77635684e-15,\n       -2.16493490e-15, -2.27595720e-15, -2.16493490e-15, -2.05391260e-15,\n       -2.27595720e-15, -2.22044605e-15, -2.22044605e-15, -2.77555756e-15,\n       -2.55351296e-15, -2.66453526e-15, -2.55351296e-15, -3.10862447e-15,\n       -2.88657986e-15, -2.99760217e-15, -2.77555756e-15, -3.21964677e-15,\n       -3.33066907e-15, -3.66373598e-15, -4.10782519e-15, -3.88578059e-15,\n       -3.66373598e-15, -3.99680289e-15, -4.32986980e-15, -4.77395901e-15,\n       -4.99600361e-15, -4.99600361e-15, -4.66293670e-15, -4.55191440e-15,\n       -4.88498131e-15, -4.32986980e-15, -4.44089210e-15, -5.44009282e-15,\n       -5.66213743e-15, -4.99600361e-15, -5.88418203e-15, -5.66213743e-15,\n       -5.99520433e-15, -4.66293670e-15, -9.54791801e-15, -7.10542736e-15,\n       -5.10702591e-15, -2.88657986e-15, -2.88657986e-15, -9.10382880e-15,\n       -3.10862447e-15, -1.11022302e-14, -7.54951657e-15, -3.77475828e-15,\n       -7.32747196e-15, -3.33066907e-15, -5.10702591e-15, -4.21884749e-15,\n       -7.99360578e-15, -7.32747196e-15, -8.65973959e-15, -1.13242749e-14,\n       -1.42108547e-14, -9.54791801e-15, -1.13242749e-14, -1.44328993e-14,\n       -1.62092562e-14, -1.26565425e-14, -1.42108547e-14, -7.54951657e-15,\n       -1.84297022e-14, -1.55431223e-14, -1.06581410e-14, -9.76996262e-15,\n       -1.86517468e-14, -1.24344979e-14, -1.15463195e-14, -1.99840144e-14,\n       -1.24344979e-14, -2.30926389e-14, -1.99840144e-14, -2.08721929e-14,\n       -1.95399252e-14, -2.48689958e-14, -2.13162821e-14, -1.68753900e-14,\n       -1.64313008e-14, -2.48689958e-14, -2.53130850e-14, -2.70894418e-14,\n       -2.66453526e-14, -2.17603713e-14, -2.93098879e-14, -2.39808173e-14,\n       -3.10862447e-14, -2.75335310e-14, -2.62012634e-14, -2.66453526e-14,\n       -3.41948692e-14, -2.35367281e-14, -3.28626015e-14, -2.48689958e-14,\n       -3.33066907e-14, -3.64153152e-14, -3.46389584e-14, -3.55271368e-14,\n       -4.08562073e-14, -3.99680289e-14, -4.17443857e-14, -4.08562073e-14,\n       -4.52970994e-14, -4.17443857e-14, -4.44089210e-14, -3.81916720e-14,\n       -4.88498131e-14, -4.70734562e-14, -4.88498131e-14, -5.15143483e-14,\n       -5.24025268e-14, -4.97379915e-14, -5.15143483e-14, -5.24025268e-14,\n       -5.68434189e-14, -5.59552404e-14, -5.68434189e-14, -5.95079541e-14,\n       -5.32907052e-14, -6.03961325e-14, -5.95079541e-14, -6.75015599e-14,\n       -6.57252031e-14, -6.92779167e-14, -6.39488462e-14, -7.46069873e-14,\n       -6.92779167e-14, -7.81597009e-14, -7.46069873e-14, -7.99360578e-14,\n       -7.63833441e-14, -8.34887715e-14, -8.88178420e-14, -9.23705556e-14,\n       -9.05941988e-14, -4.44089210e-14, -9.59232693e-14, -7.10542736e-14,\n       -5.15143483e-14, -1.42108547e-13, -1.27897692e-13, -1.03028697e-13,\n       -1.31450406e-13, -1.10134124e-13, -7.46069873e-14, -1.35003120e-13,\n       -1.74082970e-13, -1.33226763e-13, -1.52766688e-13, -1.40332190e-13,\n       -1.81188398e-13, -1.72306613e-13, -1.84741111e-13, -1.11910481e-13,\n       -1.42108547e-13, -1.98951966e-13, -2.13162821e-13, -1.45661261e-13,\n       -1.63424829e-13, -1.27897692e-13, -1.45661261e-13, -1.77635684e-13,\n       -1.84741111e-13, -1.52766688e-13, -2.09610107e-13, -1.95399252e-13,\n       -2.02504680e-13, -2.20268248e-13, -2.23820962e-13, -1.98951966e-13,\n       -2.23820962e-13, -2.23820962e-13, -2.02504680e-13, -2.09610107e-13,\n       -2.94875235e-13, -2.48689958e-13, -2.13162821e-13, -2.66453526e-13,\n       -2.62900812e-13, -3.51718654e-13, -2.55795385e-13, -2.70006240e-13,\n       -2.59348099e-13, -3.19744231e-13, -2.87769808e-13, -3.48165941e-13,\n       -3.12638804e-13, -3.76587650e-13, -3.62376795e-13, -3.69482223e-13,\n       -3.41060513e-13, -3.83693077e-13, -4.26325641e-13, -4.47641924e-13,\n       -4.33431069e-13, -4.54747351e-13, -4.54747351e-13, -4.54747351e-13,\n       -5.11590770e-13, -5.04485342e-13, -5.11590770e-13, -5.04485342e-13,\n       -5.47117907e-13, -5.18696197e-13, -5.54223334e-13, -5.82645043e-13,\n       -5.82645043e-13, -5.75539616e-13, -6.82121026e-13, -6.11066753e-13,\n       -7.24753590e-13, -6.96331881e-13, -7.10542736e-13, -7.31859018e-13,\n       -7.67386155e-13, -7.53175300e-13, -7.38964445e-13, -7.95807864e-13,\n       -7.24753590e-13, -8.10018719e-13, -7.81597009e-13, -8.66862138e-13,\n       -8.66862138e-13, -9.09494702e-13, -9.37916411e-13, -9.52127266e-13,\n       -9.80548975e-13, -1.06581410e-12, -1.05160325e-12, -1.10844667e-12,\n       -1.06581410e-12, -1.16529009e-12, -1.08002496e-12, -1.20792265e-12])",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>test_14</span>"
    ]
  },
  {
    "objectID": "test_15.html",
    "href": "test_15.html",
    "title": "19  test_15",
    "section": "",
    "text": "19.1 Symbolic solution\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ v_{1} : \\frac{- C_{1} C_{2} I_{1} R_{1} R_{2} R_{3} s^{2} - C_{1} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}, \\  v_{2} : \\frac{- C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}, \\  v_{3} : - \\frac{I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>test_15</span>"
    ]
  },
  {
    "objectID": "test_15.html#numeric-solution",
    "href": "test_15.html#numeric-solution",
    "title": "19  test_15",
    "section": "19.2 Numeric solution",
    "text": "19.2 Numeric solution\n\n# enter the element values, set I2=0\nequ1a = equ.subs({\nI1:1.0000e+00,\nR1:1.0000e+01,\nR2:1.0000e+01,\nR3:1.0000e+03,\nC1:1.0000e-02,\nC2:2.0000e-03\n})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1} - 0.1 v_{2}\\\\- 0.1 v_{1} + v_{2} \\cdot \\left(0.01 s + 0.101\\right) - 0.001 v_{3}\\\\- 0.001 v_{2} + v_{3} \\cdot \\left(0.002 s + 0.001\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ v_{1} : \\frac{- 50.0 s^{2} - 530.0 s - 250.0}{10.0 s^{2} + 56.0 s + 25.0}, \\  v_{2} : \\frac{- 500.0 s - 250.0}{10.0 s^{2} + 56.0 s + 25.0}, \\  v_{3} : - \\frac{250.0}{10.0 s^{2} + 56.0 s + 25.0}\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>test_15</span>"
    ]
  },
  {
    "objectID": "test_15.html#ac-analysis",
    "href": "test_15.html#ac-analysis",
    "title": "19  test_15",
    "section": "19.3 AC analysis",
    "text": "19.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\n1/(2*np.pi)\n\n\\(\\displaystyle 0.159154943091895\\)\n\n\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1} - 0.1 v_{2}\\\\- 0.1 v_{1} + v_{2} \\cdot \\left(0.101 + 0.01 i\\right) - 0.001 v_{3}\\\\- 0.001 v_{2} + v_{3} \\cdot \\left(0.001 + 0.002 i\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ v_{1} : -9.72329663790538 + 0.966974114846772 i, \\  v_{2} : -9.44659327581077 + 1.93394822969354 i, \\  v_{3} : -1.11573936328474 + 4.16542695626302 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   9.771261 phase:   174.32065 deg\nv2   : mag:   9.642525 phase:   168.43003 deg\nv3   : mag:   4.312268 phase:   104.99508 deg\n\n\nThe following results were obtained from LTSpice.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    9.77126 phase:    174.321°  voltage\nV(2):   mag:    9.64252 phase:     168.43°  voltage\nV(3):   mag:    4.31227 phase:    104.995°  voltage\nI(C1):  mag:  0.0964252 phase:    -101.57°  device_current\nI(C2):  mag: 0.00862454 phase:   -165.005°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.977126 phase:    174.321°  device_current\nI(R2):  mag:   0.100579 phase:    74.0313°  device_current\nI(R3):  mag: 0.00862454 phase:    14.9951°  device_current\nThe LTSpice results are the same.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>test_15</span>"
    ]
  },
  {
    "objectID": "test_15.html#ac-sweep",
    "href": "test_15.html#ac-sweep",
    "title": "19  test_15",
    "section": "19.4 AC Sweep",
    "text": "19.4 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. Thr frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_15/') # change directory to net list location\n\nfn = 'test_15.csv' # data from LTSpice\n#LTSpice_data = np.loadtxt(fn, delimiter='\\t',skiprows=1)\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\nV_3 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n    V_3[i] = LTSpice_data[i][5] + LTSpice_data[i][6]*1j\n\nLoad the Laplace polyinominal for node 5\n\nH = u1[v3]\nH\n\n\\(\\displaystyle - \\frac{250.0}{10.0 s^{2} + 56.0 s + 25.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_v3 = (a, b) # system for circuit 1\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag_v3, phase_v3 = signal.bode(system_v3, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(V_3)),'-k')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(V_3)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_3[0:-1]))-mag_v3,'-k')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_3[0:-1])*180/np.pi-phase_v3,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Bode plot difference')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>test_15</span>"
    ]
  },
  {
    "objectID": "Example-problems.html",
    "href": "Example-problems.html",
    "title": "Example problems",
    "section": "",
    "text": "Example problems\nThe table below lists the example problems completed so far.",
    "crumbs": [
      "Example problems"
    ]
  },
  {
    "objectID": "Example-problems.html#example-problems",
    "href": "Example-problems.html#example-problems",
    "title": "Example problems",
    "section": "",
    "text": "Circuit Description\nnotes\n\n\n\n\nTwo amplifier RIAA Phone Preamp\nA circuit for a phono preamp is analyized.\n\n\nTwo port parameters\nTwo port parameters are derived from the circuit’s netlist.\n\n\nThevenin equivalent circuit\nThe Thevenin equivalent circuit is obtained from a netlist.\n\n\nState variable filter\nNetwork equations for a state variable filter are obtained from the netlist which are solved in symbolic form.\n\n\nA polyphase circuit\nTBD",
    "crumbs": [
      "Example problems"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html",
    "href": "Two amplifier RIAA Phono Preamp.html",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "",
    "text": "Abstract\nThis paper analyizes the circuit for the RIAA preamp given in the Texas Instruments application note AN346, High-Performance Audio Applications of the LM833, shown in the app note as Figure 3. The schematic for the phono preamplifier was entered into LTSpice and the circuit net list was generated. A circuit analysis method called the Modified Nodal Analysis was used to derive the symbolic circuit equations and Python libraries were used to solve the equations. The preamplifier transfer function was used to calculate the Bode, impuse and step response plots. The Python results were compared to those from LTSpice. Deviation from the RIAA response curve was also examined. The sensitivity, Monte Carlo and worst case analysis for the preamplifier circuit was performed. The JupyterLab notebook show cases the use of Python in electrical engineering and circuit analysis.\nContents\n1. Introduction\n2. RIAA pre-emphasis curve\n3. AN346 RIAA Phono Preamplifier Design Procedure\n4. Analysis of the phono preamplifier circuit\n5. Summary",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#introduction",
    "href": "Two amplifier RIAA Phono Preamp.html#introduction",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.1 Introduction",
    "text": "20.1 Introduction\nThis JupyterLab notebook uses the SymPy, NumPy,SciPy and the Python programming language libraries to analyze a phono preamplifier circuit from the Texas Instruments application note, AN346, High-Performance Audio Applications of the LM833. The purpose of this analysis is to demonstrate the capability of using the Python libraries in electrical engineering circuit analysis. The circuit chosen for this analysis is a two stage RIAA Phono Preamplifier described in the application note. The preamplifier is designed to accurately reproduce the RIAA equalization curve required for play back of Vinyl LP records. The preamplifier provides about 35 dB of gain at 1kHz along with the proper gain profile and phase response. The schematic of the circuit is shown below with each node explicity annotated.\n\n\n\nSchematic\n\n\nThere has been a resurgence on the popularity of Vinyl LP records over the last few years. So the use of a RIAA Phono Preamplifier is still relevant in this age where most music is delivered by streaming. Two internet news stories describe the current market for Vinyl LP records:\nThey Said the Album Was Dying. They Were Wrong\n\nVinyl sales have grown steadily for 17 years, but jumped by a stunning 46% in 2020 and 51% in 2021 …\n\nWhy Vinyl Records Are Making a Comeback in 2022\n\nThis year, 2020, marks the first year in more than a generation since record sales — that is to say physical vinyl records — have surpassed CD sales. The reasons for this are twofold: CD sales have dropped dramatically in recent years, while sales of vinyl records are actually up this year. And while you might think it’s nostalgic Boomers or Gen Xers behind the renaissance of records, in fact surveys show it’s millennial consumers driving the rising trend in vinyl sales.\n\n\nSo vinyl is here to stay, it seems, despite all technological advances that would have seemed to threaten it. The same RIAA study that found records surpassing CDs also revealed that streaming music now account for more than 85% of all music enjoyed. Only 6% of music is now downloaded, even less than is physically purchased in the form of records, CDs, or the last tapes.\n\nToday there are hundreds of phono products sold on Amazon. Phono preamps range in price from $10 to $1,000 dollars.\nThe Phono Preamplifier also known as a phono stage, is an audio component that amplifies the signal from your turntable to a level that allows you to connect it to your sound system the same way you would with any other audio source. In addition to boosting the signal from the phono carterage, the preamp applies the RIAA equalization curve to the signal, reverting it back to the shape it was on the original recording. Phono cartridge output varies depending on the type of phono cartridge. Moving Magnet (MM) or Moving Iron (MI) cartridges typically produce a maximum output of 5mV. Moving Coil (MC) cartridges produce a much lower output, typically around 0.5mV maximum. Most phono preamps have switch that allow users to select the type of coil they have installed on their turn table arm.\nTexas Instruments provided the schematic of the preamplifier in their application note to highlight the types of applications their LM833 operational amplifier can support. Application notes are sometimes part of the marketing literature provided along with component data sheets by semiconductor manufactures.\nRIAA equalization is a specification for the recording and playback of phonograph records, established by the Recording Industry Association of America (RIAA). RIAA was formed in 1952. Its original mission was to administer recording copyright fees and problems, work with trade unions, and do research relating to the record industry and government regulations. Early RIAA standards included the RIAA equalization curve, the format of the stereophonic record groove and the dimensions of 33 1/3, 45, and 78 rpm records.\nThe purposes of the equalization are to permit greater recording times (by decreasing the mean width of each groove), to improve sound quality and to reduce the groove damage that would otherwise arise during playback. RIAA equalization is a form of pre-emphasis on recording and de-emphasis on playback. A recording is made with the low frequencies reduced and the high frequencies boosted, and on playback, the opposite occurs. The net result is a flat frequency response, but with attenuation of high-frequency noise such as hiss and clicks that arise from the recording medium. Reducing the low frequencies also limits the excursions the cutter needs to make when cutting a groove. Groove width is thus reduced, allowing more grooves to fit into a given surface area, permitting longer recording times. This also reduces physical stresses on the stylus, which might otherwise cause distortion or groove damage during playback.\n\n20.1.1 Scope\nThe analysis presented in this notebook is intended to illustrate the use of Python for circuit analysis. This is not a tutorial on how to design a better phono preamp. The circuit taken from the Texas Instruments application note is examined for what it is, which is a suggested application for the use of their audio grade op amp. However, in this analysis I don’t address the performance of the op amp relative to the implementation of the RIAA equalization curve. I’m more concerned with examining the circuit’s ability to reproduce the proper gain and phase over the audio band. The performance LM833 op amp is assumed to be sufficient for this application and in my analysis of the circuit, I’ve replaced the LM833 with an ideal op amp model. Also, it is assumed that the reader is familiar with electronic components such as resistors, capacitors and operational amplifiers also known as op amps or opamps.\n\n\n20.1.2 Methodology\nThe analysis presented in this notebook will cover a topics that are often presented during a design review. Ususaly during a design review conformance to requirements is presented. For the phono preamp circuit, the main performance requirement is minimum deviation from the RIAA curve. The application note from TI stated that the deviation is less than 0.1 dB over the audio band when using 1% resistors.\nIn this notebook the analysis is divided into sections.\n\nThe analysis will start with an description of the circuit operation and some basic calculations.\nThere are many symbols used in the equations and these are listed in a table for reference. I also tried to be constant with variable names.\nThe RIAA pre-emphasis curve is discussed and the transfer function, pole/zero plot and amplitude and phase response is plotted.\nCalculations for the phono preamplifier design procedure as covered in the application note are presented. The element values obtain with this procedure are the ones used in the analysis.\nThe equations for the transfer function of the preamp are derived by using a tecnhique known as modified nodal analysis.\nThe preamp poles and zeros are plotted and some comments about stability are provided.\nThe amplitude and phase responce of the preamp transfer function is plotted.\nThe impulse, step and group dealy are plotted\nThe amplitude and phase response of the preamp transfer function is plotted against results taken from LTSpice as a check and comparision.\nThe deviation of the amplitude and phase responce from the RIAA curve is plotted.\nSensitivity analsysis, component selection, monte carlo and worst case analysis are presented.\n\n\nimport os\nimport sys\nimport random\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\ninit_printing()\n\n\n\n20.1.3 Python library versions\n\npython: 3.10.9\nnumpy: 1.23.5\nsympy: 1.11.1\nscipy: 1.10.0\nmatplotlib: 3.7.0\n\nDefine a function to return the system gain at a frequency: get_gain()\n\ndef get_gain(freq_Hz, sys):\n    '''\n    freq_Hz: the frequency in Hz for which the system gain is desired\n    sys: a SciPy instance of the LTI class or a tuple describing the system\n    '''\n    f1 = freq_Hz - freq_Hz*0.1 # lower limit of the frequency range\n    f1a = freq_Hz - freq_Hz*0.01 # lower interpolation point\n    f2 = freq_Hz + freq_Hz*0.1 # upper limit of the frequency range\n    f2a = freq_Hz + freq_Hz*0.01  # upper interpolation point\n\n    x_axis_range = np.linspace(f1*2*np.pi, f2*2*np.pi, 1000, endpoint=True) # define the range frequency range\n    w, mag, phase = sys.bode(w=x_axis_range)\n\n    index_for_f1a = np.where(w &gt; f1a*2*np.pi)[0][0]\n    index_for_f2a = np.where(w &gt; f2a*2*np.pi)[0][0]\n\n    return np.interp(freq_Hz, [w[index_for_f1a]/(2*np.pi),w[index_for_f2a]/(2*np.pi)], [mag[index_for_f1a],mag[index_for_f2a]])\n\n\n\n20.1.4 Schematic and circuit description\nThe circuit from Figure 3 of AN346 was entered into LTSpice and the circuit nodes were numbered as shown above. Any schematic capture program could be used to for this as long as a Spice like netlist can be generated. In the schematic, the voltage source V1, is set to 5 mV to represent the output of a Moving Magnet (MM) or Moving Iron (MI) cartridge. The input to the preamp is shunted by a capacitance, which is equal to the sum of the input cable capacitance and the cartridge. This capacitance resonates with the inductance of the moving magnet cartridge to determine the frequency response of the transducer, so when a moving magnet pickup is used, Cp should be carefully chosen so that the total capacitance is equal to the recommended load capitance for that particular cartridge. 100 pF is used in this analysis. Rp is the recommended resistive load for the phono cartridge. In some comercial preamp designs, the value of Rp is user selectable with switches. As shown in the calculations, Cp and Rp have a resonant frequency of 33.86kHz.\n\nCp = 100e-12\nRp = 47e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Rp*Cp)))\n\nresonant frequency: 33,862.8 Hz\n\n\n33,862 Hz is well above the audio range.\nThe first operational amplifier, U1, takes care of the 50 Hz and 500 Hz breakpoints. For the analysis with Python, the op amp is modeled as and ideal opamp. There is expected to be some differences between the LTSpice results and the Python analysis. Using two amplifiers results in accurate conformance to the RIAA curve without reverting to the noisy inverting topology, as well as lower distortion due to the fact that each amplifier is operating at a lower gain than would be the case in a single-amplifier design.\nThe resistor, R1, which has a value of 80.6k\\(\\Omega\\) and the capacitor C1, which has a value of 0.039 \\(\\mu\\)Farads, form a resonant pair with frequency of 50.6 Hz.\n\nR1 = 80.6e3\nC1 = 0.039e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R1*C1)))\n\nresonant frequency: 50.6 Hz\n\n\n50 Hz is one of the RIAA time constants required by the RIAA specification.\nFrom here on, I’ll refer to resistors that have values in 1000’s of Ohms by using k for thousands of Ohms or just the numerical value if it’s less than 1000. Capacitors will have values indicated in \\(\\mu\\) for micro Farads and p for pico Farads, designated as \\(\\mu\\) or p. \n\nR2 = 8.45e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R2*C1)))\n\nresonant frequency: 482.9 Hz\n\n\nC1 and R2, which has a value of 8.45k, have a resonant frequency of 482.94 Hz. As describe later, these frequencies correspond to the time constants required by the RIAA specification.\nCo provides an AC ground for the non-inverting configuration of U1. Ro along with R1 and R2 set the low frequency gain of U1.\n\nRo = 499\nCo = 200e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Ro*Co)))\n\nresonant frequency: 1.6 Hz\n\n\nRo=499 and Co=200\\(\\mu\\) have a resonant frequency of 1.6 Hz.\n\nRf=R1+R2\nprint('low frequency voltage gain of U1: {:,.2f} or {:,.1f}dB'.format(1+Rf/Ro, 20*np.log10(1+Rf/Ro)))\n\nlow frequency voltage gain of U1: 179.46 or 45.1dB\n\n\nRo along with R1 and R2 set the low frequency gain of U1 at 45 dB.\n\nR3 = 2.37e3\nC3 = 0.033e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R3*C3)))\n\nresonant frequency: 2,035.0 Hz\n\n\nR3=2.37k and C3=0.033\\(\\mu\\) have a resonant frequency of 2034.96 Hz and corresponds to the the third time constant specified by RIAA.\nC4=2\\(\\mu\\) and R6=54.9k form a high pass filter with a corner frequency of 1.45Hz.\n\nR6 = 54.9e3\nC4 = 2e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R6*C4)))\n\nresonant frequency: 1.4 Hz\n\n\nU2, R4 and R5 form a non inverting configuration with a voltage gain of 3.15 or 9.98 dB.\n\nR4=2e3\nR5=4.3e3\nprint('voltage gain of U2: {:,.2f} or {:,.1f}dB'.format(1+R5/R4, 20*np.log10(1+R5/R4)))\n\nvoltage gain of U2: 3.15 or 10.0dB\n\n\n\n\n20.1.5 Symbols\nIn this notebook the following symbols are used:\n\n\n\n\n\n\n\nSymbol\ndefininition\n\n\n\n\ns\nwhen used in a polynominal: the Laplace variable equal to \\(\\alpha + j\\omega\\)\n\n\n\\(\\mu\\)\n\\(1 \\times 10^{-6}\\) multiplier, either: \\(1 \\times 10^{-6}\\) seconds or \\(1 \\times 10^{-6}\\) Farads\n\n\nT\ntime constant: T1, T2, T3\n\n\n\\(\\omega\\)\nangular frequency, radians per second, \\(\\omega = 1/T\\)\n\n\nf\nfrequency in cycles per second, \\(f = \\frac{\\omega}{2\\pi}\\)\n\n\nR\nresistor: R1, R2 etc.\n\n\nC\ncapacitor: C1, C2 etc.\n\n\nv\nnode voltage: v1, v2, v3 etc.\n\n\nV\nvoltage source, e.g. V1\n\n\nA\nmatrix describing the connectivity of the resistors, capacitors and G type (VCCS) circuit elements\n\n\nX\nvector of unknown node voltages and unknown currents\n\n\nZ\nvector of known voltages and currents\n\n\nRIAA_num\nnumerator of the RIAA pre-emphsis transfer function\n\n\nRIAA_den\ndenominator of the RIAA pre-emphsis transfer function\n\n\nw_RIAA\nradian frequncy of the RIAA pre-emphsis transfer function\n\n\nmag_RIAA\nmagnitude of the RIAA pre-emphsis transfer function\n\n\nphase_RIAA\nphase of the RIAA pre-emphsis transfer function\n\n\nRIAA_gain_1kHz\ngain of the RIAA pre-emphsis transfer function at 1kHz\n\n\npreamp_equ_sym\npreamp circuit equations with symbolic values\n\n\nU_sym\nsymbolic solution to network equations, node voltages and unknown currents\n\n\nH_sym\ntransfer function with symbolic coefficients\n\n\npreamp_equ\ncircuit equations with numeric element values\n\n\nH_preamp_num\nnumerator of the transfer function\n\n\nH_preamp_denom\ndenominator of the transfer function\n\n\npreamp_sys\nSciPy representation of the preamp system\n\n\npreamp_gain_1kHz\ngain of the preamp transfer function at 1kHz\n\n\nw_preamp\nradian frequncy of the preamp transfer function\n\n\nmag_preamp\nmagnitude of the preamp transfer function\n\n\nphase_preamp\nphase of the preamp transfer function",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "href": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.2 RIAA pre-emphasis curve",
    "text": "20.2 RIAA pre-emphasis curve\nThe RIAA equalization curve was established in 1954. The equalization is defined by time constants, T1, T2 and T3. During the Phonograph record manufacturing process, a pre-emphsis is applied to the signal, which allows for longer playback times on phonograph records by decreasing the average width of the groove cut into vinyl phonograph disks. The curve attenuates low frequencies and amplifies high frequencies, relative to 1 kHz. Since low frequencies cause wide undulations in the record groove, they must be attenuated to keep the grove within its bounds. Above 1 kHz, the frequencies are amplified which helps overcome the inherent noise produced by the phonograph needle during play-back.\nThe RIAA disc recording/reproduction standard specifies the time constants of, \\(T1 = 75 \\mu s\\), \\(T2 = 318 \\mu s\\) and \\(T3 = 3180 \\mu s\\) and the pre-emphasis transfer function:\n\\(RIAA(s)=\\frac {(sT_{1}+1)(sT_{3}+1)}{(sT_{2}+1)}\\)\nThe three time constants correspond to the frequencies calculated below.\n\nT1 = 75e-6\nT2 = 318e-6\nT3 = 3180e-6\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T1*1e6,1/(T1*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T2*1e6,1/(T2*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T3*1e6,1/(T3*2*np.pi)))\n\n75 μs corresponds to 2,122.1 Hz\n318 μs corresponds to 500.5 Hz\n3180 μs corresponds to 50.0 Hz\n\n\nThe time constants are put in polynominal form using s as the Laplace variable. The numerator and denominator of the pre-emphasis transfer function is defined below.\n\ns = symbols('s')\nRIAA_num = Eq(((s*T3+1)*(s*T1+1)),0)\nRIAA_denom = Eq(s*T2+1,0)\n\nSolve for the poles and zeros of the pre-emphasis transfer function and plot the locations on the complex s-plane. The zeros of the transfer function are the roots of the numerator polinominal. The poles of the transfer function are the roots of the denominal polinominal.\n\nRIAA_zeros = solve(RIAA_num,s)\nRIAA_poles = solve(RIAA_denom,s)\n\n\nplt.plot(np.real(RIAA_zeros), np.imag(RIAA_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(RIAA_poles), np.imag(RIAA_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(RIAA_zeros)))\nfor i in RIAA_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n-2,122.07 Hz\n-50.05 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(RIAA_poles)))\nfor i in RIAA_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-500.49 Hz\n\n\nAs shown in the plot above, the poles and zeros lay on the negative real axis. The de-emphisis transfer function of the phono pre-amplifier should have poles at the zero locations and a zero in the pole location in the plot above.\nThe code below is used to convert SymPy symbolic equations to a numpy polynomial representation. The SciPy function, TransferFunction, represents the system as the continuous-time transfer function. The Numpy function, logspace, is used to generate data points on a log scale for plotting. The SciPy function, bode, is used to generate the magnitude and phase data of a continuous-time system.\n\na = np.array(Poly(RIAA_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(RIAA_denom, s).all_coeffs(), dtype=float)\nRIAA_sys = signal.TransferFunction(a,b)\n\nx_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\nw_RIAA, mag_RIAA, phase_RIAA = RIAA_sys.bode(w=x_axis_range) # returns: rad/s, mag in dB, phase in deg\n\nFind the gain at 1kHz so the plots can be normalized for 0 dB at 1 kHz.\n\nRIAA_gain_1kHz = get_gain(1000,RIAA_sys)\n\n\nprint('The RIAA gain at 1kHz: {:.3f} dB'.format(RIAA_gain_1kHz))\n\nThe RIAA gain at 1kHz: 19.911 dB\n\n\nPlot the magnitude and phase of the RIAA curve.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_RIAA/(2*np.pi), mag_RIAA-RIAA_gain_1kHz,'-k')    # Bode magnitude plot, normalized to 0 at 1kHz\n\n# mark individual points\np3 = np.where(w_RIAA &gt; 49.9*(2*np.pi))[0][0]\np2 = np.where(w_RIAA &gt; 499.9*(2*np.pi))[0][0]\np1 = np.where(w_RIAA &gt; 2122*(2*np.pi))[0][0]\n\nplt.semilogx(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-RIAA_gain_1kHz,'^k')\n\nplt.text(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-25,'T1')\nplt.text(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-25,'T2')\nplt.text(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-25,'T3')\n\n# hightlight the audio band, 20 to 20kHz\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w_RIAA/(2*np.pi), phase_RIAA,':',color='b',label='phase')  # Bode phase plot\n\n# mark individual points\nplt.semilogx(w_RIAA[p1]/(2*np.pi), phase_RIAA[p1],'xb')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), phase_RIAA[p2],'xb')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), phase_RIAA[p3],'xb')\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\nax2.set_ylim((0,100))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('RIAA pre-emphasis Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the frequence response of the RIAA curve. The frequencies coresponsing to the time constants T1, T2 and T3 are plotted on the magnitude and phase curves. The audio band of 20Hz to 20kHz is highlighted. One thing to notice about this curve is that the amplitdue is increasing as the frequency increases. This is not a realistic function, real circuits do not have and inifinite gain at as the frequency goes tio infinity. Also, there is no zero at \\(j\\omega=0\\), so the pre-emphisis transfer function does not block DC.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "href": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.3 Phono Preamplifier Design Procedure",
    "text": "20.3 Phono Preamplifier Design Procedure\nThe following notebook cells walk through the design procedure given in the application note, starting on page 5.\nA design procedure is shown below with an illustrative example using 1% tolerance E96 components for close conformance to the ideal RIAA curve. Since 1% tolerance capacitors are often difficult to find except in 5% or 10% standard values, the design procedure calls for re-calculation of a few component values so that standard capacitor values can be used.\n\nChoose \\(R_o\\). \\(R_o\\) should be small for minimum noise contribution, but not so small that the feedback network excessively loads the amplifier. Example: Choose \\(R_o = 500\\)\nChoose 1 kHz gain, A1 of first amplifier. This will typically be around 20 dB to 30 dB. Example: Choose A1 = 26 dB = 20\nCalculate \\(R_11 = 8.058 \\times R_o \\times A_1\\)\n\n\nA1 = 20\nRo = 500\nR1 = 8.058 * Ro * A1\nprint('R1={:,.0f}'.format(R1))\n\n\nCalculate C1\n\n\\(C_1 = \\frac {3.18 \\times 10^{-3}}{R_1}\\)\n\nC1 = 3.18e-3/R1\nprint('C1={:.4e}'.format(C1))\n\nC1=3.9464e-08\n\n\nThe calculated value for capacitor C1 is not a standard value, so step 5 takes care of this.\n\nIf C1 is not a convenient value, choose the nearest convenient value and calculate a new R1 from:\n\n\\(R_1 = \\frac {3.18 \\times 10^{-3}}{3.9 \\times 10^{-8}}\\)\nChoose C1 to be 0.039\\(\\mu\\), which is a standard capacitor value.\n\nC1 = 0.039e-6\nR1 = 3.18e-3/C1\nprint('R1={:,.0f}'.format(R1))\n\nR1=81,538\n\n\nNow choose a standard resistor value close to the the calculated value, which is 80.6k.\nE96 resistor values are a set of perfered values for 1% resistors. When doing the calculations to determin the resistor values, the closest standandard value is chosen from the E96 series. The E series of preferred numbers derived for use in electronic components. It consists of the E3, E6, E12, E24, E48, E96 and E192 series, where the number after the ‘E’ designates the quantity of logarithmic value “steps” per decade.\n\nR1 = 80.6e3\n\nCalculate a new value for Ro.\n\\(R_o=\\frac {R_1}{8.058A_1}\\)\n\nRo = R1/(8.058*A1)\nprint('R1={:,.0f}'.format(Ro))\n\nR1=500\n\n\nChoose a standard value close to this value, which is 499.\n\nRo = 499\n\n\nCaluclate R2\n\\(R_2=\\frac {R_1}{9} - R_o\\)\n\n\nR2 = R1/9-Ro\nprint('R1={:,.0f}'.format(R2))\n\nR1=8,457\n\n\nChoose a standard value close to this value, which is 8.45k.\n\nR2 = 8.45e3\n\n\nChoose a convenient value for C3 in the range from 0.01 \\(\\mu\\)F to 0.05 \\(\\mu\\)F.\nExample: C3 = 0.033 \\(\\mu\\)F\n\n\nC3 = 0.033e-6\nprint('C3={:,.3f}\\u03BC'.format(C3*1e6))\n\nC3=0.033μ\n\n\n\nCalculate Rp\n\\(R_p=\\frac {75 \\mu s }{C_3}\\)\n\n\\(75 \\mu s\\) is one of the RIAA time constants.\n\nRp = 75e-6/C3\nprint('Rp={:,.0f}'.format(Rp))\n\nRp=2,273\n\n\n\nChoose a standard value for R3 that is slightly larger than Rp.\nExample: R3 = 2.37k, which is a standard resistor value.\n\n\nR3 = 2.37e3\n\n\nCalculate R6 from \\(1/R_6 = 1/R_P − 1/R_3\\)\n\n\nR6 = 1/(1/Rp-1/R3)\nprint('R6={:,.0f}'.format(R6))\n\nR6=55,374\n\n\n54.9k is the closest standard value.\n\nR6 = 54.9e3\n\n\nCalculate \\(C_4\\) for low-frequency rolloff below 1 Hz from design Equation 5.\n\n\\(C_4=\\frac{1}{2\\pi f_L(R_3+R_6)}\\)\nWhere \\(f_L\\) is the low frequency -3dB corner of the second stage.\nIn the application note, there is a comment on page 4:\n&gt; If the preamplifier is to follow the IEC recommendation (IEC Publication 98, Amendment #4), fL should equal 20.2 Hz.\nThe calculations in the app note use 1 Hz.\n\nf_L = 1.0 # Hz\nC4 = 1/(2*np.pi*f_L*(R3+R6))\nprint('C4={:,.3f}\\u03BC'.format(C4*1e6))\n\nC4=2.779μ\n\n\n2\\(\\mu\\)F is a standard value close to the calculated value.\nExample: C4 = 2 \\(\\mu\\)F.\n\nChoose gain of second amplifier.\nExample: The 1 kHz gain up to the input of the second amplifier is about 26 dB for this example. For an overall 1 kHz gain equal to about 36 dB we choose:\n\\(A_2 = 10 dB = 3.16\\)\nChoose value for R4.\nExample: R4 = 2k\n\n\nR4 = 2e3\n\n\nCalculate \\(R_5 = (A_2 − 1) R_4\\)\n\n\nA2 = 3.16\nR5 = (A2-1)*R4\nprint('R5={:,.0f}'.format(R5))\n\nR5=4,320\n\n\n4.3k is a standard value close to the calculated value.\n\nR5 = 4.3e3\n\n\nCalculate Co for low-frequency rolloff below 1 Hz from design Equation 7.\n\n\\(C_o=\\frac {1}{2\\pi f_o R_o}\\)\nwhere fo is the low-frequency −3 dB corner of the first amplifier. fo is chosen to be 1Hz for the calculations since this frequency is well below the audible frequency range.\n\nfo = 1 # 1 Hz\nCo = 1/(2*np.pi*fo*Ro)\nprint('Co={:,.3f}\\u03BC'.format(Co*1e6))\n\nCo=318.948μ\n\n\nThe value chosen in the app note for this component is 200\\(\\mu\\)F.\n\nCo = 200e-6\n\n\nprint('resonant frequency of Ro and Co: {:.2f}Hz'.format(1/(Co*Ro*2*np.pi)))\n\nresonant frequency of Ro and Co: 1.59Hz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "href": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.4 Analysis of AN-346 phono preamplifier circuit",
    "text": "20.4 Analysis of AN-346 phono preamplifier circuit\nThe schematic of the preamp was entered into LTSpice and the netlist was generated. Starting with a schematic and then using LTSpice to generate the net list eliminates errors that would occure if these circuits were analyised by hand. For small circuits with a handful of components, symbolic solutions of the node equations can be of interest, but for larger circuits, not so much. This is because the number of symbols and equations is too large to offer in insight with out some simplicication.\nIn this section the modified nodal analysis method will be used to generate the circuit equations. The modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. The Python code that generates the circuits equations is located here.\n\n20.4.1 Modified nodal analysis\nThe preamp circuit has 15 branches, 9 nodes, 3 unknown currents, 14 passive components and 2 op amps. The net list generated by LTSpice and some edits were made to put the component values into scientific notation with units of Ohms, Farads and Henerys and the opamp statements were fixed. The edited netlist is:\nV1 1 0 5e-3m\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\nThis netlist is read into the Symbolic Modified Nodal Analysis Jupyter notebook and the following circuit equations were generated.\n\\(I_{V1} + v_{1} \\left(Cp s + \\frac{1}{R_{20}}\\right) = 0\\)\n\\(v_{2} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{4} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{Ro} = 0\\)\n\\(v_{3} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{2}}{Ro} = 0\\)\n\\(v_{2} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\n\\(I_{O1} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{3}} - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(- C_{4} s v_{7} + v_{6} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\n\\(- C_{4} s v_{6} + v_{7} \\left(C_{4} s + \\frac{1}{R_{6}}\\right) = 0\\)\n\\(v_{8} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{9}}{R_{5}} = 0\\)\n\\(I_{O2} + v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{8}}{R_{5}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{1} + v_{2} = 0\\)\n\\(- v_{7} + v_{8} = 0\\)\nThe symbols and matrices generated by the modified nodal analysis code are copied here so that the circuit equations can be solved symbilically and later numerically. All the symboles that SymPy needs defined are delared. The A matrix describs the connectivity of the resistors, capacitors and G type (VCCS) circuit elements. The X matrix contains the unknown node voltages and unknown currents. The Z matrix contains the known voltages and currents sources, e.g. V1.\n\nRp, v6, Co, C4, v2, C3, s, I_V1, R6, Ro, R4, C1, R3, I_O2, R5, v3, I_O1, v4, v8, v7, V1, Cp, v1, R1, R2, v5, v9 = symbols(' Rp  v6  Co  C4  v2  C3  s  I_V1  R6  Ro  R4  C1  R3  I_O2  R5  v3  I_O1  v4  v8  v7  V1  Cp  v1  R1  R2  v5  v9 ')\nA = Matrix([[Cp*s + 1/Rp, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1/R5, 0, 0, 0, 0, 0, 0, -1/R5, 0, 0, 1], [0, 0, C1*s + 1/Ro + 1/R1, -1/Ro, -C1*s - 1/R1, 0, 0, 0, 0, 0, 0, 0], [0, 0, -1/Ro, Co*s + 1/Ro, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, -C1*s - 1/R1, 0, C1*s + 1/R2 + 1/R1, -1/R2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1/R2, 1/R3 + 1/R2, -1/R3, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, -1/R3, C3*s + C4*s + 1/R3, -C4*s, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, -C4*s, C4*s + 1/R6, 0, 0, 0, 0], [0, -1/R5, 0, 0, 0, 0, 0, 0, 1/R5 + 1/R4, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0]])\nX = Matrix( [v1, v2, v3, v4, v5, v6, v7, v8, v9, I_V1, I_O1, I_O2] )\nZ = Matrix( [0, 0, 0, 0, 0, 0, 0, 0, 0, V1, 0, 0] )\n\nThe equations are displayed in maxtrix form below.\n\npreamp_equ_sym = Eq(A*X,Z)\npreamp_equ_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\left(Cp s + \\frac{1}{Rp}\\right)\\\\I_{O2} + \\frac{v_{2}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\v_{3} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Ro}\\\\v_{4} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{3}}{Ro}\\\\v_{3} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{5} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{6}}{R_{2}}\\\\I_{O1} + v_{6} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{7}}{R_{3}} - \\frac{v_{5}}{R_{2}}\\\\- C_{4} s v_{8} + v_{7} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{3}}\\\\- C_{4} s v_{7} + v_{8} \\left(C_{4} s + \\frac{1}{R_{6}}\\right)\\\\v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}}\\\\v_{1}\\\\- v_{1} + v_{3}\\\\- v_{8} + v_{9}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThese equations can be solved in thier symbolic form using the solve function from SymPy. The solution time takes about 3 seconds on my i3 laptop.\n\nU_preamp_sym = solve(preamp_equ_sym,X)\n\nThe transfer function for the preamp is the equation for the output node, 2, divided by the equation for the input node 1.\n\nH_preamp_sym = U_preamp_sym[v2]/U_preamp_sym[v1]\n\nThe symbolic solution obtained by SymPy, while not being very interesting since they are unweildly, they illustrate the power of SymPy to easily obtain symbolic solutions that would be very difficult to obtain by hand.\n\nH_preamp_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{V_{1} \\left(C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}\\right)}\\)\n\n\nThe SymPy function, cancel(), can be used to put the preamp transfunction in to standard canonical form, where the polynomials are expanded with no common factors and the leading coefficients do not have denominators (i.e., are integers).\n\ncancel(H_preamp_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} C_{4} R_{1} R_{5} R_{6} + C_{4} Co R_{1} R_{4} R_{6} + C_{4} Co R_{1} R_{5} R_{6} + C_{4} Co R_{2} R_{4} R_{6} + C_{4} Co R_{2} R_{5} R_{6} + C_{4} Co R_{4} R_{6} Ro + C_{4} Co R_{5} R_{6} Ro\\right) + s \\left(C_{4} R_{4} R_{6} + C_{4} R_{5} R_{6}\\right)}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + R_{4} + s^{3} \\left(C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} Co R_{1} R_{4} Ro + C_{3} C_{4} R_{3} R_{4} R_{6} + C_{3} Co R_{3} R_{4} Ro + C_{4} Co R_{3} R_{4} Ro + C_{4} Co R_{4} R_{6} Ro\\right) + s \\left(C_{1} R_{1} R_{4} + C_{3} R_{3} R_{4} + C_{4} R_{3} R_{4} + C_{4} R_{4} R_{6} + Co R_{4} Ro\\right)}\\)\n\n\nThe Sympy function, factor(), can be used to factor the polynominals it into irreducible factors over the rational numbers.\n\nH_preamp_sym.factor()\n\n\\(\\displaystyle \\frac{C_{4} R_{6} s \\left(R_{4} + R_{5}\\right) \\left(C_{1} Co R_{1} R_{2} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co R_{1} s + Co R_{2} s + Co Ro s + 1\\right)}{R_{4} \\left(C_{1} R_{1} s + 1\\right) \\left(Co Ro s + 1\\right) \\left(C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} R_{3} s + C_{4} R_{3} s + C_{4} R_{6} s + 1\\right)}\\)\n\n\nThe symbolic solutions obtained above will be used later when the sinsitivity analysis of the preamp is performed. Otherwise the roots in symbolic form don’t seem to be particulary insightful, but are easily obtained by SymPy.\n\n20.4.1.1 Numerical solution\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {V1:5.0000e-03, C1:3.9000e-08, Co:2.0000e-04, Ro:4.9900e+02, R3:2.3700e+03, R1:8.0600e+04, \n    R2:8.4500e+03, Cp:1.0000e-10, Rp:4.7000e+04, C3:3.3000e-08, C4:2.0000e-06, R6:5.4900e+04, R4:2.0000e+03, R5:4.3000e+03}\n\n# put the element values into the equations\npreamp_equ = preamp_equ_sym.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instear of symbols.\n\npreamp_equ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-10} s + 2.12765957446809 \\cdot 10^{-5}\\right)\\\\I_{O2} + 0.000232558139534884 v_{2} - 0.000232558139534884 v_{9}\\\\v_{3} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.00201641496392288\\right) - 0.00200400801603206 v_{4} + v_{5} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right)\\\\- 0.00200400801603206 v_{3} + v_{4} \\cdot \\left(0.0002 s + 0.00200400801603206\\right)\\\\v_{3} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right) + v_{5} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.000130750143157091\\right) - 0.000118343195266272 v_{6}\\\\I_{O1} - 0.000118343195266272 v_{5} + 0.000540284123536314 v_{6} - 0.000421940928270042 v_{7}\\\\- 2.0 \\cdot 10^{-6} s v_{8} - 0.000421940928270042 v_{6} + v_{7} \\cdot \\left(2.033 \\cdot 10^{-6} s + 0.000421940928270042\\right)\\\\- 2.0 \\cdot 10^{-6} s v_{7} + v_{8} \\cdot \\left(2.0 \\cdot 10^{-6} s + 1.82149362477231 \\cdot 10^{-5}\\right)\\\\- 0.000232558139534884 v_{2} + 0.000732558139534884 v_{9}\\\\v_{1}\\\\- v_{1} + v_{3}\\\\- v_{8} + v_{9}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0.005\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU_preamp = solve(preamp_equ,X)\n\nThe values of the exponents are very large in the solution. The numerator and denominator for v2 could be normalized. Another option for avoiding large exponents is to 1st normalize the component values by frequency scaling. I suppose that large exponents don’t become a problem as long as they remain under two digits.\nAlmost all platforms map Python floats to the IEEE754 double precision - 64 total bits. The float information using the sys package can be as shown as follows:\n\nsys.float_info\n\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n\n\n\nprint(sys.float_info)\n\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n\n\nThe maximum exponent that Python can use is 308.\nLetting SciPy do the math and not worrying about the size of the exponents. The transfer function can be obtained by divideing the equation for node 2 by the equation for node 1. The system transfer function, is \\(H(s) = \\frac {v2}{V1}\\)\n\nH_preamp = U_preamp[v2]/U_preamp[v1]\nH_preamp\n\n\\(\\displaystyle \\frac{200.0 \\cdot \\left(2.76499422921242 \\cdot 10^{69} s^{3} + 8.80353368479522 \\cdot 10^{72} s^{2} + 4.91462150480132 \\cdot 10^{71} s\\right)}{7.65600122987477 \\cdot 10^{65} s^{4} + 1.0469819689888 \\cdot 10^{70} s^{3} + 3.44479259637884 \\cdot 10^{72} s^{2} + 6.18286042227129 \\cdot 10^{73} s + 2.84188944100537 \\cdot 10^{74}}\\)\n\n\nfactor() takes a polynomial and factors it into irreducible factors over the rational numbers. For example:\n\nH_preamp.factor()\n\n\\(\\displaystyle \\frac{6.19554973375798 s \\left(0.000314077770155853 s^{2} + 1.0 s + 0.0558255546098434\\right)}{2.69398278462456 \\cdot 10^{-9} s^{4} + 3.68410520790143 \\cdot 10^{-5} s^{3} + 0.012121487017314 s^{2} + 0.21756161 s + 1.0}\\)\n\n\n\n\n20.4.1.2 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_preamp_num, H_preamp_denom = fraction(H_preamp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na2 = np.array(Poly(H_preamp_num, s).all_coeffs(), dtype=float)\nb2 = np.array(Poly(H_preamp_denom, s).all_coeffs(), dtype=float)\npreamp_sys = signal.TransferFunction(a2,b2)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\npreamp_sys_zeros = np.roots(preamp_sys.num)\npreamp_sys_poles = np.roots(preamp_sys.den)\n\n\n\n\n20.4.2 Pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(preamp_sys_zeros), np.imag(preamp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(preamp_sys_poles), np.imag(preamp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(preamp_sys_zeros)))\nfor i in preamp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-506.73 Hz\n-0.01 Hz\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(preamp_sys_poles)))\nfor i in preamp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-2,122.88 Hz\n-50.63 Hz\n-1.59 Hz\n-1.39 Hz\n\n\nWe can see that the RIAA time constants, displayed in terms of frequency are present, althought the values diffeer by a few Hz. There are two zeros and two poles at nearly zero hz and these cancel each other.\n\n\n20.4.3 Stability\nBy inspecting the plot above, we can tell the preamplifier is stable since the phase shift at 0 dB of gain is less than 180 degrees. Additionally, all the poles of the transfer function are in the left hand plane.\nNow we can find the preamp gain at 1 kHz, so that the bode plots can be normailized.\n\npreamp_gain_1kHz = get_gain(1000, preamp_sys)\nprint('preamp gain at 1kHz: {:f} dB'.format(preamp_gain_1kHz))\n\npreamp gain at 1kHz: 34.783614 dB\n\n\n\n\n20.4.4 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nextended_x_axis_range = np.logspace(-2, 8, 5000, endpoint=True)*2*np.pi\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=extended_x_axis_range)\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b' #'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color=color,label='phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude')\n\nplt.legend(loc=0)\nplt.title('preamplifier Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe Bode plot for the preamplifier is plotted from 0.01 Hz to 100 MHz. The preamplifier circuit blocks DC because C4 in in series with the audio path.\n\n\n20.4.5 Impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n20.4.6 Group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=x_axis_range)\n\nplt.title('AN-346 phono preamplifier group delay')\nplt.semilogx(w_preamp/(2*np.pi), -np.gradient(phase_preamp*np.pi/180)/np.gradient(w_preamp),'-',label='group delay')\n\n#plt.semilogx(w_c1/(2*np.pi), -np.gradient(phase_c1)/w_c1/1e-3,'-',label='phase delay')\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies below 100 Hz, the group delay is as much as 4 ms in the audio band. According to paper, Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe preamp group delay in the low end of the audio band is of concern and some re-design should be implemented if this preamp was to be implemented. The group delay plotted above agrees with the group delay results obtained from LTSpice simulation of the preamp circuit.\n\n\n20.4.7 Comparing results to LTSpice\nThe LM833 TINA-TI Spice Model was entered into LTSpice, but it has some errors when run with LTSpice. So rather than debug the errors, an Analog Devices’s LT1115, was substiuded to obtain simulation results with an opamp model in order to comapre with the Python results, which uses an ideal opamp.\nThe table blow shows that the LM833 and LT1115 have simular performance characteristics.\n\n\n\n\n\n\n\n\n\n\n\nOp Amp\nDistortion %, THD + N at 1 kHz\nNoise, at 1 kHz (nV√Hz)\nSlew Rate, (V/µs)\nGBW (MHz)\nPower Bandwidth\n\n\n\n\nLM833N\n0.002\n4.5\n7\n15\n120 kHz @ 27 Vpp, RL = 2 kΩ, THD ≤ 1%\n\n\nLT1115\n0.002\n0.9\n10\n40\n180 kHz @ 30 VP-P, RL=2k\n\n\n\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Problem Circuits/Two amplifier RIAA Phone Preamp/') # change directory to csv file location\n\nfn = 'Two amplifier RIAA Phone Preamp.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage))+11.257,'-k')    # Bode magnitude plot, adding 11.257 dBV offset to normalized LTSpice data at 1KHz\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp-preamp_gain_1kHz,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-40,20))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color,label='LT1115 phase')  # Bode phase plot\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color='black',label='MNA phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, '-', color='b', label='LT1115 magnitude')\nax2.plot(np.NaN, np.NaN, '-.', color='k', label='MNA magnitude')\n\nplt.legend(loc=0)\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nAs is evident in the plot above, the results from LTSpice and Python agree.\n\n\n20.4.8 Preamplifier deviation from RIAA response\nThe plot below shows the deviation of the preamplifier from the RIAA response. The TI app note says conformance to the RIAA curve is within 0.1 dB from 20 Hz to 20 kHz.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.2,0.1))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_RIAA+phase_preamp,':',color=color,label='phase of S2')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude of S1')\nplt.legend(loc=0)\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe calculations below will find the minimum and maximunation deviation of the amplitude response from the RIAA curve.\n\nidx_low = np.where(w_preamp/(2*np.pi) &gt; 20)[0][0]\nidx_high = np.where(w_preamp/(2*np.pi) &gt; 20e3)[0][0]\nprint('preamp deviation from RIAA curve: {:.3f} to {:.3f} dB'.format(((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].min(),((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].max()))\n\npreamp deviation from RIAA curve: -0.045 to 0.066 dB\n\n\nThe calculations above show that within the audio range the deviation of the preamp amplitude response from the RIAA curve varies from -0.044 to 0.066 dB when the nominal component values are used.\n\n\n20.4.9 Sensitivity analysis\nAll circuits have characteristics that dependent on the values of the component. The sensitivity of a circuit’s performance is a measure of how much a particular circuit characteristic changes as a particular component value varies. In this analysis i’ll look at the changes of each pole or zero relative to the compenents value.\nThe root sensitivity function \\(S_x^y\\) gives the change occuring in filter characteristic per \\(\\delta y/ \\delta x\\).\n\\(S_x^y\\) is read as the sensitivity of the characteristic (i.e. y = \\(\\omega_n,\\) or Q or some other characteristic) with respect to the element x.\n\\(S_x^y = \\frac {x}{y} \\frac{\\delta y}{\\delta x}\\)\nWhere x is the filter component that is varied and y is the filter characteristic (\\(\\omega_n,\\) or Q etc.) that we wish to evaluate as x is varied.\nThe preamp transfer function is symbolic form is, H_preamp_sym, and we can get the numerator and denominator with the SymPy fraction function.\n\nH_sym_num, H_sym_denom = fraction(H_preamp_sym)\n\nThe Sympy solve function is used to find the root of the numerator and denimator polynominals.\n\nH_sym_zeros = solve(H_sym_num,s)\nH_sym_poles = solve(H_sym_denom,s)\n\n\n20.4.9.1 Zeros\nHow many roots are there for the numerator polynominial?\n\nprint('there are {:d} zeros'.format(len(H_sym_zeros)))\n\nthere are 3 zeros\n\n\n\n\n20.4.9.2 Z0\nThe first zero is at DC.\n\nH_sym_Z0 = H_sym_zeros[0]\nH_sym_Z0\n\n\\(\\displaystyle 0\\)\n\n\n\n\n20.4.9.3 Z1\nThe second zero is given symbolically by the expression:\n\nH_sym_Z1 = H_sym_zeros[1]\nH_sym_Z1\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\nWhat are the compenets that determine Z1?\n\nprint('the compenets that determine Z1 are: {:s} '.format(str(H_sym_Z1.free_symbols)))\n\nthe compenets that determine Z1 are: {R2, Ro, R1, C1, Co} \n\n\nWhat is the locations of Z1?\n\nprint('location of zero: {:.2f} Hz'.format(N(H_sym_Z1.subs(nominal_component_value))/(2*np.pi)))\n\nlocation of zero: -506.73 Hz\n\n\nZ1 is the zero at 500 Hz and is one of the RIAA time constants.\nWe can fine the sensitivity of Z1 to C1 with the following operation.\n\nS_C1_H_sym_Z1 = (C1/H_sym_Z1)*(H_sym_Z1.diff(C1))\nS_C1_H_sym_Z1\n\n\\(\\displaystyle \\frac{C_{1} \\left(- \\frac{1}{2 C_{1} Co \\left(R_{2} + Ro\\right)} - \\frac{C_{1} R_{1}^{2} + Co R_{1}^{2} - Co R_{1} R_{2} - Co R_{1} Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right) \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}} + \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)}\\right)}{- \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}}\\)\n\n\nEvaluating this numerically with the component values, we get get the sensitivity of Z1 to C1.\n\nprint('the sensitivity of Z1 to C1 is: {:.2f}'.format(N(S_C1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to C1 is: -1.00\n\n\nDoing the math with SymPy, we can get the sensitivity of Z1 to the other components.\n\nS_R1_H_sym_Z1 = (R1/H_sym_Z1)*(H_sym_Z1.diff(R1))\nprint('the sensitivity of Z1 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R1 is: -0.10\n\n\n\nS_R2_H_sym_Z1 = (R2/H_sym_Z1)*(H_sym_Z1.diff(R2))\nprint('the sensitivity of Z1 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R2 is: -0.85\n\n\n\nS_Co_H_sym_Z1 = (Co/H_sym_Z1)*(H_sym_Z1.diff(Co))\nprint('the sensitivity of Z1 to Co is: {:.4f}'.format(N(S_Co_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Co is: -0.0002\n\n\n\nS_Ro_H_sym_Z1 = (Ro/H_sym_Z1)*(H_sym_Z1.diff(Ro))\nprint('the sensitivity of Z1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Ro is: -0.05\n\n\nLater, we we are doing the worst case analsys, we can ignore Co. \n\n\n20.4.9.4 Z2\nThe third zero of the transfer function is Z2.\n\nH_sym_Z2 = H_sym_zeros[2]\nH_sym_Z2\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\n\nprint('the compenets that determine Z2 are: {:s} '.format(str(H_sym_Z2.free_symbols)))\n\nthe compenets that determine Z2 are: {R2, Ro, R1, C1, Co} \n\n\n\nprint('Z2: {:.3e} Hz'.format(N(H_sym_Z2.subs(nominal_component_value))/(2*np.pi)))\n\nZ2: -8.885e-3 Hz\n\n\nThe zero Z2, evaluates to a system zero at DC and is not one the of RIAA time constants.\n\nS_C1_H_sym_Z2 = (C1/H_sym_Z2)*(H_sym_Z2.diff(C1))\nprint('the sensitivity of Z2 to C1 is: {:.3e}'.format(N(S_C1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to C1 is: -1.580e-4\n\n\n\nS_Co_H_sym_Z2 = (Co/H_sym_Z2)*(H_sym_Z2.diff(Co))\nprint('the sensitivity of Z2 to Co is: {:.2f}'.format(N(S_Co_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Co is: -1.00\n\n\n\nS_R1_H_sym_Z2 = (R1/H_sym_Z2)*(H_sym_Z2.diff(R1))\nprint('the sensitivity of Z2 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R1 is: -0.90\n\n\n\nS_R2_H_sym_Z2 = (R2/H_sym_Z2)*(H_sym_Z2.diff(R2))\nprint('the sensitivity of Z2 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R2 is: -0.09\n\n\n\nS_Ro_H_sym_Z2 = (Ro/H_sym_Z2)*(H_sym_Z2.diff(Ro))\nprint('the sensitivity of Z2 to Ro is: {:.3f}'.format(N(S_Ro_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Ro is: -0.006\n\n\n\n\n20.4.9.5 Poles\nHow many poles are there in the preamp transfer function?\n\nprint('there are {:d} poles in the transfer function'.format(len(H_sym_poles)))\n\nthere are 4 poles in the transfer function\n\n\n\n\n20.4.9.6 P0\nThe first pole is:\n\nH_sym_P0 = H_sym_poles[0]\nH_sym_P0\n\n\\(\\displaystyle - \\frac{1}{C_{1} R_{1}}\\)\n\n\nThe pole P0 evaluates to one of the RIAA time constants.\n\nprint('P0: {:.2f}Hz'.format(N(H_sym_P0.subs(nominal_component_value))/(2*np.pi)))\n\nP0: -50.63Hz\n\n\n\nS_C1_H_sym_P0 = (C1/H_sym_P0)*(H_sym_P0.diff(C1))\nprint('the sensitivity of P0 to C1 is: {:.2f}'.format(N(S_C1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to C1 is: -1.00\n\n\n\nS_R1_H_sym_P0 = (R1/H_sym_P0)*(H_sym_P0.diff(R1))\nprint('the sensitivity of P0 to R1 is: {:.2f}'.format(N(S_R1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to R1 is: -1.00\n\n\n\n\n20.4.9.7 P1\nThe second pole is:\n\nH_sym_P1 = H_sym_poles[1]\nH_sym_P1\n\n\\(\\displaystyle - \\frac{1}{Co Ro}\\)\n\n\nThe pole P1 evaluates to a frequency near DC.\n\nprint('P1: {:.2f}Hz'.format(N(H_sym_P1.subs(nominal_component_value))/(2*np.pi)))\n\nP1: -1.59Hz\n\n\n\nS_Co_H_sym_P1 = (Co/H_sym_P1)*(H_sym_P1.diff(Co))\nprint('the sensitivity of P1 to Co is: {:.2f}'.format(N(S_Co_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Co is: -1.00\n\n\n\nS_Ro_H_sym_P1 = (Ro/H_sym_P1)*(H_sym_P1.diff(Ro))\nprint('the sensitivity of P1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Ro is: -1.00\n\n\n\n\n20.4.9.8 P2\nThe 3rd pole is:\n\nH_sym_P2 = H_sym_poles[2]\nH_sym_P2\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} - \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the compenets that determine P2 are: {:s} '.format(str(H_sym_P2.free_symbols)))\n\nthe compenets that determine P2 are: {R3, R6, C4, C3} \n\n\n\nprint('P2: {:.2f}Hz'.format(N(H_sym_P2.subs(nominal_component_value))/(2*np.pi)))\n\nP2: -2122.88Hz\n\n\n\nS_C3_H_sym_P2 = (C3/H_sym_P2)*(H_sym_P2.diff(C3))\nprint('the sensitivity of P2 to C3 is: {:.2f}'.format(N(S_C3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C3 is: -1.00\n\n\n\nS_C4_H_sym_P2 = (C4/H_sym_P2)*(H_sym_P2.diff(C4))\nprint('the sensitivity of P2 to C4 is: {:.3e}'.format(N(S_C4_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C4 is: -2.829e-5\n\n\n\nS_R3_H_sym_P2 = (R3/H_sym_P2)*(H_sym_P2.diff(R3))\nprint('the sensitivity of P2 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R3 is: -0.96\n\n\n\nS_R6_H_sym_P2 = (R6/H_sym_P2)*(H_sym_P2.diff(R6))\nprint('the sensitivity of P2 to R6 is: {:.3f}'.format(N(S_R6_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R6 is: -0.041\n\n\n\n\n20.4.9.9 P3\nThe 4th pole is:\n\nH_sym_P3 = H_sym_poles[3]\nH_sym_P3\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} + \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the compenets that determine P3 are: {:s} '.format(str(H_sym_P3.free_symbols)))\n\nthe compenets that determine P3 are: {R3, R6, C4, C3} \n\n\n\nprint('P3: {:.2f}Hz'.format(N(H_sym_P3.subs(nominal_component_value))/(2*np.pi)))\n\nP3: -1.39Hz\n\n\n\nS_C3_H_sym_P3 = (C3/H_sym_P3)*(H_sym_P3.diff(C3))\nprint('the sensitivity of P3 to C3 is: {:.2e}'.format(N(S_C3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C3 is: -2.83e-5\n\n\n\nS_C4_H_sym_P3 = (C4/H_sym_P3)*(H_sym_P3.diff(C4))\nprint('the sensitivity of P3 to C5 is: {:.2f}'.format(N(S_C4_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C5 is: -1.00\n\n\n\nS_R3_H_sym_P3 = (R3/H_sym_P3)*(H_sym_P3.diff(R3))\nprint('the sensitivity of P3 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R3 is: -0.04\n\n\n\nS_R6_H_sym_P3 = (R6/H_sym_P3)*(H_sym_P3.diff(R6))\nprint('the sensitivity of P3 to R6 is: {:.2f}'.format(N(S_R6_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R6 is: -0.96\n\n\nIn the worst case analysis below, the componets that have sensitivites greater than 0.05 are the ones that factor into the worst case analysis.\n\n\n\n20.4.10 Component selection\nThe table below list each of the components used in the preamp along with a link to the Digikey pages for each of the components in the preamp. Digikey is a larger distributor of electronic components in the US. All the components have operating temperature ranges that exceed the normal household envirment.\nThe resistors chosen are all 1% Metal film type resistors. Metal film resistors possess good noise characteristics and low non-linearity due to a low voltage coefficient. They are also beneficial due to long-term stability.\nThe capacitors are all polypropylene Film capacitor types. Polystyrene or polypropylene are considered the best for audio applications.\nThe Op Amp, LM833N, is a dual bipolar low noise (\\(\\frac {4.5nV}{\\sqrt{Hz}}\\)), wide bandwidth (16 MHz) audio operational amplifier from Texas Instrments.\n\n\n\nRef\nValue\nDescription\nDigikey PN\n\n\n\n\nRo\n499\n±1% 1/4W Metal Film\nRNF14FTD499RCT-ND\n\n\nRp\n47k\n±1% 1/4W Metal Film\n13-MFR-25FTE52-47KTB-ND\n\n\nR1\n80.6k\n±1% 1/4W Metal Film\n80.6KXBK-ND\n\n\nR2\n58.45k\n±1% 1/4W Metal Film\nRNF14FTD8K45CT-ND\n\n\nR3\n2.37k\n±1% 1/4W Metal Film\n13-MFR-25FBF52-2K37-ND\n\n\nR4\n2k\n±1% 1/4W Metal Film\n13-MFR-25FRF52-2KCT-ND\n\n\nR5\n4.3k\n±1% 1/4W Metal Film\nS4.3KCACT-ND\n\n\nR6\n54.9k\n±1% 1/4W Metal Film\nRNF14FTD54K9CT-ND\n\n\nCo\n200\\(\\mu\\)\n10% Film Capacitor 450V Polypropylene\n283-EFDKS45K207F064DH-ND\n\n\nCp\n100p\n10% Film Capacitor 250V Polypropylene\n399-RSBEC0100ZA00M-ND\n\n\nC1\n0.039\\(\\mu\\)\n2% Film Capacitor 25V 63V Polypropylene\nBC2066-ND\n\n\nC3\n0.033\\(\\mu\\)\n1% Film Capacitor 63V 100V Polypropylene\n399-PHE426DJ5330FR17T0CT-ND\n\n\nC4\n2\\(\\mu\\)\n10% Film Capacitor 305V 630V Polypropylene\n495-B32923P3205K000-ND\n\n\nU1, U2\nLM833N\nAudio op amp\n296-44419-5-ND\n\n\n\nThe parts in this list are considered good choices for a first pass at the bill of materials. The size of the production run and the piece part cost are also a factors which must be considered if the preamp is going to be built. One thing to notice is that Co, the 200 \\(\\mu\\) F capacitor is expensive. The use of a polypropylene film capacitor for this component is consistent with the advice of keeping all capacitors in the audio path polystyrene or polypropylene.\n\n\n20.4.11 Monte Carlo simulation\nIn this analysis the circuit equations are solved after assigning random element values from within the tolerance band to the components. This simulates building a large number of circuits with components chosen at random from bins or reals of components during the board stuffing process. All the components are required to met their specifications, but are allowed to have some varaition accorting to theier tolerance. For example a 1% 2k resistor can range from 1980 to 2020 \\(\\Omega\\). In addition to the components initial tolerance, the temperature coefficient and aging of paramters can also be included.\nIn this simulation, I’m only including the initial tolerances of parameters and I’m assuming the distritution is uniform. The Numpy function random.uniform is used to generate the random values within the tolerance range, however, for this function, the hight end-point value may or may not be included in the range depending on floating-point rounding, so if this is important, some adjustments to the code are required. The Numpy function random.seed is used to re-seed the random number generator.\n\nnum = 20 # number of simulations to run\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to the hold the results of each run\nmag_ans = np.zeros(shape=(num,len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(num,len(new_x_axis_range)))\n\ncomponent_values_tol = nominal_component_value.copy() # makde a copy\n\nrandom.seed(a=None, version=2) # re-seed the random number generator\n\nThe following takes about 15 seconds to run on for num=20 on an i3 machine.\n\nfor i in range(0,num):\n\n    component_values_tol[Ro] = random.uniform(nominal_component_value[Ro]-nominal_component_value[Ro]*0.01,nominal_component_value[Ro]+nominal_component_value[Ro]*0.01)\n    component_values_tol[Rp] = random.uniform(nominal_component_value[Rp]-nominal_component_value[Rp]*0.01,nominal_component_value[Rp]+nominal_component_value[Ro]*0.01)\n\n    component_values_tol[R1] = random.uniform(nominal_component_value[R1]-nominal_component_value[R1]*0.01,nominal_component_value[R1]+nominal_component_value[R1]*0.01)\n    component_values_tol[R2] = random.uniform(nominal_component_value[R2]-nominal_component_value[R2]*0.01,nominal_component_value[R2]+nominal_component_value[R2]*0.01)    \n    component_values_tol[R3] = random.uniform(nominal_component_value[R3]-nominal_component_value[R3]*0.01,nominal_component_value[R3]+nominal_component_value[R3]*0.01)\n    component_values_tol[R4] = random.uniform(nominal_component_value[R4]-nominal_component_value[R4]*0.01,nominal_component_value[R4]+nominal_component_value[R4]*0.01)    \n    component_values_tol[R5] = random.uniform(nominal_component_value[R5]-nominal_component_value[R5]*0.01,nominal_component_value[R5]+nominal_component_value[R5]*0.01)\n    component_values_tol[R6] = random.uniform(nominal_component_value[R6]-nominal_component_value[R6]*0.01,nominal_component_value[R6]+nominal_component_value[R6]*0.01)    \n\n    component_values_tol[Co] = random.uniform(nominal_component_value[Co]-nominal_component_value[Co]*0.1,nominal_component_value[Co]+nominal_component_value[Co]*0.1)\n    component_values_tol[Cp] = random.uniform(nominal_component_value[Cp]-nominal_component_value[Cp]*0.1,nominal_component_value[Cp]+nominal_component_value[Cp]*0.1)\n    component_values_tol[C1] = random.uniform(nominal_component_value[C1]-nominal_component_value[C1]*0.02,nominal_component_value[C1]+nominal_component_value[C1]*0.02)\n    component_values_tol[C3] = random.uniform(nominal_component_value[C3]-nominal_component_value[C3]*0.01,nominal_component_value[C3]+nominal_component_value[C3]*0.01)\n    component_values_tol[C4] = random.uniform(nominal_component_value[C4]-nominal_component_value[C4]*0.1,nominal_component_value[C4]+nominal_component_value[C4]*0.1)\n\n    # enter the element values\n    preamp_equ_tol = preamp_equ_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    \n    # save the results from each run\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\n\n20.4.12 Preamplifier deviation from RIAA response\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.3))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Monte Carlo runs showing deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe Monte Carlo simulation shows that the preamp amplitude response deviatin from the RIAA curve can very from -0.2 to 0.3 dB over the audio band. If the performance requirement for this preamp was to be within \\(\\pm\\) 0.1 dB of the RIAA curve, then some redesign or tighter component tolerancing is required.\n\n\n20.4.13 Worst case analysis\nIn a worst case analysis, we would look at:\n\nminimum and maximum values of the initial component tolerance\n\nmaximum or minumum temperature coefficients of the parameters\n\nmaximum aging or drift of parameter values\n\nSince we usually can’t tell by inspection which combination of minimum and maximum values will give the worst case, we can run a number of simulations in which all combination of minum and maximium variations are included. From the family of results we can look for the worst case.\nHow resistors and capactors in the preamp circuit?\n\nprint('number of components: {:d}'.format(len(nominal_component_value)))\n\nnumber of components: 14\n\n\nHow many combinations min and max combinations?\n\nprint('number of min and max combinations: {:,d}'.format(2**14))\n\nnumber of min and max combinations: 16,384\n\n\n16 thousand simulation runs to too many. From the sensitivity analysis above, only R1, R2, R3, R6, Ro, C1 and C3 are sensitive. Running all combinations of the min and max tolerance for this set is reasonable and is \\(2^7=128\\) combinations.\nThe tolerances for each of the componts is defined below:\n\nTol = {Ro:0.01,R1:0.01,R2:0.01,R3:0.01,R6:0.01,C1:0.02,C3:0.01}\n\nOnly C1 has a tolerance other than 1%.\nThe array ‘run’ is created that consists of a binary count, with leading zeros from 0 to 127. Then the zero values are replaced with -1.\n\nrun = []\nfor i in range(0,2**(len(Tol))):\n    temp = list('{:07b}'.format(i)) # include leading zeros\n    for j in range(len(temp)):\n        temp[j] = int(temp[j])\n    run.append(temp)\n\nrun = np.asarray(run)\nrun = np.where(run == 0, -1, run)\n\nThe first row of run is:\n\nrun[0]\n\narray([-1, -1, -1, -1, -1, -1, -1])\n\n\nIn the for loop below, at i = 0, run[0] would be all -1’s and this could apply the low tolerance range to the nominal component values.\n\nrun[-1]\n\narray([1, 1, 1, 1, 1, 1, 1])\n\n\nThe last time through the for loop, where i = 127, run[-1] is all 1’s and this would apply the high tolerance range to the nominal component values. Between i = 0 and i = 127, all combinations of minumum and maximum tolerance is appled.\n\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to hold the results\nmag_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\n\nThe following cell takes about 90 seconds to run on an i3 machine.\n\nfor i in range(len(run)):\n    component_values_tol[Ro] = nominal_component_value[Ro]*(1+run[i][0]*Tol[Ro])\n    component_values_tol[Rp] = nominal_component_value[Rp]\n\n    component_values_tol[R1] = nominal_component_value[R1]*(1+run[i][1]*Tol[R1])\n    component_values_tol[R2] = nominal_component_value[R2]*(1+run[i][2]*Tol[R2]) \n    component_values_tol[R3] = nominal_component_value[R3]*(1+run[i][3]*Tol[R3])\n\n    component_values_tol[R4] = nominal_component_value[R4] \n    component_values_tol[R5] = nominal_component_value[R5]\n    component_values_tol[R6] = nominal_component_value[R6]*(1+run[i][4]*Tol[R6])\n\n    component_values_tol[Co] = nominal_component_value[Co]\n    component_values_tol[Cp] = nominal_component_value[Cp]\n    component_values_tol[C1] = nominal_component_value[C1]*(1+run[i][5]*Tol[C1])\n    component_values_tol[C3] = nominal_component_value[C3]*(1+run[i][6]*Tol[C3])\n    component_values_tol[C4] = nominal_component_value[C4]\n    \n    # enter the element values\n    preamp_equ_tol = preamp_equ_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.4))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Worst Case deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe results above show that the worst case tolerance conditions yeild deviations of -0.19 to 0.3 dB from the RIAA curve.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#summary",
    "href": "Two amplifier RIAA Phono Preamp.html#summary",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.5 Summary",
    "text": "20.5 Summary\nThe circuit presented in this analysis is just one example of many circuits that can be found on line. For each design to be evaluated, some type of side by side analysis should be used used to down select. This notebook can be used as template for any compartivite analysis.\nThe circuit in the app note appears to have low frequency group delay that might be an issue. Also the deviation from the RIAA curve using normal component tolerances does not meet the 0.1 dB requirement. The worst case analysis also confirms this. The circuit employs an expesive 200\\(\\mu\\) Farad film capacitor. The circuit is missing a subsonic filter.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html",
    "href": "Two port parameters.html",
    "title": "21  Two port parameters",
    "section": "",
    "text": "Abstract",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#introduction",
    "href": "Two port parameters.html#introduction",
    "title": "21  Two port parameters",
    "section": "21.1 Introduction",
    "text": "21.1 Introduction",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#circuit-description",
    "href": "Two port parameters.html#circuit-description",
    "title": "21  Two port parameters",
    "section": "21.2 Circuit description",
    "text": "21.2 Circuit description\nThis notebook describes the calculation of two port parameters derived from the circuit’s netlist. A Two-port network is a circuit that has two pairs of ports or terminals and the circuit is characterized by the currents and voltages at the ports by a 2 by 2 matrix. From a two port matrix the response of the network to signals applied to the ports can be calculated easily, without solving for all the internal voltages and currents in the network. For example filters, matching networks, transmission lines, and transistors are characterized by two port parameters.\nThe first circuit is an attenuator, which could be easily analyzed by hand with a pencil, paper and a calculator, but here I’m using python to step through the calculations. These same steps can be applied to larger, more complex circuits which would be difficult to analyze by hand. The Sympy and SciPy libraries can be used to obtain symbolic and numerical results, however as is shown below, when the circuit is large, symbolic results are not that useful nor do they provide much insight.\nThe procedure starts by first drawing a schematic of the circuit with a schematic capture program such as EasyEDA (links to the schematics are provided below) then the netlist is generated and exported as a text file. The netlist is used to generate modified nodal equations with the python program described here. The equations are solved for voltages and currents at the port terminals by using SymPy to generate the z-paramters. Z-parameters are also known as open-circuit impedance parameters as they are calculated under open circuit conditions. Once the z-parameters are obtained, these can be converted into other parameters, such as Y, H, S or others.\nThe second circuit is a band pass filter. The filter is designed from a low pass prototype by using normalized values from a filter design handbook. Z and s-parameters are calculated and the results are plotted using Matplotlib.\n\nimport numpy as np\nfrom sympy import *\nimport matplotlib.pyplot as plt\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#pi-attenuator",
    "href": "Two port parameters.html#pi-attenuator",
    "title": "21  Two port parameters",
    "section": "21.3 Pi-attenuator",
    "text": "21.3 Pi-attenuator\nThe pi-attenuator is formed by three resistors with R1 and R3 as the shunt resistors on the input and output ports and R2 as the series resistor in a circuit topology in the shape of the greek letter pi. For R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms, the attenuation is 10 dB and the port impedance is 50 ohms. Pasternack’s Pi Attenuator Calculator (Pi pad attenuator) was used to design the attenuator.\nThe selection of which type a network parameter is somewhat a matter of convenience. However, some circuits can’t have their ports shorted or left open for proper operation, so s-parameters are the appropriate choice in this situation. Solving for the z-parameters is convenient since all we need to do is apply a voltage source to the input port, with the output port unterminated, and solve for the voltage and currents at each port. Since the output port is unterminated, the current into this port is zero and we can find z11 and z21. To find z21 and z22, the voltage source is applied to port 2 with port 1 unterminated.\nTo find Z-parameters attach voltage sources to both ports and find the node equations. EasyEDA was used to draw the schematic and generate the netlist. A link to the schematic is here.\n\n\n\nschematic\n\n\nThe netlist for the circuit:\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\nV2 2 0 1\n\n21.3.1 Find z11 & z21\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\nThe circuit equations generated are:\n[[Eq(I_V1 + v1*(1/R2 + 1/R1) - v2/R2, 0)],\n[Eq(v2*(1/R3 + 1/R2) - v1/R2, 0)],\n[Eq(v1, V1)]]\n\n# declare the following symbols\nI_V1, R3, R2, V1, v1, R1, v2 = symbols('I_V1 R3 R2 V1 v1 R1 v2')\n\n# use the equations generated by nodal analysis\nequ_p1 = Matrix(\n    [[Eq(I_V1 + v1*(1/R2 + 1/R1) - v2/R2, 0)],\n    [Eq(v2*(1/R3 + 1/R2) - v1/R2, 0)],\n    [Eq(v1, V1)]])\nequ_p1\n\n\\[\\left[\\begin{matrix}I_{V1} + v_{1} \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\\\v_{2} \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\\\v_{1} = V_{1}\\end{matrix}\\right]\\]\n\n\n\n# find symbolic solution\nu_p1 = solve(equ_p1,[v1, v2, I_V1])\nu_p1\n\n\\[\\left \\{ I_{V1} : - \\frac{V_{1} \\left(R_{1} + R_{2} + R_{3}\\right)}{R_{1} \\left(R_{2} + R_{3}\\right)}, \\quad v_{1} : V_{1}, \\quad v_{2} : \\frac{R_{3} V_{1}}{R_{2} + R_{3}}\\right \\}\\]\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\nA negative sign was placed in the equation to make the direction of the current flow match the definition of the two port parameters.\n\nz11 = -u_p1[v1]/u_p1[I_V1]\nz11\n\n\\[\\frac{R_{1} \\left(R_{2} + R_{3}\\right)}{R_{1} + R_{2} + R_{3}}\\]\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = -u_p1[v2]/u_p1[I_V1]\nz21\n\n\\[\\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\]\n\n\n\n\n21.3.2 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the net list.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\nThe circuit equations generated by the MNA python code.\n[[Eq(v1*(1/R2 + 1/R1) - v2/R2, 0)],\n[Eq(I_V2 + v2*(1/R3 + 1/R2) - v1/R2, 0)],\n[Eq(v2, V2)]]\n\n# declare the following symbols\nR3, R2, V2, v1, R1, I_V2, v2 = symbols('R3 R2 V2 v1 R1 I_V2 v2')\n\n# use the equations generated by nodal analysis\nequ_p2 = Matrix(\n    [[Eq(v1*(1/R2 + 1/R1) - v2/R2, 0)],\n    [Eq(I_V2 + v2*(1/R3 + 1/R2) - v1/R2, 0)],\n    [Eq(v2, V2)]])\nequ_p2\n\n\\[\\left[\\begin{matrix}v_{1} \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\\\I_{V2} + v_{2} \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\\\v_{2} = V_{2}\\end{matrix}\\right]\\]\n\n\n\n# find symbolic solution\nu_p2 = solve(equ_p2,[v1, v2, I_V2])\nu_p2\n\n\\[\\left \\{ I_{V2} : - \\frac{V_{2} \\left(R_{1} + R_{2} + R_{3}\\right)}{R_{3} \\left(R_{1} + R_{2}\\right)}, \\quad v_{1} : \\frac{R_{1} V_{2}}{R_{1} + R_{2}}, \\quad v_{2} : V_{2}\\right \\}\\]\n\n\n\\(z_{12}=\\frac{V_1}{I_2}\\text{  when  }I_1=0\\)\n\nz12 = -u_p2[v1]/u_p2[I_V2]\nz12\n\n\\[\\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\]\n\n\n\\(z_{22}=\\frac{V_2}{I_2}\\text{  when  }I_1=0\\)\n\nz22 = -u_p2[v2]/u_p2[I_V2]\nz22\n\n\\[\\frac{R_{3} \\left(R_{1} + R_{2}\\right)}{R_{1} + R_{2} + R_{3}}\\]\n\n\nThe common names for the z-parameters are:\nz11: input driving point impedance\nz12: reverse transfer impedance\nz21: forward transfer impedance\nz22: output driving point impedance\nThe elements of the matrix can be displayed:\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\[\\left[\\begin{matrix}\\frac{R_{1} \\left(R_{2} + R_{3}\\right)}{R_{1} + R_{2} + R_{3}} & \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\\\\\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}} & \\frac{R_{3} \\left(R_{1} + R_{2}\\right)}{R_{1} + R_{2} + R_{3}}\\end{matrix}\\right]\\]\n\n\nActual values for each of the components can be substituted for the symbols with R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms\n\natten_values = {R1:96.25,R2:71.15,R3:96.25}\n\n\nz11_val = z11.subs(atten_values)\nz12_val = z12.subs(atten_values)\nz21_val = z21.subs(atten_values)\nz22_val = z22.subs(atten_values)\n\nThe numeric values of the impedance matrix\n\nnp.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=np.float)\n\narray([[61.11227005, 35.13772995],\n       [35.13772995, 61.11227005]])",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#calculate-z-in-and-z-out-ki-and-kv",
    "href": "Two port parameters.html#calculate-z-in-and-z-out-ki-and-kv",
    "title": "21  Two port parameters",
    "section": "21.4 Calculate Z in and Z out, ki and kv",
    "text": "21.4 Calculate Z in and Z out, ki and kv\nA two-port circuit is typically driven at port 1 and loaded at port 2, and four equations needed to solve the four unknowns.\n\\(\\begin{align*}\n\\begin{bmatrix} -1 & 0 & z11 & z12 \\\\\\ 0 & -1 & z21 & z22 \\\\\\ 1 & 0 & Z_S & 0 \\\\\\ 0 & 1 & 0 & Z_L\n\\end{bmatrix}\n\\begin{bmatrix}\n  V_1  \\\\\n  V_2  \\\\\n  I_1 \\\\\n  I_2\n\\end{bmatrix}\n{} &= \\begin{bmatrix}\n  0  \\\\\n  0  \\\\\n  V_g \\\\\n  0\n\\end{bmatrix}\n\\end{align*}\\)\nReference: https://www.ee.nthu.edu.tw/~sdyang/Courses/Circuits/Ch18_Std.pdf\nPutting into SymPy\n\nZ11, Z12, Z21, Z22 = symbols('Z11 Z12 Z21 Z22')\nZ_s, Z_l, Vg = symbols('Z_s Z_l Vg')\n\neqZ = Eq(Matrix([[-1,0,Z11,Z12],[0,-1,Z21,Z22],[1,0,Z_s,0],[0,1,0,Z_l]])*Matrix([V1,V2,I_V1,I_V2]),Matrix([0,0,Vg,0]))\neqZ\n\n\\[\\left[\\begin{matrix}I_{V1} Z_{11} + I_{V2} Z_{12} - V_{1}\\\\I_{V1} Z_{21} + I_{V2} Z_{22} - V_{2}\\\\I_{V1} Z_{s} + V_{1}\\\\I_{V2} Z_{l} + V_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\Vg\\\\0\\end{matrix}\\right]\\]\n\n\n\nansZ = solve(eqZ,[V1, V2, I_V1,I_V2])\nansZ\n\n\\[\\left \\{ I_{V1} : \\frac{Vg \\left(Z_{22} + Z_{l}\\right)}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\quad I_{V2} : - \\frac{Vg Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\quad V_{1} : \\frac{Vg \\left(Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21}\\right)}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\quad V_{2} : \\frac{Vg Z_{21} Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}\\right \\}\\]\n\n\n\n# current gain\nansZ[I_V2]/ansZ[I_V1]\n\n\\[- \\frac{Z_{21}}{Z_{22} + Z_{l}}\\]\n\n\n\n# voltage gain\nansZ[V2]/ansZ[V1]\n\n\\[\\frac{Z_{21} Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21}}\\]\n\n\n\n# Z input\nansZ[V1]/ansZ[I_V1]\n\n\\[\\frac{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21}}{Z_{22} + Z_{l}}\\]\n\n\n\n# Z out\nansZ[V2]/ansZ[I_V2]\n\n\\[- Z_{l}\\]\n\n\nSympy returns the output impedance as simply \\(-Z_l\\), since this is the algebraic simplification of the equations. Most textbooks will give the output impedance in terms of the z-parameters and the source impedance: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#calculate-input-and-output-impedance-for-the-attenuator",
    "href": "Two port parameters.html#calculate-input-and-output-impedance-for-the-attenuator",
    "title": "21  Two port parameters",
    "section": "21.5 Calculate input and output impedance for the attenuator",
    "text": "21.5 Calculate input and output impedance for the attenuator\nThe input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\)\nTextbook equation: \\(Z_{in}=Z_{11}-\\frac{Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\) where \\(Z_{L}\\) is the impedance of the load connected to port two.\nThe output impedance from textbooks is: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\), where \\(Z_{S}\\) is the impedance of the source connected to port one.\n\n# Zin\nZl = 50 # load impedance\nprint('input impedance of network from z-parameters: {:.2f}'.format(np.abs((z11_val*z22_val+z11_val*Zl-z12_val*z21_val)/(z22_val+Zl))))\n\ninput impedance of network from z-parameters: 50.00\n\n\n\n# Zout\nZs = 50 # source impedance\nprint('output impedance of network from z-parameters: {:.2f}'.format(np.abs(z22_val-(z12_val*z21_val)/(z11_val+Zs))))\n\noutput impedance of network from z-parameters: 50.00",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#calculate-the-voltage-gain-for-the-attenuator",
    "href": "Two port parameters.html#calculate-the-voltage-gain-for-the-attenuator",
    "title": "21  Two port parameters",
    "section": "21.6 Calculate the voltage gain for the attenuator",
    "text": "21.6 Calculate the voltage gain for the attenuator\nVoltage gain: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), from text books: \\(K_v=\\frac{Z_{21}Z_{L}}{\\Delta _Z+Z_{11}Z_L}\\)\n\n#Kv\nprint('voltage gain of network from z-parameters: {:.2f} dB'.format(20*np.log10(float((z21_val*Zl)/(z11_val*z22_val + z11_val*Zl - z12_val*z21_val)))))\n\nvoltage gain of network from z-parameters: -10.00 dB",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#convert-z-parameters-to-y-parameters",
    "href": "Two port parameters.html#convert-z-parameters-to-y-parameters",
    "title": "21  Two port parameters",
    "section": "21.7 Convert z-parameters to y-parameters",
    "text": "21.7 Convert z-parameters to y-parameters\nThe z-parameters can be converted to admittance or y-parameters with the following code:\nFind the determinant of the z-parameter matrix:\n\ndet_z = np.linalg.det(np.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=np.float))\nprint('determinant = {:.2f}'.format(det_z))\n\ndeterminant = 2500.05\n\n\nDisplay the y-parameter matrix.\n\nnp.array([[z22_val/det_z,-z12_val/det_z],[-z21_val/det_z,z11_val/det_z]],dtype=np.float)\n\narray([[ 0.02444442, -0.01405481],\n       [-0.01405481,  0.02444442]])\n\n\n\n21.7.1 Convert z-parameters to s-parameters\nThe 2-port S-parameters have the following generic descriptions:\n\\(S_{11} \\text{ is the input port voltage reflection coefficient}\\)\n\\(S_{12} \\text{ is the reverse voltage gain}\\)\n\\(S_{21} \\text{ is the forward voltage gain}\\)\n\\(S_{22} \\text{ is the output port voltage reflection coefficient}\\)\nThe z-parameter can be converted to scattering or s-parameters with the following:\n\\(s_{11} = \\frac {(Z_{11}-Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\n\\(s_{12} = \\frac {2Z_{12}Z_o} {\\Delta Z}\\)\n\\(s_{21} = \\frac {2Z_{21}Z_o} {\\Delta Z}\\)\n\\(s_{22} = \\frac {(Z_{11}+Z_o)(Z_{22}-Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\nwhere: \\(\\Delta Z = (Z_{11}+Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}\\) and \\(Z_o\\) is the characteristic impedance.\n\nZ_o = 50 # characteristic impedance\ndel_z = (z11_val+Z_o)*(z22_val+Z_o)-z12_val*z21_val\n\nS = np.array([[((z11_val-Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z,(2*z12_val*Z_o)/del_z],\n              [(2*z21_val*Z_o)/del_z,((z11_val+Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z]],dtype=np.float)\nS # display the s-parameter matrix\n\narray([[-1.00004488e-01,  3.16234863e-01],\n       [ 3.16234863e-01,  4.45363654e-06]])\n\n\n\n21.7.1.1 Input return loss\nInput return loss \\(RL_{in}\\) indicates impedance match of the port to the source. A number of 10 dB or greater, indicates that the match is probably acceptable.\n\\(RL_{in} =-20\\log_{10}\\left|S_{11}\\right|\\)\n\nprint('Input return loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[0,0]))))\n\nInput return loss = 20.00 dB\n\n\n\n\n21.7.1.2 Insertion loss\nInsertion loss \\(IL\\) is the reciprocal of the magnitude of the transmission coefficient, S21, expressed in decibels.\n\\(IL=-20\\log _{10} \\left|S_{21} \\right|\\)\n\nprint('Insertion loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[1,0]))))\n\nInsertion loss = 10.00 dB\n\n\nThis value agrees with the design of the attenuator as being a 10 dB attenuator.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#band-pass-filter",
    "href": "Two port parameters.html#band-pass-filter",
    "title": "21  Two port parameters",
    "section": "21.8 Band Pass Filter",
    "text": "21.8 Band Pass Filter\nThe circuit below is a band pass filter designed from normalized filter design tables. The third order low pass filter prototype was transformed into a bandpass filter as shown in the figure below. Butterworth filter coefficients were chosen for this design. A Butterworth filter is a type of signal processing filter that has a flat passband response.\n\n\n\nschematic\n\n\nThe link to the schematic in EasyEDA is here.\nThe low pass to bandpass transformation calculations are shown below. The filter was designed to have a center frequency of 10 MHz and a 3 dB bandwidth of 1 MHz. The normalized filter values were obtained from [1] and are:\n3rd order Butterworth LPF prototype\nRs/Rl = 1\nC1 = 1\nL2 = 2\nC1 = 1\nThe bandpass filter has the following design parameters: The source and load impedance is 50 ohms, the filter bandwidth is 1 MHz and the center frequency is 10 MHz. Following example 5-2 of reference [1], but with the following changes:\n\ncenter freq = 10MHz\n\nbandwidth 1MHz\n\nRs=Rl=50\n\nReference:\n1) Electronic Filter Design Handbook, 3rd edition, McGraw-Hill, 1995\n\nf_center = 10e6\nf_3dB_BW = 1e6 # 3dB bandwidth\nfo = np.sqrt((f_center-f_3dB_BW/2)*(f_center+f_3dB_BW/2)) # geometric center frequency\nprint('geometric center frequency = {:.3f}MHz'.format(fo/1e6))\n\ngeometric center frequency = 9.987MHz\n\n\n\nZ = 50 # load and source resistance\nFSF = 2*np.pi*f_3dB_BW\nprint('frequency scaling factor = {:.3f}'.format(FSF))\n\nfrequency scaling factor = 6283185.307\n\n\nThe first element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled.\n\n# C1 is 1st shunt capacitor\nC1n = 1 # normalized value from the tables in the filter handbook\nC1p = C1n/(FSF*Z)\nprint('capacitor = {:.3f}nF'.format(C1p*1e9))\n\nwo = 2*np.pi*fo\nL1p = 1/(wo**2*C1p) # calculate the value of the inductor that resonates with the capacitor at the center frequency\nprint('inductor = {:.3f}nH'.format(L1p*1e9))\n\ncapacitor = 3.183nF\ninductor = 79.777nH\n\n\nThe second element in the lowpass prototype is a series capacitor and for the lowpass to bandpass transformation the capacitor is replaced by a capacitor and inductor in series with the same normalized value. The normalized values are then frequency scaled.\n\n# L2 is the 2nd series inductor\nL2n = 2 # normalized value from the tables in the filter handbook\nL2p = L2n*Z/FSF\nprint('inductor = {:.3f}uH'.format(L2p*1e6))\n\nC2p = 1/(wo**2*L2p) # calculate the value of the capacitor that resonates with the inductor at the center frequency\nprint('capacitor = {:.3f}pF'.format(C2p*1e12))\n\ninductor = 15.915uH\ncapacitor = 15.955pF\n\n\nThe last element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled. The values for this branch of the circuit are the same as for the first shunt element.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z11-and-z12",
    "href": "Two port parameters.html#find-z11-and-z12",
    "title": "21  Two port parameters",
    "section": "21.9 Find z11 and z12",
    "text": "21.9 Find z11 and z12\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations. The component values in the netlist have all been set to one. Later, the actual component values will be used.\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\nThe circuit equations generated are:\n[[Eq(C1*s*v1 - I_L1 + I_L2 + I_V1, 0)],\n[Eq(-C2*s*v3 - I_L3 + v2*(C2*s + C3*s), 0)],\n[Eq(-C2*s*v2 + C2*s*v3 - I_L2, 0)],\n[Eq(v1, V1)],\n[Eq(-I_L1*L1*s - v1, 0)],\n[Eq(-I_L2*L2*s + v1 - v3, 0)],\n[Eq(-I_L3*L3*s - v2, 0)]]\n\n# declare the following symbols\nL2, I_L2, v2, v1, I_V1, C1, C3, v3, V1, L1, I_L3, s, C2, L3, I_L1 = symbols('L2 I_L2 v2 v1 I_V1 C1 C3 v3 V1 L1 I_L3 s C2 L3 I_L1')\n\n# use the equations generated by nodal analysis\nequ_p1 = Matrix(\n    [[Eq(C1*s*v1 - I_L1 + I_L2 + I_V1, 0)],\n    [Eq(-C2*s*v3 - I_L3 + v2*(C2*s + C3*s), 0)],\n    [Eq(-C2*s*v2 + C2*s*v3 - I_L2, 0)],\n    [Eq(v1, V1)],\n    [Eq(-I_L1*L1*s - v1, 0)],\n    [Eq(-I_L2*L2*s + v1 - v3, 0)],\n    [Eq(-I_L3*L3*s - v2, 0)]])\nequ_p1\n\n\\[\\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1} = 0\\\\- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\\\v_{1} = V_{1}\\\\- I_{L1} L_{1} s - v_{1} = 0\\\\- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\\\- I_{L3} L_{3} s - v_{2} = 0\\end{matrix}\\right]\\]\n\n\nAt this point we can use the power of SymPy and obtain a symbolic solution, but as you can see the results don’t seem that useful.\n\nsolve(equ_p1,[v1, v2, v3, I_V1, I_L1, I_L2, I_L3])\n\n\\[\\left \\{ I_{L1} : - \\frac{V_{1}}{L_{1} s}, \\quad I_{L2} : \\frac{C_{2} V_{1} s \\left(C_{3} L_{3} s^{2} + 1\\right)}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}, \\quad I_{L3} : - \\frac{C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}, \\quad I_{V1} : - \\frac{V_{1} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} s^{6} + C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} C_{2} L_{1} L_{3} s^{4} + C_{1} C_{3} L_{1} L_{3} s^{4} + C_{1} L_{1} s^{2} + C_{2} C_{3} L_{1} L_{3} s^{4} + C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1\\right)}{L_{1} s \\left(C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1\\right)}, \\quad v_{1} : V_{1}, \\quad v_{2} : \\frac{C_{2} L_{3} V_{1} s^{2}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}, \\quad v_{3} : \\frac{V_{1} \\left(C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1\\right)}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\right \\}\\]\n\n\n\nelement_values = {L1:L1p,C1:C1p,C2:C2p,L2:L2p,L3:L1p,C3:C1p}\n\nSubstituting actual values for the circuit elements, we get:\n\n# find solution\nu_p1 = solve(equ_p1.subs(element_values),[v1, v2, v3, I_V1, I_L1, I_L2, I_L3])\nu_p1\n\n\\[\\left \\{ I_{L1} : - \\frac{12534954.6878233 V_{1}}{s}, \\quad I_{L2} : \\frac{3.9888456915262 \\cdot 10^{31} V_{1} s \\left(1.58711127259301 \\cdot 10^{29} s^{2} + 6.25 \\cdot 10^{44}\\right)}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\quad I_{L3} : - \\frac{2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\quad I_{V1} : - \\frac{5.01398187512931 \\cdot 10^{-37} V_{1} \\left(6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}\\right)}{s \\left(1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}\\right)}, \\quad v_{1} : V_{1}, \\quad v_{2} : \\frac{1.98886124385089 \\cdot 10^{69} V_{1} s^{2}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\quad v_{3} : \\frac{6.25 \\cdot 10^{43} V_{1} \\left(6.38026687027365 \\cdot 10^{27} s^{2} + 2.5 \\cdot 10^{43}\\right)}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}\\right \\}\\]\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\n\nz11 = -u_p1[v1]/u_p1[I_V1]\nz11.simplify()\n\n\\[\\frac{1.0 \\left(2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s\\right)}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\]\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = -u_p1[v2]/u_p1[I_V1]\nz21.simplify()\n\n\\[\\frac{3.96663030178903 \\cdot 10^{105} s^{3}}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\]",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z12-z22-1",
    "href": "Two port parameters.html#find-z12-z22-1",
    "title": "21  Two port parameters",
    "section": "21.10 Find z12 & z22",
    "text": "21.10 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the netlist.\n*V1 1 0 1\nV2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\nThe circuit equations generated by the MNA python code.\n[[Eq(C1*s*v1 - I_L1 + I_L2, 0)],\n[Eq(-C2*s*v3 - I_L3 + I_V2 + v2*(C2*s + C3*s), 0)],\n[Eq(-C2*s*v2 + C2*s*v3 - I_L2, 0)],\n[Eq(v2, V2)],\n[Eq(-I_L1*L1*s - v1, 0)],\n[Eq(-I_L2*L2*s + v1 - v3, 0)],\n[Eq(-I_L3*L3*s - v2, 0)]]\n\n# declare the following symbols\nV2, L2, I_L2, v2, v1, C1, C3, L1, v3, I_L3, s, C2, L3, I_V2, I_L1 = symbols('V2 L2 I_L2 v2 v1 C1 C3 L1 v3 I_L3 s C2 L3 I_V2 I_L1')\n\n# use the equations generated by nodal analysis\nequ_p2 = Matrix(\n    [[Eq(C1*s*v1 - I_L1 + I_L2, 0)],\n    [Eq(-C2*s*v3 - I_L3 + I_V2 + v2*(C2*s + C3*s), 0)],\n    [Eq(-C2*s*v2 + C2*s*v3 - I_L2, 0)],\n    [Eq(v2, V2)],\n    [Eq(-I_L1*L1*s - v1, 0)],\n    [Eq(-I_L2*L2*s + v1 - v3, 0)],\n    [Eq(-I_L3*L3*s - v2, 0)]])\nequ_p2\n\n\\[\\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2} = 0\\\\- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\\\v_{2} = V_{2}\\\\- I_{L1} L_{1} s - v_{1} = 0\\\\- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\\\- I_{L3} L_{3} s - v_{2} = 0\\end{matrix}\\right]\\]\n\n\n\n# find symbolic solution\nu_p2 = solve(equ_p2.subs(element_values),[v1, v2, v3, I_V2, I_L1, I_L2, I_L3])\nu_p2\n\n\\[\\left \\{ I_{L1} : - \\frac{9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\quad I_{L2} : - \\frac{3.9888456915262 \\cdot 10^{31} V_{2} s \\left(6.34844509037205 \\cdot 10^{27} s^{2} + 2.5 \\cdot 10^{43}\\right)}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\quad I_{L3} : - \\frac{12534954.6878233 V_{2}}{s}, \\quad I_{V2} : - \\frac{2.00559275005172 \\cdot 10^{-38} V_{2} \\left(6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}\\right)}{s \\left(4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}\\right)}, \\quad v_{1} : \\frac{7.95544497540356 \\cdot 10^{67} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\quad v_{2} : V_{2}, \\quad v_{3} : \\frac{59832685372893.0 V_{2} s^{2} \\left(6.73590944720122 \\cdot 10^{40} s^{2} + 2.66587853717 \\cdot 10^{56}\\right)}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}\\right \\}\\]\n\n\n\\(z_{12} = \\frac {V_1}{I_2} \\text{  when  } I_1=0\\)\n\nz12 = -u_p2[v1]/u_p2[I_V2]\nz12.simplify()\n\n\\[\\frac{3.96663030178903 \\cdot 10^{105} s^{3}}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\]\n\n\n\\(z_{22} = \\frac {V_2}{I_2} \\text{  when  } I_1=0\\)\n\nz22 = -u_p2[v2]/u_p2[I_V2]\nz22.simplify()\n\n\\[\\frac{1.0 \\left(2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s\\right)}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\]\n\n\ndisplaying the z-parameter matrix\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\[\\left[\\begin{matrix}\\frac{1.9944228457631 \\cdot 10^{36} s \\left(1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}\\right)}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}} & \\frac{3.96663030178903 \\cdot 10^{105} s^{3}}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\\\\\frac{3.96663030178903 \\cdot 10^{105} s^{3}}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}} & \\frac{4.98605711440775 \\cdot 10^{37} s \\left(4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}\\right)}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\end{matrix}\\right]\\]\n\n\nThe complete z-parameter matrix is shown above. It’s kind of interesting that the exponents on many of the coefficients are so large. Using the SymPy function lambdify to turn the symbolic expression into a function.\n\nfunc_z11_s = lambdify(s, z11)\nfunc_z12_s = lambdify(s, z12) \nfunc_z21_s = lambdify(s, z21) \nfunc_z22_s = lambdify(s, z22) \n\nUsing the results from above, the input impedance of a two-port network is given by: The input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\), where \\(Z_{L}\\) is the impedance of the load connected to port two.\n\n# set the source and load impedance\nZl = Zs = 50\n\nw = np.linspace(9e6*2*np.pi, 11e6*2*np.pi, 1000, endpoint=True)\n\nplt.title('Input impedance')\n\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='|Zin|')\nplt.plot(w/(2*np.pi)/1e6, np.real((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Re Zin')\nplt.plot(w/(2*np.pi)/1e6, np.imag((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Im Zin')\n\nplt.ylabel('impedance, ohms')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitude of the input impedance (in blue), the real part of the input impedance (in orange) and the imaginary part of the input impedance (in green). Near 10Hz, the magnitude and real part of the input impedance is 50 ohms and the imaginary part is about zero. This shows that the design equations produced the desired results. The input impedance bandwidth of the filter is about 1 MHz.\nThe voltage gain of the filter calculated from the z-parameters is: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), which is plotted below:\n\nplt.title('Voltage gain')\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z21_s(1j*w)*Zl)/(func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))),'-',label='|Kv|')\nplt.ylabel('Kv')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the voltage gain of the filter (in blue) plotted from the z-parameters. The filter is centered at 10MHz and the bandwidth appears to be 1 MHz.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "href": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "title": "21  Two port parameters",
    "section": "21.11 Convert z-parameters to s-parameters",
    "text": "21.11 Convert z-parameters to s-parameters\nAlthough applicable at any frequency, s-parameters are mostly used for networks operating at radio frequency (RF) and microwave frequencies. The s-parameters can be calculated from the z-parameters with the following formulas:\n\nZ_o = 50 # characteristic impedance\n\nw = np.linspace(8e6*2*np.pi, 12e6*2*np.pi, 2000, endpoint=True)\ns11 = np.zeros(len(w),dtype=complex)\ns12 = np.zeros(len(w),dtype=complex)\ns21 = np.zeros(len(w),dtype=complex)\ns22 = np.zeros(len(w),dtype=complex)\n\nfor i in range(len(w)):\n    del_z = (func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i])\n    s11[i] = ((func_z11_s(1j*w[i])-Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n    s12[i] = (2*func_z12_s(1j*w[i])*Z_o)/del_z\n    s21[i] = (2*func_z21_s(1j*w[i])*Z_o)/del_z\n    s22[i] = ((func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])-Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n\nplt.title('S-parameters')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s11)),'-',label='|s11|dB')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s21)),'-',label='|s21|dB')\nplt.ylabel('|S11| & |S21|, dB')\nplt.xlabel('Frequency, MHz')\nplt.ylim((-20,1))\nplt.yticks(np.arange(-20, 1, 5))\n#plt.xlim((-1,20))\n#plt.xticks(np.arange(0, 20+1, 2.0))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitudes in dB of the input reflection coefficient (in blue) and the forward voltage gain (in orange).\nThe magnitude of the input reflection coefficient indicates the amount of energy reflected back to the source due to the impedance mismatch. The smaller the reflection coefficient the better the match, and in dB, large negative values are very small small numbers. A rule of thumb is that |S11| less than about -9.5 dB is a reasonable match, since this corresponds to about a 2:1 VSWR or a mismatch loss of about 0.5 dB. The frequency range over which this match occurs is called the impedance bandwidth.\nThe plot of |S21| shows the forward voltage gain of the filter in dB. The filter was designed to be a band pass filter with a center frequency of 10 MHz, which is clearly shown in the plot. The plot is similar to what would be seen on a network analyzer.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#summary",
    "href": "Two port parameters.html#summary",
    "title": "21  Two port parameters",
    "section": "21.12 Summary",
    "text": "21.12 Summary\nIn this notebook the parameters for two port networks were generated from the circuit’s netlist. Using python, the circuit equations were automatically generated by using modified nodal analysis, then SymPy was used to solve for the network currents and voltages. Z-parameters were calculated for the circuits, from which y and s parameters were generated. The z-parameters were used to generate input impedance and transfer functions.\nThis notebook has demonstrated that two port parameters can easily be generated from a circuit’s netlist with python.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html",
    "href": "Thevenin equivalent circuit.html",
    "title": "22  Thevenin equivalent circuit",
    "section": "",
    "text": "Abstract",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#introduction",
    "href": "Thevenin equivalent circuit.html#introduction",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.1 Introduction",
    "text": "22.1 Introduction",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#circuit-description",
    "href": "Thevenin equivalent circuit.html#circuit-description",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.2 Circuit description",
    "text": "22.2 Circuit description\nThe Thevenin equivalent circuit is the reduction of a linear one port circuit to a single source and impedance and is based on Thevenin’s Theorem. This notebook describes solving problem 11.25, given in chapter 11 of Johnson, Hilburn, and Johnson (1978). The Python libraries of SimPy and Numpy are used to perform the math in the proposed solution. The problem asks the student to replace the circuit to the left of terminals a-b by its Thevenin equivalent and find V. The schematic was drawn using LTspice and the nodes were numbered. Terminals a-b are across the resistor R3. The circuit given in the textbook does not include a reference node, however the node at the bottom of the schematic was chosen as the reference node, ground.\n\nHaving drawn the circuit in LTspice, the following netlist was exported as a text file.\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 j2\nL2 1 3 j3\nC1 1 2 -j3\nC2 3 0 -j2\nI1 0 1 -1-j1\nThe component values for the inductors and capacitors are complex as well as the value of the current source. It is assumed that the impedance of the inductors and capacitors are at a frequency of 1 radian per second. So accordingly, the values in the net list used by the Python code to generate the network equations has been adjusted as follows:\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nI1 0 1 1\nThe component values are not used when the symbolic network equations are generated, only the reference designators, R1, C1, L1 etc. are used.\n\nfrom sympy import *\nimport numpy as np\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "href": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.3 Find the open circuit voltage, Voc",
    "text": "22.3 Find the open circuit voltage, Voc\nRemoving R3 and C2 from the netlist, this gives Voc = V3. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\n*C2 3 0 0.5\nNetwork equations generated by the MNA code are:\n[[Eq(C1*s*v1 - C1*s*v2 + I_L2, I1)],\n[Eq(-C1*s*v1 + I_L1 + v2*(C1*s + 1/R2 + 1/R1) - v3/R2, 0)],\n[Eq(-I_L2 - v2/R2 + v3/R2, 0)],\n[Eq(-I_L1*L1*s + v2, 0)],\n[Eq(-I_L2*L2*s + v1 - v3, 0)]])\nThe following Python code declares the symbols and equations.\n\n# declare the following symbols\nI_L1, s, C1, I1, R2, R1, v3, v1, I_L2, L1, v2, L2 = symbols('I_L1 s C1 I1 R2 R1 v3 v1 I_L2 L1 v2 L2')\n\n# use the equations generated by nodal analysis\nequ = Matrix(\n    [[Eq(C1*s*v1 - C1*s*v2 + I_L2, I1)],\n    [Eq(-C1*s*v1 + I_L1 + v2*(C1*s + 1/R2 + 1/R1) - v3/R2, 0)],\n    [Eq(-I_L2 - v2/R2 + v3/R2, 0)],\n    [Eq(-I_L1*L1*s + v2, 0)],\n    [Eq(-I_L2*L2*s + v1 - v3, 0)]]) \n    \nequ\n\n\\[\\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\\\- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}} = 0\\\\- I_{L1} L_{1} s + v_{2} = 0\\\\- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\end{matrix}\\right]\\]\n\n\nThe symbolic solution for the network equations can easily be obtained with SymPy using the solve function. Using the index [v3], the open circuit voltage at node 3 in symbolic form is:\n\nsolve(equ,[v1, v2, v3, I_L1, I_L2])[v3]\n\n\\[\\frac{I_{1} \\left(C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}\\right)}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\]\n\n\nTo solve numerically, replace symbols with the element values and the Laplace variable, s, with \\(j\\omega\\) where \\(\\omega=1\\).\n\nequ1a = equ.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nequ1a  # display the equations\n\n\\[\\left[\\begin{matrix}I_{L2} + 0.333333333333333 i v_{1} - 0.333333333333333 i v_{2} = -1.0 - 1.0 i\\\\I_{L1} - 0.333333333333333 i v_{1} + v_{2} \\left(\\frac{1}{3} + 0.333333333333333 i\\right) - \\frac{v_{3}}{6} = 0\\\\- I_{L2} - \\frac{v_{2}}{6} + \\frac{v_{3}}{6} = 0\\\\- 2.0 i I_{L1} + v_{2} = 0\\\\- 3.0 i I_{L2} + v_{1} - v_{3} = 0\\end{matrix}\\right]\\]\n\n\nSolving the system of equations for the open circuit voltage at node v3.\n\nVoc = solve(equ1a,[v1, v2, v3, I_L1, I_L2])[v3]\nVoc\n\n\\[-1.8 + 0.6 i\\]",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "href": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.4 Find the short circuit current, Isc",
    "text": "22.4 Find the short circuit current, Isc\nRemove C2 and R3, set node 3 to zero, find current in L2 and R2. New net list:\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33\nEquations generated\n[[Eq(C1*s*v1 - C1*s*v2 + I_L2, I1)],\n[Eq(-C1*s*v1 + I_L1 + v2*(C1*s + 1/R2 + 1/R1), 0)],\n[Eq(-I_L1*L1*s + v2, 0)],\n[Eq(-I_L2*L2*s + v1, 0)]]\n\nL2, L1, v1, R1, I_L1, R2, s, I_L2, v2, I1, C1 = symbols('L2 L1 v1 R1 I_L1 R2 s I_L2 v2 I1 C1')\n\nequ = Matrix(\n    [[Eq(C1*s*v1 - C1*s*v2 + I_L2, I1)],\n    [Eq(-C1*s*v1 + I_L1 + v2*(C1*s + 1/R2 + 1/R1), 0)],\n    [Eq(-I_L1*L1*s + v2, 0)],\n    [Eq(-I_L2*L2*s + v1, 0)]])    \n    \nequ\n\n\\[\\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) = 0\\\\- I_{L1} L_{1} s + v_{2} = 0\\\\- I_{L2} L_{2} s + v_{1} = 0\\end{matrix}\\right]\\]\n\n\nA symbolic solution for the circuit current in L2 and R2:\n\nu = solve(equ,[v1, v2, I_L1, I_L2])\nu[v2]/R2 + u[I_L2]\n\n\\[\\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}} + \\frac{I_{1} \\left(L_{1} s \\left(C_{1} R_{1} R_{2} s + R_{1} + R_{2}\\right) + R_{1} R_{2}\\right)}{- C_{1}^{2} L_{1} L_{2} R_{1} R_{2} s^{4} + C_{1} L_{1} L_{2} s^{3} \\left(C_{1} R_{1} R_{2} s + R_{1} + R_{2}\\right) + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} s \\left(C_{1} R_{1} R_{2} s + R_{1} + R_{2}\\right) + R_{1} R_{2}}\\]\n\n\nTo solve numerically, enter the element values.\n\nequ1a = equ.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nequ1a  # display the equations\n\n\\[\\left[\\begin{matrix}I_{L2} + 0.333333333333333 i v_{1} - 0.333333333333333 i v_{2} = -1.0 - 1.0 i\\\\I_{L1} - 0.333333333333333 i v_{1} + v_{2} \\left(\\frac{1}{3} + 0.333333333333333 i\\right) = 0\\\\- 2.0 i I_{L1} + v_{2} = 0\\\\- 3.0 i I_{L2} + v_{1} = 0\\end{matrix}\\right]\\]\n\n\nSolve the system of equations.\n\nu1 = solve(equ1a,[v1, v2, v3, I_L1, I_L2])\nu1\n\n\\[\\left \\{ I_{L1} : -1.5 - 1.5 i, \\quad I_{L2} : -0.5 + 1.5 i, \\quad v_{1} : -4.5 - 1.5 i, \\quad v_{2} : 3.0 - 3.0 i\\right \\}\\]\n\n\nCurrent in I_R2 = V2/R2\n\nIsc = u1[v2]/6 + u1[I_L2]\nIsc\n\n\\[1.0 i\\]\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\[0.6 + 1.8 i\\]\n\n\nVoc along with Zth are the values to the Thevenin equivalent circuit.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.5 Find V3 using the Thevenin equivalent circuit",
    "text": "22.5 Find V3 using the Thevenin equivalent circuit\nThe load attached to the Thevenin equivalent circuit is the parallel of the resistor and capacitor.\n\\(Z = \\frac{1}{\\frac{1}{R}+\\frac{1}{C}}\\)\nThe load \\(Z\\) is the parallel combination of R = 6 and C = -j2.\n\nZ = (1)/(1/(6)+1/(-2j))\nZ\n\n(0.6-1.7999999999999998j)\n\n\nUsing the values for \\(V_{oc}\\) and \\(Z_{th}\\) obtained above, we write the equation for V3 as a voltage divider and have SymPy simplify the result.\n\nsimplify(Z*Voc/(Zth+Z))\n\n\\[4.62592926927148 \\cdot 10^{-16} + 3.0 i\\]\n\n\nWe can get SymPy to ignore small numbers by using the round function set to 3 digits.\n\nsimplify(Z*Voc/(Zth+Z)).round(3)\n\n\\[3.0 i\\]",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.6 Find V3 using the complete circuit",
    "text": "22.6 Find V3 using the complete circuit\nChecking the answer for V3, by solving the equations for the complete circuit. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nEquations generated are:\n[[Eq(C1*s*v1 - C1*s*v2 + I_L2, I1)],\n[Eq(-C1*s*v1 + I_L1 + v2*(C1*s + 1/R2 + 1/R1) - v3/R2, 0)],\n[Eq(-I_L2 + v3*(C2*s + 1/R3 + 1/R2) - v2/R2, 0)],\n[Eq(-I_L1*L1*s + v2, 0)],\n[Eq(-I_L2*L2*s + v1 - v3, 0)]]\nDeclare the symbols and equations for the complete circuit.\n\nR3, C2, L2, L1, v1, R1, I_L1, R2, s, I_L2, v3, v2, I1, C1 = symbols('R3 C2 L2 L1 v1 R1 I_L1 R2 s I_L2 v3 v2 I1 C1')\n\nequ = Matrix(\n    [[Eq(C1*s*v1 - C1*s*v2 + I_L2, I1)],\n    [Eq(-C1*s*v1 + I_L1 + v2*(C1*s + 1/R2 + 1/R1) - v3/R2, 0)],\n    [Eq(-I_L2 + v3*(C2*s + 1/R3 + 1/R2) - v2/R2, 0)],\n    [Eq(-I_L1*L1*s + v2, 0)],\n    [Eq(-I_L2*L2*s + v1 - v3, 0)]])\nequ # display the equations\n\n\\[\\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\\\- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\\\- I_{L1} L_{1} s + v_{2} = 0\\\\- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\end{matrix}\\right]\\]\n\n\nSolving for v3 using the symbolic values\n\nsolve(equ,[v1, v2, v3, I_L1, I_L2])[v3]\n\n\\[\\frac{I_{1} R_{3} \\left(C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}\\right)}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\]\n\n\nInserting the element values into the equations.\n\nequ1a = equ.subs({L1:2, L2:3, R1:6, R2:6, R3:6, C1:1/3, C2:1/2, I1:-1-1j, s:1j})\nequ1a  # display the equations\n\n\\[\\left[\\begin{matrix}I_{L2} + 0.333333333333333 i v_{1} - 0.333333333333333 i v_{2} = -1.0 - 1.0 i\\\\I_{L1} - 0.333333333333333 i v_{1} + v_{2} \\left(\\frac{1}{3} + 0.333333333333333 i\\right) - \\frac{v_{3}}{6} = 0\\\\- I_{L2} - \\frac{v_{2}}{6} + v_{3} \\left(\\frac{1}{3} + 0.5 i\\right) = 0\\\\- 2.0 i I_{L1} + v_{2} = 0\\\\- 3.0 i I_{L2} + v_{1} - v_{3} = 0\\end{matrix}\\right]\\]\n\n\nSolving the system of equations for v3 using the SymPy solve function.\n\nsolve(equ1a,[v1, v2, v3, I_L1, I_L2])[v3]\n\n\\[3.0 i\\]\n\n\nThe value obtained by solving the system equations for the complete network agrees with the Thevenin equivalent circuit solution.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#references",
    "href": "Thevenin equivalent circuit.html#references",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.7 References",
    "text": "22.7 References\n\nBasic Electric Circuit Analysis, D. E. Johnson, J. L. Hilburn, and J. R. Johnson, Prentice-Hall, 1978\n\nhttps://www.analog.com/en/design-center/design-tools-and-calculators/ltspice-simulator.html\n\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html",
    "href": "State-variable-filter.html",
    "title": "23  State Variable Filter",
    "section": "",
    "text": "Abstract\nThis notebook analyzes a state variable filter by solving the network equations in symbolic form. The filter uses three OpAmps, seven resistors and two capacitors.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#introduction",
    "href": "State-variable-filter.html#introduction",
    "title": "23  State Variable Filter",
    "section": "23.1 Introduction",
    "text": "23.1 Introduction\nA state variable filter using opamps was first described by Tow (1968). The filter shown in the schematic below has low pass (LP), high pass (HP) and band pass (BP) outputs. For certain combinations of resistors and capacitors, the natural frequency and Q of filter can be independently determined. All the element values are assigned a value of 1, since they will be assigned as part of the filter design process.\n\nThe net list for the filter is:\n* state_variable_filter.asc\nR3 3 1 1\nR6 6 4 1\nR7 8 7 1\nR5 4 3 1\nR2 7 5 1\nC1 7 6 1\nC2 2 8 1\nO1 3 5 4 \nO2 6 0 7 \nV1 1 0 1\nO3 8 0 2 \nR1 5 0 1\nR4 2 3 1\nThe following network equations were generated with the MNA code:\n\\(I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}} = 0\\)\n\\(- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}} = 0\\)\n\\(v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}} = 0\\)\n\\(I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}} = 0\\)\n\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}} = 0\\)\n\\(- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}} = 0\\)\n\\(- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}} = 0\\)\n\\(- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(v_{3} - v_{5} = 0\\)\n\\(v_{6} = 0\\)\n\\(v_{8} = 0\\)\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\ninit_printing()\n\nCopy the text strings generated by the Symbolic Modified Nodal Analysis Jupyter notebook to the cell below.\n\nv3, C1, R4, I_O1, R3, I_O2, I_V1, R2, v4, R6, R5, v5, V1, v2, v1, v6, s, v7, I_O3, C2, v8, R1, R7 = symbols(' v3  C1  R4  I_O1  R3  I_O2  I_V1  R2  v4  R6  R5  v5  V1  v2  v1  v6  s  v7  I_O3  C2  v8  R1  R7 ')\nA = Matrix([[1/R3, 0, -1/R3, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, C2*s + 1/R4, -1/R4, 0, 0, 0, 0, -C2*s, 0, 0, 0, 1], [-1/R3, -1/R4, 1/R5 + 1/R4 + 1/R3, -1/R5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, -1/R5, 1/R6 + 1/R5, 0, -1/R6, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1/R2 + 1/R1, 0, -1/R2, 0, 0, 0, 0, 0], [0, 0, 0, -1/R6, 0, C1*s + 1/R6, -C1*s, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1/R2, -C1*s, C1*s + 1/R7 + 1/R2, -1/R7, 0, 0, 1, 0], [0, -C2*s, 0, 0, 0, 0, -1/R7, C2*s + 1/R7, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]])\nX = Matrix( [v1, v2, v3, v4, v5, v6, v7, v8, I_V1, I_O1, I_O2, I_O3] )\nZ = Matrix( [0, 0, 0, 0, 0, 0, 0, 0, V1, 0, 0, 0] )\n\nequ = Eq(A*X,Z)\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}}\\\\- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}}\\\\v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}}\\\\I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}}\\\\- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}}\\\\- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}}\\\\- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}}\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nTakes about 50 seconds to solve\n\nU_sym = solve(equ,X)\n\nThe symbolic solution to the network equations:\n\nU_sym\n\n\\(\\displaystyle \\left\\{ I_{O1} : \\frac{C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{2} R_{1} R_{4} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  I_{O2} : \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{5} V_{1} s - C_{2} R_{2} R_{4} R_{5} V_{1} s - C_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  I_{O3} : \\frac{C_{2} R_{1} R_{4} R_{5} V_{1} s + C_{2} R_{1} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} V_{1} s + R_{1} R_{5} V_{1} + R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  I_{V1} : \\frac{- C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{7} V_{1} s - C_{2} R_{1} R_{5} R_{7} V_{1} s - R_{1} R_{5} V_{1} - R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{- R_{1} R_{4} R_{5} V_{1} - R_{2} R_{4} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{3} : \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{4} : \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{5} : \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{6} : 0, \\  v_{7} : \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}, \\  v_{8} : 0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#low-pass",
    "href": "State-variable-filter.html#low-pass",
    "title": "23  State Variable Filter",
    "section": "23.2 Low Pass",
    "text": "23.2 Low Pass\nThe low pass transfer function.\n\nH_sym_lp = cancel(U_sym[v2]/V1,s)\nH_sym_lp\n\n\\(\\displaystyle \\frac{- R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}}{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)}\\)\n\n\n\nsym_num, sym_denom = fraction(H_sym_lp,s) #returns numerator and denominator\n\n\nsym_num\n\n\\(\\displaystyle - R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}\\)\n\n\n\n23.2.1 Characteristic equation\n\nsym_denom\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)\\)\n\n\nGet the coefficients of the Laplace variable, s, from the quadratic equation:\n\\(as^{2}+bs+c=0\\)\n\na = sym_denom.coeff(s**2)\na\n\n\\(\\displaystyle C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\)\n\n\n\nb = sym_denom.coeff(s)\nb\n\n\\(\\displaystyle C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\)\n\n\nTo find the c coefficient just subract off \\(bs\\) and \\(cs^2\\) from the quadratic equation.\n\nc = sym_denom - b*s - a*s**2\nc\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#natural-frequency-and-q-factor",
    "href": "State-variable-filter.html#natural-frequency-and-q-factor",
    "title": "23  State Variable Filter",
    "section": "23.3 Natural frequency and Q factor",
    "text": "23.3 Natural frequency and Q factor\nThe expressions for the natural frequency and Q factor are shown below:\n\\(\\omega _n = \\sqrt {\\frac {c}{a}}\\)\n\\(Q = \\omega _n \\frac {a}{b}\\)\nThese xpressions have their orgin in classical mechanics describing harmonic oscillators and are applicable to 2nd order electrical systems.\nThe damping ratio is defined by the equation:\n\\(\\zeta = \\frac {1}{2Q}\\)\n\nomega_n = sqrt(c/a)\nomega_n\n\n\\(\\displaystyle \\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}}\\)\n\n\n\nQ = (a/b)*omega_n\nQ\n\n\\(\\displaystyle \\frac{\\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right)}{C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}}\\)\n\n\nSimply the expressions for Q and \\(\\omega _n\\) by letting R = R1 = R3 = R4 = R5 = R6 = R7 and C = C1 = C2.\n\nR, C = symbols('R C')\n\n\nsimplify = {\n    R1:R,\n    R3:R,\n    R4:R,\n    R5:R,\n    R6:R,\n    R7:R,\n    C1:C,\n    C2:C}\n\n\nomega_n_simp = omega_n.subs(simplify).factor()\nomega_n_simp\n\n\\(\\displaystyle \\sqrt{\\frac{1}{C^{2} R^{2}}}\\)\n\n\n\nQ_simp = Q.subs(simplify).factor()\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nBy inspection Q could be simplified more, because C cancels out, but we will leave it.\nLet C = 0.1\\(\\mu\\)F, solve for R to get a natural frequency of 1kHz.\n\nomega_n_simp = omega_n_simp.subs({C:0.1e-6})\nomega_n_simp\n\n\\(\\displaystyle 10000000.0 \\sqrt{\\frac{1}{R^{2}}}\\)\n\n\n\nRnew = solve(Eq(omega_n_simp,1000*2*np.pi),R)\nRnew\n\n\\(\\displaystyle \\left[ -1591.54943091895, \\  1591.54943091895\\right]\\)\n\n\n\nRnew = float(Rnew[1])\nRnew\n\n\\(\\displaystyle 1591.54943091895\\)\n\n\nWith R and C chosen,\n\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nSubstituting C=0.1\\(\\mu\\)F and R = Rnew into Q_simp\n\nQ_simp = Q_simp.subs({C:0.1e-6,R:Rnew})\nQ_simp\n\n\\(\\displaystyle 0.00020943951023932 R_{2} + 0.333333333333333\\)\n\n\nSolve for R2 for the desired Q=3.\n\nR2new = solve(Eq(Q_simp,3),R2)\nR2new = R2new[0]\nR2new\n\n\\(\\displaystyle 12732.3954473516\\)\n\n\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {\n    V1:1,\n    R3:Rnew,\n    R6:Rnew,\n    R7:Rnew,\n    R5:Rnew,\n    R2:R2new,\n    C1:0.1e-6,\n    C2:0.1e-6,\n    R1:Rnew,\n    R4:Rnew}\n\n\nQ.subs(nominal_component_value)\n\n\\(\\displaystyle 3.0\\)\n\n\n\nomega_n.subs(nominal_component_value)/(2*np.pi)\n\n\\(\\displaystyle 1000.0\\)\n\n\n\ndamping_ratio = 1/(2*Q.subs(nominal_component_value))\ndamping_ratio\n\n\\(\\displaystyle 0.166666666666667\\)\n\n\n\n23.3.1 Numerical solution\n\n# put the element values into the equations\nequ1 = equ.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instead of symbols.\n\nequ1\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.000628318530717959 v_{1} - 0.000628318530717959 v_{3}\\\\I_{O3} - 1.0 \\cdot 10^{-7} s v_{8} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right) - 0.000628318530717959 v_{3}\\\\- 0.000628318530717959 v_{1} - 0.000628318530717959 v_{2} + 0.00188495559215388 v_{3} - 0.000628318530717959 v_{4}\\\\I_{O1} - 0.000628318530717959 v_{3} + 0.00125663706143592 v_{4} - 0.000628318530717959 v_{6}\\\\0.000706858347057704 v_{5} - 7.8539816339745 \\cdot 10^{-5} v_{7}\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000628318530717959 v_{4} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-7} s v_{6} - 7.8539816339745 \\cdot 10^{-5} v_{5} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000706858347057704\\right) - 0.000628318530717959 v_{8}\\\\- 1.0 \\cdot 10^{-7} s v_{2} - 0.000628318530717959 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU = solve(equ1,X)\n\n\n\n23.3.2 Low pass filter transfer function\n\nH_lp = U[v2]/U[v1]\nH_lp.factor()\n\n\\(\\displaystyle - \\frac{1.0}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\nThe SymPy function, factor(), takes a polynomial and factors it into irreducible factors over the rational numbers. Notice that the value is negative, indicating that the filter configuration is inverting.\n\n23.3.2.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_lp_num, H_lp_denom = fraction(H_lp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\nlp_a = np.array(Poly(H_lp_num, s).all_coeffs(), dtype=float)\nlp_b = np.array(Poly(H_lp_denom, s).all_coeffs(), dtype=float)\nlp_sys = signal.TransferFunction(lp_a,lp_b)\n\n\n\n\n23.3.3 High pass filter transfer function\n\nH_hp = U[v4]/U[v1]\nH_hp.factor()\n\n\\(\\displaystyle - \\frac{2.53302959105844 \\cdot 10^{-8} s^{2}}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_hp_num, H_hp_denom = fraction(H_hp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nhp_a = np.array(Poly(H_hp_num, s).all_coeffs(), dtype=float)\nhp_b = np.array(Poly(H_hp_denom, s).all_coeffs(), dtype=float)\nhp_sys = signal.TransferFunction(hp_a,hp_b)\n\n\n\n23.3.4 Band pass filter transfer function\n\nH_bp = U[v7]/U[v1]\nH_bp.factor()\n\n\\(\\displaystyle \\frac{0.000159154943091895 s}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_bp_num, H_bp_denom = fraction(H_bp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nbp_a = np.array(Poly(H_bp_num, s).all_coeffs(), dtype=float)\nbp_b = np.array(Poly(H_bp_denom, s).all_coeffs(), dtype=float)\nbp_sys = signal.TransferFunction(bp_a,bp_b)\n\n\n\n23.3.5 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nlp_sys_zeros = np.roots(lp_sys.num)\nlp_sys_poles = np.roots(lp_sys.den)\n\n\n23.3.5.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(lp_sys_zeros), np.imag(lp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(lp_sys_poles), np.imag(lp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(lp_sys_zeros)))\nfor i in lp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(lp_sys_poles)))\nfor i in lp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-166.67+986.01j Hz\n-166.67-986.01j Hz\n\n\n\n\n\n23.3.6 Stability\nBy inspecting the plot above, we can tell the filter is stable since all the poles of the transfer function are in the left hand plane.\n\n\n23.3.7 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nx_axis_range = np.logspace(2, 4, 5000, endpoint=True)*2*np.pi\nw, lp_mag, lp_phase = lp_sys.bode(w=x_axis_range)\nw, hp_mag, hp_phase = hp_sys.bode(w=x_axis_range)\nw, bp_mag, bp_phase = bp_sys.bode(w=x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# Bode magnitude plot\nplt.semilogx(w/(2*np.pi), lp_mag,'-r')\nplt.semilogx(w/(2*np.pi), hp_mag,'-b')\nplt.semilogx(w/(2*np.pi), bp_mag,'-g')\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k' #'tab:blue'\n\n# Bode phase plot\nplt.semilogx(w/(2*np.pi), lp_phase,':r',label='LP phase')\nplt.semilogx(w/(2*np.pi), hp_phase,':b',label='HP phase')\nplt.semilogx(w/(2*np.pi), bp_phase,':g',label='BP phase')\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='r', label='LP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='b', label='HP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='g', label='BP magnitude')\n\nplt.legend(loc=0)\nplt.title('Filter Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe Bode plot for the preamplifier is plotted from 100 Hz to 1 kHz.\n\n\n23.3.8 Low pass filter impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n23.3.9 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\n#w_preamp, mag_preamp, phase_preamp = bp_sys.bode(w=x_axis_range)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(lp_phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#summary",
    "href": "State-variable-filter.html#summary",
    "title": "23  State Variable Filter",
    "section": "23.4 Summary",
    "text": "23.4 Summary\n\n\n\n\nTow, J. 1968. “Active RC Filters—a State-Space Realization.” Proceedings of the IEEE 56 (6): 1137–39. https://doi.org/10.1109/PROC.1968.6502.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html",
    "href": "Superposition_and_polyphase_circuit.html",
    "title": "24  A polyphase circuit",
    "section": "",
    "text": "Abstract",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#introduction",
    "href": "Superposition_and_polyphase_circuit.html#introduction",
    "title": "24  A polyphase circuit",
    "section": "24.1 Introduction",
    "text": "24.1 Introduction\nA circuit to illustrate superposition and polyphase circuit analysis.\n\nWhat is a phasor?\nPhasor\nIn physics and engineering, a phasor (a portmanteau of phase vector[1][2]) is a complex number representing a sinusoidal function whose amplitude (A), and initial phase (θ) are time-invariant and whose angular frequency (ω) is fixed. It is related to a more general concept called analytic representation,[3] which decomposes a sinusoid into the product of a complex constant and a factor depending on time and frequency. The complex constant, which depends on amplitude and phase, is known as a phasor, or complex amplitude,[4][5] and (in older texts) sinor[6] or even complexor.[6\nA common application is in the steady-state analysis of an electrical network powered by time varying current where all signals are assumed to be sinusoidal with a common frequency. Phasor representation allows the analyst to represent the amplitude and phase of the signal using a single complex number. The only difference in their analytic representations is the complex amplitude (phasor). A linear combination of such functions can be represented as a linear combination of phasors (known as phasor arithmetic or phasor algebra[7]: 53 ) and the time/frequency dependent factor that they all have in common.\nCharles Proteus Steinmetz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#circuit-description",
    "href": "Superposition_and_polyphase_circuit.html#circuit-description",
    "title": "24  A polyphase circuit",
    "section": "24.2 Circuit description",
    "text": "24.2 Circuit description\nThe most commen every day poly phase circuits are three phase power circuits for the electric utility. In this example there thre three phases and three frequencies. To illustrate supper posistion .\n\na collection of AC and DC sources\ncoupled inductors\ndependent sources\nRLC\nnon planer\n\ntoo large to do by hand, can’t simplify, not planar, so loop analysis is difficult. But also too large for symbolic solution.\n\n\n\nsource\nDC\nMagnitude @ angle\nfrequency, Hz\n\n\n\n\nV1\n5\n7 @ 135\n3\n\n\nV2\n1\n1 @ 35\n5\n\n\nI1\n2\n3 @ 300\n7\n\n\n\n\n\n\nsource\nDC\nAC, mag @ phase\nomega\n\n\n\n\nV1\n5\n7 @ 135\n\\(2 \\pi 3\\)\n\n\nV2\n1\n1 @ 35\n\\(2 \\pi 5\\)\n\n\nI1\n2\n3 @ 300\n\\(2 \\pi 7\\)\n\n\n\nIndependent sources get set to zero one at a time for each frequency.\nV is zero because is an AC short and I is zero because no current flows and is open.\nSuperposition theorem\nWhat is the Superposition Theorem?\nThe strategy used in the superposition theorem is to eliminate all but one source of power within a network at a time. Then, we use series and parallel circuit analysis techniques to determine voltage drops and currents within the modified network for each power source separately.\nThis process is then repeated sequentially by individually evaluating the circuit for every voltage and current source in the system. After each individual analysis has been completed, the voltage and current values are all “superimposed” on top of each other (added algebraically) to find the actual voltage drops and currents with all sources active.\nWhat does it mean to turn off a current source? It means we set ‍\n. That’s the same as replacing the current source with an open circuit.\nWhat does it mean to turn off a voltage source? It means we set ‍\n. This is the same thing as replacing the voltage source or battery by a short circuit.\nThe theorem does not apply to non-linear circuits. The requisite of linearity indicates that the superposition theorem is only applicable to determine voltage and current but not power. Power dissipation is a nonlinear function that does not algebraically add to an accurate total when only one source is considered at a time.\nSuperposition works for voltage and current but not power. In other words, the sum of the powers of each source with the other sources turned off is not the real consumed power. To calculate power we first use superposition to find both current and voltage of each linear element and then calculate the sum of the multiplied voltages and currents.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#circuit-description-1",
    "href": "Superposition_and_polyphase_circuit.html#circuit-description-1",
    "title": "24  A polyphase circuit",
    "section": "24.3 Circuit description",
    "text": "24.3 Circuit description\nV1 6 1 5 AC 7 90\nV2 10 12 1 AC 1 35\nI3 3 4 2 AC 3 210\nL3 11 14 3 Rser=0\nL1 1 5 5 Rser=0\nL4 14 13 2 Rser=0\nL2 4 8 7 Rser=0\nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\ninit_printing()\n\nIn electrical engineering, a time invarient sinusudial signal can be represented either by polar or rectangular notation. The function polar converts the polar representation, also called a phasor to rectangular notation.\n\ndef polar(mag, ang, units='deg'):\n    ''' polar to rectangular conversion\n        mag: float\n            magnitude of the time invarient sinusudial signal\n        ang: float\n            the angle of the time invarient sinusudial signal\n        units: string\n            if units is set to deg, and is in degrees not radians\n    '''\n    if units == 'deg':\n        ang = ang * np.pi / 180\n    return mag * np.exp(1j * ang)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#symbolic-mna-code",
    "href": "Superposition_and_polyphase_circuit.html#symbolic-mna-code",
    "title": "24  A polyphase circuit",
    "section": "24.4 Symbolic MNA code",
    "text": "24.4 Symbolic MNA code",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#load-the-net-list",
    "href": "Superposition_and_polyphase_circuit.html#load-the-net-list",
    "title": "24  A polyphase circuit",
    "section": "24.5 Load the net list",
    "text": "24.5 Load the net list\nindependent sources have their values set to the DC value.\n\nexample_net_list = '''\nV1 6 1 5 \nV2 10 12 1 \nI3 3 4 2 \nL3 11 14 3 \nL1 1 5 5 \nL4 14 13 2 \nL2 4 8 7 \nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\n'''\n\n\nreport, df, df2, A, X, Z = SymMNA.smna(example_net_list)\n\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 24\nnumber of branches: 23\nnumber of nodes: 14\nnumber of unknown currents: 7\nnumber of RLC (passive components): 18\nnumber of inductors: 4\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 1\nnumber of F - CCCS: 0\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 1\n\n\n\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\n\nequ = Eq(A*X,Z)\n\n\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}}\\\\- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}}\\\\- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}}\\\\I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\I_{H1} + \\frac{v_{7}}{R_{6}}\\\\- I_{L2} + \\frac{v_{8}}{R_{7}}\\\\v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}}\\\\I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}}\\\\I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}}\\\\- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}}\\\\- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right)\\\\- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14}\\\\- I_{L1} L_{1} s + v_{1} - v_{5}\\\\- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14}\\\\- I_{L2} L_{2} s + v_{4} - v_{8}\\\\- I_{V2} h_{1} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{3}\\\\I_{3}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{8}, \\  v_{12}, \\  v_{11}, \\  v_{3}, \\  v_{5}, \\  I_{L3}, \\  C_{3}, \\  v_{4}, \\  h_{1}, \\  I_{L2}, \\  R_{10}, \\  v_{7}, \\  L_{1}, \\  R_{1}, \\  R_{6}, \\  v_{10}, \\  V_{2}, \\  I_{L1}, \\  v_{8}, \\  M_{1}, \\  v_{2}, \\  L_{3}, \\  I_{L4}, \\  R_{7}, \\  I_{V1}, \\  g_{1}, \\  v_{9}, \\  s, \\  L_{4}, \\  v_{14}, \\  v_{13}, \\  R_{4}, \\  C_{2}, \\  R_{11}, \\  R_{5}, \\  R_{3}, \\  v_{6}, \\  I_{V2}, \\  V_{1}, \\  C_{1}, \\  I_{3}, \\  R_{2}, \\  L_{2}, \\  v_{1}, \\  I_{H1}, \\  R_{9}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#symbolic-solution",
    "href": "Superposition_and_polyphase_circuit.html#symbolic-solution",
    "title": "24  A polyphase circuit",
    "section": "24.6 Symbolic solution",
    "text": "24.6 Symbolic solution\nsymbolic_solution = solve(equ,X)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#built-a-dictionary-of-element-values",
    "href": "Superposition_and_polyphase_circuit.html#built-a-dictionary-of-element-values",
    "title": "24  A polyphase circuit",
    "section": "24.7 Built a dictionary of element values",
    "text": "24.7 Built a dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:f},'.format(df.iloc[i]['element'].lower(),df.iloc[i]['value']))\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:.4e},'.format(df.iloc[i]['element'],df.iloc[i]['value']))\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.979795897\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.02279, \\  C_{2} : 0.008443, \\  C_{3} : 0.01266, \\  I_{3} : 2.0, \\  K_{1} : 0.4, \\  L_{1} : 5.0, \\  L_{2} : 7.0, \\  L_{3} : 3.0, \\  L_{4} : 2.0, \\  M_{1} : 0.979795897113271, \\  R_{1} : 100.0, \\  R_{10} : 1.0, \\  R_{11} : 10.0, \\  R_{2} : 20.0, \\  R_{3} : 75.0, \\  R_{4} : 1.0, \\  R_{5} : 10.0, \\  R_{6} : 50.0, \\  R_{7} : 200.0, \\  R_{8} : 100.0, \\  R_{9} : 10.0, \\  V_{1} : 5.0, \\  V_{2} : 1.0, \\  g_{1} : 2.0, \\  h_{1} : 2.0\\right\\}\\)\n\n\n\nelement_values[I3]\n\n\\(\\displaystyle 2.0\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#operating-point",
    "href": "Superposition_and_polyphase_circuit.html#operating-point",
    "title": "24  A polyphase circuit",
    "section": "24.8 Operating point",
    "text": "24.8 Operating point\n\nequ_values = equ.subs(element_values)\nequ_values\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} - 0.02279 s v_{3} + v_{1} \\cdot \\left(0.02279 s + 0.01\\right) - 0.01 v_{2}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.02279 s v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.02279 s + 0.0633333333333333\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.008443 s v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.008443 s + 0.0133333333333333\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} - 0.01266 s v_{13} + v_{12} \\cdot \\left(0.01266 s + 0.15\\right) - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.01266 s v_{12} + 0.021103 s v_{13} - 0.008443 s v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 3.0 I_{L3} s - 0.979795897113271 I_{L4} s + v_{11} - v_{14}\\\\- 5.0 I_{L1} s + v_{1} - v_{5}\\\\- 0.979795897113271 I_{L3} s - 2.0 I_{L4} s - v_{13} + v_{14}\\\\- 7.0 I_{L2} s + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\5.0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nequ_values_dc = equ_values.subs({s:0})\nequ_values_dc  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + 0.01 v_{1} - 0.01 v_{2}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.05 v_{12} + 0.0633333333333333 v_{3} - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.0133333333333333 v_{3} + 0.0133333333333333 v_{4}\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + 0.15 v_{12} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\v_{11} - v_{14}\\\\v_{1} - v_{5}\\\\- v_{13} + v_{14}\\\\v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\5.0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_dc = solve(equ_values_dc,X)\nU_dc\n\n\\(\\displaystyle \\left\\{ I_{H1} : -11.5738896073146, \\  I_{L1} : 20.3047789474962, \\  I_{L2} : 2.80469316139686, \\  I_{L3} : 15.3718733304192, \\  I_{L4} : 0.0, \\  I_{V1} : -0.993290561707708, \\  I_{V2} : -21.2980695092039, \\  v_{1} : -1432.92537125407, \\  v_{10} : 909.862274758366, \\  v_{11} : -1453.23015020156, \\  v_{12} : 908.862274758366, \\  v_{13} : -1453.23015020156, \\  v_{14} : -1453.23015020156, \\  v_{2} : 696.881579666327, \\  v_{3} : 621.290619384137, \\  v_{4} : 560.938632279372, \\  v_{5} : -1432.92537125407, \\  v_{6} : -1427.92537125407, \\  v_{7} : 578.694480365729, \\  v_{8} : 560.938632279372, \\  v_{9} : -1437.85827687114\\right\\}\\)\n\n\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown            mag    phase, deg\n---------  -----------  ------------\nv1         1432.925371    180.000000\nv2          696.881580      0.000000\nv3          621.290619      0.000000\nv4          560.938632      0.000000\nv5         1432.925371    180.000000\nv6         1427.925371    180.000000\nv7          578.694480      0.000000\nv8          560.938632      0.000000\nv9         1437.858277    180.000000\nv10         909.862275      0.000000\nv11        1453.230150    180.000000\nv12         908.862275      0.000000\nv13        1453.230150    180.000000\nv14        1453.230150    180.000000\nI_V1          0.993291    180.000000\nI_V2         21.298070    180.000000\nI_L3         15.371873      0.000000\nI_L1         20.304779      0.000000\nI_L4          0.000000    nan\nI_L2          2.804693      0.000000\nI_H1         11.573890    180.000000\n\n\nLTSpice results:\n--- Operating Point ---\nV(6):    -1427.93    voltage\nV(1):    -1432.93    voltage\nV(10):   909.862     voltage\nV(12):   908.862     voltage\nV(3):    621.291     voltage\nV(4):    560.939     voltage\nV(11):   -1453.23    voltage\nV(14):   -1453.23    voltage\nV(5):    -1432.93    voltage\nV(13):   -1453.23    voltage\nV(8):    560.939     voltage\nV(7):    578.694     voltage\nV(2):    696.882     voltage\nV(9):    -1437.86    voltage\nI(C1):   4.68156e-11     device_current\nI(C2):   1.70056e-11     device_current\nI(C3):   -2.99041e-11    device_current\nI(H1):   -11.5739    device_current\nI(L3):   15.3719     device_current\nI(L1):   20.3048     device_current\nI(L4):   -4.69091e-11    device_current\nI(L2):   2.80469     device_current\nI(I3):   2   device_current\nI(R9):   -21.2981    device_current\nI(R6):   11.5739     device_current\nI(R4):   20.3048     device_current\nI(R1):   -21.2981    device_current\nI(R3):   0.804693    device_current\nI(R7):   -2.80469    device_current\nI(R11):  -236.209    device_current\nI(R5):   0.993291    device_current\nI(R10):  15.3719     device_current\nI(R8):   -14.3786    device_current\nI(R2):   -14.3786    device_current\nI(G1):   -271.886    device_current\nI(V1):   -0.993291   device_current\nI(V2):   -21.2981    device_current",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#independednt-sources-with-the-same-frequency",
    "href": "Superposition_and_polyphase_circuit.html#independednt-sources-with-the-same-frequency",
    "title": "24  A polyphase circuit",
    "section": "24.9 Independednt sources with the same frequency",
    "text": "24.9 Independednt sources with the same frequency\n\nev_w = element_values.copy() # ev for element values\n\n\nev_w[I3] = polar(3, 300, units='deg')\nev_w[V2] = polar(1, 35, units='deg')\nev_w[V1] = polar(7, 135, units='deg')\n\n\nev_w\n\n{V1: (-4.949747468305832+4.949747468305833j),\n V2: (0.8191520442889918+0.573576436351046j),\n I3: (1.5000000000000004-2.598076211353316j),\n L3: 3.0,\n L1: 5.0,\n L4: 2.0,\n L2: 7.0,\n h1: 2.0,\n g1: 2.0,\n C1: 0.02279,\n C2: 0.008443,\n C3: 0.01266,\n R9: 10.0,\n R6: 50.0,\n R4: 1.0,\n R1: 100.0,\n R3: 75.0,\n R7: 200.0,\n R11: 10.0,\n R5: 10.0,\n R10: 1.0,\n R8: 100.0,\n R2: 20.0,\n K1: 0.4,\n M1: 0.9797958971132712}\n\n\n\nequ_ev_w = equ.subs(ev_w)\n\n\nequ_ev_w = equ_ev_w.subs({s:2*np.pi*3j})\n\n\nequ_ev_w\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 0.429581379451868 i\\right) - 0.01 v_{2} - 0.429581379451868 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.429581379451868 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 0.429581379451868 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.159146800645552 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.159146800645552 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.238635377966681 i\\right) - 0.238635377966681 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.238635377966681 i v_{12} + 0.397782178612232 i v_{13} - 0.159146800645552 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 56.5486677646163 i I_{L3} - 18.4687175543308 i I_{L4} + v_{11} - v_{14}\\\\- 94.2477796076938 i I_{L1} + v_{1} - v_{5}\\\\- 18.4687175543308 i I_{L3} - 37.6991118430775 i I_{L4} - v_{13} + v_{14}\\\\- 131.946891450771 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-1.5 + 2.59807621135332 i\\\\1.5 - 2.59807621135332 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\-4.94974746830583 + 4.94974746830583 i\\\\0.819152044288992 + 0.573576436351046 i\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_w = solve(equ_ev_w,X)\nU_w\n\n\\(\\displaystyle \\left\\{ I_{H1} : -0.153544437655104 - 0.0892500106463104 i, \\  I_{L1} : 3.54302617527629 + 2.81001510230497 i, \\  I_{L2} : 0.945703908332592 + 0.362574674184583 i, \\  I_{L3} : 10.4231744502691 + 8.54663272904898 i, \\  I_{L4} : -18.259482746311 - 6.1397795231405 i, \\  I_{V1} : -9.32392610428119 - 8.09480804421826 i, \\  I_{V2} : -2.15750009464392 - 0.711695486372941 i, \\  v_{1} : -11.7358260876709 + 30.815864490805 i, \\  v_{10} : 225.58918432316 + 109.102367991829 i, \\  v_{11} : -120.348009049058 - 53.7291012121207 i, \\  v_{12} : 224.770032278871 + 108.528791555478 i, \\  v_{13} : 175.939942772077 + 189.947116585154 i, \\  v_{14} : 249.558831793383 - 305.91650072323 i, \\  v_{2} : 204.014183376721 + 101.985413128099 i, \\  v_{3} : 11.992222072043 + 5.8858915050614 i, \\  v_{4} : 141.300180489087 + 197.297625774247 i, \\  v_{5} : 253.101857968659 - 303.106485620925 i, \\  v_{6} : -16.6855735559768 + 35.7656119591109 i, \\  v_{7} : 7.6772218827552 + 4.46250053231552 i, \\  v_{8} : 189.140781666518 + 72.5149348369166 i, \\  v_{9} : -109.924834598789 - 45.1824684830717 i\\right\\}\\)\n\n\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown           mag    phase, deg\n---------  ----------  ------------\nv1          32.974947    110.848692\nv2         228.085097     26.560180\nv3          13.358784     26.142224\nv4         242.676934     54.390602\nv5         394.884910    -50.137234\nv6          39.466281    115.010256\nv7           8.879958     30.167939\nv8         202.565177     20.976390\nv9         118.848327   -157.655839\nv10        250.586925     25.809942\nv11        131.797039   -155.941733\nv12        249.599812     25.773280\nv13        258.910739     47.192371\nv14        394.796803    -50.793317\nI_V1        12.347531   -139.036272\nI_V2         2.271853   -161.743805\nI_L3        13.479150     39.350535\nI_L1         4.522081     38.418341\nI_L4        19.264101   -161.414701\nI_L2         1.012826     20.976390\nI_H1         0.177599   -149.832061\n\n\n\nans1[v1]-ans1[v2]\n\n\\(\\displaystyle -215.750009464392 - 71.1695486372941 i\\)\n\n\n\nabs(ans1[v1]-ans1[v2])\n\n\\(\\displaystyle 227.185323551328\\)\n\n\n\nfloat(arg(ans1[v1]-ans1[v2])*180/np.pi)\n\n\\(\\displaystyle -161.743805013083\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#independednt-sources-with-the-different-frequencies",
    "href": "Superposition_and_polyphase_circuit.html#independednt-sources-with-the-different-frequencies",
    "title": "24  A polyphase circuit",
    "section": "24.10 Independednt sources with the different frequencies",
    "text": "24.10 Independednt sources with the different frequencies\n\n\n\nsource\nDC\nAC, mag @ phase\nfrequency, Hz\n\n\n\n\nV1\n5\n7 @ 135\n3\n\n\nV2\n1\n1 @ 35\n5\n\n\nI1\n2\n3 @ 300\n7\n\n\n\n\\(2 \\pi 3\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#ac-analysis",
    "href": "Superposition_and_polyphase_circuit.html#ac-analysis",
    "title": "24  A polyphase circuit",
    "section": "24.11 AC analysis",
    "text": "24.11 AC analysis\nSolve equations a frequency of 1.491MHz or \\(\\omega\\) equal to 9.3682292e6 radians per second, s = 9.3682292e6j.\n\nFind the current in R1 and the voltage across v1-v2\n\nnumber of independent voltage sources: 2  \nnumber of independent current sources: 1  \n\nV1 6 1 5 AC 7 90\nV2 10 12 1 AC 1 35\nI3 3 4 2 AC 3 210",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#numeric-solution",
    "href": "Superposition_and_polyphase_circuit.html#numeric-solution",
    "title": "24  A polyphase circuit",
    "section": "24.12 Numeric solution",
    "text": "24.12 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nelement_values[V1]\n\n\\(\\displaystyle 5.0\\)\n\n\n\nelement_values[V1] = 1+1j\n\n\nelement_values[V1]\n\n(1+1j)\n\n\n\n3j\n\n3j\n\n\n\npolar(7, 100, units='deg')\n\n(-1.2155372436685121+6.893654271085456j)\n\n\n\nequ1a_1rad_per_s = equ1a.subs({s:3+9.3682292e6j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.07837 + 213501.943468 i\\right) - 0.01 v_{2} - 0.02279 v_{3} \\cdot \\left(3.0 + 9368229.2 i\\right)\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.02279 v_{1} \\cdot \\left(3.0 + 9368229.2 i\\right) - 0.05 v_{12} + v_{3} \\cdot \\left(1.11837 + 213501.943468 i\\right) - 1.0 v_{4}\\\\I_{L2} - 0.008443 v_{13} \\cdot \\left(3.0 + 9368229.2 i\\right) - 1.0 v_{3} + v_{4} \\cdot \\left(1.025329 + 79095.9591356 i\\right)\\\\- I_{L1} - 10.0 v_{14} + 10.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 1.0 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 10.0 v_{11} - 0.1 v_{6} + 10.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 10.0 v_{11} - 10.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.18798 + 118601.781672 i\\right) - 0.01266 v_{13} \\cdot \\left(3.0 + 9368229.2 i\\right) - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.01266 v_{12} \\cdot \\left(3.0 + 9368229.2 i\\right) + 0.021103 v_{13} \\cdot \\left(3.0 + 9368229.2 i\\right) - 0.008443 v_{4} \\cdot \\left(3.0 + 9368229.2 i\\right)\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 10.1 v_{14} + 2.0 v_{2} - 10.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 3.0 I_{L3} \\cdot \\left(3.0 + 9368229.2 i\\right) - 0.979795897113271 I_{L4} \\cdot \\left(3.0 + 9368229.2 i\\right) + v_{11} - v_{14}\\\\- 5.0 I_{L1} \\cdot \\left(3.0 + 9368229.2 i\\right) + v_{1} - v_{5}\\\\- 0.979795897113271 I_{L3} \\cdot \\left(3.0 + 9368229.2 i\\right) - 2.0 I_{L4} \\cdot \\left(3.0 + 9368229.2 i\\right) - v_{13} + v_{14}\\\\- 7.0 I_{L2} \\cdot \\left(3.0 + 9368229.2 i\\right) + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\5.0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{H1} : 0.0455167613956052 + 2.8063799348635 \\cdot 10^{-7} i, \\  I_{L1} : 3.92097471955556 \\cdot 10^{-12} - 1.08062176287193 \\cdot 10^{-6} i, \\  I_{L2} : 2.55267302265801 \\cdot 10^{-14} - 2.87700671148874 \\cdot 10^{-8} i, \\  I_{L3} : 1.29319497551419 \\cdot 10^{-11} - 3.42599846234041 \\cdot 10^{-6} i, \\  I_{L4} : -1.6007231644986 \\cdot 10^{-11} + 4.48027399654328 \\cdot 10^{-6} i, \\  I_{V1} : -0.0455167614085116 + 3.11659040173918 \\cdot 10^{-6} i, \\  I_{V2} : -0.0261802575095712 + 1.75141221429105 \\cdot 10^{-8} i, \\  v_{1} : 0.00684375364308504 - 2.25097957267989 \\cdot 10^{-7} i, \\  v_{10} : 2.88667207969592 - 2.15165139298814 \\cdot 10^{-6} i, \\  v_{11} : 4.55167613955668 + 3.12834059063578 \\cdot 10^{-5} i, \\  v_{12} : 1.88667207969592 - 2.15165139298814 \\cdot 10^{-6} i, \\  v_{13} : 1.88667207977109 - 3.16488805843569 \\cdot 10^{-6} i, \\  v_{14} : -50.6107180118775 - 0.000167570658638913 i, \\  v_{2} : 2.6248695046002 - 1.97651017155904 \\cdot 10^{-6} i, \\  v_{3} : 0.00684375362353718 - 3.15666237772171 \\cdot 10^{-7} i, \\  v_{4} : 1.88667207982717 - 4.68420301596592 \\cdot 10^{-6} i, \\  v_{5} : -50.6107180118771 - 0.0001676787208152 i, \\  v_{6} : 5.00684375364308 - 2.25097957267989 \\cdot 10^{-7} i, \\  v_{7} : -0.0455167613956052 - 2.8063799348635 \\cdot 10^{-7} i, \\  v_{8} : 5.10534604531602 \\cdot 10^{-12} - 5.75401342297747 \\cdot 10^{-6} i, \\  v_{9} : 4.55167613955797 + 3.09408060601238 \\cdot 10^{-5} i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.006844 phase:    -0.00188 deg\nv2   : mag:   2.624870 phase:    -0.00004 deg\nv3   : mag:   0.006844 phase:    -0.00264 deg\nv4   : mag:   1.886672 phase:    -0.00014 deg\nv5   : mag:  50.610718 phase:  -179.99981 deg\nv6   : mag:   5.006844 phase:    -0.00000 deg\nv7   : mag:   0.045517 phase:  -179.99965 deg\nv8   : mag:   0.000006 phase:   -89.99995 deg\nv9   : mag:   4.551676 phase:     0.00039 deg\nv10  : mag:   2.886672 phase:    -0.00004 deg\nv11  : mag:   4.551676 phase:     0.00039 deg\nv12  : mag:   1.886672 phase:    -0.00007 deg\nv13  : mag:   1.886672 phase:    -0.00010 deg\nv14  : mag:  50.610718 phase:  -179.99981 deg\nI_V1 : mag:   0.045517 phase:   179.99608 deg\nI_V2 : mag:   0.026180 phase:   179.99996 deg\nI_L3 : mag:   0.000003 phase:   -89.99978 deg\nI_L1 : mag:   0.000001 phase:   -89.99979 deg\nI_L4 : mag:   0.000004 phase:    90.00020 deg\nI_L2 : mag:   0.000000 phase:   -89.99995 deg\nI_H1 : mag:   0.045517 phase:     0.00035 deg\n\n\n\ntable_header = ['unknown', 'mag, dB','phase, deg']\ntable_row = []\n\nfor name, value in ans1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown      mag, dB    phase, deg\n---------  ---------  ------------\nv1          0.006844     -0.001885\nv2          2.624870     -0.000043\nv3          0.006844     -0.002643\nv4          1.886672     -0.000142\nv5         50.610718   -179.999810\nv6          5.006844     -0.000003\nv7          0.045517   -179.999647\nv8          0.000006    -89.999949\nv9          4.551676      0.000389\nv10         2.886672     -0.000043\nv11         4.551676      0.000394\nv12         1.886672     -0.000065\nv13         1.886672     -0.000096\nv14        50.610718   -179.999810\nI_V1        0.045517    179.996077\nI_V2        0.026180    179.999962\nI_L3        0.000003    -89.999784\nI_L1        0.000001    -89.999792\nI_L4        0.000004     90.000205\nI_L2        0.000000    -89.999949\nI_H1        0.045517      0.000353",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#ac-sweep",
    "href": "Superposition_and_polyphase_circuit.html#ac-sweep",
    "title": "24  A polyphase circuit",
    "section": "24.13 AC Sweep",
    "text": "24.13 AC Sweep",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#find-v_1s-v_2s.",
    "href": "Superposition_and_polyphase_circuit.html#find-v_1s-v_2s.",
    "title": "24  A polyphase circuit",
    "section": "24.14 Find \\(V_{1}(s)-V_{2}(s)\\).",
    "text": "24.14 Find \\(V_{1}(s)-V_{2}(s)\\).\n\nH = (u1[v1]-u1[v2]).cancel()\nH\n\n\\(\\displaystyle \\frac{- 1.45477630598504 \\cdot 10^{48} s^{7} - 7.57095055819837 \\cdot 10^{49} s^{6} - 2.62941112067424 \\cdot 10^{51} s^{5} + 9.22466212689688 \\cdot 10^{52} s^{4} + 3.47360412840924 \\cdot 10^{53} s^{3} + 2.12825011456623 \\cdot 10^{54} s^{2} + 5.21001791479266 \\cdot 10^{54} s + 2.7767336 \\cdot 10^{54}}{5.55676851302481 \\cdot 10^{47} s^{7} + 2.5436023614194 \\cdot 10^{49} s^{6} - 1.32339374128287 \\cdot 10^{51} s^{5} - 5.55792980190024 \\cdot 10^{52} s^{4} - 1.17902545405813 \\cdot 10^{53} s^{3} - 1.06281500129569 \\cdot 10^{54} s^{2} - 1.22564886586046 \\cdot 10^{54} s - 3.538628105 \\cdot 10^{52}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\n\nx = np.logspace(-3, 3, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w/(2*np.pi), phase,':',color='b')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('peak: {:.2f} dB at {:.3f} Hz'.format(mag.max(),w[np.argmax(mag)]/(2*np.pi)))\n\npeak: 11.21 dB at 0.684 Hz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "Superposition_and_polyphase_circuit.html#summary",
    "href": "Superposition_and_polyphase_circuit.html#summary",
    "title": "24  A polyphase circuit",
    "section": "24.15 Summary",
    "text": "24.15 Summary",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>A polyphase circuit</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html",
    "href": "2nd_order_BRF.html",
    "title": "25  2nd Order BRF",
    "section": "",
    "text": "Abstract",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#introduction",
    "href": "2nd_order_BRF.html#introduction",
    "title": "25  2nd Order BRF",
    "section": "25.1 Introduction",
    "text": "25.1 Introduction\nThis notebook walks through the Python code used to generate and solve the circuit network equations. The example starts with a net list for the circuit shown below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#circuit-description",
    "href": "2nd_order_BRF.html#circuit-description",
    "title": "25  2nd Order BRF",
    "section": "25.2 Circuit description",
    "text": "25.2 Circuit description\nThe circuit below is a 2nd order band reject filter, problem 13-20 from Budak (1974). The schematic of the circuit is shown below with each node explicity annotated. The problem asks to obtain: \\(\\frac {V_o} {V_i}\\), which according to the way I have labled the nodes, is \\(\\frac {V_2} {V_1}\\).\n\nThe net list for this circuit is:\n* 2nd order BRF\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\nReference:\n1. Aram Budak, Passive and Active Network Analysis and Synthesis, Houghton Mifflin Comp. 1974\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#load-the-net-list",
    "href": "2nd_order_BRF.html#load-the-net-list",
    "title": "25  2nd Order BRF",
    "section": "25.3 Load the net list",
    "text": "25.3 Load the net list\nindependent sources have their values set to the DC value.\n\nexample_net_list = '''\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\n'''\n\n\nreport, df, df2, A, X, Z = SymMNA.smna(example_net_list)\n\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 8\nnumber of branches: 7\nnumber of nodes: 5\nnumber of unknown currents: 2\nnumber of RLC (passive components): 6\nnumber of inductors: 0\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 1\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\\\I_{V1}\\\\I_{O1}\\end{matrix}\\right]\\)\n\n\n\nZ\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\n\nequ = Eq(A*X,Z)\n\n\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{4} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}}\\\\I_{O1} + \\frac{v_{2}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\\\v_{3} \\left(C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\- C_{1} s v_{1} - C_{2} s v_{5} + v_{4} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{3}, \\  V_{1}, \\  R_{1}, \\  R_{3}, \\  C_{3}, \\  s, \\  v_{1}, \\  v_{5}, \\  v_{2}, \\  I_{O1}, \\  R_{2}, \\  v_{4}, \\  C_{1}, \\  C_{2}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#symbolic-mna-code",
    "href": "2nd_order_BRF.html#symbolic-mna-code",
    "title": "25  2nd Order BRF",
    "section": "25.4 Symbolic MNA code",
    "text": "25.4 Symbolic MNA code\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#read-the-net-list-and-preprocess-it",
    "href": "2nd_order_BRF.html#read-the-net-list-and-preprocess-it",
    "title": "25  2nd Order BRF",
    "section": "25.5 Read the net list and preprocess it",
    "text": "25.5 Read the net list and preprocess it\nThe following steps are performed:\n\nremove blank lines and comments\n\nconvert first letter of element name to upper case\n\nremoves extra spaces between entries\n\ncount number of entries on each line, make sure the count is correct, count each element type\n\n\nexample_net_list = '''O1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1'''\n\n\ncontent = example_net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove spice directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\nfor i in content:\n    print(i)\n\nO1 2 5 2\nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\n\n\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#parser",
    "href": "2nd_order_BRF.html#parser",
    "title": "25  2nd Order BRF",
    "section": "25.6 Parser",
    "text": "25.6 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTspice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: opamp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n25.6.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n25.6.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n# Check for position of voltages sources in the dataframe.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # re-order the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#print-net-list-report",
    "href": "2nd_order_BRF.html#print-net-list-report",
    "title": "25  2nd Order BRF",
    "section": "25.7 Print net list report",
    "text": "25.7 Print net list report\n\n# print a report\nprint('Net list report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNet list report\nnumber of lines in netlist: 8\nnumber of branches: 7\nnumber of nodes: 5\nnumber of unknown currents: 2\nnumber of RLC (passive components): 6\nnumber of inductors: 0\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 1\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\ndf\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nO1\n2\n5\nNaN\nNaN\n2\nNaN\nNaN\nNaN\nNaN\n\n\n2\nC3\n3\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nC1\n4\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n4\nC2\n5\n4\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n5\nR1\n2\n4\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n6\nR2\n3\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n7\nR3\n5\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nO1\n2\n5\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed\n\n\n# initialize some symbolic matrix with zeros\n# A is formed by [[G, C] [B, D]]\n# Z = [I,E]\n# X = [V, J]\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\n\n25.7.0.1 some debugging notes:\nIs it possible to have i_unk == 0 ?, what about a network with only current sources? This would make B = 0 for example. Did one test, need to run others\nIs there a valid op amp case where B is n by 1?",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#g-matrix",
    "href": "2nd_order_BRF.html#g-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.8 G matrix",
    "text": "25.8 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & - C_{1} s & 0\\\\0 & \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0\\\\- \\frac{1}{R_{2}} & 0 & C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{3}}\\\\- C_{1} s & - \\frac{1}{R_{1}} & 0 & C_{1} s + C_{2} s + \\frac{1}{R_{1}} & - C_{2} s\\\\0 & 0 & - \\frac{1}{R_{3}} & - C_{2} s & C_{2} s + \\frac{1}{R_{3}}\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#b-matrix",
    "href": "2nd_order_BRF.html#b-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.9 B Matrix",
    "text": "25.9 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The code loop through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0\\\\0 & 1\\\\0 & 0\\\\0 & 0\\\\0 & 0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#c-matrix",
    "href": "2nd_order_BRF.html#c-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.10 C matrix",
    "text": "25.10 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\n25.10.1 Op Amp elements\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results likely will be erroneous.\nReferences use in the debugging of the opamp stamp:\n\nDesign of Analog Circuits Through Symbolic Analysis, edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fernández\n\nComputer Aided Design and Design Automation, edited by Wai-Kai Chen\n\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & -1\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#d-matrix",
    "href": "2nd_order_BRF.html#d-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.11 D matrix",
    "text": "25.11 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n&gt; m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes:\nCan the K statement be anywhere in the net list, even before Lx and Ly?\n12/6/2017 doing some debugging on with coupled inductors\nLTspice seems to put the phasing dot on the neg node when it generates the netlist\nThis code uses M for mutual inductance, LTspice uses k for the coupling coefficient.\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0\\\\0 & 0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#v-matrix",
    "href": "2nd_order_BRF.html#v-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.12 V matrix",
    "text": "25.12 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#j-matrix",
    "href": "2nd_order_BRF.html#j-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.13 J matrix",
    "text": "25.13 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{O1}\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#i-matrix",
    "href": "2nd_order_BRF.html#i-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.14 I matrix",
    "text": "25.14 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#ev-matrix",
    "href": "2nd_order_BRF.html#ev-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.15 Ev matrix",
    "text": "25.15 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#z-matrix",
    "href": "2nd_order_BRF.html#z-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.16 Z matrix",
    "text": "25.16 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#x-matrix",
    "href": "2nd_order_BRF.html#x-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.17 X matrix",
    "text": "25.17 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{O1}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#a-matrix",
    "href": "2nd_order_BRF.html#a-matrix",
    "title": "25  2nd Order BRF",
    "section": "25.18 A matrix",
    "text": "25.18 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n    A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & - C_{1} s & 0 & 1 & 0\\\\0 & \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1\\\\- \\frac{1}{R_{2}} & 0 & C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{3}} & 0 & 0\\\\- C_{1} s & - \\frac{1}{R_{1}} & 0 & C_{1} s + C_{2} s + \\frac{1}{R_{1}} & - C_{2} s & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{3}} & - C_{2} s & C_{2} s + \\frac{1}{R_{3}} & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & -1 & 0 & 0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#generate-the-circuit-equations",
    "href": "2nd_order_BRF.html#generate-the-circuit-equations",
    "title": "25  2nd Order BRF",
    "section": "25.19 generate the circuit equations",
    "text": "25.19 generate the circuit equations\n\nequ = Eq(A*Matrix(X),Matrix(Z))\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{4} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}}\\\\I_{O1} + \\frac{v_{2}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\\\v_{3} \\left(C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\- C_{1} s v_{1} - C_{2} s v_{5} + v_{4} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#symbolic-solution",
    "href": "2nd_order_BRF.html#symbolic-solution",
    "title": "25  2nd Order BRF",
    "section": "25.20 Symbolic solution",
    "text": "25.20 Symbolic solution\n\nv1, v2, v3, v4, v5, I_V1, I_O = symbols('v1 v2 v3 v4 v5 I_V1 I_O')\n\n\nsymbolic_solution = solve(equ,X)\n\n\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{O1} : \\frac{C_{1} C_{3} R_{2} V_{1} s^{2}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  I_{V1} : \\frac{- C_{1} C_{2} C_{3} R_{1} R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} V_{1} s^{3} - C_{1} C_{3} R_{1} V_{1} s^{2} - C_{1} C_{3} R_{2} V_{1} s^{2} - C_{2} C_{3} R_{1} V_{1} s^{2} - C_{3} V_{1} s}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{3} : \\frac{C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{4} : \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} C_{3} R_{1} R_{2} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}, \\  v_{5} : \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\right\\}\\)\n\n\nThe symbolic solution for \\(\\frac {V_o}{V_i}\\):\n\n(symbolic_solution[v2]/symbolic_solution[v1]).factor()\n\n\\(\\displaystyle \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + 1}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\n\n\nBuilt a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:f},'.format(df.iloc[i]['element'].lower(),df.iloc[i]['value']))\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:.4e},'.format(df.iloc[i]['element'],df.iloc[i]['value']))\n\nelement_values = dict(zip(element_value_keys, element_value_values))",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#numeric-solution",
    "href": "2nd_order_BRF.html#numeric-solution",
    "title": "25  2nd Order BRF",
    "section": "25.21 Numeric solution",
    "text": "25.21 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ1a = equ.subs(element_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 1.0 s v_{4} + v_{1} \\cdot \\left(1.0 s + 1.0\\right) - 1.0 v_{3}\\\\I_{O1} + 2.0 v_{2} - 2.0 v_{4}\\\\- 1.0 v_{1} + v_{3} \\cdot \\left(2.0 s + 2.0\\right) - 1.0 v_{5}\\\\- 1.0 s v_{1} - 1.0 s v_{5} - 2.0 v_{2} + v_{4} \\cdot \\left(2.0 s + 2.0\\right)\\\\- 1.0 s v_{4} - 1.0 v_{3} + v_{5} \\cdot \\left(1.0 s + 1.0\\right)\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{O1} : \\frac{2.0 s^{2}}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}, \\  I_{V1} : - \\frac{2.0 s}{s + 1.0}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}, \\  v_{3} : \\frac{s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}, \\  v_{4} : \\frac{s^{3} + 2.0 s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}, \\  v_{5} : \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#ac-analysis",
    "href": "2nd_order_BRF.html#ac-analysis",
    "title": "25  2nd Order BRF",
    "section": "25.22 AC analysis",
    "text": "25.22 AC analysis\nSolve the equations at a frequency of 0.159154 mHz or \\(\\omega\\) equal to 1 radians per second, s = 1.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(1.0 + 1.0 i\\right) - 1.0 v_{3} - 1.0 i v_{4}\\\\I_{O1} + 2.0 v_{2} - 2.0 v_{4}\\\\- 1.0 v_{1} + v_{3} \\cdot \\left(2.0 + 2.0 i\\right) - 1.0 v_{5}\\\\- 1.0 i v_{1} - 2.0 v_{2} + v_{4} \\cdot \\left(2.0 + 2.0 i\\right) - 1.0 i v_{5}\\\\- 1.0 v_{3} - 1.0 i v_{4} + v_{5} \\cdot \\left(1.0 + 1.0 i\\right)\\\\v_{1}\\\\v_{2} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{O1} : 0.5 + 0.5 i, \\  I_{V1} : -1.0 - 1.0 i, \\  v_{1} : 1.0, \\  v_{2} : 0.0, \\  v_{3} : 0.25 - 0.25 i, \\  v_{4} : 0.25 + 0.25 i, \\  v_{5} : 0.0\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.000000 phase:     0.00000 deg\nv2   : mag:   0.000000 phase:         nan deg\nv3   : mag:   0.353553 phase:   -45.00000 deg\nv4   : mag:   0.353553 phase:    45.00000 deg\nv5   : mag:   0.000000 phase:         nan deg\nI_V1 : mag:   1.414214 phase:  -135.00000 deg\nI_O1 : mag:   0.707107 phase:    45.00000 deg",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#ac-sweep",
    "href": "2nd_order_BRF.html#ac-sweep",
    "title": "25  2nd Order BRF",
    "section": "25.23 AC Sweep",
    "text": "25.23 AC Sweep\nLooking at node 2 voltage.\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\n\nx = np.logspace(-1, 0, 500, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('null: {:.2f} dB at {:.3f} Hz'.format(mag.min(),w[np.argmin(mag)]/(2*np.pi)))\n\nnull: -57.42 dB at 0.159 Hz\n\n\n\n\n\n\nBudak, A. 1974. Passive and Active Network Analysis and Synthesis. Houghton Mifflin.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html",
    "href": "Elliptic-function-LPF.html",
    "title": "26  Elliptic Function LPF",
    "section": "",
    "text": "Abstract",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#introduction",
    "href": "Elliptic-function-LPF.html#introduction",
    "title": "26  Elliptic Function LPF",
    "section": "26.1 Introduction",
    "text": "26.1 Introduction\n\n\n\nSchematic",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#circuit-description",
    "href": "Elliptic-function-LPF.html#circuit-description",
    "title": "26  Elliptic Function LPF",
    "section": "26.2 Circuit description",
    "text": "26.2 Circuit description\nThe circuit shown below is an elliptic function VCVS filter, which contains zeros and poles. The filter cutoff is 100 Hz. The circuit is from Williams and Taylor (1995), example 3-13.\nThis is the modified net list, V4 line was changed. The lines for the inductors were also changed.\n* Elliptic function VCVS LPF\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7\nV1 1 0 1\nR5 6 0 10e3\nR6 7 6 44.2e3\n\nThis netlist is read into the Symbolic Modified Nodal Analysis Jupyter notebook and the following circuit equations were generated.\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\n\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\n\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\n\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\n\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\n\\(- C_{3} s v_{4} + I_{O} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{5} + v_{6} = 0\\)\n\n#import os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\ninit_printing()\n\nCopy the text strings generated by the Symbolic Modified Nodal Analysis Jupyter notebook to the cell below. used in nodal analysis\n\nC1, v4, v1, V1, R7, v5, R4, R3, R2, v2, C4, C2, s, R1, C5, I_O1, v3, I_V1, v7, C3, R6, v6, R5 = symbols(' C1  v4  v1  V1  R7  v5  R4  R3  R2  v2  C4  C2  s  R1  C5  I_O1  v3  I_V1  v7  C3  R6  v6  R5 ')\nA = Matrix([[C1*s + 1/R1, 0, -C1*s, -1/R1, 0, 0, 0, 1, 0], [0, C5*s + 1/R7, 0, 0, 0, 0, -1/R7, 0, 0], [-C1*s, 0, C1*s + C2*s + 1/R3, 0, -C2*s, 0, 0, 0, 0], [-1/R1, 0, 0, C3*s + 1/R2 + 1/R1, -1/R2, 0, -C3*s, 0, 0], [0, 0, -C2*s, -1/R2, C2*s + C4*s + 1/R4 + 1/R2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1/R6 + 1/R5, -1/R6, 0, 0], [0, -1/R7, 0, -C3*s, 0, -1/R6, C3*s + 1/R7 + 1/R6, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1, 1, 0, 0, 0]])\nX = Matrix( [v1, v2, v3, v4, v5, v6, v7, I_V1, I_O1] )\nZ = Matrix( [0, 0, 0, 0, 0, 0, 0, V1, 0] )\n\nequ = Eq(A*X,Z)\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}}\\\\v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}}\\\\- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right)\\\\- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\\\- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}}\\\\v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}}\\\\- C_{3} s v_{4} + I_{O1} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}}\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#symbolic-solution",
    "href": "Elliptic-function-LPF.html#symbolic-solution",
    "title": "26  Elliptic Function LPF",
    "section": "26.3 Symbolic solution",
    "text": "26.3 Symbolic solution\ntook about 2hrs\nsymbolic_solution = solve(equ,X)\nsymbolic_solution[v2]\nprint(‘\\({:s}\\)’.format(latex(symbolic_solution[v2])))",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#numeric-solution",
    "href": "Elliptic-function-LPF.html#numeric-solution",
    "title": "26  Elliptic Function LPF",
    "section": "26.4 Numeric solution",
    "text": "26.4 Numeric solution\n\n# enter the element values, set I2=0\nequ1a = equ.subs({\n    V1:1.0000e+00,\n    R3:4.7500e+03,\n    R4:7.3200e+04,\n    R1:9.5300e+03,\n    R2:9.5300e+03,\n    R7:1.0000e+04,\n    C1:5.0000e-08,\n    C2:5.0000e-08,\n    C3:1.0000e-07,\n    C4:2.2000e-07,\n    C5:1.8000e-07,\n    R5:1.0000e+04,\n    R6:4.4200e+04})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 5.0 \\cdot 10^{-8} s v_{3} + v_{1} \\cdot \\left(5.0 \\cdot 10^{-8} s + 0.000104931794333683\\right) - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(1.8 \\cdot 10^{-7} s + 0.0001\\right) - 0.0001 v_{7}\\\\- 5.0 \\cdot 10^{-8} s v_{1} - 5.0 \\cdot 10^{-8} s v_{5} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000210526315789474\\right)\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000209863588667366\\right) - 0.000104931794333683 v_{5}\\\\- 5.0 \\cdot 10^{-8} s v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(2.7 \\cdot 10^{-7} s + 0.000118592996519475\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 1.0 \\cdot 10^{-7} s v_{4} - 0.0001 v_{2} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.00012262443438914\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\n\nu1 = solve(equ1a,X)\n#u1\n\n\nu1[v2]\n\n\\(\\displaystyle \\frac{7.66402714932125 \\cdot 10^{50} s^{3} + 1.60840024120068 \\cdot 10^{54} s^{2} + 3.37544646631832 \\cdot 10^{57} s + 7.10620308698594 \\cdot 10^{60}}{2.49434389140272 \\cdot 10^{48} s^{4} + 7.82471226796141 \\cdot 10^{51} s^{3} + 7.48699036699101 \\cdot 10^{54} s^{2} + 5.1465987346903 \\cdot 10^{57} s + 1.65249706814803 \\cdot 10^{60}}\\)\n\n\nprint(‘\\({:s}\\)’.format(latex(u1[v2])))\ncancel(u1[v2],s)\nu1[v2].factor()\nprint(‘\\({:s}\\)’.format(latex(u1[v2].factor())))",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-analysis",
    "href": "Elliptic-function-LPF.html#ac-analysis",
    "title": "26  Elliptic Function LPF",
    "section": "26.5 AC analysis",
    "text": "26.5 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.000104931794333683 + 5.0 \\cdot 10^{-8} i\\right) - 5.0 \\cdot 10^{-8} i v_{3} - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(0.0001 + 1.8 \\cdot 10^{-7} i\\right) - 0.0001 v_{7}\\\\- 5.0 \\cdot 10^{-8} i v_{1} + v_{3} \\cdot \\left(0.000210526315789474 + 1.0 \\cdot 10^{-7} i\\right) - 5.0 \\cdot 10^{-8} i v_{5}\\\\- 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(0.000209863588667366 + 1.0 \\cdot 10^{-7} i\\right) - 0.000104931794333683 v_{5} - 1.0 \\cdot 10^{-7} i v_{7}\\\\- 5.0 \\cdot 10^{-8} i v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(0.000118592996519475 + 2.7 \\cdot 10^{-7} i\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 0.0001 v_{2} - 1.0 \\cdot 10^{-7} i v_{4} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(0.00012262443438914 + 1.0 \\cdot 10^{-7} i\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{O1} : -7.93435920129207 \\cdot 10^{-5} - 1.04780349935858 \\cdot 10^{-6} i, \\  I_{V1} : -1.08386750560814 \\cdot 10^{-5} + 8.52355840173172 \\cdot 10^{-8} i, \\  v_{1} : 1.0, \\  v_{2} : 4.30026497245804 - 0.0113503038879469 i, \\  v_{3} : 3.60498736870606 \\cdot 10^{-7} + 0.000425934844116181 i, \\  v_{4} : 0.896707629673498 + 0.00128879494390739 i, \\  v_{5} : 0.793410590960342 - 0.000666019730170192 i, \\  v_{6} : 0.793410590960342 - 0.000666019730170192 i, \\  v_{7} : 4.30028540300504 - 0.00360982693752243 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.000000 phase:     0.00000 deg\nv2   : mag:   4.300280 phase:    -0.15123 deg\nv3   : mag:   0.000426 phase:    89.95151 deg\nv4   : mag:   0.896709 phase:     0.08235 deg\nv5   : mag:   0.793411 phase:    -0.04810 deg\nv6   : mag:   0.793411 phase:    -0.04810 deg\nv7   : mag:   4.300287 phase:    -0.04810 deg\nI_V1 : mag:   0.000011 phase:   179.54943 deg\nI_O1 : mag:   0.000079 phase:  -179.24340 deg\n\n\nThe following results were obtained from LTSpice.\n       --- AC Analysis ---\n\n\nThe LTSpice results are the same.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-sweep",
    "href": "Elliptic-function-LPF.html#ac-sweep",
    "title": "26  Elliptic Function LPF",
    "section": "26.6 AC Sweep",
    "text": "26.6 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. Thr frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-sweep-1",
    "href": "Elliptic-function-LPF.html#ac-sweep-1",
    "title": "26  Elliptic Function LPF",
    "section": "26.7 AC Sweep",
    "text": "26.7 AC Sweep\nLooking at node 2 voltage.\n\nv4, I_F1, I_Ea1, v1, v2, v5, I_L1, v3, I_V1, I_V2 = symbols(' v4 I_F1 I_Ea1 v1 v2 v5 I_L1 v3 I_V1 I_V2')\n\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{7.66402714932125 \\cdot 10^{50} s^{3} + 1.60840024120068 \\cdot 10^{54} s^{2} + 3.37544646631832 \\cdot 10^{57} s + 7.10620308698594 \\cdot 10^{60}}{2.49434389140272 \\cdot 10^{48} s^{4} + 7.82471226796141 \\cdot 10^{51} s^{3} + 7.48699036699101 \\cdot 10^{54} s^{2} + 5.1465987346903 \\cdot 10^{57} s + 1.65249706814803 \\cdot 10^{60}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit 1\n\n\nx = np.logspace(1, 3, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "References",
    "section": "",
    "text": "Budak, A. 1974. Passive and Active Network Analysis and\nSynthesis. Houghton Mifflin.\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The\nCircuits and Filters Handbook, 3rd Edition. CRC Press.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of\nAnalog Circuits Through Symbolic Analysis.\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd\nEdition. McGraw-Hill.\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal\nApproach to Network Analysis.” IEEE Transactions on Circuits\nand Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric\nCircuit Analysis. Prentice-Hall, Inc.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit\nEquations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific\nComputing. Numerical Recipes in c Book Set. Cambridge University\nPress.\n\n\nTow, J. 1968. “Active RC Filters—a State-Space\nRealization.” Proceedings of the IEEE 56 (6): 1137–39.\nhttps://doi.org/10.1109/PROC.1968.6502.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design\nHandbook, Third Edition. McGraw-Hill Education.\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley &\nSons.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "SymMNA_py.html",
    "href": "SymMNA_py.html",
    "title": "Appendix A — SymMNA.py",
    "section": "",
    "text": "the listing needs an update before finalizing the book\n\n\"\"\"Symbolic modified nodal analysis\nLast update: 15 Jan 2024\n\nDescription:\nThe modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear \ncircuit analysis.\n\nMy code started initially by following Erik Cheever's Analysis of Resistive Circuits [1], which used Matlab code \nto generate modified nodal equations. I somewhat followed his MATLAB file for resistors, capacitors, opamps and independent sources. \nThe naming of the matrices follows his convention. The preprocessor and parser code was converted from my old C code. \nThe use of pandas for a data frame is new and sympy is used to do the math and the use of element \nstamps is from [2].\n\nInductors are being addressed in the D matrix. Erik's code puts inductors into the G matrix as 1/s/L.  \nMy code puts the inductor contribution into the D matrix and the unknown current from the inductor into \nthe B and C matrices.  Coupled inductors also affect the D matrix, so it makes sense to allow the inductors \nto be in the D matrix rather than the G matrix.\n\nReferences:\n1. [Analysis of  Resistive Circuits](http://www.swarthmore.edu/NatSci/echeeve1/Ref/mna/MNA1.html), retrieved October 6, 2017  \n2. [ECE 570 Session 3](http://www2.engr.arizona.edu/~ece570/session3.pdf), Computer Aided Engineering for Integrated Circuits, retreived November 13, 2023  \n\nUsage:  See SMNA_func_test.py\n\"\"\"\n\nfrom sympy import *\nimport numpy as np\nimport pandas as pd\n\ndef smna(net_list):\n    \"\"\"Symbolic modified nodal analysis\n    Parameters\n    ----------\n    net_list: str\n        The circuit net list, needs a \\n at the end of each line\n    Returns\n    -------\n    df: pandas dataframe\n            circuit net list info loaded into a dataframe\n    df2: pandas dataframe\n            branches with unknown currents\n    A: sympy matrix\n            The A matrix is (m+n) by (m+n) and is the combination of 4 smaller matrices, G, B, C, and D.\n            The G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections\n            between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, \n            where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage \n            sources, current controlling elements, etc. In python row and columns are: G[row, column]\n            The B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes\n            and m is the number of current unknowns, i_unk. There is one column for each unknown current.\n            The code loop through all the branches and process elements that have stamps for the B matrix: \n            The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).\n            The code is similar to the B matrix code, except the indices are swapped. The code loops through \n            all the branches and process elements that have stamps for the C matrix: \n            The D matrix is an m by m matrix, where m is the number of unknown currents. \n    X: list\n            The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages \n            and the currents through the independent voltage sources). The top n elements are the n node \n            voltages. The bottom m elements represent the currents through the m independent voltage \n            sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix \n            is m by 1 and holds the unknown currents through the voltage sources\n    Z: list\n            The Z matrix holds the independent voltage and current sources and is the combination\n            of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, \n            and m is the number of independent voltage sources. The I matrix is n by 1 and contains \n            the sum of the currents through the passive elements into the corresponding node (either \n            zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the \n            values of the independent voltage sources.\n    \"\"\"\n\n    # initialize variables\n    num_rlc = 0 # number of passive elements\n    num_ind = 0 # number of inductors\n    num_v = 0    # number of independent voltage sources\n    num_i = 0    # number of independent current sources\n    i_unk = 0  # number of current unknowns\n    num_opamps = 0   # number of op amps\n    num_vcvs = 0     # number of controlled sources of various types\n    num_vccs = 0\n    num_cccs = 0\n    num_ccvs = 0\n    num_cpld_ind = 0 # number of coupled inductors\n\n    content = net_list.splitlines()\n\n    content = [x.strip() for x in content]  #remove leading and trailing white space\n    # remove empty lines\n    while '' in content:\n        content.pop(content.index(''))\n\n    # remove comment lines, these start with a asterisk *\n    content = [n for n in content if not n.startswith('*')]\n    # remove other comment lines, these start with a semicolon ;\n    content = [n for n in content if not n.startswith(';')]\n    # remove spice directives, these start with a period, .\n    content = [n for n in content if not n.startswith('.')]\n    # converts 1st letter to upper case\n    #content = [x.upper() for x in content] &lt;- this converts all to upper case\n    content = [x.capitalize() for x in content]\n    # removes extra spaces between entries\n    content = [' '.join(x.split()) for x in content]\n\n    line_cnt = len(content) # number of lines in the netlist\n    branch_cnt = 0  # number of branches in the netlist\n    # check number of entries on each line, count each element type\n    for i in range(line_cnt):\n        x = content[i][0]\n        tk_cnt = len(content[i].split()) # split the line into a list of words\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_rlc += 1\n            branch_cnt += 1\n            if x == 'L':\n                num_ind += 1\n        elif x == 'V':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_v += 1\n            branch_cnt += 1\n        elif x == 'I':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_i += 1\n            branch_cnt += 1\n        elif x == 'O':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_opamps += 1\n        elif x == 'E':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vcvs += 1\n            branch_cnt += 1\n        elif x == 'G':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vccs += 1\n            branch_cnt += 1\n        elif x == 'F':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_cccs += 1\n            branch_cnt += 1\n        elif x == 'H':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_ccvs += 1\n            branch_cnt += 1\n        elif x == 'K':\n            if (tk_cnt != 4):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_cpld_ind += 1\n        else:\n            raise Exception(\"unknown element type in branch {:d}: {:s}\".format(i,content[i]))\n\n\n    ''' The parser performs the following operations.\n     1. puts branch elements into data frame  \n     2. counts number of nodes  \n\n     data frame labels:\n     - element: type of element  \n     - p node: positive node  \n     - n node: negative node, for a current source, the arrow point terminal, LTspice \n     puts the inductor phasing dot on this terminal  \n     - cp node: controlling positive node of branch  \n     - cn node: controlling negative node of branch  \n     - Vout: opamp output node  \n     - value: value of element or voltage  \n     - Vname: voltage source through which the controlling current flows. Need to \n     add a zero volt voltage source to the controlling branch.  \n     - Lname1: name of coupled inductor 1  \n     - Lname2: name of coupled inductor 2'''  \n\n    # build the pandas data frame\n    df = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n        'Vout','value','Vname','Lname1','Lname2'])\n\n    # this data frame is for branches with unknown currents\n    df2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n    # ### Functions to load branch elements into data frame and check for gaps in node numbering\n\n    # loads voltage or current sources into branch structure\n    def indep_source(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads passive elements into branch structure\n    def rlc_element(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads multi-terminal elements into branch structure\n    # O - Op Amps\n    def opamp_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vout'] = int(tk[3])\n\n    # G - VCCS\n    def vccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # E - VCVS\n    # in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\n    def vcvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # F - CCCS\n    def cccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # H - CCVS\n    def ccvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # K - Coupled inductors\n    def cpld_ind_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n        df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # function to scan df and get largest node number\n    def count_nodes():\n        # need to check that nodes are consecutive\n        # fill array with node numbers\n        p = np.zeros(line_cnt+1)\n        for i in range(line_cnt):\n            # need to skip coupled inductor 'K' statements\n            if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n                p[df['p node'][i]] = df['p node'][i]\n                p[df['n node'][i]] = df['n node'][i]\n\n        # find the largest node number\n        if df['n node'].max() &gt; df['p node'].max():\n            largest = df['n node'].max()\n        else:\n            largest =  df['p node'].max()\n\n        largest = int(largest)\n        # check for unfilled elements, skip node 0\n        for i in range(1,largest):\n            if p[i] == 0:\n                raise Exception('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n        return largest\n\n    # load branch info into data frame\n    for i in range(line_cnt):\n        x = content[i][0]\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            rlc_element(i)\n        elif (x == 'V') or (x == 'I'):\n            indep_source(i)\n        elif x == 'O':\n            opamp_sub_network(i)\n        elif x == 'E':\n            vcvs_sub_network(i)\n        elif x == 'G':\n            vccs_sub_network(i)\n        elif x == 'F':\n            cccs_sub_network(i)\n        elif x == 'H':\n            ccvs_sub_network(i)\n        elif x == 'K':\n            cpld_ind_sub_network(i)\n        else:\n            raise Exception(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n    '''29 Nov 2023:  When the D matrix is built, independent voltage sources are processed\n    in the data frame order when building the D matrix. If the voltage source followed element\n    L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different\n    row in relation to its position in the Ev matrix. This would cause the node attached to \n    the terminal of the voltage source to be zero volts.  \n    Solution - The following block of code was added to move voltage source types to the \n    beginning of the net list dataframe before any calculations are performed.''' \n\n    # Check for position of voltages sources in the dataframe.\n    source_index = [] # keep track of voltage source row number\n    other_index = [] # make a list of all other types\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V'):\n            source_index.append(i)\n        else:\n            other_index.append(i)\n\n    df = df.reindex(source_index+other_index,copy=True) # re-order the data frame\n    df.reset_index(drop=True, inplace=True) # renumber the index\n\n    # count number of nodes\n    num_nodes = count_nodes()\n\n    # Build df2: consists of branches with current unknowns, used for C & D matrices\n    # walk through data frame and find these parameters\n    count = 0\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n            df2.loc[count,'element'] = df.loc[i,'element']\n            df2.loc[count,'p node'] = df.loc[i,'p node']\n            df2.loc[count,'n node'] = df.loc[i,'n node']\n            count += 1\n\n    # print the netlist report\n    report = 'Net list report\\n'\n    report=report+('number of lines in netlist: {:d}\\n'.format(line_cnt))\n    report=report+'number of branches: {:d}\\n'.format(branch_cnt)\n    report=report+'number of nodes: {:d}\\n'.format(num_nodes)\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are current unknows\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\n    report=report+'number of unknown currents: {:d}\\n'.format(i_unk)\n    report=report+'number of RLC (passive components): {:d}\\n'.format(num_rlc)\n    report=report+'number of inductors: {:d}\\n'.format(num_ind)\n    report=report+'number of independent voltage sources: {:d}\\n'.format(num_v)\n    report=report+'number of independent current sources: {:d}\\n'.format(num_i)\n    report=report+'number of op amps: {:d}\\n'.format(num_opamps)\n    report=report+'number of E - VCVS: {:d}\\n'.format(num_vcvs)\n    report=report+'number of G - VCCS: {:d}\\n'.format(num_vccs)\n    report=report+'number of F - CCCS: {:d}\\n'.format(num_cccs)\n    report=report+'number of H - CCVS: {:d}\\n'.format(num_ccvs)\n    report=report+'number of K - Coupled inductors: {:d}\\n'.format(num_cpld_ind)\n\n    # initialize some symbolic matrix with zeros\n    # A is formed by [[G, C] [B, D]]\n    # Z = [I,E]\n    # X = [V, J]\n    V = zeros(num_nodes,1)\n    I = zeros(num_nodes,1)\n    G = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\n    s = Symbol('s')  # the Laplace variable\n\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are element types that have unknown currents\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    # if i_unk == 0, just generate empty arrays\n    B = zeros(num_nodes,i_unk)\n    C = zeros(i_unk,num_nodes)\n    D = zeros(i_unk,i_unk)\n    Ev = zeros(i_unk,1)\n    J = zeros(i_unk,1)\n\n    ''' The G matrix is n by n, where n is the number of nodes. \n    The matrix is formed by the interconnections between the resistors, \n    capacitors and VCCS type elements.  In the original paper G is called Yr, \n    where Yr is a reduced form of the nodal matrix excluding the contributions \n    due to voltage sources, current controlling elements, etc.  In python row \n    and columns are: G[row, column]'''\n    for i in range(len(df)):  # process each row in the data frame\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node']\n        cn2 = df.loc[i,'cn node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'R':\n            g = 1/sympify(df.loc[i,'element'])\n        if x == 'C':\n            g = s*sympify(df.loc[i,'element'])\n        if x == 'G':   #vccs type element\n            g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n        if (x == 'R') or (x == 'C'):\n            # If neither side of the element is connected to ground\n            # then subtract it from the appropriate location in the matrix.\n            if (n1 != 0) and (n2 != 0):\n                G[n1-1,n2-1] += -g\n                G[n2-1,n1-1] += -g\n\n            # If node 1 is connected to ground, add element to diagonal of matrix\n            if n1 != 0:\n                G[n1-1,n1-1] += g\n\n            # same for for node 2\n            if n2 != 0:\n                G[n2-1,n2-1] += g\n\n        if x == 'G':    #vccs type element\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0 and cn1 != 0:\n                G[n1-1,cn1-1] += g\n\n            if n2 != 0 and cn2 != 0:\n                G[n2-1,cn2-1] += g\n\n            if n1 != 0 and cn2 != 0:\n                G[n1-1,cn2-1] -= g\n\n            if n2 != 0 and cn1 != 0:\n                G[n2-1,cn1-1] -= g\n\n    '''The B matrix is an n by m matrix with only 0, 1 and -1 elements, where \n    n = number of nodes and m is the number of current unknowns, i_unk. There is \n    one column for each unknown current. The code loop through all the branches \n    and process elements that have stamps for the B matrix:  \n     - Voltage sources (V)  \n     - Opamps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)    \n\n    The order of the columns is as they appear in the netlist.  CCCS (F) does not get\n    its own column because the controlling current is through a zero volt voltage source,\n    called Vname and is already in the net list.'''\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n            B[n_vout-1,sn] = 1\n            sn += 1   # increment source count\n        if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\n    ''' The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).  \n    The code is similar to the B matrix code, except the indices are swapped.   The code loops through \n    all the branches and process elements that have stamps for the C matrix:  \n     - Voltage sources (V)  \n     - Opamps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)  \n\n     Op Amp elements\n     The op amp element is assumed to be an ideal op amp and use of this component is valid only when \n     used in circuits with a DC path (a short or a resistor) from the output terminal to the negative \n     input terminal of the op amp. No error checking is provided and if the condition is violated, \n     the results likely will be erroneous.   \n\n     References use in the debugging of the opamp stamp:   \n     1. Design of Analog Circuits Through Symbolic Analysis, edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fern├índez   \n     2. Computer Aided Design and Design Automation, edited by Wai-Kai Chen  \n\n     find the the column position in the C and D matrix for controlled sources\n     needs to return the node numbers and branch number of controlling branch'''\n    def find_vname(name):\n        # need to walk through data frame and find these parameters\n        for i in range(len(df2)):\n            # process all the elements creating unknown currents\n            if name == df2.loc[i,'element']:\n                n1 = df2.loc[i,'p node']\n                n2 = df2.loc[i,'n node']\n                return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n        raise Exception('failed to find matching branch element in find_vname')\n\n    # generate the C Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        cn2 = df.loc[i,'cn node']\n        n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n        if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n            # C[sn,n_vout-1] = 1\n            if i_unk &gt; 1:  #is B greater than 1 by n?, O\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   # increment source count\n\n        if x == 'F':  # need to count F (cccs) types\n            sn += 1   #increment source count\n        if x == 'H':  # H: ccvs\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n                # add entry for cp and cn of the controlling voltage\n                if cn1 != 0:\n                    C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n                if cn2 != 0:\n                    C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n                vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n                if vn1 != 0:\n                    C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n                if vn2 != 0:\n                    C[vn2-1] = sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\n    ''' The D matrix is an m by m matrix, where m is the number of unknown currents.  \n    m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n    Stamps that affect the D matrix are: inductor, ccvs and cccs  \n    inductors: minus sign added to keep current flow convention consistent  \n\n    Coupled inductors notes:  \n    Can the K statement be anywhere in the net list, even before Lx and Ly?   \n    12/6/2017 doing some debugging on with coupled inductors  \n    LTspice seems to put the phasing dot on the neg node when it generates the netlist   \n    This code uses M for mutual inductance, LTspice uses k for the coupling coefficient.'''  \n\n    # generate the D Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        #cn2 = df.loc[i,'cn node']\n        #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n        # process elements with input to D matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is D greater than 1 by 1?\n                D[sn,sn] += -s*sympify(df.loc[i,'element'])\n            else:\n                D[sn] += -s*sympify(df.loc[i,'element'])\n            sn += 1   #increment source count\n\n        if x == 'H':  # H: ccvs\n            # if there is a H type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'F':  # F: cccs\n            # if there is a F type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            D[sn,sn] = 1\n            sn += 1   #increment source count\n\n        if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n            # if there is a K type, D is m by m\n            vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n            vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n            # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n            D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n            D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n    ''' The V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.  \n    Maybe make small v's v_1 so as not to confuse v1 with V1.'''\n    # generate the V matrix\n    for i in range(num_nodes):\n        V[i] = sympify('v{:d}'.format(i+1))\n\n    ''' The J matrix is an m by 1 matrix, where m is the number of unknown currents.\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    The J matrix is an m by 1 matrix, with one entry for each i_unk from a source'''\n    for i in range(len(df2)):\n        # process all the unknown currents\n        J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\n    ''' The I matrix is an n by 1 matrix, where n is the number of nodes. The value\n    of each element of I is determined by the sum of current sources into the \n    corresponding node. If there are no current sources connected to the node, the value is zero.'''\n\n    # generate the I matrix, current sources have n2 = arrow end of the element\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'I':\n            g = sympify(df.loc[i,'element'])\n            # sum the current into each node\n            if n1 != 0:\n                I[n1-1] -= g\n            if n2 != 0:\n                I[n2-1] += g\n\n    # The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n    sn = 0   # count source number\n    for i in range(len(df)):\n        # process all the passive elements\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            Ev[sn] = sympify(df.loc[i,'element'])\n            sn += 1\n\n\n    ''' The Z matrix holds the independent voltage and current sources and is the combination of 2\n    smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the\n    number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents\n    through the passive elements into the corresponding node (either zero, or the sum of independent\n    current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.'''\n    Z = I[:] + Ev[:]  # the + operator in python concatenates the lists\n\n\n    ''' The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through\n    the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the\n    currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages.\n    The J matrix is m by 1 and holds the unknown currents through the voltage sources '''\n    X = V[:] + J[:]  # the + operator in python concatenates the lists\n\n    # The A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n    n = num_nodes\n    m = i_unk\n    A = zeros(m+n,m+n)\n    for i in range(n):\n        for j in range(n):\n            A[i,j] = G[i,j]\n\n    if i_unk &gt; 1:\n        for i in range(n):\n            for j in range(m):\n                A[i,n+j] = B[i,j]\n                A[n+j,i] = C[j,i]\n\n        for i in range(m):\n            for j in range(m):\n                A[n+i,n+j] = D[i,j]\n\n    if i_unk == 1:\n        for i in range(n):\n            A[i,n] = B[i]\n            A[n,i] = C[i]\n        A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\n    return report, df, df2, A, X, Z",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>SymMNA.py</span>"
    ]
  },
  {
    "objectID": "Change-log.html",
    "href": "Change-log.html",
    "title": "Appendix B — Change Log",
    "section": "",
    "text": "The following table is a history of the code development.\n\n\n\nTable B.1: Change log\n\n\n\n\n\n\n\n\n\nDate\nEvent\n\n\n\n\n7/1/2015\nVer 1 - coding started, derived from network.c code\n\n\n8/18/2017\nchanged approach, now implementing a modified nodal analysis\n\n\n8/19/2017\nWrote some code to generate symbolic matrices, works ok, so heading down the sympy path. Basic debugging finished, but still need to verify some circuits using Ls and Cs.\n\n\n8/30/2017\nStarted to add code for op amps\n\n\n9/1/2017\nCode added to process op amps\n\n\n9/3/2017\nAdded code to remove spice directives. Fixed orientation of current sources in I matrix. N2 is the arrow end of the current source.\n\n\n9/5/2017\nAfter doing some verification testing with inductors and capacitors, it seems that inductors are not being treated correctly. According to some research, inductor stamp affects the B,C and D arrays. Erik Cheever’s code puts inductors into the G matrix as 1/s/L. LTspice results are different than the python code. Capacitors seem to work OK. Plan is to add controlled sources, then get inductors working.\n\n\n9/6/2017\nopamp_test_circuit_426 is not working. Results not the same as LTspice Chebyshev_LPF_1dB_4pole: cut off frequency not correct, other features look OK still need to debug opamps and inductors Adding: VCCS = G type branch element: G needs to be modified CCVS = H type branch element: B, C and D need to be modified\n\n\n9/10/2017\nresearching formulation of B matrix what about a network with only 1 current source? The B, C and D matrix would be 0 by 0. Think about changing the name of the G matrix to Yr, to keep same as Ho’s IEEE paper.CCVS = H type branch element: B, C and D need to be modifiedCCCS = F type branch element: B, C and D need to be modifiedVCCS = G type branch element: G needs to be modifiedVCVS = E type branch element: B and C need to be modifiedFor CCCS = F type branch elements and CCVS = H type branch elements, need to add a zero volt voltage source to the net list through which the current flows. It is necessary to add to the net list one extra voltage source for every F and H type element.\n\n\n9/12/2017\nstill working on the B matrix\n\n\n9/18/2017\nstill debugging B matrix, looks like we don’t need find_vname() or df2. This is because a zero volt voltage source is add to the netlist in spice. need to add cccs type to the list of i_unk. Filled out some B matrices by hand and got the same answer as the code.\n\n\n9/30/2017\ndebugging B, C & D matricesvcvs is a E type element and sympy didn’t like it, fixed problem in parser by changing the lable E to Ea. Also changed the E matrix name to Ev. Code seems to run, just need to verify it. Need to find a new name for func1.\n\n\n10/1/2017\nCleaning up comments and notes.\n\n\n10/4/2017\nFixed incrementing of sn in D matrix. D matrix needs to count all i_unks. In find_vnam() fixed col_num to return just the row number in df2.\n\n\n10/5/2017\nFixed E type in matrix C. Added cccs to i_unk count. Fixed E type in D. Fixed J matrix. need to look at the equations next, they don’t look correct.\n\n\n10/7/2017\nUpdates to the comments. Verifying equations with hand generated KCL equations. Fixed H type in D.\n\n\n10/9/2017\nStill verifying code. Fixed F type in C. Still need to verify op amps, inductors and capacitors.\n\n\n11/19/2017\nFixing some documentation.\n\n\n11/30/2017\nFixing C matrix for op amps, one test case ran OKChen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the opamp stamp.\n\n\n12/2/2017\nAdded code for coupled inductors, not tested yet.\n\n\n12/6/2017\nTesting code for coupled inductors. Changes made to D matrix code. test_circuit_9 seems to give the correct results.\n\n\n18 Feb 2022\nNoticed a bug when independent voltage source is last line in net list, moving to 1st line in netlist generated what seems like correct equations. Investigation continues. For now, ordering the net list with sources first seems to work. Problem is with generation of the Ev and J matrices. In this version, I corrected some grammer and spelling errors.\n\n\n11/14/2023\nNew version of Sympy does not support non-Expr objects in a Matrix. Code to generate the circuit equations towards the end of the notebook produced an error. This line generated the error: \\(equ[i] = Eq(eq\\_temp,Z[i])\\). See the note here for details. In SymPy 1.8 and earlier versions it was possible to put non-Expr elements in a Matrix and the matrix elements could be any arbitrary Python object. Corrections have been made in this notebook. At the time of dubugging this issue, I’m running sympy.__version__ = ‘1.11.1’\n\n\n29 Nov 2023\nProblem - When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.Solution - added code to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n\n1/9/2024\nCode for building matrix A was not including matrix D if i_unk == 1. The following line of code is new: \\(A[n,n] = D[0]\\) also with a comment. Added verification tests test_14 and test_15 for the case of i_unk == 1 and 0.\n\n\n1/16/2024\ncreated a function to implement smna, replaced warning print statements with raise Exception()\n\n\n\n\n\n\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  }
]