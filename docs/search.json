[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "About This Book\nThis website is my online book - Symbolic Modified Nodal Analysis using Python. Symbolic circuit analysis is a circuit analysis method that derives network equations with the circuit elements represented by symbols and the topology of the circuit described by a netlist. Python is a general purpose programming language with a large standard library and packages.\nOne of the first topics taught to electrical engineering students is basic electrical circuit analysis. This can be thought of as EE 101, and deals with circuit models not physical circuits. The voltage to current relationship for resistors is described by Ohm’s law, \\(v=iR\\). The voltage to current relationships for capacitors and inductors can be described by the following differential equations: \\[v(t) = \\frac{1}{C} \\int_{t_0}^t i \\mathrm d t+v(t_0)\\] \\[v=L \\frac {\\mathrm d i}{\\mathrm d t}\\] Since differential equations are used to model capacitors and inductors, EE 101 is usually taught after courses in calculus and differential equations. If an electrical network has several branches or loops, then there is a family of equations that describe the circuit, and these are a system of differential equations. Most of the problems presented in textbooks are relatively simple since developing the differential equations and solving them in the time domain with pencil and paper is laborious. After subjecting their students to the rigors of time domain analysis, professors introduce phasors and frequency domain analysis using Laplace transformed circuit elements. Here the problem turns into an algebra problem and students wonder why so much classroom effort was placed on obtaining solutions by solving differential equations.\nThe circuit analysis technique presented in this book analyzes electrical circuits in the frequency domain. The inductors and capacitors in the circuit are replaced by their transformed values. Inductors are replace by their steady state Laplace value, \\(sL\\), where L is the value of the inductor with units of henrys (named after Joseph Henery) and \\(s\\) is the Laplace variable equal to \\(j \\omega\\) where \\(j\\) is the imaginary number and \\(\\omega\\) is the radian frequency. Capacitors in the circuit are replace by their steady state Laplace value, \\(\\frac {1}{sC}\\) where C is the value of the capacitor with units in farads (named after Micheal Faraday).\nThere are 15 code validation test circuits followed by example problems. The chapters for these circuits can be referenced as examples on how to use my Python code to analyze electrical circuits.\nThis book was written in R MarkDown using plain text files and JupyterLab notebooks. The source files were rendered into a book using Quarto, an open-source scientific and technical publishing system. Quarto does a good job of formatting the documents into web pages for a book. Some of the lines of code and mathematical expressions are wider than the page and Quarto inserts a slider bar in the code or equation windows. Chapter and paragraph numbering are automatically generated by Quarto as well as the numbering of figures and tables.\nI don’t have a proof reader or professional editor for this project. Instead, I’m relying on the LibreOffice spell checker and the grammar and spell checker of Google Docs to help me with this part of the writing process.\nSource code for this book is available here and related material is located here. Python code contained in this book can run in a browser-based environment, see Appendix C — Google Colab. Additionally, online schematics editors are available, see Appendix E — EasyEDA. By using web based tools, the reader is not required to install any programs.",
    "crumbs": [
      "About This Book"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "Python Module Version\nThe following versions were used in this book.\n\n\n\nTable 1: Library versions\n\n\n\n\n\n\n\n\n\nPackage\nversion\n\n\n\n\nPython\n3.10.9\n\n\nJupyterLab\n3.5.3\n\n\nIPython\n8.10.0\n\n\nNumPy\n1.23.5\n\n\nSymPy\n1.11.1\n\n\nSciPy\n1.10.0\n\n\nPandas\n1.5.3\n\n\nTabulate\n0.8.10\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8\n\n\nQuarto\n1.4.553\n\n\n\n\n\n\nThe Jupyter notebooks are available from my GitHub repository. The results presented in this book should be reproducible if the libraries and modules have the same version numbers.\n\n\nUpdate History\nThis book will be updated occasionally to fix typos, spelling and grammar mistakes. Additionally, new content will be added as new chapters in the Example Problems section.\n\n\n\ndate\ndescription\n\n\n\n\n29 Dec 2023\ntest version\n\n\n26 Jan 2024\nvarious updates to draft\n\n\n27 Apr 2024\nadding/removing example problems\n\n\n1 May 2024\nrendering book with Quarto 1.4\n\n\nPublished dateshow above\nsee Table B.2\n\n\n\n\n\n\nAbout the Author\nThis book is published under the pseudonym Tiburonboy.\nWhen I was about ten years old, my parents gave me an electronics kit for Christmas. It was a collection of resistors, capacitors, transistors and other assorted electronic components. The kit included about ten plans to build various circuits like an AM radio and audio oscillator. Ever since then I have been interested in radios and electronics.\nAfter graduating from high school, my Dad asked me what I was going to study in college and I told him mathematics. He suggested that I study electrical engineering since engineers were more in demand than mathematicians and electrical engineering was very math oriented. This turned out to be the best advice he gave me, because for the next 37 years my interest in electronics evolved into a very rewarding career as an electrical engineer.\nMy first job after graduating from college was working as a civilian for the US Navy. For more than 40 years I have been designing electronic circuits for instrumentation and telemetry systems. I have five Patents and have published seven technical papers.\n\n\nFeedback\nIf you have complaints, find any errors, or have suggestions, send me an email at:\njuan1543cabrillo@sudomail.com\n\n\nBibTeX\n@online{Tiburonboy2024, \n    author = {Tiburonboy}, \n    title = {Symbolic Modified Nodal Analysis using Python},\n    year = {2024},\n    url = {https://tiburonboy.github.io/Symbolic-Modified-Nodal-Analysis-using-Python/},\n    urldate = {2025-08-13}\n}\n\n\n\nLicense\nThis work (includes python code, documentation, test circuits, etc.) is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n\nShare — Copy and redistribute the material in any medium or format.\n\nAdapt — Remix, transform, and build upon the material for any purpose, even commercially.\n\nAttribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\n\nShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.",
    "crumbs": [
      "About This Book"
    ]
  },
  {
    "objectID": "Preface.html",
    "href": "Preface.html",
    "title": "Preface",
    "section": "",
    "text": "Survey of other symbolic circuit analysis code\nThe Python code presented in this notebook is somewhat unique since Python is open source, free and runs on a variety of platforms, the code presented in this IPython notebook is portable. As described in the About this book, this code is made available under a public domain license and archived in a github repository.\nThere are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, TINA and Maple.\nSLiCAP is a symbolic linear analysis tool. SLiCAP is now a Python program, but originally it was written in MATLAB.\nTINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some symbolic analysis capability.\nMaple is a mathematical package and there is an application note available describing its use in symbolic circuit analysis. The application note presents a method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.\nSymbolic Circuit Analysis is a web page devoted to symbolic circuit analysis.\nSAPWIN is a windows program package for symbolic and numerical simulation of analog circuits.\nLcapy is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics. Hayes (2022) provides an overview of Lcapy as well as a survey of symbolic circuit analysis packages.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Preface.html#chapter-contents",
    "href": "Preface.html#chapter-contents",
    "title": "Preface",
    "section": "Chapter contents",
    "text": "Chapter contents\n\nThe first four chapters describe my implementation of symbolic circuit analysis with Python. The next part of the book consists of 15 circuits that are used to validate the Python code. These are Jupyter notebooks that have been rendered into chapters. The last part of the book contains circuit analysis example problems; followed by references, code listing and a change log. Section links are provided below.\n\n1  Introduction introduces the topic of MNA and describes how Python can easily solve mathematical expressions that would be very hard and laborious to do with pencil and paper.\n\nJupyterlab, variable names, large exponents\nPractical network size for symbolic solutions\nLinear and nonlinear circuits\nState variables\nPros and cons of MNA\n\n2  Theory describes the theory behind MNA.\n3  SMNA Example walks through a circuit analysis problem from netlist generation to AC analysis and generation of a frequency response plot of the circuit.\n4  SMNA function provides a description of the Python function that implements the symbolic MNA procedure.\n\nValidation tests: There are 15 circuits that were used to validate the Python code. These circuits range from simple circuits that you would find in textbooks, to complex circuits that would be very difficult to analyze if not for computers. There are also a couple of test circuits designed to generate sub-matrices of all zeros during the formulation of the network equations.\nExample problems: The last part of the book is a collection of interesting circuits (at least to me) that showcase the power and ease with which the Python code can solve circuit analysis problems.\nReferences: This section provides information about works cited in this book.\nAppendix A — SymMNA.py is the Python source listing of the MNA function called in the verification tests and example problems sections.\nAppendix B — Change Log is a list of the changes to the MNA code and this book.\nAppendix C — Google Colab provides instructions about running the code contained in this book in Google’s Colab. All that is needed is a gmail account.\nAppendix D — SMNA mobile is a JupyterLab notebook that can be used as a template for circuit analysis using Colab on a mobile device.\nAppendix E — EasyEDA provides a link to an web based schematic editor program than can be used to generate schematics and a netlist from a schematic.\n\n\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nHayes, M. 2022. “Lcapy: Symbolic Linear Circuit Analysis with Python.” https://doi.org/10.7717/peerj-cs.875.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific Computing. Numerical Recipes in c Book Set. Cambridge University Press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 JupyterLab\nAll the validation and example problem circuits are presented in JupyterLab notebooks and rendered into chapters by Quarto.\nVariable names\nI’ve tried to be consistent with the use of variable names throughout the Jupyter notebooks. Resistors, capacitors and inductors use R, L and C as reference designators. The names chosen for the other variables are listed in Table 1.1\nExpressions generated by SymPy that have imaginary quantities will use \\(i\\) for the imaginary number. Typically, electrical engineers will use \\(j\\) for the imaginary number since \\(i\\) is the variable used for electrical current. Depending on who generates the equation, either \\(i\\) or \\(j\\) might be used and the reader should short these out based on context. Usually, the variables used for current have a number, e.g. \\(i_1\\) or \\(i_2\\) and a lone \\(i\\) would be the imaginary number.\nLarge exponents\nThe values of the exponents can be very large in the numerical solution to the network equations when using real component values. Often you will see in engineering text books that the author uses normalized component values, where the values have been frequency and impedance scaled to a frequency of \\(\\omega = 1\\) and one of the resistors or other components normalized to a value of one. This keeps the numerical values obtained in the solution to the network equations from getting very large or small.\nAlmost all platforms map Python floats to the IEEE754 double precision - 64 total bits. Using the sys package, the float information is reported as follows:\nmax=1.7976931348623157e+308\n max_exp=1024\n max_10_exp=308\n min=2.2250738585072014e-308\n min_exp=-1021\n min_10_exp=-307\n dig=15\n mant_dig=53\n epsilon=2.220446049250313e-16\n radix=2\n rounds=1\nThe maximum exponent that Python can use is 308. In this book, I’m going to let Python do the math and not worry about the size of the exponents. I suppose that large exponents don’t become a problem as long as they remain under two digits.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#jupyterlab",
    "href": "Introduction.html#jupyterlab",
    "title": "1  Introduction",
    "section": "",
    "text": "Table 1.1: Variable names\n\n\n\n\n\n\n\n\n\nVariable name\ndefinition\n\n\n\n\nNE_sym\nNetwork equations, symbolic\n\n\nNE\nNetwork equations with component values\n\n\nNE_dc\nNetwork equations with \\(s=0\\)\n\n\nNE_w1\nNetwork equations with \\(s=j \\omega\\) and \\(\\omega\\) equal to a numeric value\n\n\nU_sym\nThe solution to the symbolic network equations\n\n\nU\nThe solution to network equations with component values\n\n\nU_ac\nThe solution to network equations at some frequency\n\n\nH_sym\nsystem transfer function, symbolic\n\n\nH\nSystem transfer function with component values\n\n\n\\(V_1, V_2,\\) …\nCapital letter V for independent voltage sources\n\n\n\\(v_1, v_2,\\) …\nSmall letter v for the node voltages\n\n\n\\(I_1, I_2,\\) …\nCapital letter I for independent current sources\n\n\n\\(R_1, R_2,\\) …\nCapital letter R for resistors\n\n\n\\(L_1, L_2,\\) …\nCapital letter L for inductors\n\n\n\\(C_1, C_2,\\) …\nCapital letter C for capacitors\n\n\n\\(E_1, E_2,\\) …\nVoltage controlled voltage source (VCVS)\n\n\n\\(F_1, F_2,\\) …\nCurrent controlled current source (CCCS)\n\n\n\\(G_1, G_2,\\) …\nVoltage controlled current source (VCCS)\n\n\n\\(H_1, H_2,\\) …\nCurrent controlled voltage source (CCVS)\n\n\n\\(K_1, K_2,\\) …\nInductor coupling coefficients\n\n\n\\(M_1, M_2,\\) …\nMutual inductance\n\n\n\\(O_1, O_2,\\) …\nOp Amp components\n\n\nA\nConnectivity matrix\n\n\nX\nUnknown voltages and currents vector\n\n\nZ\nKnown voltages and currents vector",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#practical-network-size-for-symbolic-solutions",
    "href": "Introduction.html#practical-network-size-for-symbolic-solutions",
    "title": "1  Introduction",
    "section": "1.2 Practical network size for symbolic solutions",
    "text": "1.2 Practical network size for symbolic solutions\nTest circuit number 4, Chapter 8, has 26 branches, 13 nodes, 18 resistors, 4 independent sources and 4 dependent sources. A symbolic solution for this problem was taking too long on my i3-8130U 2.20GHz computer, so I interrupted the kernel, and proceeded with a numerical solution, which can be solved quite quickly. The complexity of a circuit can be reduced by letting some components have the same value, for example \\(R_1 = R_2 = R_3 = R\\), which would reduce the number of symbols that are being manipulated.\nAnother circuit, shown below, a 100 Hz low pass elliptic function filter, is an example of a circuit where the size of the symbolic expressions became too large and the number of terms too great to allow any reasonable interpenetration of the circuit’s operation. The Python kernel needed to be interrupted during the symbolic solution when running on my laptop, however, see Appendix C for instructions about running a Jupyter notebook in Google Colab where a symbolic solution was obtained in about five seconds. After actual component values are substituted into the network equations a numerical solution was easily obtained by SymPy, see Chapter 26 for this circuit’s notebook.\n\n\n\nElliptic function low pass filter\n\n\nThe net list for this circuit is:\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7\nV1 1 0 1\nR5 6 0 10e3\nR6 7 6 44.2e3\nThe following circuit equations were generated by the MNA code in less than one second:\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\n\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\n\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\n\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\n\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\n\\(- C_{3} s v_{4} + I_{O} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{5} + v_{6} = 0\\)\nAfter about two hours running on an i3 machine a symbolic solution was obtained, but it’s too long to display and doesn’t offer too much insight into the function of the circuit.\nAfter substituting numerical values for the components, the following solution for the voltage at node 2 was obtained in less than one second.\n\\(\\frac{4.30028181226968 \\cdot \\left(1.0784981875 \\cdot 10^{-10} s^{3} + 2.263375 \\cdot 10^{-7} s^{2} + 0.000474999999999999 s + 1.0\\right)}{1.50943922351291 \\cdot 10^{-12} s^{4} + 4.7350839034956 \\cdot 10^{-9} s^{3} + 4.53071325287237 \\cdot 10^{-6} s^{2} + 0.00311443743767615 s + 1.0}\\)\nSee Chapter 25 for a reduced complexity version of the schematic above, for which a symbolic solution was obtained in less than one second.\nPython together with SymPy has enabled the ability to explore circuit analysis problems without having to resort to pages and pages of hand calculations. The results can then be displayed with good looking graphics and LaTex rendered equations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#linear-and-nonlinear-circuits",
    "href": "Introduction.html#linear-and-nonlinear-circuits",
    "title": "1  Introduction",
    "section": "1.3 Linear and nonlinear circuits",
    "text": "1.3 Linear and nonlinear circuits\nThe Python code in the book supports linear circuit analysis. The element types - resistors, capacitors, inductors, independent and dependent sources are all linear, therefore the circuits that are modeled using these element types are linear circuits. A linear circuit is a circuit where the superposition principle is valid.\nNon-linear circuit elements, such as diodes and transistors, are not supported. It might be possible to modify the Python code to support non-linear circuit elements and generate valid network equations, but finding solutions to nonlinear network equations is difficult and outside the scope of this book.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#state-variables",
    "href": "Introduction.html#state-variables",
    "title": "1  Introduction",
    "section": "1.4 State variables",
    "text": "1.4 State variables\nA topic that is sometimes included in engineering text books on circuit analysis is state variable analysis. State variable analysis is a method of describing the electrical network in terms of a set of first order differential equations, see Hayt and Kemmerly (1978), chapter 17 and Haykin (1970), chapter 2. The normal form of the state equations and the analysis approach relies on a network topology where energy storage elements, typically the capacitors and inductors, are placed in the network tree and equations are written in normal form. Deriving a set of state equations is not is not included in the scope of this book. Typically there is a state equation for each inductor and capacitor, whereas the MNA approach writes network equations based primarily on unknown node voltages.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#pros-and-cons-of-mna",
    "href": "Introduction.html#pros-and-cons-of-mna",
    "title": "1  Introduction",
    "section": "1.5 Pros and cons of MNA",
    "text": "1.5 Pros and cons of MNA\nThe MNA approach is a suitable technique for hand analysis of small circuits as well as for computer analysis of larger circuits using the same algorithm as illustrated in this book. One disadvantage of the MNA technique is that often additional equations are generated, when a smaller number would be sufficient. For students doing homework problems and solving sets of equations by hand, the extra equation or two, generated by the MNA technique makes matrix inversions much harder.\nFor example, the circuit in Figure 1.1, can be described by the following two mesh equations:\n\n\n\\(\\displaystyle L_{1} s \\left(i_{1} - i_{2}\\right) + R_{1} i_{1} + \\frac{i_{1} - i_{2}}{C_{1} s} = V_{1}\\)\n\n\n\n\n\\(\\displaystyle L_{1} s \\left(- i_{1} + i_{2}\\right) + \\frac{i_{2}}{C_{2} s} + \\frac{- i_{1} + i_{2}}{C_{1} s} = 0\\)\n\n\nwhere \\(i_1\\) and \\(i_2\\) are the unknown currents.\nThe MNA procedure generated five equations, but one of them was trivial. Only two equations need to be solved to find the mesh currents, which are:\n\n\n\\(i_{1} = \\frac{C_{1} C_{2} L_{1} V_{1} s^{3} + C_{1} V_{1} s + C_{2} V_{1} s}{C_{1} C_{2} L_{1} R_{1} s^{3} + C_{1} L_{1} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + 1}\\)\\(i_{2} = \\frac{C_{1} C_{2} L_{1} V_{1} s^{3} + C_{2} V_{1} s}{C_{1} C_{2} L_{1} R_{1} s^{3} + C_{1} L_{1} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + 1}\\)\n\n\nModern pocket scientific calculators that engineering students now use can solve sets of linear equations relatively easily. However, some effort is required to enter the equations into the calculator.\nWhen a computer is used to generate the schematic for a circuit and the net list is exported to the Python code, the extra equations that the MNA approach generates is not a practical concern. Using the examples in this book as templates for problem solving makes the work flow very easy, which is the main benefit of using MNA.\n\n\n\n\n\nHaykin, S. 1970. Active Network Theory. Addison Wesley.\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Theory.html",
    "href": "Theory.html",
    "title": "2  Theory",
    "section": "",
    "text": "2.1 Network equations\nThe network equations are a set of independent equations expressed in this code in matrix form. There is an equation for each node based on Kirchhoff’s current law and an equation for each current unknown. The current unknowns are the currents from the voltages sources, Op Amps, voltage controlled voltage sources, current controlled voltage sources, current controlled current sources and inductors.\nEquation 2.1 are the network equations in matrix form.\n\\[A\\cdot X = Z \\tag{2.1}\\]\nMatrix \\(A\\) describes the connectivity of the resistors, capacitors and G type (VCCS) circuit elements. The \\(X\\) vector contains unknown node voltages and unknown currents from the voltage sources and inductors. The \\(Z\\) vector contains the known voltages and currents. The \\(A\\) matrix is formed by four sub matrices, \\(G\\), \\(B\\), \\(C\\) and \\(D\\), which are described below.\n\\[A = \\begin{bmatrix}G B\\\\C D\\end{bmatrix} \\tag{2.2}\\]\nThe matrix \\(G\\) is formed from the coefficients representing the KCL equations for each node. The positive diagonal of \\(G_{k,k}\\) are the conductance terms of the resistor and capacitor elements connected to node k. The off diagonal terms of \\(G_{k,j}\\) are the resistors and capacitor conductances connecting node k to node j. G type elements (VCCS) have input to the G matrix at the connection and controlling node positions.\nThe \\(B\\) matrix describes the connectivity of the unknown branch currents. Independent voltage sources, Op Amps, H, F and E type elements as well as inductors have inputs to the B matrix.\nThe \\(C\\) matrix describes the connectivity of the unknown branch currents and is mainly the transpose of the \\(B\\) matrix, with the exception of the F type elements (CCCS) and includes the E type value.\nThe \\(D\\) matrix also describes connectivity of the unknown currents. The \\(D\\) matrix is composed of zeros unless there are controlled sources and inductors in the network.\nThe \\(X\\) vector is composed of the \\(V\\) and \\(J\\) vectors as shown in Equation 2.3.\n\\[X = \\begin{bmatrix}V\\\\J\\end{bmatrix} \\tag{2.3}\\]\nThe \\(V\\) vector contains the node voltages which are the voltage unknowns to be solved for. The \\(J\\) vector contains the unknown currents from each voltage source.\nThe \\(Z\\) vector is composed of the I and Ev vectors as shown Equation 2.4.\n\\[Z = \\begin{bmatrix}I\\\\Ev\\end{bmatrix} \\tag{2.4}\\]\nThe I vector contains the known currents and the Ev vector contains the known voltages. The name Ev is used because SymPy uses e and E sometimes for the constant 2.71, also called Euler’s number. The use of E or e as a symbol was causing some errors when the code was run.\nPutting all the parts together:\n\\[\\begin{bmatrix}G B\\\\C D\\end{bmatrix} \\cdot \\begin{bmatrix}V\\\\J\\end{bmatrix} = \\begin{bmatrix}I\\\\Ev\\end{bmatrix} \\tag{2.5}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#network-equations",
    "href": "Theory.html#network-equations",
    "title": "2  Theory",
    "section": "",
    "text": "2.1.1 Stamps\nStamps are templates for modifying the \\(B\\), \\(C\\) and \\(D\\) matrices and facilitate the construction of the matrices. The stamps used in this implementation of the MNA allow the circuit connections of the components to be used to directly populate the various matrices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#code-description",
    "href": "Theory.html#code-description",
    "title": "2  Theory",
    "section": "2.2 Code description",
    "text": "2.2 Code description\nThe code is divided in the following sections.\nPreprocessor: The preprocessor reads in the netlist text file and removes comments, extra spaces and blank lines. The first letter of the element type is capitalized to make subsequent parsing of the file easier. The number of lines are counted and the number of entries on each line are checked to make sure the count is consistent with the element type.\nParser: The parser code loads the preprocessed netlist into a data frame. A report is generated which consists of a count of the element types in the netlist.\nMatrix formulation: Each of the matrices and vectors are generated.\nCircuit equation generation: The circuit equations are generated in a loop. SymPy automatically does some simplification according to its default settings. Two for loops perform the matrix multiplication on the equation: \\(A\\cdot X = Z\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#netlist-file-format",
    "href": "Theory.html#netlist-file-format",
    "title": "2  Theory",
    "section": "2.3 Netlist file format",
    "text": "2.3 Netlist file format\nThe input file which describes the circuit is a text file called the netlist. A netlist consists of a statement defining each circuit element and its connection to circuit nodes. A node is any point on a circuit where two or more circuit elements meet. The nodes are numbered from 1 to N in any order and node 0 is the ground node or circuit common. A ground node is required. Choose a ground or reference node, which usually is taken to be at a potential of zero volts. All other node voltages constitute n unknowns. The nodes should be numbered in consecutive order. Each line in the netlist are either comments, SPICE directives or circuit elements.\nSPICE directives are commands to SPICE and the first character on the line is a period. Comment lines start with a * or ;. The default file extension is ‘.net’. The Python code does some preprocessing of the netlist to check the basic formatting of the netlist is correct.\nThe preprocessor performs the following steps:\n\nremove blank lines and comments\n\nconvert first letter of element name to uppercase\n\nremoves extra spaces between entries\n\ncounts number of entries on each line to make sure the count is correct and counts each element type\n\nThe element types that are supported are resistors, capacitors, inductors, independent sources and controlled sources. Each line in the netlist file contains a circuit element.\nThe format for the element description is\nletterXX n1 n2 value\nWhere\nletter signifies the element type, i.e. R, L, C, V, I, O, E, F, G, H or K\nXX is a string of letters or numbers that uniquely identify the element.\nThe element types are described in the following sections.\n\n2.3.1 Resistors, capacitors and inductors\nThe resistors, capacitors and inductors are described by the following line:\nR/L/CXX N1 N2 value\nWhere:\nXX = the name of the component, can be any length\nN1 = the first terminal\nN2 = the second terminal\nValue = component value in ohms, Farads or Henrys.\nFor example, a resistor named R1 connected between nodes 1 and 2 with a value of 3000 ohms.\nR1 2 4 3000\nSPICE supports other parameters, but these are not allowed in this Python implementation.\n\n\n2.3.2 Coupled inductors\nTwo coupled inductors are described by the following line.\nKXX LYY LZZ VALUE\nThe parameters are:\nLYY = the name of the first coupled inductor\nLZZ = the name of the second coupled inductor\nVALUE = the coefficient of coupling, K, where 0 &lt; K\nThe orientation of the inductors is determined by the first node, which is considered to be the dotted node. When LTSpice generates a net list the phasing dot gets associated with the negative node. This does not seem to affect the equations generated by the Python code. LTSpice uses the coupling coefficient, k. The symbolic equations use the mutual inductance, M as shown in Equation 2.6.\n\\[M = k\\sqrt{L_1L_2} \\tag{2.6}\\]\nSee Chapter 3 and Chapter 10 for example circuits that have coupled inductors and the code to calculate \\(M\\) and substitute a numerical value into the symbolic network equations.\n\n\n2.3.3 Independent sources\nIndependent sources are formatted as if they are DC sources, even if the source is intended to be an AC source. The value of the source or its type, AC or DC, doesn’t matter when seeking a symbolic solution. The numeric value of the source can be changed when doing a numerical analysis, by following the procedures illustrated in the test or problem circuits. A voltage source is described by the following line.\nVXX N+ N- VALUE\nThe parameters are:\nN+ = the name of the positive terminal\nN- = the name of the negative terminal\nVALUE = the value of the DC voltage\nA current source is described by the following line.\nIXX N+ N- VALUE\nThe parameters are:\nN+= the name of the positive terminal, current leaves this terminal (pointy end of the arrow)\nN- = the name of the negative terminal\nVALUE = the value of the DC current\n\n\n2.3.4 Controlled sources\nThe voltage-controlled dependent sources are defined using statements of the form\nG/EXX nout+ nout- nc+ nc- gain\nwhere E is a voltage-controlled voltage source, G is a voltage-controlled current source, the output voltage is connected between nodes nout+ and nout-, and the control voltage is measured at node nc+ with respect to node nc-.\nExamples:\nE1 5 1 4 3 10 defines a voltage source that makes node 5 a voltage 10 times (v4 - v3) above the voltage at node 1.\nG1 2 1 5 8 50 defines a current source connected between node 2 (the + node) and node 1 and supplying a current 50 times (v5 - v8).\nThe current-controlled dependent sources are defined by statements of the form\nF/HXX nout+ nout- Vcontrol gain\nwhere F is a current-controlled current source, H is a current-controlled voltage source, and the output current source is connected between nodes nout+ and nout-, with positive current flowing through the source from node nout+ to nout-. The control current flows from the positive node of the source Vcontrol through the source and out the negative node.\nExamples:\nFds 11 9 Vsens 1.25 defines a current source connected from node 11 to node 9 that generates a current 1.25 times the current flowing through the source Vsens.\nH1 30 20 V5 100 defines a voltage source connected from node 30 to node 20 and supplying a voltage 100 times the current through the source V5. It is frequently necessary to add a voltage source with value 0 V to the circuit to sense the control current for these sources.\nThe direction of positive controlling current flow is from the positive node, through the source, to the negative node of VNAM. VALUE is the current gain.\n\n\n2.3.5 Op Amps\nAn Op Amp component is described by the following line.\nOXX N+ N- Vout\nThe output of the Op Amp is a voltage source.\nThe Op Amp element is assumed to be an ideal Op Amp and the voltage at the input terminals are defined by the model to equal each other. The use of this component is valid only when used in a network with a path from the output terminal to the negative input terminal of the Op Amp. No error checking is provided and if the condition is violated, the results will be likely erroneous. Op Amp circuits with Inductors and/or capacitors in the feedback path may not analyze correctly at \\(s = 0\\) or \\(s = \\infty\\). See Chapter 34 and Chapter 35 for additional comments.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "Theory.html#analysis-procedure",
    "href": "Theory.html#analysis-procedure",
    "title": "2  Theory",
    "section": "2.4 Analysis procedure",
    "text": "2.4 Analysis procedure\n\nDraw the circuit to be analyzed in LTSpice or some other schematic capture program. Label the nodes. The Symbolic Modified Network Analysis code will provide warnings for netlist formatting errors and non consecutive node numbering, but will still generate nodal equations which may be erroneous. Users should verify the results.\n\nExport the netlist of the circuit and convert component values to units of Ohms, Farads and Henrys. Use scientific notation, for example, replace component values such as 2k with 2e3 and 2u with 2e-6.\n\nChange Op Amp reference designators, for example U1 to O1 (capitol letter O, not zero).\n\nVoltage sources and current sources need to be set to zero in some cases. See test circuits and problem circuits for examples.\n\nCall the function smna(net_list). Follow the example in Chapter 4.\nSee the test and problem chapters for examples on how to use Python and MNA for symbolic and numerical circuit analysis.\n\n\n\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Theory</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html",
    "href": "SMNA_example.html",
    "title": "3  SMNA Example",
    "section": "",
    "text": "3.1 Introduction\nThis chapter walks through the Python code used to generate and solve the circuit network equations. Figure 3.1 is the schematic for the circuit used in this example. The analysis procedure first requires a circuit net list, which can be generated by hand with a text editor. For small circuits, such as those assigned as homework problems, this is not difficult since the number of nodes and components is small. College textbook problems are usually meant by the authors to be solved by hand with pencil and paper. In this example LTSpice was used to draw the schematic and label the components and nodes. Most schematic capture programs have the ability to export a SPICE net list, which then can be pasted into the procedure described here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#circuit-description",
    "href": "SMNA_example.html#circuit-description",
    "title": "3  SMNA Example",
    "section": "3.2 Circuit description",
    "text": "3.2 Circuit description\nThe circuit in Figure 3.1 is a 2nd order band pass filter with magnetic coupling. The netlist generated by LTSpice is shown below.\nV1 1 0 AC 1\nR1 3 1 1k\nR4 2 0 10k\nC1 3 0 0.01µ\nC2 2 0 0.01µ\nL1 4 0 1µ\nL2 5 0 1µ\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe LTSpice netlist requires some editing. The line in the netlist that defines the independent AC source, V1, needs to be formatted as if it were a DC source. For symbolic analysis we are only concerned with the label for the source at this time. Later, in this example, an AC analysis will be performed and \\(j \\omega\\) will be substituted for the Laplace variable, \\(s\\). Also, the suffixes that SPICE allows in the component values e.g., k and \\(\\mu\\), need to be replaced by their corresponding multiplication factors as shown below.\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe following Python modules are used:\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom tabulate import tabulate\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#symbolic-mna-code",
    "href": "SMNA_example.html#symbolic-mna-code",
    "title": "3  SMNA Example",
    "section": "3.3 Symbolic MNA code",
    "text": "3.3 Symbolic MNA code\nA count of the component types are initialized to zero.\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "href": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "title": "3  SMNA Example",
    "section": "3.4 Read the net list and preprocess it",
    "text": "3.4 Read the net list and preprocess it\nThe circuit netlist is pasted into the code cell below. A new line character is required at the end of each line and the triple quotes in the code cell below preserve the line breaks.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\n'''\n\nThe code cell below performs the following operations:\n\nsplit the net list into a list of lines at the line breaks\nremove blank lines and comments\n\nconvert first letter of element name to uppercase\n\nremoves extra spaces between entries\n\n\ncontent = net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove SPICE directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\n# display the cleaned up netlist\nfor i in content:\n    print(i)\n\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 l1 l2 0.15\n\n\n\n3.4.1 Process each line in the netlist\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#parser",
    "href": "SMNA_example.html#parser",
    "title": "3  SMNA Example",
    "section": "3.5 Parser",
    "text": "3.5 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTSpice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: Op Amp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n3.5.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in SymPy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n3.5.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list data frame before any calculations are performed.\n\n# Check for the position of voltage sources in the data frame.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # reorder the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#print-netlist-report",
    "href": "SMNA_example.html#print-netlist-report",
    "title": "3  SMNA Example",
    "section": "3.6 Print netlist report",
    "text": "3.6 Print netlist report\n\n# print a report\nprint('Netlist report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNetlist report\nnumber of lines in netlist: 10\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 3\nnumber of RLC (passive components): 8\nnumber of inductors: 2\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 1\n\n\n\ndf\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n3\n1\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n2\nR4\n2\n0\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n3\nC1\n3\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n4\nC2\n2\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nL1\n4\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n6\nL2\n5\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n7\nR2\n4\n3\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nR3\n2\n5\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n9\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.15\nNaN\nL1\nL2\n\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nL1\n4\n0\n\n\n2\nL2\n5\n0\n\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#initialize-matrices",
    "href": "SMNA_example.html#initialize-matrices",
    "title": "3  SMNA Example",
    "section": "3.7 Initialize matrices",
    "text": "3.7 Initialize matrices\n\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\nDebugging notes: Is it possible to have i_unk == 0, what about a network with only current sources? This would make B = 0. See test_14 and test_15.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#g-matrix",
    "href": "SMNA_example.html#g-matrix",
    "title": "3  SMNA Example",
    "section": "3.8 G matrix",
    "text": "3.8 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}}\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#b-matrix",
    "href": "SMNA_example.html#b-matrix",
    "title": "3  SMNA Example",
    "section": "3.9 B Matrix",
    "text": "3.9 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The code loop through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOp Amps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the Op Amp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & 0\\\\0 & 1 & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#c-matrix",
    "href": "SMNA_example.html#c-matrix",
    "title": "3  SMNA Example",
    "section": "3.10 C matrix",
    "text": "3.10 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOp Amps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\n3.10.1 Op Amp elements\nThe Op Amp element is assumed to be an ideal Op Amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the Op Amp. No error checking is provided and if the condition is violated, the results likely will be erroneous. Chen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the Op Amp stamp.\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # Op Amp type, input connections of the Op Amp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#d-matrix",
    "href": "SMNA_example.html#d-matrix",
    "title": "3  SMNA Example",
    "section": "3.11 D matrix",
    "text": "3.11 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n\nm = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes: 12/6/2017 doing some debugging on with coupled inductors; LTSpice seems to put the phasing dot on the neg node when it generates the netlist. This Python code uses M for mutual inductance, LTSpice uses k for the coupling coefficient. Inductors in LTSpice have a \\(20m\\Omega\\) series resistance that needs to be set to zero.\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0\\\\0 & - L_{1} s & - M_{1} s\\\\0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#v-matrix",
    "href": "SMNA_example.html#v-matrix",
    "title": "3  SMNA Example",
    "section": "3.12 V matrix",
    "text": "3.12 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#j-matrix",
    "href": "SMNA_example.html#j-matrix",
    "title": "3  SMNA Example",
    "section": "3.13 J matrix",
    "text": "3.13 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{L1}\\\\I_{L2}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#i-matrix",
    "href": "SMNA_example.html#i-matrix",
    "title": "3  SMNA Example",
    "section": "3.14 I matrix",
    "text": "3.14 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ev-matrix",
    "href": "SMNA_example.html#ev-matrix",
    "title": "3  SMNA Example",
    "section": "3.15 Ev matrix",
    "text": "3.15 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#z-matrix",
    "href": "SMNA_example.html#z-matrix",
    "title": "3  SMNA Example",
    "section": "3.16 Z matrix",
    "text": "3.16 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#x-matrix",
    "href": "SMNA_example.html#x-matrix",
    "title": "3  SMNA Example",
    "section": "3.17 X matrix",
    "text": "3.17 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#a-matrix",
    "href": "SMNA_example.html#a-matrix",
    "title": "3  SMNA Example",
    "section": "3.18 A matrix",
    "text": "3.18 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n    A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}} & 0 & 0 & 0\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0 & 0 & 1 & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 1\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & - L_{1} s & - M_{1} s\\\\0 & 0 & 0 & 0 & 1 & 0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#generate-the-circuit-equations",
    "href": "SMNA_example.html#generate-the-circuit-equations",
    "title": "3  SMNA Example",
    "section": "3.19 generate the circuit equations",
    "text": "3.19 generate the circuit equations\n\nNE_sym = Eq(A*Matrix(X),Matrix(Z))\n\nDisplay the network equations.\n\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = v_{2} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}}\\)\\(0 = v_{3} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\)\\(0 = I_{L1} - \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}}\\)\\(0 = I_{L2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{5}}{R_{3}}\\)\\(V_{1} = v_{1}\\)\\(0 = - I_{L1} L_{1} s - I_{L2} M_{1} s + v_{4}\\)\\(0 = - I_{L1} M_{1} s - I_{L2} L_{2} s + v_{5}\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#symbolic-solution",
    "href": "SMNA_example.html#symbolic-solution",
    "title": "3  SMNA Example",
    "section": "3.20 Symbolic solution",
    "text": "3.20 Symbolic solution\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  v_{2}, \\  C_{2}, \\  L_{1}, \\  I_{L1}, \\  I_{V1}, \\  R_{3}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  s, \\  R_{4}, \\  R_{1}, \\  I_{L2}, \\  V_{1}, \\  R_{2}, \\  L_{2}, \\  v_{1}, \\  M_{1}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the solution.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{M_{1} R_{4} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{3} = \\frac{C_{2} L_{1} L_{2} R_{4} V_{1} s^{3} + C_{2} L_{1} R_{3} R_{4} V_{1} s^{2} + C_{2} L_{2} R_{2} R_{4} V_{1} s^{2} - C_{2} M_{1}^{2} R_{4} V_{1} s^{3} + C_{2} R_{2} R_{3} R_{4} V_{1} s + L_{1} L_{2} V_{1} s^{2} + L_{1} R_{3} V_{1} s + L_{1} R_{4} V_{1} s + L_{2} R_{2} V_{1} s - M_{1}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1} + R_{2} R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{4} = \\frac{C_{2} L_{1} L_{2} R_{4} V_{1} s^{3} + C_{2} L_{1} R_{3} R_{4} V_{1} s^{2} - C_{2} M_{1}^{2} R_{4} V_{1} s^{3} + L_{1} L_{2} V_{1} s^{2} + L_{1} R_{3} V_{1} s + L_{1} R_{4} V_{1} s - M_{1}^{2} V_{1} s^{2}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{5} = \\frac{C_{2} M_{1} R_{3} R_{4} V_{1} s^{2} + M_{1} R_{3} V_{1} s + M_{1} R_{4} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} L_{1} L_{2} R_{4} V_{1} s^{4} - C_{1} C_{2} L_{1} R_{3} R_{4} V_{1} s^{3} - C_{1} C_{2} L_{2} R_{2} R_{4} V_{1} s^{3} + C_{1} C_{2} M_{1}^{2} R_{4} V_{1} s^{4} - C_{1} C_{2} R_{2} R_{3} R_{4} V_{1} s^{2} - C_{1} L_{1} L_{2} V_{1} s^{3} - C_{1} L_{1} R_{3} V_{1} s^{2} - C_{1} L_{1} R_{4} V_{1} s^{2} - C_{1} L_{2} R_{2} V_{1} s^{2} + C_{1} M_{1}^{2} V_{1} s^{3} - C_{1} R_{2} R_{3} V_{1} s - C_{1} R_{2} R_{4} V_{1} s - C_{2} L_{2} R_{4} V_{1} s^{2} - C_{2} R_{3} R_{4} V_{1} s - L_{2} V_{1} s - R_{3} V_{1} - R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{L1} = \\frac{C_{2} L_{2} R_{4} V_{1} s^{2} + C_{2} R_{3} R_{4} V_{1} s + L_{2} V_{1} s + R_{3} V_{1} + R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{L2} = \\frac{- C_{2} M_{1} R_{4} V_{1} s^{2} - M_{1} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\n\n\nThe transfer function can be simplified with the help of SymPy and the coefficients of the Laplace term can be collected. The transfer function at node 2 is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).simplify().collect(s)\nH_sym\n\n\\(\\displaystyle \\frac{M_{1} R_{4} s}{R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)}\\)\n\n\nThe numerator and denominator can be extracted from the expression.\n\nnum_sym, denom_sym = fraction(H_sym)\n\nDisplay the numerator:\n\nnum_sym\n\n\\(\\displaystyle M_{1} R_{4} s\\)\n\n\nDisplay the denominator:\n\ndenom_sym\n\n\\(\\displaystyle R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)\\)\n\n\nSolve for the roots of the denominator.\n\n#solve(denom_sym,s)\n\nThe code above was taking a long time, so it was interrupted and commented out.\n\n3.20.1 Built a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nThe mutual inductance between L1 and L2 is calculated from the coupling coeeficient.\n\\(M = k\\sqrt{L_1L_2}\\)\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.000000150\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  K_{1} : 0.15, \\  L_{1} : 1.0 \\cdot 10^{-6}, \\  L_{2} : 1.0 \\cdot 10^{-6}, \\  M_{1} : 1.5 \\cdot 10^{-7}, \\  R_{1} : 1000.0, \\  R_{2} : 0.5, \\  R_{3} : 0.5, \\  R_{4} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#numeric-solution",
    "href": "SMNA_example.html#numeric-solution",
    "title": "3  SMNA Example",
    "section": "3.21 Numeric solution",
    "text": "3.21 Numeric solution\nSubstitute the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\)\\(0 = v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.0001\\right) - 2.0 v_{5}\\)\\(0 = - 0.001 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.001\\right) - 2.0 v_{4}\\)\\(0 = I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\)\\(0 = I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - 1.0 \\cdot 10^{-6} I_{L1} s - 1.5 \\cdot 10^{-7} I_{L2} s + v_{4}\\)\\(0 = - 1.5 \\cdot 10^{-7} I_{L1} s - 1.0 \\cdot 10^{-6} I_{L2} s + v_{5}\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s and displaying the transfer function.\n\nU = solve(NE,X)\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\nThe numerator and denominator can be extracted from the expression.\n\nnum, denom = fraction(H)\n\nDisplay the numerator:\n\nnum\n\n\\(\\displaystyle 6.0 \\cdot 10^{20} s\\)\n\n\nDisplay the denominator:\n\ndenom\n\n\\(\\displaystyle 391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}\\)\n\n\nThe roots of the denominator can be obtained with the solve function.\n\nsolve(denom,s)\n\n\\(\\displaystyle \\left[ -321649.557914015 - 10842889.0903087 i, \\  -321649.557914015 + 10842889.0903087 i, \\  -244859.393492634 - 9323420.66838014 i, \\  -244859.393492634 + 9323420.66838014 i\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ac-analysis",
    "href": "SMNA_example.html#ac-analysis",
    "title": "3  SMNA Example",
    "section": "3.22 AC analysis",
    "text": "3.22 AC analysis\nSolve equations a frequency of 1.491MHz or \\(\\omega\\) equal to 9.3682292e6 radians per second, s = 9.3682292e6j.\n\nNE_1rad_per_s = NE.subs({s:9.3682292e6j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_1rad_per_s.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_1rad_per_s.rhs[i]),latex(NE_1rad_per_s.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\)\\(0 = v_{2} \\cdot \\left(2.0001 + 0.093682292 i\\right) - 2.0 v_{5}\\)\\(0 = - 0.001 v_{1} + v_{3} \\cdot \\left(2.001 + 0.093682292 i\\right) - 2.0 v_{4}\\)\\(0 = I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\)\\(0 = I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - 9.3682292 i I_{L1} - 1.40523438 i I_{L2} + v_{4}\\)\\(0 = - 1.40523438 i I_{L1} - 9.3682292 i I_{L2} + v_{5}\\)\n\n\n\nU_1rad_per_s = solve(NE_1rad_per_s,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_1rad_per_s.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.101262    -21.012442\nv3         0.101577     -5.111761\nv4         0.101240     -2.443264\nv5         0.101378    -18.330736\nI_V1       0.000899   -179.423099\nI_L1       0.009469    -89.691641\nI_L2       0.009486   -111.073602",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#ac-sweep",
    "href": "SMNA_example.html#ac-sweep",
    "title": "3  SMNA Example",
    "section": "3.23 AC Sweep",
    "text": "3.23 AC Sweep\nLooking at node 2 voltage, calculate the transfer function.\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\nGet the coefficients of the numerator and denominator polynomials.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\nUse the SciPy bode function to calculate the magnitude and phase response of the transfer function.\n\nx = np.logspace(6, 6.5, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results with Matplotlib.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w/(2*np.pi), phase,':',color='b')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('peak: {:.2f} dB at {:.3f} MHz'.format(mag.max(),w[np.argmax(mag)]/(2*np.pi)/1e6,))\n\npeak: -19.89 dB at 1.490 MHz",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA_example.html#summary",
    "href": "SMNA_example.html#summary",
    "title": "3  SMNA Example",
    "section": "3.24 Summary",
    "text": "3.24 Summary\nIn this chapter a walk through of the Python code that implements the symbolic MNA procedure was presented. The network equations in symbolic form were solved and the filter’s symbolic transfer function was obtained. Then the component values were substituted into the network equations and solved again. The node voltages were obtained at a discrete frequency and then an AC sweep was done for the transfer function.\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press. https://www.gbv.de/dms/ilmenau/toc/585302871.PDF.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis. https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>SMNA Example</span>"
    ]
  },
  {
    "objectID": "SMNA-function.html",
    "href": "SMNA-function.html",
    "title": "4  SMNA function",
    "section": "",
    "text": "4.1 AC analysis\nAn AC analysis of the circuit can also be performed by substituting \\(j \\omega\\) for \\(s\\) in the network equations and solving for the voltage at any desired node. The independent voltage source can be adjusted to a different amplitude and phase.\nFor example, we can change the independent voltage source, V1, to have an amplitude of 10 at a frequency of 10 Hz with a phase of shift of 30 degrees.\nsource_amp = 10\nsource_phase = 30 # phase in degrees\nnew_V1 = source_amp*np.exp(1j*(source_phase*np.pi/180))\n\nfreq_Hz = 10 #Hz\nw = 2*np.pi*freq_Hz # radian frequency\n\nelement_values[V1] = new_V1\nNE_Nw = equ.subs(element_values)\nNE_Nw = NE_Nw.subs({s:1j*w})\n\ntemp = ''\nfor i in range(shape(NE_Nw.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_Nw.rhs[i]),latex(NE_Nw.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.00166666666666667 v_{1} - 0.00166666666666667 v_{2}\\)\\(0 = I_{L1} - 0.00166666666666667 v_{1} + v_{2} \\cdot \\left(0.00166666666666667 + 2.38761041672824 \\cdot 10^{-5} i\\right)\\)\\(0 = - I_{L1} + v_{3} \\cdot \\left(0.00166666666666667 + 2.38761041672824 \\cdot 10^{-5} i\\right)\\)\\(8.66025403784439 + 5.0 i = v_{1}\\)\\(0 = - 9.55044166691297 i I_{L1} + v_{2} - v_{3}\\)\nAgain, we can use the SymPy function, solve, to get a solution for \\(V_1 = 10 sin(2 \\pi 10 t + 30)\\) and print the unknown voltages and currents.\nU_Nw = solve(NE_Nw,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_Nw .items():\n  table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1         10.000000     30.000000\nv2          4.999392     29.635345\nv3          4.999899     28.723214\nI_V1        0.008335   -149.635448\nI_L1        0.008334     29.543958\nThe values obtained from the Python code agree with the results from LTSpice.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SMNA function</span>"
    ]
  },
  {
    "objectID": "SMNA-function.html#summary",
    "href": "SMNA-function.html#summary",
    "title": "4  SMNA function",
    "section": "4.2 Summary",
    "text": "4.2 Summary\nIn this chapter the use of the function smna(net_list) was described and an example circuit was analyzed.\n\n\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SMNA function</span>"
    ]
  },
  {
    "objectID": "Validation-tests.html",
    "href": "Validation-tests.html",
    "title": "Validation tests",
    "section": "",
    "text": "Summary of test results\nLTSpice displays results using 6 digits, with zero to two digits to the left of the decimal point and the remainder of the digits to the right of the decimal point. The Python results can be displayed with 6 digits to the left of the decimal point. So when comparing the numerical results there will be some rounding differences. Most of the test circuits analyzed with the MNA Python code produced numerical results that were identical within rounding, to those obtained from LTSpice. However, there were a few exceptions discussed below.",
    "crumbs": [
      "Validation tests"
    ]
  },
  {
    "objectID": "Validation-tests.html#summary-of-test-results",
    "href": "Validation-tests.html#summary-of-test-results",
    "title": "Validation tests",
    "section": "",
    "text": "Test circuit 8\n\nThe circuit shown above is the test circuit for Test 8. This circuit is too large to produce meaningful symbolic solutions. The numeric results obtained from the Python MNA code have larger differences to LTSpice than was typical for the other test circuits. There are small differences at \\(\\omega = 0\\) and \\(\\omega = 1\\) between the Python NMA code and LTSpice solutions; with the differences being less than 0.001. The results for the AC sweep had larger differences. The magnitude and phase results over the frequency range of 0.01 to 10 Hz shows that the magnitude difference was as much as 0.005 and the phase was as much as 0.02 difference. At this time I don’t have an explanation for the differences.\n\n\nTest circuit 12\n\nThe Python MNA code produced node voltage solutions for the AC sweep that were slightly different from those obtained from LTSpice for the test circuit shown above. The magnitude difference was at most 0.001 and the phase difference was as much as 0.175 degrees. I’m not sure why for some circuits there is an almost exact numerical agreement to the LTSpice results and for other circuits there is as much as a 0.001 difference.\n\n\nTest circuit 13\n\nThe circuit constructed for Test 13, shown above, was designed to see how the MNA code would handle such an unusual circuit. A loop of inductors and current sources is not a typical circuit configuration. LTSpice produced an error during the operating point analysis, whereas the Python MNA code would generate network equations without issue. However, the Python code would not produce a solution for all the circuit unknowns; the current in L4 was not determined. To fix this problem a small series resistor was added to L1.\nIf we stop to consider how the circuit is operating at DC, we see that each of the current sources have an inductor in parallel, which at DC, acts as a short circuit. Which means that the node voltages would all be equal, \\(v_1 = v_2 = v_3 = v_{ref}\\). So the solution to the network equations at DC should be \\(v_1 = v_2 = v_3 = 0\\). At a frequency of \\(\\omega = \\infty\\), the inductors would act as an open circuits and the currents flowing into each node would not be equal, because the current sources are not equal or opposite, so Kirchhoff’s current law would be violated. So this is a pathological case and such cases might not be obvious by inspection. Also, without the small series resistor added to L1, the AC analysis results produced by the Python MNA code agreed with the LTSpice results. The conclusion is that some sort of sanity check is needed for the circuit and just because the Python code spits out answers that are correct at some frequencies, it does not mean that the MNA circuit equations are valid at all frequencies.\n\n\nTest circuit 14\n\nThe circuit above was designed to have only one unknown current. The magnitude difference was at most 0.006 and the phase difference was as much as 0.6 degrees between the Python MNA and LTSpice results. It is kind of curious that circuits for Tests 12, 13, and 14 which are all driven by sinusoidal current sources have AC solutions which are slightly different from LTSpice.  \nThe following file types are archived here:\n\n\n\n\n\n\n\nfile name\nDescription\n\n\n\n\ntest_*.asc\nLTSpice circuit schematic\n\n\nreadme.md\na description of the circuit\n\n\ntest_*.ipynb\ntest report Jupyter notebook\n\n\ntest_*.net\nSpice net list\n\n\ntest_*.png\nimage of the schematic for display in the notebook\n\n\ntest_*.csv\ncsv data exported from LTSpice",
    "crumbs": [
      "Validation tests"
    ]
  },
  {
    "objectID": "test_1.html",
    "href": "test_1.html",
    "title": "5  Test 1",
    "section": "",
    "text": "5.1 Load the netlist\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\nnet_list = '''\nR2 1 2 1\nR3 4 3 1\nR4 2 5 2\nV1 1 0 2\nI1 4 0 9\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_1.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "5  Test 1",
    "section": "5.2 Call the symbolic modified nodal analysis function",
    "text": "5.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the SMNA function. The A, X and Z are formulated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{F1} + v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} + \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\n\n\n\n5.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 4\nnumber of RLC (passive components): 4\nnumber of inductors: 0\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n5.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 1\\\\0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 1 & -1\\\\- \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{4}} & 0 & 0 & \\frac{1}{R_{4}} & 0 & -1 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1\\end{matrix}\\right]\\)\n\n\n\n\n5.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}\\right]\\)\n\n\n\n\n5.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0\\right]\\)\n\n\n\n\n5.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n3\nR3\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n4\nR4\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nI1\n4\n0\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n6\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n5.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n\n\n\n\n\n\n\n\n5.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{F1} + v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} + \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{4}, \\  v_{3}, \\  ea_{1}, \\  I_{1}, \\  R_{2}, \\  R_{1}, \\  I_{Ea1}, \\  I_{V1}, \\  v_{1}, \\  f_{1}, \\  V_{2}, \\  I_{F1}, \\  I_{V2}, \\  v_{5}, \\  R_{4}, \\  R_{3}, \\  v_{2}, \\  V_{1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#symbolic-solution",
    "href": "test_1.html#symbolic-solution",
    "title": "5  Test 1",
    "section": "5.3 Symbolic solution",
    "text": "5.3 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{2} V_{2} f_{1} + R_{2} V_{2} - R_{4} V_{1}}{R_{2} f_{1} - R_{2} - R_{4}}\\)\\(v_{3} = \\frac{I_{1} R_{1} R_{3} ea_{1} + R_{1} V_{1} ea_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}\\)\\(v_{4} = \\frac{- I_{1} R_{1} R_{3} + R_{1} V_{1} ea_{1} + R_{3} V_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}\\)\\(v_{5} = - V_{2}\\)\\(I_{V1} = \\frac{- I_{1} R_{2} R_{3} f_{1} + I_{1} R_{2} R_{3} + I_{1} R_{3} R_{4} - R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} ea_{1} - R_{1} V_{1} f_{1} + R_{1} V_{1} - R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} ea_{1} - R_{1} V_{2} f_{1} + R_{1} V_{2} - R_{2} V_{1} f_{1} + R_{2} V_{1} - R_{3} V_{1} f_{1} + R_{3} V_{1} - R_{3} V_{2} f_{1} + R_{3} V_{2} + R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}\\)\\(I_{V2} = \\frac{V_{1} + V_{2}}{R_{2} f_{1} - R_{2} - R_{4}}\\)\\(I_{Ea1} = \\frac{- I_{1} R_{1} R_{2} ea_{1} f_{1} + I_{1} R_{1} R_{2} ea_{1} - I_{1} R_{1} R_{2} f_{1} + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{4} ea_{1} + I_{1} R_{1} R_{4} + R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} f_{1} + R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} f_{1} + R_{2} V_{1} f_{1} - R_{2} V_{1} + R_{3} V_{1} f_{1} + R_{3} V_{2} f_{1} - R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}\\)\\(I_{F1} = \\frac{V_{1} f_{1} + V_{2} f_{1}}{R_{2} f_{1} - R_{2} - R_{4}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#construct-a-dictionary-of-element-values",
    "href": "test_1.html#construct-a-dictionary-of-element-values",
    "title": "5  Test 1",
    "section": "5.4 Construct a dictionary of element values",
    "text": "5.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 2.0\nV2 = 0.0\nR2 = 1.0\nR3 = 1.0\nR4 = 2.0\nI1 = 9.0\nea1 = 2.0\nf1 = 2.0\nR1 = 2.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#numerical-solution",
    "href": "test_1.html#numerical-solution",
    "title": "5  Test 1",
    "section": "5.5 Numerical solution",
    "text": "5.5 Numerical solution\nSubstitute numerical values in place of the symbolic reference designators.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.5 v_{1} - 1.0 v_{2} - 0.5 v_{4}\\)\\(0 = I_{F1} - 1.0 v_{1} + 1.5 v_{2} - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} + 1.0 v_{3} - 1.0 v_{4}\\)\\(-9.0 = - 0.5 v_{1} - 1.0 v_{3} + 1.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(2.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution. Six significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           4.000000\nv3           6.285714\nv4          -1.142857\nv5           0.000000\nI_V1         0.428571\nI_V2        -2.000000\nI_Ea1      -11.428571\nI_F1        -4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_2.html",
    "href": "test_2.html",
    "title": "6  Test 2",
    "section": "",
    "text": "6.1 Load the net list\nnet_list = '''\nR1 9 5 5\nR2 5 1 2\nR5 6 2 3\nR6 2 0 5\nR8 8 7 8\nR10 10 9 9\nR11 6 5 4\nR12 2 1 2\nR14 7 6 10\nR15 11 10 5\nV1 9 0 10\nV2 1 0 2\nV3 7 3 3\nV4 7 11 5\nI1 4 0 3\nI2 2 3 1\nI3 10 6 2\nI4 8 12 2\nR7 8 4 10\nR16 3 0 6\nR3 12 11 10\nR4 4 3 3\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_2.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "6  Test 2",
    "section": "6.2 Call the symbolic modified nodal analysis function",
    "text": "6.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = - I_{1}\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{6}}{R_{11}} - \\frac{v_{9}}{R_{1}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{7}}{R_{14}} - \\frac{v_{5}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{7} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{6}}{R_{14}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{8}} - \\frac{v_{4}}{R_{7}} = - I_{4}\\)\\(I_{V1} + v_{9} \\cdot \\left(\\frac{1}{R_{10}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{10}} - \\frac{v_{5}}{R_{1}} = 0\\)\\(v_{10} \\cdot \\left(\\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{11}}{R_{15}} - \\frac{v_{9}}{R_{10}} = - I_{3}\\)\\(- I_{V4} + v_{11} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{12}}{R_{3}} - \\frac{v_{10}}{R_{15}} = 0\\)\\(- \\frac{v_{11}}{R_{3}} + \\frac{v_{12}}{R_{3}} = I_{4}\\)\\(v_{9} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(- v_{3} + v_{7} = V_{3}\\)\\(- v_{11} + v_{7} = V_{4}\\)\n\n\nThe MNA method generates 16 equations. Given that this circuit has 12 nodes and is plannar so that 10 loop currents can be defined, it would seem that 10 or 13 equations would be sufficient to characterize the circuit. The generation of extra equations compaired to application of Kirchhoff’s current law (KCL) or Kirchhoff’s voltage law (KVL) requires more work to solve for the unknows.\n\n6.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 22\nnumber of branches: 22\nnumber of nodes: 12\nnumber of unknown currents: 4\nnumber of RLC (passive components): 14\nnumber of inductors: 0\nnumber of independent voltage sources: 4\nnumber of independent current sources: 4\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n6.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & - \\frac{1}{R_{5}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\\\0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & - \\frac{1}{R_{8}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & \\frac{1}{R_{10}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{10}} & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{10}} & \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{3}} + \\frac{1}{R_{15}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n6.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}\\right]\\)\n\n\n\n\n6.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  - I_{1}, \\  0, \\  I_{3}, \\  0, \\  - I_{4}, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}\\right]\\)\n\n\n\n\n6.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n9\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n7\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n7\n11\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nR1\n9\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n5\nR2\n5\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n6\nR5\n6\n2\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n7\nR6\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n8\nR8\n8\n7\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n9\nR10\n10\n9\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n10\nR11\n6\n5\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n11\nR12\n2\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n12\nR14\n7\n6\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n13\nR15\n11\n10\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n14\nI1\n4\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n15\nI2\n2\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n16\nI3\n10\n6\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n17\nI4\n8\n12\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n18\nR7\n8\n4\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n19\nR16\n3\n0\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n20\nR3\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n21\nR4\n4\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n6.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n9\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n7\n3\n\n\n3\nV4\n7\n11\n\n\n\n\n\n\n\n\n\n\n6.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( V_{2}, \\  R_{1}, \\  I_{V2}, \\  v_{6}, \\  R_{14}, \\  I_{V1}, \\  V_{4}, \\  R_{3}, \\  R_{7}, \\  R_{5}, \\  R_{4}, \\  I_{2}, \\  v_{12}, \\  I_{3}, \\  v_{8}, \\  R_{16}, \\  v_{11}, \\  R_{15}, \\  v_{3}, \\  v_{1}, \\  v_{5}, \\  I_{V3}, \\  v_{10}, \\  R_{11}, \\  V_{1}, \\  I_{V4}, \\  v_{4}, \\  R_{8}, \\  v_{9}, \\  V_{3}, \\  R_{12}, \\  R_{6}, \\  R_{10}, \\  I_{4}, \\  I_{1}, \\  R_{2}, \\  v_{2}, \\  v_{7}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#symbolic-solution",
    "href": "test_2.html#symbolic-solution",
    "title": "6  Test 2",
    "section": "6.3 Symbolic solution",
    "text": "6.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#construct-a-dictionary-of-element-values",
    "href": "test_2.html#construct-a-dictionary-of-element-values",
    "title": "6  Test 2",
    "section": "6.4 Construct a dictionary of element values",
    "text": "6.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nV2 = 2.0\nV3 = 3.0\nV4 = 5.0\nR1 = 5.0\nR2 = 2.0\nR5 = 3.0\nR6 = 5.0\nR8 = 8.0\nR10 = 9.0\nR11 = 4.0\nR12 = 2.0\nR14 = 10.0\nR15 = 5.0\nI1 = 3.0\nI2 = 1.0\nI3 = 2.0\nI4 = 2.0\nR7 = 10.0\nR16 = 6.0\nR3 = 10.0\nR4 = 3.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#numerical-solution",
    "href": "test_2.html#numerical-solution",
    "title": "6  Test 2",
    "section": "6.5 Numerical solution",
    "text": "6.5 Numerical solution\nSubstitute numerical values in place the symbolic reference designators.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{5}\\)\\(-1.0 = - 0.5 v_{1} + 1.03333333333333 v_{2} - 0.333333333333333 v_{6}\\)\\(1.0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(-3.0 = - 0.333333333333333 v_{3} + 0.433333333333333 v_{4} - 0.1 v_{8}\\)\\(0 = - 0.5 v_{1} + 0.95 v_{5} - 0.25 v_{6} - 0.2 v_{9}\\)\\(2.0 = - 0.333333333333333 v_{2} - 0.25 v_{5} + 0.683333333333333 v_{6} - 0.1 v_{7}\\)\\(0 = I_{V3} + I_{V4} - 0.1 v_{6} + 0.225 v_{7} - 0.125 v_{8}\\)\\(-2.0 = - 0.1 v_{4} - 0.125 v_{7} + 0.225 v_{8}\\)\\(0 = I_{V1} - 0.111111111111111 v_{10} - 0.2 v_{5} + 0.311111111111111 v_{9}\\)\\(-2.0 = 0.311111111111111 v_{10} - 0.2 v_{11} - 0.111111111111111 v_{9}\\)\\(0 = - I_{V4} - 0.2 v_{10} + 0.3 v_{11} - 0.1 v_{12}\\)\\(2.0 = - 0.1 v_{11} + 0.1 v_{12}\\)\\(10.0 = v_{9}\\)\\(2.0 = v_{1}\\)\\(3.0 = - v_{3} + v_{7}\\)\\(5.0 = - v_{11} + v_{7}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           1.532489\nv3          -6.665281\nv4         -16.236710\nv5           4.408083\nv6           4.750715\nv7          -3.665281\nv8         -18.141472\nv9          10.000000\nv10         -8.427681\nv11         -8.665281\nv12         11.334719\nI_V1        -3.165903\nI_V2         0.970286\nI_V3         1.079596\nI_V4        -2.047520\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(9):    10  voltage\nV(5):    4.40808     voltage\nV(1):    2   voltage\nV(6):    4.75072     voltage\nV(2):    1.53249     voltage\nV(8):    -18.1415    voltage\nV(7):    -3.66528    voltage\nV(10):   -8.42768    voltage\nV(11):   -8.66528    voltage\nV(3):    -6.66528    voltage\nV(4):    -16.2367    voltage\nV(12):   11.3347     voltage\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   1.11838     device_current\nI(R2):   1.20404     device_current\nI(R5):   1.07274     device_current\nI(R6):   0.306498    device_current\nI(R8):   -1.80952    device_current\nI(R10):  -2.04752    device_current\nI(R11):  0.0856581   device_current\nI(R12):  -0.233756   device_current\nI(R14):  -0.8416     device_current\nI(R15):  -0.0475201  device_current\nI(R7):   -0.190476   device_current\nI(R16):  -1.11088    device_current\nI(R3):   2   device_current\nI(R4):   -3.19048    device_current\nI(V1):   -3.1659     device_current\nI(V2):   0.970286    device_current\nI(V3):   1.0796  device_current\nI(V4):   -2.04752    device_current\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_3.html",
    "href": "test_3.html",
    "title": "7  Test 3",
    "section": "",
    "text": "7.1 Load the net list\nnet_list = '''\nR2 2 5 2\nV1 1 0 1\nI1 4 0 9\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\nC1 1 2 1\nL1 4 3 1\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_3.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "7  Test 3",
    "section": "7.2 Call the symbolic modified nodal analysis function",
    "text": "7.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{2} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{1} s v_{1} + I_{F1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} - I_{L1} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{5}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- I_{L1} L_{1} s - v_{3} + v_{4} = 0\\)\n\n\n\n7.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 5\nnumber of RLC (passive components): 4\nnumber of inductors: 1\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n7.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{1}} & - C_{1} s & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0 & 0\\\\- C_{1} s & C_{1} s + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & -1\\\\- \\frac{1}{R_{1}} & 0 & 0 & \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & - \\frac{1}{R_{2}} & 0 & 0 & \\frac{1}{R_{2}} & 0 & -1 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0\\\\0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & - L_{1} s\\end{matrix}\\right]\\)\n\n\n\n\n7.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}, \\  I_{L1}\\right]\\)\n\n\n\n\n7.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n7.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nI1\n4\n0\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n4\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n6\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nC1\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n8\nL1\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n7.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n4\nL1\n4\n3\n\n\n\n\n\n\n\n\n\n\n7.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  R_{1}, \\  v_{4}, \\  I_{V2}, \\  V_{1}, \\  I_{1}, \\  L_{1}, \\  I_{Ea1}, \\  v_{1}, \\  v_{3}, \\  ea_{1}, \\  s, \\  f_{1}, \\  V_{2}, \\  v_{5}, \\  I_{F1}, \\  I_{V1}, \\  v_{2}, \\  R_{2}, \\  I_{L1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#symbolic-solution",
    "href": "test_3.html#symbolic-solution",
    "title": "7  Test 3",
    "section": "7.3 Symbolic solution",
    "text": "7.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} R_{2} V_{1} s + V_{2} f_{1} - V_{2}}{C_{1} R_{2} s - f_{1} + 1}\\)\\(v_{3} = \\frac{I_{1} L_{1} R_{1} ea_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)\\(v_{4} = \\frac{- I_{1} L_{1} R_{1} s + L_{1} V_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)\\(v_{5} = - V_{2}\\)\\(I_{V1} = \\frac{- C_{1} I_{1} L_{1} R_{2} s^{2} + C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{1} s^{2} + C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} L_{1} V_{2} s^{2} + C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} ea_{1} s + C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{1} s + C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} s + C_{1} R_{1} V_{2} f_{1} s - C_{1} R_{1} V_{2} s - C_{1} R_{2} V_{1} s + I_{1} L_{1} f_{1} s - I_{1} L_{1} s + V_{1} f_{1} - V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}\\)\\(I_{V2} = \\frac{- C_{1} V_{1} s - C_{1} V_{2} s}{C_{1} R_{2} s - f_{1} + 1}\\)\\(I_{Ea1} = \\frac{- C_{1} I_{1} R_{1} R_{2} ea_{1} s - C_{1} I_{1} R_{1} R_{2} s - C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} f_{1} s + C_{1} R_{2} V_{1} s + I_{1} R_{1} ea_{1} f_{1} - I_{1} R_{1} ea_{1} + I_{1} R_{1} f_{1} - I_{1} R_{1} - V_{1} f_{1} + V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}\\)\\(I_{F1} = \\frac{- C_{1} V_{1} f_{1} s - C_{1} V_{2} f_{1} s}{C_{1} R_{2} s - f_{1} + 1}\\)\\(I_{L1} = \\frac{- I_{1} R_{1} ea_{1} - I_{1} R_{1} + V_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#construct-a-dictionary-of-element-values",
    "href": "test_3.html#construct-a-dictionary-of-element-values",
    "title": "7  Test 3",
    "section": "7.4 Construct a dictionary of element values",
    "text": "7.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 1.0\nV2 = 0.0\nR2 = 2.0\nI1 = 9.0\nea1 = 2.0\nf1 = 2.0\nR1 = 2.0\nC1 = 1.0\nL1 = 1.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#dc-operating-point",
    "href": "test_3.html#dc-operating-point",
    "title": "7  Test 3",
    "section": "7.5 DC operating point",
    "text": "7.5 DC operating point\nBoth V1 and I1 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.5 v_{1} - 0.5 v_{4}\\)\\(0 = I_{F1} + 0.5 v_{2} - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} - I_{L1}\\)\\(-9.0 = I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          1.000000\nv2          0.000000\nv3          0.666667\nv4          0.666667\nv5          0.000000\nI_V1       -0.166667\nI_V2        0.000000\nI_Ea1      -8.833333\nI_F1        0.000000\nI_L1       -8.833333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    -2e-12  voltage\nV(5):    0   voltage\nV(1):    1   voltage\nV(4):    0.666667    voltage\nV(3):    0.666667    voltage\nI(C1):   1e-12   device_current\nI(F1):   2e-12   device_current\nI(L1):   -8.83333    device_current\nI(I1):   9   device_current\nI(R2):   -1e-12  device_current\nI(R1):   0.166667    device_current\nI(E1):   -8.83333    device_current\nI(V1):   -0.166667   device_current\nI(V2):   1e-12   device_current\nThe results from LTSpice agree with the SymPy results.\n\n7.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I1 = 0\n\nelement_values[I1] = 0\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(0.5 + 1.0 i\\right) - 1.0 i v_{2} - 0.5 v_{4}\\)\\(0 = I_{F1} - 1.0 i v_{1} + v_{2} \\cdot \\left(0.5 + 1.0 i\\right) - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} - I_{L1}\\)\\(0 = I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = - 1.0 i I_{L1} - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.894427    -26.565051\nv3         0.657596     -9.462322\nv4         0.677834      4.573921\nv5         0.000000    nan\nI_V1       0.294086    -36.027373\nI_V2       0.447214    153.434949\nI_Ea1      0.738882    149.683220\nI_F1       0.894427    153.434949\nI_L1       0.164399     -9.462322\n\n\nThe LTSpice solution is shown below:\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:   0.894427 phase:   -26.5651°  voltage\nV(5):   mag:          0 phase:          0°  voltage\nV(1):   mag:          1 phase:          0°  voltage\nV(4):   mag:   0.677834 phase:    4.57392°  voltage\nV(3):   mag:   0.657596 phase:   -9.46232°  voltage\nI(C1):  mag:   0.447214 phase:    153.435°  device_current\nI(F1):  mag:   0.894427 phase:    153.435°  device_current\nI(L1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(R2):  mag:   0.447214 phase:   -26.5651°  device_current\nI(R1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(E1):  mag:   0.738882 phase:    149.683°  device_current\nI(V1):  mag:   0.294086 phase:   -36.0274°  device_current\nI(V2):  mag:   0.447214 phase:    153.435°  device_current\n\n\n7.5.2 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. Thr frequenct weep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} - 1.0 s v_{2} + v_{1} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{4}\\)\\(0 = I_{F1} - 1.0 s v_{1} + v_{2} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} - I_{L1}\\)\\(0 = I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = - 1.0 I_{L1} s - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n7.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_3.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-15}\\) and \\(10^{-13}\\) for the phase indicating the numerical difference is very small.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_4.html",
    "href": "test_4.html",
    "title": "8  Test 4",
    "section": "",
    "text": "8.1 Load the net list\nnet_list = '''\nV4 1 2 10\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR5 4 8 5\nR9 1 9 9\nR1 1 5 3\nR10 8 0 10\nR13 9 11 7\nR14 10 9 10\nR15 0 11 3\nR2 3 5 5\nR6 7 1 2\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_4.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "8  Test 4",
    "section": "8.2 Call the symbolic modified nodal analysis function",
    "text": "8.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V4} + v_{1} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) - \\frac{v_{9}}{R_{9}} - \\frac{v_{7}}{R_{6}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(\\frac{v_{4}}{R_{5}} - \\frac{v_{8}}{R_{5}} = I_{2}\\)\\(I_{F1} - I_{V2} + v_{1} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- g_{1} v_{4} + g_{1} v_{9} + v_{7} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{1}}{R_{6}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} - \\frac{v_{4}}{R_{5}} = 0\\)\\(- I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{1}}{R_{9}} - \\frac{v_{11}}{R_{13}} = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\n\n\n\n8.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 26\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 6\nnumber of RLC (passive components): 18\nnumber of inductors: 0\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n8.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccc}\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} - \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{6}} & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{5}} & 0 & 0 & 0 & - \\frac{1}{R_{5}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{3}} - \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{6}} & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & \\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & - \\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & - \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{13}} & 0 & \\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n8.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}\\right]\\)\n\n\n\n\n8.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n8.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR5\n4\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n11\nR9\n1\n9\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n12\nR1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n13\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n14\nR13\n9\n11\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n15\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n16\nR15\n0\n11\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n17\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n18\nR6\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n19\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n20\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n21\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n22\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n23\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n24\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n25\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n8.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n\n\n\n\n\n\n\n\n8.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{5}, \\  I_{V2}, \\  v_{8}, \\  h_{1}, \\  v_{11}, \\  R_{12}, \\  R_{7}, \\  I_{Ea1}, \\  V_{4}, \\  R_{1}, \\  R_{3}, \\  V_{1}, \\  ea_{1}, \\  v_{12}, \\  R_{11}, \\  g_{1}, \\  R_{14}, \\  v_{4}, \\  I_{2}, \\  v_{2}, \\  v_{6}, \\  v_{1}, \\  v_{5}, \\  R_{15}, \\  V_{2}, \\  I_{F1}, \\  v_{13}, \\  R_{18}, \\  R_{17}, \\  R_{4}, \\  R_{6}, \\  v_{10}, \\  v_{3}, \\  R_{13}, \\  R_{8}, \\  v_{9}, \\  R_{16}, \\  f_{1}, \\  I_{H1}, \\  v_{7}, \\  R_{10}, \\  R_{9}, \\  R_{2}, \\  I_{V4}, \\  I_{V1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#symbolic-solution",
    "href": "test_4.html#symbolic-solution",
    "title": "8  Test 4",
    "section": "8.3 Symbolic solution",
    "text": "8.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#construct-a-dictionary-of-element-values",
    "href": "test_4.html#construct-a-dictionary-of-element-values",
    "title": "8  Test 4",
    "section": "8.4 Construct a dictionary of element values",
    "text": "8.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV4 = 10.0\nV1 = 0.0\nV2 = 0.0\nI2 = 5.0\nf1 = 5.0\nea1 = 3.0\ng1 = 2.0\nh1 = 2.0\nR3 = 10.0\nR4 = 1.0\nR5 = 5.0\nR9 = 9.0\nR1 = 3.0\nR10 = 10.0\nR13 = 7.0\nR14 = 10.0\nR15 = 3.0\nR2 = 5.0\nR6 = 2.0\nR7 = 6.0\nR11 = 5.0\nR12 = 9.0\nR16 = 10.0\nR8 = 5.0\nR17 = 8.0\nR18 = 4.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#numerical-solution",
    "href": "test_4.html#numerical-solution",
    "title": "8  Test 4",
    "section": "8.5 Numerical solution",
    "text": "8.5 Numerical solution\nSubstitute numerical values in place the symbolic reference designators.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V4} + 1.04444444444444 v_{1} - 0.433333333333333 v_{5} - 0.5 v_{7} - 0.111111111111111 v_{9}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(-5.0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(5.0 = 0.2 v_{4} - 0.2 v_{8}\\)\\(0 = I_{F1} - I_{V2} - 0.433333333333333 v_{1} - 0.2 v_{3} + 0.633333333333333 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 0.5 v_{1} - 1.0 v_{3} - 2.0 v_{4} + 1.66666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.2 v_{4} - 0.166666666666667 v_{7} + 0.666666666666667 v_{8}\\)\\(0 = - I_{F1} - 0.111111111111111 v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.553968253968254 v_{9}\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = 0.576190476190476 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(10.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          -2.528148\nv2         -12.528148\nv3         -26.854161\nv4          18.928828\nv5         -21.885182\nv6         -26.854161\nv7         -14.774289\nv8          -6.071172\nv9          16.675687\nv10          1.207520\nv11          1.418845\nv12        -15.647159\nv13        -21.885182\nI_V4       -12.377360\nI_V1         1.790752\nI_V2         1.559506\nI_F1         8.953758\nI_Ea1      -14.021017\nI_H1       -14.168112\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -2.52815    voltage\nV(2):    -12.5281    voltage\nV(3):    -26.8542    voltage\nV(4):    18.9288     voltage\nV(5):    -21.8852    voltage\nV(9):    16.6757     voltage\nV(12):   -15.6472    voltage\nV(10):   1.20752     voltage\nV(7):    -14.7743    voltage\nV(8):    -6.07117    voltage\nV(11):   1.41885     voltage\nV(6):    -26.8542    voltage\nV(13):   -21.8852    voltage\nI(F1):   8.95376     device_current\nI(H1):   -14.1681    device_current\nI(I2):   5   device_current\nI(R3):   -1.9357     device_current\nI(R4):   -12.0799    device_current\nI(R5):   5   device_current\nI(R9):   -2.13376    device_current\nI(R1):   6.45234     device_current\nI(R10):  -0.607117   device_current\nI(R13):  2.17955     device_current\nI(R14):  -1.54682    device_current\nI(R15):  -0.472948   device_current\nI(R2):   -0.993796   device_current\nI(R6):   -6.12307    device_current\nI(R7):   1.45052     device_current\nI(R11):  -3.09363    device_current\nI(R12):  -0.134169   device_current\nI(R16):  -1.7066     device_current\nI(R8):   -4.1566     device_current\nI(R17):  1.79075     device_current\nI(R18):  1.55951     device_current\nI(G1):   -4.50628    device_current\nI(E1):   -14.021     device_current\nI(V4):   -12.3774    device_current\nI(V1):   1.79075     device_current\nI(V2):   1.55951     device_current\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_5.html",
    "href": "test_5.html",
    "title": "9  Test 5",
    "section": "",
    "text": "9.1 Load the net list\nnet_list = '''\nV4 1 2 20\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR9 4 8 9\nR10 8 0 10\nR13 9 11 7\nR14 10 9 10\nR2 3 5 5\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\nC1 7 1 2\nC2 1 9 5\nL1 1 5 3 \nL2 0 11 8 \n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_5.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "9  Test 5",
    "section": "9.2 Call the symbolic modified nodal analysis function",
    "text": "9.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(\\frac{v_{4}}{R_{9}} - \\frac{v_{8}}{R_{9}} = I_{2}\\)\\(I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{4}}{R_{9}} - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{2} s v_{1} - I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{11}}{R_{13}} = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(- I_{L2} + v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L2} L_{2} s - v_{11} = 0\\)\n\n\n\n9.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 26\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 8\nnumber of RLC (passive components): 18\nnumber of inductors: 2\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n9.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccccc}C_{1} s + C_{2} s + \\frac{1}{R_{3}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} & 0 & - C_{1} s & 0 & - C_{2} s & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{9}} & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{3}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{1} s & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & - \\frac{1}{R_{9}} & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & - \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{13}} & 0 & \\frac{1}{R_{16}} + \\frac{1}{R_{13}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{2} s\\end{array}\\right]\\)\n\n\n\n\n9.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}\\right]\\)\n\n\n\n\n9.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n9.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR9\n4\n8\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n11\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n12\nR13\n9\n11\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n13\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n14\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n15\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n16\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n17\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n18\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n19\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n20\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n21\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n22\nC1\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n23\nC2\n1\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n24\nL1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n25\nL2\n0\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n9.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n6\nL1\n1\n5\n\n\n7\nL2\n0\n11\n\n\n\n\n\n\n\n\n\n\n9.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{13}, \\  ea_{1}, \\  I_{L2}, \\  v_{6}, \\  I_{V2}, \\  v_{8}, \\  V_{4}, \\  v_{11}, \\  s, \\  R_{16}, \\  v_{9}, \\  v_{2}, \\  R_{18}, \\  V_{1}, \\  v_{5}, \\  I_{V1}, \\  R_{8}, \\  R_{12}, \\  g_{1}, \\  h_{1}, \\  L_{1}, \\  C_{2}, \\  I_{V4}, \\  I_{H1}, \\  I_{F1}, \\  I_{Ea1}, \\  R_{3}, \\  v_{1}, \\  f_{1}, \\  R_{17}, \\  v_{12}, \\  R_{11}, \\  C_{1}, \\  R_{7}, \\  V_{2}, \\  v_{7}, \\  L_{2}, \\  I_{2}, \\  R_{13}, \\  v_{3}, \\  R_{9}, \\  R_{14}, \\  R_{2}, \\  v_{10}, \\  v_{4}, \\  I_{L1}, \\  R_{10}, \\  R_{4}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#symbolic-solution",
    "href": "test_5.html#symbolic-solution",
    "title": "9  Test 5",
    "section": "9.3 Symbolic solution",
    "text": "9.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#construct-a-dictionary-of-element-values",
    "href": "test_5.html#construct-a-dictionary-of-element-values",
    "title": "9  Test 5",
    "section": "9.4 Construct a dictionary of element values",
    "text": "9.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV4 = 20.0\nV1 = 0.0\nV2 = 0.0\nI2 = 5.0\nf1 = 5.0\nea1 = 3.0\ng1 = 2.0\nh1 = 2.0\nR3 = 10.0\nR4 = 1.0\nR9 = 9.0\nR10 = 10.0\nR13 = 7.0\nR14 = 10.0\nR2 = 5.0\nR7 = 6.0\nR11 = 5.0\nR12 = 9.0\nR16 = 10.0\nR8 = 5.0\nR17 = 8.0\nR18 = 4.0\nC1 = 2.0\nC2 = 5.0\nL1 = 3.0\nL2 = 8.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#dc-operating-point",
    "href": "test_5.html#dc-operating-point",
    "title": "9  Test 5",
    "section": "9.5 DC operating point",
    "text": "9.5 DC operating point\nBoth V4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + 0.1 v_{1} - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(-5.0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(5.0 = 0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 1.0 v_{3} - 2.0 v_{4} + 1.16666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\)\\(0 = - I_{F1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.442857142857143 v_{9}\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = v_{1} - v_{5}\\)\\(0 = - v_{11}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          -5.020059\nv2         -25.020059\nv3         -40.666907\nv4          26.781121\nv5          -5.020059\nv6         -40.666907\nv7         -32.212572\nv8         -18.218879\nv9          23.720095\nv10          2.417779\nv11          0.000000\nv12        -18.353392\nv13         -5.020059\nI_V4       -20.241983\nI_V1         1.955856\nI_V2        -3.333333\nI_F1         9.779280\nI_Ea1      -17.029166\nI_H1       -22.197839\nI_L1        20.241983\nI_L2        -1.553246\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -5.02006    voltage\nV(2):    -25.0201    voltage\nV(3):    -40.6669    voltage\nV(4):    26.7811     voltage\nV(5):    -5.02006    voltage\nV(9):    23.7201     voltage\nV(12):   -18.3534    voltage\nV(10):   2.41778     voltage\nV(7):    -32.2126    voltage\nV(8):    -18.2189    voltage\nV(11):   0   voltage\nV(6):    -40.6669    voltage\nV(13):   -5.02006    voltage\nI(C1):   -5.4385e-11     device_current\nI(C2):   -1.43701e-10    device_current\nI(F1):   9.77928     device_current\nI(H1):   -22.1978    device_current\nI(L1):   20.242  device_current\nI(L2):   -1.55325    device_current\nI(I2):   5   device_current\nI(R3):   -8.88178e-16    device_current\nI(R4):   -8.45434    device_current\nI(R9):   5   device_current\nI(R10):  -1.82189    device_current\nI(R13):  3.38859     device_current\nI(R14):  -2.13023    device_current\nI(R2):   -7.12937    device_current\nI(R7):   2.33228     device_current\nI(R11):  -4.26046    device_current\nI(R12):  -0.268642   device_current\nI(R16):  -1.83534    device_current\nI(R8):   -4.48961    device_current\nI(R17):  1.95586     device_current\nI(R18):  -3.33333    device_current\nI(G1):   -6.12205    device_current\nI(E1):   -17.0292    device_current\nI(V4):   -20.242     device_current\nI(V1):   1.95586     device_current\nI(V2):   -3.33333    device_current\nThe results from LTSpice agree with the SymPy results.\n\n9.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I2 = 0\n\nelement_values[I2] = 0\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = 0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\)\\(0 = - I_{F1} - 5.0 i v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(0.442857142857143 + 5.0 i\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 i I_{L1} + v_{1} - v_{5}\\)\\(0 = - 8.0 i I_{L2} - v_{11}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          3.599764    -52.169011\nv2         18.017879   -170.920917\nv3          1.855665     65.635428\nv4          1.903808      8.371520\nv5         14.354390     47.295045\nv6          1.855665     65.635428\nv7          4.531708    -16.043028\nv8          1.903808      8.371520\nv9          1.498280    -10.433515\nv10         3.010258   -107.783771\nv11         2.426237   -163.488259\nv12         8.767364    169.347366\nv13        14.354390     47.295045\nI_V4       10.838028   -177.106564\nI_V1        2.387928   -166.271733\nI_V2        5.102027   -154.058091\nI_F1       11.939640   -166.271733\nI_Ea1       3.858821    148.425320\nI_H1        8.504523    179.867890\nI_L1        5.120760    150.658972\nI_L2        0.303280    -73.488259\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    3.59976 phase:    -52.169°  voltage\nV(2):   mag:    18.0179 phase:   -170.921°  voltage\nV(3):   mag:    1.85567 phase:    65.6354°  voltage\nV(4):   mag:    1.90381 phase:    8.37152°  voltage\nV(5):   mag:    14.3544 phase:     47.295°  voltage\nV(9):   mag:    1.49828 phase:   -10.4335°  voltage\nV(12):  mag:    8.76736 phase:    169.347°  voltage\nV(10):  mag:    3.01026 phase:   -107.784°  voltage\nV(7):   mag:    4.53171 phase:    -16.043°  voltage\nV(8):   mag:    1.90381 phase:    8.37152°  voltage\nV(11):  mag:    2.42624 phase:   -163.488°  voltage\nV(6):   mag:    1.85567 phase:    65.6354°  voltage\nV(13):  mag:    14.3544 phase:     47.295°  voltage\nI(C1):  mag:    5.34483 phase:    126.532°  device_current\nI(C2):  mag:    13.3732 phase:    15.9359°  device_current\nI(F1):  mag:    11.9396 phase:   -166.272°  device_current\nI(H1):  mag:    8.50452 phase:    179.868°  device_current\nI(L1):  mag:    5.12076 phase:    150.659°  device_current\nI(L2):  mag:    0.30328 phase:   -73.4883°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:    1.53623 phase:     60.659°  device_current\nI(R4):  mag:    4.64174 phase:    140.656°  device_current\nI(R9):  mag:          0 phase:          0°  device_current\nI(R10): mag:   0.190381 phase:    8.37152°  device_current\nI(R13): mag:   0.546091 phase:    6.28131°  device_current\nI(R14): mag:   0.352995 phase:   -132.679°  device_current\nI(R2):  mag:     2.5213 phase:    -135.36°  device_current\nI(R7):  mag:   0.484448 phase:     148.25°  device_current\nI(R11): mag:   0.705989 phase:   -132.679°  device_current\nI(R12): mag:   0.334473 phase:    72.2162°  device_current\nI(R16): mag:   0.670093 phase:    159.833°  device_current\nI(R8):  mag:   0.360393 phase:    128.347°  device_current\nI(R17): mag:    2.38793 phase:   -166.272°  device_current\nI(R18): mag:    5.10203 phase:   -154.058°  device_current\nI(G1):  mag:    1.36963 phase:   -126.779°  device_current\nI(E1):  mag:    3.85882 phase:    148.425°  device_current\nI(V4):  mag:     10.838 phase:   -177.107°  device_current\nI(V1):  mag:    2.38793 phase:   -166.272°  device_current\nI(V2):  mag:    5.10203 phase:   -154.058°  device_current\n\n\n\n9.5.2 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = 0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\)\\(0 = - I_{F1} - 5.0 s v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(5.0 s + 0.442857142857143\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 I_{L1} s + v_{1} - v_{5}\\)\\(0 = - 8.0 I_{L2} s - v_{11}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n9.5.3 Plot the voltage at node 5\n\nH = U_ac[v5]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_5.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\) and \\(10^{-12}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_6.html",
    "href": "test_6.html",
    "title": "10  Test 6",
    "section": "",
    "text": "10.1 Load the net list\nnet_list = '''\nV4 1 2 20\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR10 8 0 10\nR14 10 9 10\nR2 3 5 5\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\nC1 7 1 2\nC2 1 9 5\nL1 1 5 3\nL2 0 11 8\nL3 9 11 8\nL4 4 8 10\nK1 L3 L4 0.5\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_6.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "10  Test 6",
    "section": "10.2 Call the symbolic modified nodal analysis function",
    "text": "10.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(I_{L4} = I_{2}\\)\\(I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(- I_{L4} + v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{2} s v_{1} - I_{F1} + I_{L3} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(- I_{L2} - I_{L3} + \\frac{v_{11}}{R_{16}} - \\frac{v_{12}}{R_{16}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L2} L_{2} s - v_{11} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{1} s - v_{11} + v_{9} = 0\\)\\(- I_{L3} M_{1} s - I_{L4} L_{4} s + v_{4} - v_{8} = 0\\)\n\n\n\n10.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 27\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 10\nnumber of RLC (passive components): 18\nnumber of inductors: 4\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 1\n\n\n\n\n\n10.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccccccc}C_{1} s + C_{2} s + \\frac{1}{R_{3}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} & 0 & - C_{1} s & 0 & - C_{2} s & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\- \\frac{1}{R_{3}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{1} s & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & 0 & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\- C_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{16}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{2} s & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{1} s\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{4} s\\end{array}\\right]\\)\n\n\n\n\n10.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}\\right]\\)\n\n\n\n\n10.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n10.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n11\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n12\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n13\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n14\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n15\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n16\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n17\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n18\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n19\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n20\nC1\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n21\nC2\n1\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n22\nL1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n23\nL2\n0\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n24\nL3\n9\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n25\nL4\n4\n8\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n26\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.5\nNaN\nL3\nL4\n\n\n\n\n\n\n\n\n\n\n10.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n6\nL1\n1\n5\n\n\n7\nL2\n0\n11\n\n\n8\nL3\n9\n11\n\n\n9\nL4\n4\n8\n\n\n\n\n\n\n\n\n\n\n10.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{2}, \\  R_{2}, \\  I_{L4}, \\  I_{Ea1}, \\  R_{14}, \\  v_{10}, \\  v_{13}, \\  f_{1}, \\  v_{12}, \\  R_{4}, \\  L_{3}, \\  L_{2}, \\  v_{11}, \\  v_{7}, \\  v_{4}, \\  C_{1}, \\  V_{2}, \\  I_{V2}, \\  V_{4}, \\  R_{10}, \\  M_{1}, \\  g_{1}, \\  L_{1}, \\  ea_{1}, \\  v_{2}, \\  R_{8}, \\  R_{7}, \\  h_{1}, \\  I_{H1}, \\  v_{5}, \\  v_{1}, \\  s, \\  R_{3}, \\  I_{F1}, \\  R_{16}, \\  I_{L2}, \\  L_{4}, \\  I_{V1}, \\  I_{V4}, \\  R_{12}, \\  V_{1}, \\  v_{6}, \\  v_{9}, \\  I_{L3}, \\  R_{18}, \\  I_{2}, \\  I_{L1}, \\  v_{8}, \\  R_{17}, \\  v_{3}, \\  R_{11}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#symbolic-solution",
    "href": "test_6.html#symbolic-solution",
    "title": "10  Test 6",
    "section": "10.3 Symbolic solution",
    "text": "10.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#construct-a-dictionary-of-element-values",
    "href": "test_6.html#construct-a-dictionary-of-element-values",
    "title": "10  Test 6",
    "section": "10.4 Construct a dictionary of element values",
    "text": "10.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV4 = 20.0\nV1 = 0.0\nV2 = 0.0\nI2 = 5.0\nf1 = 5.0\nea1 = 3.0\ng1 = 2.0\nh1 = 2.0\nR3 = 10.0\nR4 = 1.0\nR10 = 10.0\nR14 = 10.0\nR2 = 5.0\nR7 = 6.0\nR11 = 5.0\nR12 = 9.0\nR16 = 10.0\nR8 = 5.0\nR17 = 8.0\nR18 = 4.0\nC1 = 2.0\nC2 = 5.0\nL1 = 3.0\nL2 = 8.0\nL3 = 8.0\nL4 = 10.0\nK1 = 0.5\n\n\n\n10.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt; K1 L3 L4 0.5\nK1 identifies the mutual inductance between two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1 = symbols('K1')\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 4.472135955\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  C_{2} : 5.0, \\  I_{2} : 5.0, \\  K_{1} : 0.5, \\  L_{1} : 3.0, \\  L_{2} : 8.0, \\  L_{3} : 8.0, \\  L_{4} : 10.0, \\  M_{1} : 4.47213595499958, \\  R_{10} : 10.0, \\  R_{11} : 5.0, \\  R_{12} : 9.0, \\  R_{14} : 10.0, \\  R_{16} : 10.0, \\  R_{17} : 8.0, \\  R_{18} : 4.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  R_{4} : 1.0, \\  R_{7} : 6.0, \\  R_{8} : 5.0, \\  V_{1} : 0.0, \\  V_{2} : 0.0, \\  V_{4} : 20.0, \\  ea_{1} : 3.0, \\  f_{1} : 5.0, \\  g_{1} : 2.0, \\  h_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#dc-operating-point",
    "href": "test_6.html#dc-operating-point",
    "title": "10  Test 6",
    "section": "10.5 DC operating point",
    "text": "10.5 DC operating point\nBoth V4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + 0.1 v_{1} - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(-5.0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(5.0 = I_{L4}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 1.0 v_{3} - 2.0 v_{4} + 1.16666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\)\\(0 = - I_{F1} + I_{L3} - 0.3 v_{10} + 0.3 v_{9}\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = v_{1} - v_{5}\\)\\(0 = - v_{11}\\)\\(0 = - v_{11} + v_{9}\\)\\(0 = v_{4} - v_{8}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           3.367922\nv2         -16.632078\nv3         -15.060648\nv4          -1.041413\nv5           3.367922\nv6         -15.060648\nv7         -14.843180\nv8          -1.041413\nv9           0.000000\nv10          5.066334\nv11          0.000000\nv12         -9.965411\nv13          3.367922\nI_V4        -6.036903\nI_V1        -0.196429\nI_V2        -3.333333\nI_F1        -0.982144\nI_Ea1       -1.510600\nI_H1        -5.840475\nI_L1         6.036903\nI_L2         0.458785\nI_L3         0.537756\nI_L4         5.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    3.36792     voltage\nV(2):    -16.6321    voltage\nV(3):    -15.0606    voltage\nV(4):    -1.04141    voltage\nV(5):    3.36792     voltage\nV(9):    1.11022e-16     voltage\nV(12):   -9.96541    voltage\nV(10):   5.06633     voltage\nV(7):    -14.8432    voltage\nV(8):    -1.04141    voltage\nV(11):   0   voltage\nV(6):    -15.0606    voltage\nV(13):   3.36792     voltage\nI(C1):   -3.64222e-11    device_current\nI(C2):   1.68396e-11     device_current\nI(F1):   -0.982144   device_current\nI(H1):   -5.84047    device_current\nI(L1):   6.0369  device_current\nI(L2):   0.458785    device_current\nI(L3):   0.537756    device_current\nI(L4):   5   device_current\nI(I2):   5   device_current\nI(R3):   5.32907e-16     device_current\nI(R4):   -0.217468   device_current\nI(R10):  -0.104141   device_current\nI(R14):  0.506633    device_current\nI(R2):   -3.68571    device_current\nI(R7):   2.30029     device_current\nI(R11):  1.01327     device_current\nI(R12):  -0.562926   device_current\nI(R16):  -0.996541   device_current\nI(R8):   -2.80385    device_current\nI(R17):  -0.196429   device_current\nI(R18):  -3.33333    device_current\nI(G1):   2.08283     device_current\nI(E1):   -1.5106     device_current\nI(V4):   -6.0369     device_current\nI(V1):   -0.196429   device_current\nI(V2):   -3.33333    device_current\nThe results from LTSpice agree with the SymPy results.\n\n10.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I2 = 0 and V4 = 10\n\nelement_values[I2] = 0\nelement_values[V4] = 10\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = I_{L4}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\)\\(0 = - I_{F1} + I_{L3} - 5.0 i v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(0.3 + 5.0 i\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(10 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 i I_{L1} + v_{1} - v_{5}\\)\\(0 = - 8.0 i I_{L2} - v_{11}\\)\\(0 = - 8.0 i I_{L3} - 4.47213595499958 i I_{L4} - v_{11} + v_{9}\\)\\(0 = - 4.47213595499958 i I_{L3} - 10.0 i I_{L4} + v_{4} - v_{8}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.636070    -13.116769\nv2         8.414810   -177.471137\nv3         0.586907     -3.586473\nv4         1.987061     30.488547\nv5         7.659782     29.941452\nv6         0.586907     -3.586473\nv7         1.673460      2.228237\nv8         0.848285      0.506771\nv9         1.767765     29.618572\nv10        0.268017     -3.585934\nv11        0.916416    -90.556353\nv12        3.543942    163.157171\nv13        7.659782     29.941452\nI_V4       5.376987   -165.047830\nI_V1       1.124824   -177.869238\nI_V2       2.602977   -164.421170\nI_F1       5.624122   -177.869238\nI_Ea1      1.485962   -145.541756\nI_H1       4.287481   -161.710238\nI_L1       2.186723    129.745082\nI_L2       0.114552     -0.556353\nI_L3       0.295629    -40.810152\nI_L4       0.000000    nan\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    1.63607 phase:   -13.1168°  voltage\nV(2):   mag:    8.41481 phase:   -177.471°  voltage\nV(3):   mag:   0.586907 phase:   -3.58647°  voltage\nV(4):   mag:    1.98706 phase:    30.4885°  voltage\nV(5):   mag:    7.65978 phase:    29.9415°  voltage\nV(9):   mag:    1.76776 phase:    29.6186°  voltage\nV(12):  mag:    3.54394 phase:    163.157°  voltage\nV(10):  mag:   0.268017 phase:   -3.58593°  voltage\nV(7):   mag:    1.67346 phase:    2.22824°  voltage\nV(8):   mag:   0.848285 phase:   0.506771°  voltage\nV(11):  mag:   0.916416 phase:   -90.5564°  voltage\nV(6):   mag:   0.586907 phase:   -3.58647°  voltage\nV(13):  mag:    7.65978 phase:    29.9415°  voltage\nI(C1):  mag:   0.886817 phase:    169.762°  device_current\nI(C2):  mag:    6.23121 phase:    2.60332°  device_current\nI(F1):  mag:    5.62412 phase:   -177.869°  device_current\nI(H1):  mag:    4.28748 phase:    -161.71°  device_current\nI(L1):  mag:    2.18672 phase:    129.745°  device_current\nI(L2):  mag:   0.114552 phase:  -0.556353°  device_current\nI(L3):  mag:   0.295629 phase:   -40.8102°  device_current\nI(L4):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:   0.656017 phase:    39.7451°  device_current\nI(R4):  mag:    1.09119 phase:   -174.648°  device_current\nI(R10): mag:  0.0848285 phase:   0.506771°  device_current\nI(R14): mag:   0.155047 phase:   -144.949°  device_current\nI(R2):  mag:    1.43557 phase:    -147.47°  device_current\nI(R7):  mag:   0.137659 phase:   -176.004°  device_current\nI(R11): mag:   0.310094 phase:   -144.949°  device_current\nI(R12): mag:  0.0297797 phase:    176.414°  device_current\nI(R16): mag:    0.39014 phase:    150.127°  device_current\nI(R8):  mag:  0.0532384 phase:   -170.438°  device_current\nI(R17): mag:    1.12482 phase:   -177.869°  device_current\nI(R18): mag:    2.60298 phase:   -164.421°  device_current\nI(G1):  mag:   0.442271 phase:    -142.54°  device_current\nI(E1):  mag:    1.48596 phase:   -145.542°  device_current\nI(V4):  mag:    5.37699 phase:   -165.048°  device_current\nI(V1):  mag:    1.12482 phase:   -177.869°  device_current\nI(V2):  mag:    2.60298 phase:   -164.421°  device_current\n\n\n10.5.2 AC Sweep\nLooking at node 10 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = I_{L4}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\)\\(0 = - I_{F1} + I_{L3} - 5.0 s v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(5.0 s + 0.3\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(10 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 I_{L1} s + v_{1} - v_{5}\\)\\(0 = - 8.0 I_{L2} s - v_{11}\\)\\(0 = - 8.0 I_{L3} s - 4.47213595499958 I_{L4} s - v_{11} + v_{9}\\)\\(0 = - 4.47213595499958 I_{L3} s - 10.0 I_{L4} s + v_{4} - v_{8}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n10.5.3 Plot the voltage at node 10\n\nH = U_ac[v10]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 1000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_6.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\) and \\(10^{-11}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_7.html",
    "href": "test_7.html",
    "title": "11  Test 7",
    "section": "",
    "text": "11.1 Load the net list\nnet_list = '''\nR1 16 8 5\nR2 8 1 2\nR6 2 0 5\nR8 11 10 8\nR10 23 22 9\nR11 9 8 4\nR12 2 1 2\nR14 10 9 10\nR15 24 23 5\nV1 22 0 10 \nV2 1 0 2\nV3 10 3 3\nV4 10 20 5\nI1 5 0 3\nI2 2 3 1\nI3 16 9 2\nI4 12 18 2\nR7 12 5 10\nR16 3 0 6\nR3 26 25 10\nR4 4 3 3\nF1 14 7 V2 2\nE1 15 21 2 7 2\nH1 4 0 V2 3\nG1 11 4 13 12 2\nL1 16 23 1 \nL2 25 9 4 \nV5 20 28 0\nV6 23 27 0\nL3 22 21 2 \nL4 17 11 5 \nC1 23 18 2\nC2 12 11 2\nL5 0 7 1 \nL6 9 2 2 \nF2 0 27 V2 2\nE2 17 26 10 9 2\nH2 27 26 V2 3\nG2 16 28 0 5 2\nV7 24 25 0\nV8 0 6 0\nR9 22 16 3\nR13 15 0 5\nR17 19 13 5\nR18 13 6 2\nR19 23 19 7\nR20 20 19 5\nR21 19 18 3\nR22 14 13 3\nR23 5 4 1\nR24 20 14 3\nR25 23 28 10\nR5 28 0 3\nK1 L1 L2 0.707\nK2 L3 L4 0.707\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_7.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "11  Test 7",
    "section": "11.2 Call the symbolic modified nodal analysis function",
    "text": "11.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}} = - I_{1}\\)\\(- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}} = 0\\)\\(- I_{F1} - I_{L5} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}} = 0\\)\\(- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}} = 0\\)\\(- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}} = 0\\)\\(- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}} = - I_{4}\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}} = 0\\)\\(I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}} = 0\\)\\(I_{Ea1} + \\frac{v_{15}}{R_{13}} = 0\\)\\(I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}} = - I_{3}\\)\\(I_{Ea2} + I_{L4} = 0\\)\\(- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}} = I_{4}\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}} = 0\\)\\(- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}} = 0\\)\\(- I_{Ea1} - I_{L3} = 0\\)\\(I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}} = 0\\)\\(- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}} = 0\\)\\(I_{V7} - \\frac{v_{23}}{R_{15}} + \\frac{v_{24}}{R_{15}} = 0\\)\\(I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{F2} + I_{H2} - I_{V6} = 0\\)\\(- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}} = 0\\)\\(v_{22} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(v_{10} - v_{3} = V_{3}\\)\\(v_{10} - v_{20} = V_{4}\\)\\(v_{20} - v_{28} = V_{5}\\)\\(v_{23} - v_{27} = V_{6}\\)\\(v_{24} - v_{25} = V_{7}\\)\\(- v_{6} = V_{8}\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21} = 0\\)\\(- I_{V2} h_{1} + v_{4} = 0\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22} = 0\\)\\(- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17} = 0\\)\\(- I_{L5} L_{5} s - v_{7} = 0\\)\\(- I_{L6} L_{6} s - v_{2} + v_{9} = 0\\)\\(I_{F2} - I_{V2} f_{2} = 0\\)\\(- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26} = 0\\)\\(- I_{V2} h_{2} - v_{26} + v_{27} = 0\\)\n\n\n\n11.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 55\nnumber of branches: 53\nnumber of nodes: 28\nnumber of unknown currents: 20\nnumber of RLC (passive components): 33\nnumber of inductors: 6\nnumber of independent voltage sources: 8\nnumber of independent current sources: 4\nnumber of Op Amps: 0\nnumber of E - VCVS: 2\nnumber of G - VCCS: 2\nnumber of F - CCCS: 2\nnumber of H - CCVS: 2\nnumber of K - Coupled inductors: 2\n\n\n\n\n\n11.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccccccccccccccccccccccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{23}} & - \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & g_{1} & - g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & - \\frac{1}{R_{23}} & \\frac{1}{R_{7}} + \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{8}} & C_{2} s + \\frac{1}{R_{8}} & - C_{2} s - g_{1} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & - C_{2} s & C_{2} s + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{22}} & \\frac{1}{R_{24}} + \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - g_{2} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{1} s + \\frac{1}{R_{21}} & - \\frac{1}{R_{21}} & 0 & 0 & 0 & - C_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{21}} & \\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{20}} & 0 & 0 & - \\frac{1}{R_{19}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{20}} & \\frac{1}{R_{24}} + \\frac{1}{R_{20}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - C_{1} s & - \\frac{1}{R_{19}} & 0 & 0 & - \\frac{1}{R_{10}} & C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 1\\\\0 & 0 & 0 & 0 & g_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - ea_{1} & 0 & 0 & 0 & 0 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{2} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{2} s & - L_{4} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{5} s & 0 & 0 & 0 & 0\\\\0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{6} s & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ea_{2} & - ea_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & - h_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n11.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  v_{14}, \\  v_{15}, \\  v_{16}, \\  v_{17}, \\  v_{18}, \\  v_{19}, \\  v_{20}, \\  v_{21}, \\  v_{22}, \\  v_{23}, \\  v_{24}, \\  v_{25}, \\  v_{26}, \\  v_{27}, \\  v_{28}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}, \\  I_{V5}, \\  I_{V6}, \\  I_{V7}, \\  I_{V8}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}, \\  I_{L5}, \\  I_{L6}, \\  I_{F2}, \\  I_{Ea2}, \\  I_{H2}\\right]\\)\n\n\n\n\n11.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  0, \\  - I_{1}, \\  0, \\  0, \\  0, \\  I_{3}, \\  0, \\  0, \\  - I_{4}, \\  0, \\  0, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}, \\  V_{5}, \\  V_{6}, \\  V_{7}, \\  V_{8}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n11.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n22\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n10\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n10\n20\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nV5\n20\n28\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nV6\n23\n27\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n6\nV7\n24\n25\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n7\nV8\n0\n6\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n8\nR1\n16\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n9\nR2\n8\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n10\nR6\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n11\nR8\n11\n10\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n12\nR10\n23\n22\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n13\nR11\n9\n8\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n14\nR12\n2\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n15\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n16\nR15\n24\n23\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n17\nI1\n5\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n18\nI2\n2\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n19\nI3\n16\n9\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n20\nI4\n12\n18\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n21\nR7\n12\n5\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n22\nR16\n3\n0\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n23\nR3\n26\n25\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n24\nR4\n4\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n25\nF1\n14\n7\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n26\nEa1\n15\n21\n2\n7\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n27\nH1\n4\n0\nNaN\nNaN\nNaN\n3.0\nV2\nNaN\nNaN\n\n\n28\nG1\n11\n4\n13\n12\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n29\nL1\n16\n23\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n30\nL2\n25\n9\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n31\nL3\n22\n21\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n32\nL4\n17\n11\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n33\nC1\n23\n18\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n34\nC2\n12\n11\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n35\nL5\n0\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n36\nL6\n9\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n37\nF2\n0\n27\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n38\nEa2\n17\n26\n10\n9\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n39\nH2\n27\n26\nNaN\nNaN\nNaN\n3.0\nV2\nNaN\nNaN\n\n\n40\nG2\n16\n28\n0\n5\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n41\nR9\n22\n16\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n42\nR13\n15\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n43\nR17\n19\n13\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n44\nR18\n13\n6\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n45\nR19\n23\n19\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n46\nR20\n20\n19\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n47\nR21\n19\n18\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n48\nR22\n14\n13\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n49\nR23\n5\n4\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n50\nR24\n20\n14\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n51\nR25\n23\n28\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n52\nR5\n28\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n53\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.707\nNaN\nL1\nL2\n\n\n54\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.707\nNaN\nL3\nL4\n\n\n\n\n\n\n\n\n\n\n11.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n22\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n10\n3\n\n\n3\nV4\n10\n20\n\n\n4\nV5\n20\n28\n\n\n5\nV6\n23\n27\n\n\n6\nV7\n24\n25\n\n\n7\nV8\n0\n6\n\n\n8\nF1\n14\n7\n\n\n9\nEa1\n15\n21\n\n\n10\nH1\n4\n0\n\n\n11\nL1\n16\n23\n\n\n12\nL2\n25\n9\n\n\n13\nL3\n22\n21\n\n\n14\nL4\n17\n11\n\n\n15\nL5\n0\n7\n\n\n16\nL6\n9\n2\n\n\n17\nF2\n0\n27\n\n\n18\nEa2\n17\n26\n\n\n19\nH2\n27\n26\n\n\n\n\n\n\n\n\n\n\n11.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{19}, \\  M_{1}, \\  L_{5}, \\  I_{Ea2}, \\  R_{14}, \\  R_{13}, \\  I_{L4}, \\  s, \\  h_{1}, \\  v_{18}, \\  I_{V1}, \\  I_{F1}, \\  R_{10}, \\  I_{H2}, \\  I_{V3}, \\  v_{11}, \\  I_{V5}, \\  v_{12}, \\  v_{15}, \\  R_{17}, \\  L_{6}, \\  g_{2}, \\  v_{7}, \\  I_{L6}, \\  v_{9}, \\  V_{7}, \\  v_{3}, \\  I_{F2}, \\  R_{16}, \\  v_{1}, \\  R_{9}, \\  v_{4}, \\  v_{27}, \\  I_{2}, \\  C_{2}, \\  L_{4}, \\  R_{12}, \\  v_{23}, \\  R_{18}, \\  v_{21}, \\  ea_{1}, \\  L_{2}, \\  V_{1}, \\  v_{17}, \\  g_{1}, \\  h_{2}, \\  I_{H1}, \\  I_{V2}, \\  L_{1}, \\  R_{11}, \\  R_{24}, \\  R_{2}, \\  I_{V4}, \\  R_{21}, \\  R_{15}, \\  f_{2}, \\  v_{6}, \\  I_{L5}, \\  R_{19}, \\  V_{3}, \\  R_{1}, \\  I_{1}, \\  f_{1}, \\  I_{Ea1}, \\  v_{10}, \\  I_{V8}, \\  v_{28}, \\  V_{2}, \\  L_{3}, \\  R_{25}, \\  M_{2}, \\  ea_{2}, \\  I_{4}, \\  R_{3}, \\  R_{5}, \\  R_{4}, \\  R_{8}, \\  R_{22}, \\  v_{5}, \\  R_{7}, \\  I_{V7}, \\  v_{26}, \\  V_{6}, \\  v_{25}, \\  R_{6}, \\  v_{8}, \\  R_{23}, \\  v_{2}, \\  v_{13}, \\  v_{22}, \\  R_{20}, \\  V_{4}, \\  I_{L1}, \\  v_{16}, \\  I_{V6}, \\  v_{24}, \\  I_{L2}, \\  v_{20}, \\  V_{8}, \\  C_{1}, \\  V_{5}, \\  I_{3}, \\  I_{L3}, \\  v_{14}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#symbolic-solution",
    "href": "test_7.html#symbolic-solution",
    "title": "11  Test 7",
    "section": "11.3 Symbolic solution",
    "text": "11.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#construct-a-dictionary-of-element-values",
    "href": "test_7.html#construct-a-dictionary-of-element-values",
    "title": "11  Test 7",
    "section": "11.4 Construct a dictionary of element values",
    "text": "11.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nV2 = 2.0\nV3 = 3.0\nV4 = 5.0\nV5 = 0.0\nV6 = 0.0\nV7 = 0.0\nV8 = 0.0\nR1 = 5.0\nR2 = 2.0\nR6 = 5.0\nR8 = 8.0\nR10 = 9.0\nR11 = 4.0\nR12 = 2.0\nR14 = 10.0\nR15 = 5.0\nI1 = 3.0\nI2 = 1.0\nI3 = 2.0\nI4 = 2.0\nR7 = 10.0\nR16 = 6.0\nR3 = 10.0\nR4 = 3.0\nf1 = 2.0\nea1 = 2.0\nh1 = 3.0\ng1 = 2.0\nL1 = 1.0\nL2 = 4.0\nL3 = 2.0\nL4 = 5.0\nC1 = 2.0\nC2 = 2.0\nL5 = 1.0\nL6 = 2.0\nf2 = 2.0\nea2 = 2.0\nh2 = 3.0\ng2 = 2.0\nR9 = 3.0\nR13 = 5.0\nR17 = 5.0\nR18 = 2.0\nR19 = 7.0\nR20 = 5.0\nR21 = 3.0\nR22 = 3.0\nR23 = 1.0\nR24 = 3.0\nR25 = 10.0\nR5 = 3.0\nK1 = 0.707\nK2 = 0.707\n\n\n\n11.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt;K1 L1 L2 0.707\nK2 L3 L4 0.707\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2 = symbols('K1 K2')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nmutual inductance, M1 = 1.414000000\nmutual inductance, M2 = 2.235730306",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#dc-operating-point",
    "href": "test_7.html#dc-operating-point",
    "title": "11  Test 7",
    "section": "11.5 DC operating point",
    "text": "11.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(-1.0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(1.0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(-3.0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\)\\(2.0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + 0.125 v_{11} - 2.0 v_{12} + 2.0 v_{13}\\)\\(-2.0 = 0.1 v_{12} - 0.1 v_{5}\\)\\(0 = 1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(-2.0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(2.0 = 0.333333333333333 v_{18} - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + 0.553968253968254 v_{23} - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(10.0 = v_{22}\\)\\(2.0 = v_{1}\\)\\(3.0 = v_{10} - v_{3}\\)\\(5.0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = v_{16} - v_{23}\\)\\(0 = v_{25} - v_{9}\\)\\(0 = - v_{21} + v_{22}\\)\\(0 = - v_{11} + v_{17}\\)\\(0 = - v_{7}\\)\\(0 = - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           5.971750\nv3         -10.279202\nv4          13.605119\nv5           8.605119\nv6           0.000000\nv7           0.000000\nv8           7.098329\nv9           5.971750\nv10         -7.279202\nv11        -18.854648\nv12        -11.394881\nv13         -7.101000\nv14        -23.295220\nv15         21.943500\nv16         21.252375\nv17        -18.854648\nv18          8.136867\nv19          2.136867\nv20        -12.279202\nv21         10.000000\nv22         10.000000\nv23         21.252375\nv24          5.971750\nv25          5.971750\nv26          7.647256\nv27         21.252375\nv28        -12.279202\nI_V1         0.612356\nI_V2         4.535040\nI_V3       -10.674641\nI_V4        10.552805\nI_V5         9.764013\nI_V6        -1.761697\nI_V7         3.056125\nI_V8         3.550500\nI_F1         9.070079\nI_Ea1       -4.388700\nI_H1        -4.373678\nI_L1         8.628637\nI_L2         3.223676\nI_L3         4.388700\nI_L4         7.140832\nI_L5        -9.070079\nI_L6         4.180225\nI_F2         9.070079\nI_Ea2       -7.140832\nI_H2         7.308382\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(16):   21.2524     voltage\nV(8):    7.09833     voltage\nV(1):    2   voltage\nV(2):    5.97175     voltage\nV(11):   -18.8546    voltage\nV(10):   -7.2792     voltage\nV(23):   21.2524     voltage\nV(22):   10  voltage\nV(9):    5.97175     voltage\nV(24):   5.97175     voltage\nV(3):    -10.2792    voltage\nV(20):   -12.2792    voltage\nV(5):    8.60512     voltage\nV(12):   -11.3949    voltage\nV(18):   8.13687     voltage\nV(26):   7.64726     voltage\nV(25):   5.97175     voltage\nV(4):    13.6051     voltage\nV(14):   -23.2952    voltage\nV(7):    0   voltage\nV(15):   21.9435     voltage\nV(21):   10  voltage\nV(13):   -7.101  voltage\nV(28):   -12.2792    voltage\nV(27):   21.2524     voltage\nV(17):   -18.8546    voltage\nV(6):    0   voltage\nV(19):   2.13687     voltage\nI(C1):   2.6231e-11  device_current\nI(C2):   1.49195e-11     device_current\nI(F1):   9.07008     device_current\nI(F2):   9.07008     device_current\nI(H1):   -4.37368    device_current\nI(H2):   7.30838     device_current\nI(L1):   8.62864     device_current\nI(L2):   3.22368     device_current\nI(L3):   4.3887  device_current\nI(L4):   7.14083     device_current\nI(L5):   -9.07008    device_current\nI(L6):   4.18022     device_current\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   2.83081     device_current\nI(R2):   2.54916     device_current\nI(R6):   1.19435     device_current\nI(R8):   -1.44693    device_current\nI(R10):  1.25026     device_current\nI(R11):  -0.281645   device_current\nI(R12):  1.98588     device_current\nI(R14):  -1.3251     device_current\nI(R15):  -3.05612    device_current\nI(R7):   -2  device_current\nI(R16):  -1.7132     device_current\nI(R3):   0.167551    device_current\nI(R4):   7.96144     device_current\nI(R9):   -3.75079    device_current\nI(R13):  4.3887  device_current\nI(R17):  1.84757     device_current\nI(R18):  -3.5505     device_current\nI(R19):  2.73079     device_current\nI(R20):  -2.88321    device_current\nI(R21):  -2  device_current\nI(R22):  -5.39807    device_current\nI(R23):  -5  device_current\nI(R24):  3.67201     device_current\nI(R25):  3.35316     device_current\nI(R5):   -4.09307    device_current\nI(G1):   8.58776     device_current\nI(G2):   -17.2102    device_current\nI(E1):   -4.3887     device_current\nI(E2):   -7.14083    device_current\nI(V1):   0.612356    device_current\nI(V2):   4.53504     device_current\nI(V3):   -10.6746    device_current\nI(V4):   10.5528     device_current\nI(V5):   9.76401     device_current\nI(V6):   -1.7617     device_current\nI(V7):   3.05612     device_current\nI(V8):   3.5505  device_current\n\nThe results from LTSpice agree with the SymPy results.\n\n11.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\nV2, V3, V4, I1, I2, I3, I4 are DC sources and are set to zero for AC analysis.\n\nelement_values[V2] = 0\nelement_values[V3] = 0\nelement_values[V4] = 0\nelement_values[I1] = 0\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\)\\(0 = 1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 i I_{L1} - 1.414 i I_{L2} + v_{16} - v_{23}\\)\\(0 = - 1.414 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\)\\(0 = - 2.0 i I_{L3} - 2.23573030573904 i I_{L4} - v_{21} + v_{22}\\)\\(0 = - 2.23573030573904 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\)\\(0 = - 1.0 i I_{L5} - v_{7}\\)\\(0 = - 2.0 i I_{L6} - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          0.000000    nan\nv2          1.269063   -156.737432\nv3          5.563110     92.699863\nv4          5.822884    -82.858298\nv5          5.049515    -83.161299\nv6          0.000000    nan\nv7          3.881923      7.141702\nv8          3.734176    -63.802595\nv9          2.183378   -102.275110\nv10         5.563110     92.699863\nv11         2.699909     95.168114\nv12         2.700976    103.385120\nv13         2.281731     84.349178\nv14         9.719907     94.381715\nv15         5.149976   -119.308730\nv16        15.692738    -57.591025\nv17        10.020727     70.734148\nv18        12.269643    -67.106998\nv19         5.029569    -61.518344\nv20         5.563110     92.699863\nv21         7.926685    -18.560431\nv22        10.000000      0.000000\nv23        12.247990    -72.779714\nv24        10.615913    -41.644709\nv25        10.615913    -41.644709\nv26         6.594170    -63.890173\nv27        12.247990    -72.779714\nv28         5.563110     92.699863\nI_V1        4.873462    -98.660056\nI_V2        1.940961    -82.858298\nI_V3        4.719081     94.525274\nI_V4        5.842672    -86.521779\nI_V5        6.490055    -83.573802\nI_V6        3.704717     80.775839\nI_V7        1.266856   -132.840858\nI_V8        1.140866    -95.650822\nI_F1        3.881923    -82.858298\nI_Ea1       1.029995     60.691270\nI_H1        4.026860     71.937257\nI_L1        3.651246    -84.027986\nI_L2        1.589691   -149.132274\nI_L3        1.029995   -119.308730\nI_L4        1.609380    -11.044380\nI_L5        3.881923     97.141702\nI_L6        0.888344   -156.737432\nI_F2        3.881923    -82.858298\nI_Ea2       1.609380    168.955620\nI_H2        1.093990    -10.267379\n\n\nThe results from LTSpice are shown below and agree with the Python results.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    15.6927 phase:    -57.591°  voltage\nV(8):   mag:    3.73418 phase:   -63.8026°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:    1.26906 phase:   -156.737°  voltage\nV(11):  mag:    2.69991 phase:    95.1681°  voltage\nV(10):  mag:    5.56311 phase:    92.6999°  voltage\nV(23):  mag:     12.248 phase:   -72.7797°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:    2.18338 phase:   -102.275°  voltage\nV(24):  mag:    10.6159 phase:   -41.6447°  voltage\nV(3):   mag:    5.56311 phase:    92.6999°  voltage\nV(20):  mag:    5.56311 phase:    92.6999°  voltage\nV(5):   mag:    5.04951 phase:   -83.1613°  voltage\nV(12):  mag:    2.70098 phase:    103.385°  voltage\nV(18):  mag:    12.2696 phase:    -67.107°  voltage\nV(26):  mag:    6.59417 phase:   -63.8902°  voltage\nV(25):  mag:    10.6159 phase:   -41.6447°  voltage\nV(4):   mag:    5.82288 phase:   -82.8583°  voltage\nV(14):  mag:    9.71991 phase:    94.3817°  voltage\nV(7):   mag:    3.88192 phase:     7.1417°  voltage\nV(15):  mag:    5.14998 phase:   -119.309°  voltage\nV(21):  mag:    7.92669 phase:   -18.5604°  voltage\nV(13):  mag:    2.28173 phase:    84.3492°  voltage\nV(28):  mag:    5.56311 phase:    92.6999°  voltage\nV(27):  mag:     12.248 phase:   -72.7797°  voltage\nV(17):  mag:    10.0207 phase:    70.7341°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    5.02957 phase:   -61.5183°  voltage\nI(C1):  mag:    2.42683 phase:   -70.9646°  device_current\nI(C2):  mag:   0.773901 phase:   -80.8809°  device_current\nI(F1):  mag:    3.88192 phase:   -82.8583°  device_current\nI(F2):  mag:    3.88192 phase:   -82.8583°  device_current\nI(H1):  mag:    4.02686 phase:    71.9373°  device_current\nI(H2):  mag:    1.09399 phase:   -10.2674°  device_current\nI(L1):  mag:    3.65125 phase:    -84.028°  device_current\nI(L2):  mag:    1.58969 phase:   -149.132°  device_current\nI(L3):  mag:       1.03 phase:   -119.309°  device_current\nI(L4):  mag:    1.60938 phase:   -11.0444°  device_current\nI(L5):  mag:    3.88192 phase:    97.1417°  device_current\nI(L6):  mag:   0.888344 phase:   -156.737°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:    2.39746 phase:   -55.6595°  device_current\nI(R2):  mag:    1.86709 phase:   -63.8026°  device_current\nI(R6):  mag:   0.253813 phase:   -156.737°  device_current\nI(R8):  mag:   0.358508 phase:   -89.6236°  device_current\nI(R10): mag:     1.4803 phase:   -118.583°  device_current\nI(R11): mag:   0.609557 phase:    150.054°  device_current\nI(R12): mag:   0.634531 phase:   -156.737°  device_current\nI(R14): mag:   0.769305 phase:    88.4942°  device_current\nI(R15): mag:    1.26686 phase:    47.1591°  device_current\nI(R7):  mag:   0.773901 phase:    99.1191°  device_current\nI(R16): mag:   0.927185 phase:    92.6999°  device_current\nI(R3):  mag:   0.515704 phase:    167.307°  device_current\nI(R4):  mag:    3.79248 phase:   -85.0285°  device_current\nI(R9):  mag:    4.44783 phase:    83.1593°  device_current\nI(R13): mag:       1.03 phase:   -119.309°  device_current\nI(R17): mag:    1.40714 phase:   -72.0029°  device_current\nI(R18): mag:    1.14087 phase:    84.3492°  device_current\nI(R19): mag:    1.05441 phase:   -80.4269°  device_current\nI(R20): mag:    2.06528 phase:     104.93°  device_current\nI(R21): mag:    2.42683 phase:    109.035°  device_current\nI(R22): mag:    2.49454 phase:    97.4264°  device_current\nI(R23): mag:   0.773901 phase:    99.1191°  device_current\nI(R24): mag:    1.38747 phase:   -83.3702°  device_current\nI(R25): mag:    1.76885 phase:   -77.3024°  device_current\nI(R5):  mag:    1.85437 phase:    92.6999°  device_current\nI(G1):  mag:    1.84371 phase:   -22.7819°  device_current\nI(G2):  mag:     10.099 phase:    96.8387°  device_current\nI(E1):  mag:       1.03 phase:    60.6913°  device_current\nI(E2):  mag:    1.60938 phase:    168.956°  device_current\nI(V1):  mag:    4.87346 phase:   -98.6601°  device_current\nI(V2):  mag:    1.94096 phase:   -82.8583°  device_current\nI(V3):  mag:    4.71908 phase:    94.5253°  device_current\nI(V4):  mag:    5.84267 phase:   -86.5218°  device_current\nI(V5):  mag:    6.49005 phase:   -83.5738°  device_current\nI(V6):  mag:    3.70472 phase:    80.7758°  device_current\nI(V7):  mag:    1.26686 phase:   -132.841°  device_current\nI(V8):  mag:    1.14087 phase:   -95.6508°  device_current\n\n\n11.5.2 AC Sweep\nLooking at node 17 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(2.0 s + 0.125\\right) + v_{12} \\left(- 2.0 s - 2.0\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 s v_{11} + v_{12} \\cdot \\left(2.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = 1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = - 2.0 s v_{23} + v_{18} \\cdot \\left(2.0 s + 0.333333333333333\\right) - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 s v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(2.0 s + 0.553968253968254\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 I_{L1} s - 1.414 I_{L2} s + v_{16} - v_{23}\\)\\(0 = - 1.414 I_{L1} s - 4.0 I_{L2} s + v_{25} - v_{9}\\)\\(0 = - 2.0 I_{L3} s - 2.23573030573904 I_{L4} s - v_{21} + v_{22}\\)\\(0 = - 2.23573030573904 I_{L3} s - 5.0 I_{L4} s - v_{11} + v_{17}\\)\\(0 = - 1.0 I_{L5} s - v_{7}\\)\\(0 = - 2.0 I_{L6} s - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n11.5.3 Plot the voltage at node 10\n\nH = U_ac[v17]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 1000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_7.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\) and \\(10^{-11}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_8.html",
    "href": "test_8.html",
    "title": "12  Test 8",
    "section": "",
    "text": "12.1 Load the net list\nnet_list = '''\nR1 16 8 5\nR2 8 1 2\nR6 2 0 5\nR8 11 10 8\nR10 23 22 9\nR11 9 8 4\nR12 2 1 2\nR14 10 9 10\nR15 24 23 5\nV1 22 0 10\nV2 1 0 2\nV3 10 3 3\nV4 10 20 5\nI1 5 0 3\nI2 2 3 1\nI3 16 9 2\nI4 12 18 2\nR7 12 5 10\nR16 3 0 6\nR3 26 25 10\nR4 4 3 3\nF1 14 7 V2 2\nE1 15 21 2 7 2\nH1 4 0 V2 3\nG1 11 4 13 12 2\nL1 16 23 1 \nL2 25 9 4 \nV5 20 28 0\nV6 23 27 0\nL3 22 21 2 \nL4 17 11 5 \nC1 23 18 2\nC2 12 11 2\nL5 0 7 1 \nL6 9 2 2 \nF2 0 27 V2 2\nE2 17 26 10 9 2\nH2 27 26 V2 3\nG2 16 28 0 5 2\nV7 24 25 0\nV8 0 6 0\nR9 22 16 3\nR13 15 0 5\nR17 19 13 5\nR18 13 6 2\nR19 23 19 7\nR20 20 19 5\nR21 19 18 3\nR22 14 13 3\nR23 5 4 1\nR24 20 14 3\nR25 23 28 10\nR5 28 0 3\nR26 32 31 20e3\nR27 30 29 10e3\nR28 13 30 2\nR29 24 32 5\nR30 29 21 20e3\nR31 31 8 10e3\nO1 29 0 30 \nO2 31 0 32 \nK1 L1 L2 0.8\nK2 L3 L4 0.2\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_8.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "12  Test 8",
    "section": "12.2 Call the symbolic modified nodal analysis function",
    "text": "12.2 Call the symbolic modified nodal analysis function\nThe circuit has 32 nodes and 59 branches, which results in 54 network equations. The Python code can generate these equations in about 1 second.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}} = - I_{1}\\)\\(- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}} = 0\\)\\(- I_{F1} - I_{L5} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{31}}{R_{31}} - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}} = 0\\)\\(- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}} = 0\\)\\(- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}} = 0\\)\\(- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}} = - I_{4}\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{30}}{R_{28}} - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}} = 0\\)\\(I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}} = 0\\)\\(I_{Ea1} + \\frac{v_{15}}{R_{13}} = 0\\)\\(I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}} = - I_{3}\\)\\(I_{Ea2} + I_{L4} = 0\\)\\(- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}} = I_{4}\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}} = 0\\)\\(- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}} = 0\\)\\(- I_{Ea1} - I_{L3} + \\frac{v_{21}}{R_{30}} - \\frac{v_{29}}{R_{30}} = 0\\)\\(I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}} = 0\\)\\(- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}} = 0\\)\\(I_{V7} + v_{24} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{32}}{R_{29}} - \\frac{v_{23}}{R_{15}} = 0\\)\\(I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{F2} + I_{H2} - I_{V6} = 0\\)\\(- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}} = 0\\)\\(v_{29} \\cdot \\left(\\frac{1}{R_{30}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{21}}{R_{30}} - \\frac{v_{30}}{R_{27}} = 0\\)\\(I_{O1} + v_{30} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{13}}{R_{28}} - \\frac{v_{29}}{R_{27}} = 0\\)\\(v_{31} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{8}}{R_{31}} - \\frac{v_{32}}{R_{26}} = 0\\)\\(I_{O2} + v_{32} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{24}}{R_{29}} - \\frac{v_{31}}{R_{26}} = 0\\)\\(v_{22} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(v_{10} - v_{3} = V_{3}\\)\\(v_{10} - v_{20} = V_{4}\\)\\(v_{20} - v_{28} = V_{5}\\)\\(v_{23} - v_{27} = V_{6}\\)\\(v_{24} - v_{25} = V_{7}\\)\\(- v_{6} = V_{8}\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21} = 0\\)\\(- I_{V2} h_{1} + v_{4} = 0\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22} = 0\\)\\(- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17} = 0\\)\\(- I_{L5} L_{5} s - v_{7} = 0\\)\\(- I_{L6} L_{6} s - v_{2} + v_{9} = 0\\)\\(I_{F2} - I_{V2} f_{2} = 0\\)\\(- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26} = 0\\)\\(- I_{V2} h_{2} - v_{26} + v_{27} = 0\\)\\(v_{29} = 0\\)\\(v_{31} = 0\\)\n\n\n\nprint('There are {:d} network equations for this circuit generated by MNA'.format(len(X)))\n\nThere are 54 network equations for this circuit generated by MNA\n\n\n\n12.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 63\nnumber of branches: 59\nnumber of nodes: 32\nnumber of unknown currents: 22\nnumber of RLC (passive components): 39\nnumber of inductors: 6\nnumber of independent voltage sources: 8\nnumber of independent current sources: 4\nnumber of Op Amps: 2\nnumber of E - VCVS: 2\nnumber of G - VCCS: 2\nnumber of F - CCCS: 2\nnumber of H - CCVS: 2\nnumber of K - Coupled inductors: 2\n\n\n\n\n\n12.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccccccccccccccccccccccccccccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{23}} & - \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & g_{1} & - g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & - \\frac{1}{R_{23}} & \\frac{1}{R_{7}} + \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{31}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{8}} & C_{2} s + \\frac{1}{R_{8}} & - C_{2} s - g_{1} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & - C_{2} s & C_{2} s + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{28}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{22}} & \\frac{1}{R_{24}} + \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - g_{2} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{1} s + \\frac{1}{R_{21}} & - \\frac{1}{R_{21}} & 0 & 0 & 0 & - C_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{21}} & \\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{20}} & 0 & 0 & - \\frac{1}{R_{19}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{20}} & \\frac{1}{R_{24}} + \\frac{1}{R_{20}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - C_{1} s & - \\frac{1}{R_{19}} & 0 & 0 & - \\frac{1}{R_{10}} & C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{29}} + \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{29}} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 1 & 0 & 0\\\\0 & 0 & 0 & 0 & g_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{30}} + \\frac{1}{R_{27}} & - \\frac{1}{R_{27}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{28}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{27}} & \\frac{1}{R_{28}} + \\frac{1}{R_{27}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{31}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{31}} + \\frac{1}{R_{26}} & - \\frac{1}{R_{26}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{29}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{26}} & \\frac{1}{R_{29}} + \\frac{1}{R_{26}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - ea_{1} & 0 & 0 & 0 & 0 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{2} s & - L_{4} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{5} s & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{6} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ea_{2} & - ea_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n12.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  v_{14}, \\  v_{15}, \\  v_{16}, \\  v_{17}, \\  v_{18}, \\  v_{19}, \\  v_{20}, \\  v_{21}, \\  v_{22}, \\  v_{23}, \\  v_{24}, \\  v_{25}, \\  v_{26}, \\  v_{27}, \\  v_{28}, \\  v_{29}, \\  v_{30}, \\  v_{31}, \\  v_{32}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}, \\  I_{V5}, \\  I_{V6}, \\  I_{V7}, \\  I_{V8}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}, \\  I_{L5}, \\  I_{L6}, \\  I_{F2}, \\  I_{Ea2}, \\  I_{H2}, \\  I_{O1}, \\  I_{O2}\\right]\\)\n\n\n\n\n12.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  0, \\  - I_{1}, \\  0, \\  0, \\  0, \\  I_{3}, \\  0, \\  0, \\  - I_{4}, \\  0, \\  0, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}, \\  V_{5}, \\  V_{6}, \\  V_{7}, \\  V_{8}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n12.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n22\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n10\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n10\n20\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nV5\n20\n28\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nR31\n31\n8\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n59\nO1\n29\n0\nNaN\nNaN\n30\nNaN\nNaN\nNaN\nNaN\n\n\n60\nO2\n31\n0\nNaN\nNaN\n32\nNaN\nNaN\nNaN\nNaN\n\n\n61\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.8\nNaN\nL1\nL2\n\n\n62\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.2\nNaN\nL3\nL4\n\n\n\n\n63 rows × 10 columns\n\n\n\n\n\n\n12.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n22\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n10\n3\n\n\n3\nV4\n10\n20\n\n\n4\nV5\n20\n28\n\n\n5\nV6\n23\n27\n\n\n6\nV7\n24\n25\n\n\n7\nV8\n0\n6\n\n\n8\nF1\n14\n7\n\n\n9\nEa1\n15\n21\n\n\n10\nH1\n4\n0\n\n\n11\nL1\n16\n23\n\n\n12\nL2\n25\n9\n\n\n13\nL3\n22\n21\n\n\n14\nL4\n17\n11\n\n\n15\nL5\n0\n7\n\n\n16\nL6\n9\n2\n\n\n17\nF2\n0\n27\n\n\n18\nEa2\n17\n26\n\n\n19\nH2\n27\n26\n\n\n20\nO1\n29\n0\n\n\n21\nO2\n31\n0\n\n\n\n\n\n\n\n\n\n\n12.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( ea_{1}, \\  v_{19}, \\  R_{8}, \\  I_{Ea2}, \\  R_{14}, \\  R_{3}, \\  R_{15}, \\  g_{2}, \\  v_{27}, \\  I_{V8}, \\  V_{5}, \\  V_{8}, \\  h_{2}, \\  V_{6}, \\  I_{V7}, \\  v_{32}, \\  R_{31}, \\  I_{H2}, \\  v_{25}, \\  R_{1}, \\  v_{5}, \\  M_{1}, \\  I_{V1}, \\  R_{19}, \\  I_{1}, \\  I_{V5}, \\  I_{L1}, \\  I_{L4}, \\  v_{7}, \\  R_{18}, \\  R_{16}, \\  R_{25}, \\  v_{20}, \\  v_{8}, \\  R_{4}, \\  s, \\  v_{28}, \\  v_{22}, \\  v_{14}, \\  C_{2}, \\  ea_{2}, \\  v_{24}, \\  v_{16}, \\  I_{O1}, \\  v_{4}, \\  f_{1}, \\  h_{1}, \\  v_{3}, \\  v_{10}, \\  V_{1}, \\  R_{9}, \\  R_{12}, \\  I_{4}, \\  I_{L3}, \\  R_{20}, \\  v_{26}, \\  v_{11}, \\  R_{23}, \\  I_{L6}, \\  v_{31}, \\  v_{9}, \\  g_{1}, \\  I_{3}, \\  V_{3}, \\  I_{V3}, \\  V_{4}, \\  I_{V2}, \\  v_{23}, \\  R_{22}, \\  L_{1}, \\  R_{10}, \\  v_{1}, \\  I_{V4}, \\  R_{6}, \\  v_{13}, \\  R_{21}, \\  L_{2}, \\  I_{L2}, \\  L_{4}, \\  v_{6}, \\  I_{F2}, \\  v_{17}, \\  L_{6}, \\  R_{30}, \\  R_{2}, \\  R_{28}, \\  L_{5}, \\  v_{12}, \\  v_{18}, \\  R_{29}, \\  I_{Ea1}, \\  C_{1}, \\  R_{17}, \\  L_{3}, \\  R_{27}, \\  R_{26}, \\  V_{2}, \\  v_{21}, \\  I_{L5}, \\  v_{2}, \\  V_{7}, \\  R_{5}, \\  v_{29}, \\  f_{2}, \\  I_{2}, \\  I_{F1}, \\  R_{13}, \\  v_{15}, \\  R_{24}, \\  v_{30}, \\  I_{O2}, \\  M_{2}, \\  I_{H1}, \\  R_{7}, \\  R_{11}, \\  I_{V6}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#symbolic-solution",
    "href": "test_8.html#symbolic-solution",
    "title": "12  Test 8",
    "section": "12.3 Symbolic solution",
    "text": "12.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#construct-a-dictionary-of-element-values",
    "href": "test_8.html#construct-a-dictionary-of-element-values",
    "title": "12  Test 8",
    "section": "12.4 Construct a dictionary of element values",
    "text": "12.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nV2 = 2.0\nV3 = 3.0\nV4 = 5.0\nV5 = 0.0\nV6 = 0.0\nV7 = 0.0\nV8 = 0.0\nR1 = 5.0\nR2 = 2.0\nR6 = 5.0\nR8 = 8.0\nR10 = 9.0\nR11 = 4.0\nR12 = 2.0\nR14 = 10.0\nR15 = 5.0\nI1 = 3.0\nI2 = 1.0\nI3 = 2.0\nI4 = 2.0\nR7 = 10.0\nR16 = 6.0\nR3 = 10.0\nR4 = 3.0\nf1 = 2.0\nea1 = 2.0\nh1 = 3.0\ng1 = 2.0\nL1 = 1.0\nL2 = 4.0\nL3 = 2.0\nL4 = 5.0\nC1 = 2.0\nC2 = 2.0\nL5 = 1.0\nL6 = 2.0\nf2 = 2.0\nea2 = 2.0\nh2 = 3.0\ng2 = 2.0\nR9 = 3.0\nR13 = 5.0\nR17 = 5.0\nR18 = 2.0\nR19 = 7.0\nR20 = 5.0\nR21 = 3.0\nR22 = 3.0\nR23 = 1.0\nR24 = 3.0\nR25 = 10.0\nR5 = 3.0\nR26 = 20000.0\nR27 = 10000.0\nR28 = 2.0\nR29 = 5.0\nR30 = 20000.0\nR31 = 10000.0\nO1 = nan\nO2 = nan\nK1 = 0.8\nK2 = 0.2\n\n\n\n12.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt;K1 L1 L2 0.8\nK2 L3 L4 0.2\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2 = symbols('K1 K2')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nmutual inductance, M1 = 1.600000000\nmutual inductance, M2 = 0.632455532",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#dc-operating-point",
    "href": "test_8.html#dc-operating-point",
    "title": "12  Test 8",
    "section": "12.5 DC operating point",
    "text": "12.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(-1.0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(1.0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(-3.0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\)\\(2.0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + 0.125 v_{11} - 2.0 v_{12} + 2.0 v_{13}\\)\\(-2.0 = 0.1 v_{12} - 0.1 v_{5}\\)\\(0 = 1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(-2.0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(2.0 = 0.333333333333333 v_{18} - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + 0.553968253968254 v_{23} - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(0 = - 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\)\\(0 = I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\)\\(0 = 0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\)\\(0 = I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\)\\(10.0 = v_{22}\\)\\(2.0 = v_{1}\\)\\(3.0 = v_{10} - v_{3}\\)\\(5.0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = v_{16} - v_{23}\\)\\(0 = v_{25} - v_{9}\\)\\(0 = - v_{21} + v_{22}\\)\\(0 = - v_{11} + v_{17}\\)\\(0 = - v_{7}\\)\\(0 = - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\\(0 = v_{29}\\)\\(0 = v_{31}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           5.487985\nv3         -13.447794\nv4          17.339762\nv5          12.339762\nv6           0.000000\nv7           0.000000\nv8          10.071856\nv9           5.487985\nv10        -10.447794\nv11        -13.224949\nv12         -7.660238\nv13         -7.240585\nv14        -28.683952\nv15         20.975971\nv16         35.986371\nv17        -13.224949\nv18         10.795432\nv19          4.795432\nv20        -15.447794\nv21         10.000000\nv22         10.000000\nv23         35.986371\nv24          5.487985\nv25          5.487985\nv26         18.646609\nv27         35.986371\nv28        -15.447794\nv29          0.000000\nv30         -5.000000\nv31          0.000000\nv32        -20.143712\nI_V1         7.353804\nI_V2         5.779921\nI_V3       -13.503818\nI_V4        14.750251\nI_V5        14.386843\nI_V6        -9.751819\nI_V7         0.973338\nI_V8         3.620293\nI_F1        11.559841\nI_Ea1       -4.195194\nI_H1       -14.423214\nI_L1         8.834498\nI_L2         2.289200\nI_L3         4.195694\nI_L4         0.492160\nI_L5       -11.559841\nI_L6         3.841590\nI_F2        11.559841\nI_Ea2       -0.492160\nI_H2         1.808023\nI_O1        -1.119793\nI_O2         5.127347\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(16):   35.9859     voltage\nV(8):    10.0718     voltage\nV(1):    2   voltage\nV(2):    5.48801     voltage\nV(11):   -13.2252    voltage\nV(10):   -10.4477    voltage\nV(23):   35.9859     voltage\nV(22):   10  voltage\nV(9):    5.48801     voltage\nV(24):   5.48801     voltage\nV(3):    -13.4477    voltage\nV(20):   -15.4477    voltage\nV(5):    12.3397     voltage\nV(12):   -7.66035    voltage\nV(18):   10.7954     voltage\nV(26):   18.6462     voltage\nV(25):   5.48801     voltage\nV(4):    17.3397     voltage\nV(14):   -28.6838    voltage\nV(7):    0   voltage\nV(15):   20.976  voltage\nV(21):   10  voltage\nV(13):   -7.24054    voltage\nV(28):   -15.4477    voltage\nV(27):   35.9859     voltage\nV(17):   -13.2252    voltage\nV(6):    0   voltage\nV(19):   4.79535     voltage\nV(32):   -20.1428    voltage\nV(31):   0.000252699     voltage\nV(30):   -4.99994    voltage\nV(29):   3.88014e-05     voltage\nI(C1):   5.03811e-11     device_current\nI(C2):   1.11297e-11     device_current\nI(F1):   11.5598     device_current\nI(F2):   11.5598     device_current\nI(H1):   -14.4228    device_current\nI(H2):   1.80825     device_current\nI(L1):   8.83452     device_current\nI(L2):   2.28924     device_current\nI(L3):   4.1957  device_current\nI(L4):   0.492428    device_current\nI(L5):   -11.5598    device_current\nI(L6):   3.84161     device_current\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   5.18282     device_current\nI(R2):   4.03588     device_current\nI(R6):   1.0976  device_current\nI(R8):   -0.347188   device_current\nI(R10):  2.88732     device_current\nI(R11):  -1.14594    device_current\nI(R12):  1.744   device_current\nI(R14):  -1.59357    device_current\nI(R15):  -6.09957    device_current\nI(R7):   -2  device_current\nI(R16):  -2.24128    device_current\nI(R3):   1.31582     device_current\nI(R4):   10.2625     device_current\nI(R9):   -8.66196    device_current\nI(R13):  4.1952  device_current\nI(R17):  2.40718     device_current\nI(R18):  -3.62027    device_current\nI(R19):  4.45579     device_current\nI(R20):  -4.04861    device_current\nI(R21):  -2  device_current\nI(R22):  -7.14775    device_current\nI(R23):  -5  device_current\nI(R24):  4.41202     device_current\nI(R25):  5.14336     device_current\nI(R5):   -5.14924    device_current\nI(R26):  -0.00100715     device_current\nI(R27):  -0.000499998    device_current\nI(R28):  -1.1203     device_current\nI(R29):  5.12615     device_current\nI(R30):  -0.000499998    device_current\nI(R31):  -0.00100715     device_current\nI(G1):   0.839616    device_current\nI(G2):   -24.6793    device_current\nI(E1):   -4.1952     device_current\nI(E2):   -0.492428   device_current\nI(V1):   7.35358     device_current\nI(V2):   5.77988     device_current\nI(V3):   -13.5037    device_current\nI(V4):   14.7501     device_current\nI(V5):   14.3867     device_current\nI(V6):   -9.75152    device_current\nI(V7):   0.97342     device_current\nI(V8):   3.62027     device_current\nIx(u1:3):    -1.1198     subckt_current\nIx(u2:3):    5.12716     subckt_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n12.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\nV2, V3, V4, I1, I2, I3, I4 are DC sources and are set to zero for AC analysis.\n\nelement_values[V2] = 0\nelement_values[V3] = 0\nelement_values[V4] = 0\nelement_values[I1] = 0\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\)\\(0 = 1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(0 = - 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\)\\(0 = I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\)\\(0 = 0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\)\\(0 = I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 i I_{L1} - 1.6 i I_{L2} + v_{16} - v_{23}\\)\\(0 = - 1.6 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\)\\(0 = - 2.0 i I_{L3} - 0.632455532033676 i I_{L4} - v_{21} + v_{22}\\)\\(0 = - 0.632455532033676 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\)\\(0 = - 1.0 i I_{L5} - v_{7}\\)\\(0 = - 2.0 i I_{L6} - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\\(0 = v_{29}\\)\\(0 = v_{31}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          0.000000    nan\nv2          0.529312   -148.498854\nv3          2.318355    160.462708\nv4          2.716202    -16.110995\nv5          2.274423    -15.079695\nv6          0.000000    nan\nv7          1.810802     73.889005\nv8          2.202609     -5.887185\nv9          0.910663    -94.036532\nv10         2.318355    160.462708\nv11         2.230400    146.370665\nv12         2.194128    152.046037\nv13         1.799206    158.492008\nv14         4.771405    162.040739\nv15         8.166288    -49.821325\nv16        10.488620      0.340133\nv17         3.084191     60.400459\nv18         8.481449     -4.374848\nv19         3.704998     -2.371134\nv20         2.318355    160.462708\nv21         7.507931    -17.093526\nv22        10.000000      0.000000\nv23         8.497267     -9.753103\nv24         4.119822      7.433394\nv25         4.119822      7.433394\nv26         5.805567     -6.783261\nv27         8.497267     -9.753103\nv28         2.318355    160.462708\nv29         0.000000    nan\nv30         3.753966    162.906474\nv31         0.000000    nan\nv32         4.405217    174.112815\nI_V1        1.542202    134.030697\nI_V2        0.905401    -16.110995\nI_V3        2.063669    161.965216\nI_V4        2.338768    -18.698461\nI_V5        2.701207    -15.096706\nI_V6        1.422424   -174.447987\nI_V7        0.931072   -153.824119\nI_V8        0.899603    -21.507992\nI_F1        1.810802    -16.110995\nI_Ea1       1.633258    130.178675\nI_H1        1.484613   -177.450035\nI_L1        2.862976    -26.151162\nI_L2        0.854027   -141.418577\nI_L3        1.633573    -49.814207\nI_L4        0.541202    -73.251389\nI_L5        1.810802    163.889005\nI_L6        0.370519   -148.498854\nI_F2        1.810802    -16.110995\nI_Ea2       0.541202    106.748611\nI_H2        0.717411    -63.158104\nI_O1        0.982866    -13.053681\nI_O2        1.693733      0.548292\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    10.4887 phase:   0.339452°  voltage\nV(8):   mag:    2.20263 phase:    -5.8879°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:   0.529319 phase:   -148.499°  voltage\nV(11):  mag:    2.23038 phase:    146.371°  voltage\nV(10):  mag:    2.31839 phase:    160.462°  voltage\nV(23):  mag:    8.49732 phase:   -9.75384°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:   0.910675 phase:   -94.0363°  voltage\nV(24):  mag:     4.1199 phase:    7.43283°  voltage\nV(3):   mag:    2.31839 phase:    160.462°  voltage\nV(20):  mag:    2.31839 phase:    160.462°  voltage\nV(5):   mag:    2.27445 phase:   -15.0807°  voltage\nV(12):  mag:    2.19411 phase:    152.046°  voltage\nV(18):  mag:     8.4815 phase:   -4.37559°  voltage\nV(26):  mag:    5.80559 phase:   -6.78388°  voltage\nV(25):  mag:     4.1199 phase:    7.43283°  voltage\nV(4):   mag:    2.71624 phase:   -16.1119°  voltage\nV(14):  mag:    4.77144 phase:     162.04°  voltage\nV(7):   mag:    1.81082 phase:    73.8881°  voltage\nV(15):  mag:    8.16625 phase:   -49.8218°  voltage\nV(21):  mag:    7.50792 phase:   -17.0934°  voltage\nV(13):  mag:    1.79919 phase:    158.492°  voltage\nV(28):  mag:    2.31839 phase:    160.462°  voltage\nV(27):  mag:    8.49732 phase:   -9.75384°  voltage\nV(17):  mag:    3.08423 phase:    60.4014°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    3.70502 phase:   -2.37192°  voltage\nV(32):  mag:    4.40507 phase:    174.112°  voltage\nV(31):  mag: 6.0913e-05 phase:   -4.03597°  voltage\nV(30):  mag:    3.75389 phase:    162.907°  voltage\nV(29):  mag: 4.73489e-05 phase:   -16.1831°     voltage\nI(C1):  mag:     1.5935 phase:   -5.92837°  device_current\nI(C2):  mag:   0.444041 phase:   -21.4012°  device_current\nI(F1):  mag:    1.81082 phase:   -16.1119°  device_current\nI(F2):  mag:    1.81082 phase:   -16.1119°  device_current\nI(H1):  mag:    1.48461 phase:   -177.452°  device_current\nI(H2):  mag:   0.717409 phase:   -63.1574°  device_current\nI(L1):  mag:    2.86299 phase:   -26.1518°  device_current\nI(L2):  mag:   0.854034 phase:   -141.418°  device_current\nI(L3):  mag:    1.63357 phase:   -49.8147°  device_current\nI(L4):  mag:   0.541197 phase:   -73.2497°  device_current\nI(L5):  mag:    1.81082 phase:    163.888°  device_current\nI(L6):  mag:   0.370523 phase:   -148.499°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:     1.6605 phase:    1.98853°  device_current\nI(R2):  mag:    1.10131 phase:    -5.8879°  device_current\nI(R6):  mag:   0.105864 phase:   -148.499°  device_current\nI(R8):  mag:  0.0705929 phase:    54.5194°  device_current\nI(R10): mag:   0.241259 phase:   -138.471°  device_current\nI(R11): mag:   0.589029 phase:   -163.163°  device_current\nI(R12): mag:    0.26466 phase:   -148.499°  device_current\nI(R14): mag:   0.270792 phase:    141.553°  device_current\nI(R15): mag:   0.944208 phase:    155.303°  device_current\nI(R7):  mag:   0.444041 phase:    158.599°  device_current\nI(R16): mag:   0.386398 phase:    160.462°  device_current\nI(R3):  mag:   0.207524 phase:   -35.9644°  device_current\nI(R4):  mag:    1.67746 phase:   -17.6897°  device_current\nI(R9):  mag:   0.164149 phase:   -172.751°  device_current\nI(R13): mag:    1.63325 phase:   -49.8218°  device_current\nI(R17): mag:    1.08737 phase:   -8.59974°  device_current\nI(R18): mag:   0.899593 phase:    158.492°  device_current\nI(R19): mag:   0.692348 phase:   -15.3907°  device_current\nI(R20): mag:    1.19191 phase:    171.035°  device_current\nI(R21): mag:     1.5935 phase:    174.072°  device_current\nI(R22): mag:   0.992596 phase:    164.183°  device_current\nI(R23): mag:   0.444041 phase:    158.599°  device_current\nI(R24): mag:   0.818256 phase:   -16.4696°  device_current\nI(R25): mag:    1.07892 phase:   -11.8466°  device_current\nI(R5):  mag:   0.772795 phase:    160.462°  device_current\nI(R26): mag: 0.000220257 phase:    174.112°     device_current\nI(R27): mag: 0.000375394 phase:    162.907°     device_current\nI(R28): mag:   0.982466 phase:   -13.0516°  device_current\nI(R29): mag:     1.6935 phase:   0.548618°  device_current\nI(R30): mag: 0.000375394 phase:    162.907°     device_current\nI(R31): mag: 0.000220257 phase:    174.112°     device_current\nI(G1):  mag:    0.90747 phase:   -54.3873°  device_current\nI(G2):  mag:    4.54891 phase:    164.919°  device_current\nI(E1):  mag:    1.63325 phase:    130.178°  device_current\nI(E2):  mag:   0.541197 phase:     106.75°  device_current\nI(V1):  mag:    1.54213 phase:    134.031°  device_current\nI(V2):  mag:   0.905412 phase:   -16.1119°  device_current\nI(V3):  mag:     2.0637 phase:    161.964°  device_current\nI(V4):  mag:     2.3388 phase:   -18.6996°  device_current\nI(V5):  mag:    2.70125 phase:   -15.0979°  device_current\nI(V6):  mag:    1.42243 phase:    -174.45°  device_current\nI(V7):  mag:   0.931071 phase:   -153.824°  device_current\nI(V8):  mag:   0.899593 phase:   -21.5082°  device_current\nIx(u1:3):   mag:    0.98284 phase:   -13.0531°  subckt_current\nIx(u2:3):   mag:    1.69372 phase:   0.547783°  subckt_current\n\n\n\n12.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(2.0 s + 0.125\\right) + v_{12} \\left(- 2.0 s - 2.0\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 s v_{11} + v_{12} \\cdot \\left(2.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = 1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = - 2.0 s v_{23} + v_{18} \\cdot \\left(2.0 s + 0.333333333333333\\right) - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 s v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(2.0 s + 0.553968253968254\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(0 = - 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\)\\(0 = I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\)\\(0 = 0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\)\\(0 = I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 I_{L1} s - 1.6 I_{L2} s + v_{16} - v_{23}\\)\\(0 = - 1.6 I_{L1} s - 4.0 I_{L2} s + v_{25} - v_{9}\\)\\(0 = - 2.0 I_{L3} s - 0.632455532033676 I_{L4} s - v_{21} + v_{22}\\)\\(0 = - 0.632455532033676 I_{L3} s - 5.0 I_{L4} s - v_{11} + v_{17}\\)\\(0 = - 1.0 I_{L5} s - v_{7}\\)\\(0 = - 2.0 I_{L6} s - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\\(0 = v_{29}\\)\\(0 = v_{31}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n12.5.3 Plot the voltage at node 10\n\nH = U_ac[v21]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 10*2*np.pi, 1000, endpoint=True)\nx = np.logspace(-2, 1, 300, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_8.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other, but not to the same precision as in previous tests.\n\nfrequency[0:-1]\n\narray([0.01      , 0.01023293, 0.01047129, 0.01071519, 0.01096478,\n       0.01122018, 0.01148154, 0.01174898, 0.01202264, 0.01230269,\n       0.01258925, 0.0128825 , 0.01318257, 0.01348963, 0.01380384,\n       0.01412538, 0.0144544 , 0.01479108, 0.01513561, 0.01548817,\n       0.01584893, 0.0162181 , 0.01659587, 0.01698244, 0.01737801,\n       0.01778279, 0.01819701, 0.01862087, 0.01905461, 0.01949845,\n       0.01995262, 0.02041738, 0.02089296, 0.02137962, 0.02187762,\n       0.02238721, 0.02290868, 0.02344229, 0.02398833, 0.02454709,\n       0.02511886, 0.02570396, 0.02630268, 0.02691535, 0.02754229,\n       0.02818383, 0.02884032, 0.02951209, 0.03019952, 0.03090295,\n       0.03162278, 0.03235937, 0.03311311, 0.03388442, 0.03467369,\n       0.03548134, 0.03630781, 0.03715352, 0.03801894, 0.03890451,\n       0.03981072, 0.04073803, 0.04168694, 0.04265795, 0.04365158,\n       0.04466836, 0.04570882, 0.04677351, 0.04786301, 0.04897788,\n       0.05011872, 0.05128614, 0.05248075, 0.05370318, 0.05495409,\n       0.05623413, 0.05754399, 0.05888437, 0.06025596, 0.0616595 ,\n       0.06309573, 0.06456542, 0.06606934, 0.0676083 , 0.0691831 ,\n       0.07079458, 0.0724436 , 0.07413102, 0.07585776, 0.07762471,\n       0.07943282, 0.08128305, 0.08317638, 0.0851138 , 0.08709636,\n       0.08912509, 0.09120108, 0.09332543, 0.09549926, 0.09772372,\n       0.1       , 0.1023293 , 0.10471285, 0.10715193, 0.10964782,\n       0.11220185, 0.11481536, 0.11748976, 0.12022644, 0.12302688,\n       0.12589254, 0.12882496, 0.13182567, 0.13489629, 0.13803843,\n       0.14125375, 0.14454398, 0.14791084, 0.15135612, 0.15488166,\n       0.15848932, 0.16218101, 0.16595869, 0.16982437, 0.17378008,\n       0.17782794, 0.18197009, 0.18620871, 0.19054607, 0.19498446,\n       0.19952623, 0.20417379, 0.20892961, 0.21379621, 0.21877616,\n       0.22387211, 0.22908677, 0.23442288, 0.23988329, 0.24547089,\n       0.25118864, 0.25703958, 0.2630268 , 0.26915348, 0.27542287,\n       0.28183829, 0.28840315, 0.29512092, 0.30199517, 0.30902954,\n       0.31622777, 0.32359366, 0.33113112, 0.33884416, 0.34673685,\n       0.35481339, 0.36307805, 0.37153523, 0.3801894 , 0.38904514,\n       0.39810717, 0.40738028, 0.41686938, 0.42657952, 0.43651583,\n       0.44668359, 0.45708819, 0.46773514, 0.47863009, 0.48977882,\n       0.50118723, 0.51286138, 0.52480746, 0.5370318 , 0.54954087,\n       0.56234133, 0.57543994, 0.58884366, 0.60255959, 0.616595  ,\n       0.63095734, 0.64565423, 0.66069345, 0.67608298, 0.69183097,\n       0.70794578, 0.72443596, 0.74131024, 0.75857758, 0.77624712,\n       0.79432823, 0.81283052, 0.83176377, 0.85113804, 0.87096359,\n       0.89125094, 0.91201084, 0.9332543 , 0.95499259, 0.97723722,\n       1.        , 1.02329299, 1.04712855, 1.07151931, 1.0964782 ,\n       1.12201845, 1.14815362, 1.17489755, 1.20226443, 1.23026877,\n       1.25892541, 1.28824955, 1.31825674, 1.34896288, 1.38038426,\n       1.41253754, 1.44543977, 1.47910839, 1.51356125, 1.54881662,\n       1.58489319, 1.6218101 , 1.65958691, 1.69824365, 1.73780083,\n       1.77827941, 1.81970086, 1.86208714, 1.90546072, 1.9498446 ,\n       1.99526231, 2.04173794, 2.08929613, 2.13796209, 2.18776162,\n       2.23872114, 2.29086765, 2.34422882, 2.39883292, 2.45470892,\n       2.51188643, 2.57039578, 2.63026799, 2.6915348 , 2.7542287 ,\n       2.81838293, 2.8840315 , 2.95120923, 3.01995172, 3.09029543,\n       3.16227766, 3.23593657, 3.31131121, 3.38844156, 3.4673685 ,\n       3.54813389, 3.63078055, 3.71535229, 3.80189396, 3.89045145,\n       3.98107171, 4.07380278, 4.16869383, 4.26579519, 4.36515832,\n       4.46683592, 4.5708819 , 4.67735141, 4.78630092, 4.89778819,\n       5.01187234, 5.12861384, 5.2480746 , 5.37031796, 5.49540874,\n       5.62341325, 5.75439937, 5.88843655, 6.02559586, 6.16595002,\n       6.30957344, 6.45654229, 6.60693448, 6.76082975, 6.91830971,\n       7.07945784, 7.2443596 , 7.41310241, 7.58577575, 7.76247117,\n       7.94328235, 8.12830516, 8.31763771, 8.51138038, 8.7096359 ,\n       8.91250938, 9.12010839, 9.33254301, 9.54992586, 9.77237221])\n\n\n\nw/(2*np.pi)\n\narray([0.01      , 0.01023293, 0.01047129, 0.01071519, 0.01096478,\n       0.01122018, 0.01148154, 0.01174898, 0.01202264, 0.01230269,\n       0.01258925, 0.0128825 , 0.01318257, 0.01348963, 0.01380384,\n       0.01412538, 0.0144544 , 0.01479108, 0.01513561, 0.01548817,\n       0.01584893, 0.0162181 , 0.01659587, 0.01698244, 0.01737801,\n       0.01778279, 0.01819701, 0.01862087, 0.01905461, 0.01949845,\n       0.01995262, 0.02041738, 0.02089296, 0.02137962, 0.02187762,\n       0.02238721, 0.02290868, 0.02344229, 0.02398833, 0.02454709,\n       0.02511886, 0.02570396, 0.02630268, 0.02691535, 0.02754229,\n       0.02818383, 0.02884032, 0.02951209, 0.03019952, 0.03090295,\n       0.03162278, 0.03235937, 0.03311311, 0.03388442, 0.03467369,\n       0.03548134, 0.03630781, 0.03715352, 0.03801894, 0.03890451,\n       0.03981072, 0.04073803, 0.04168694, 0.04265795, 0.04365158,\n       0.04466836, 0.04570882, 0.04677351, 0.04786301, 0.04897788,\n       0.05011872, 0.05128614, 0.05248075, 0.05370318, 0.05495409,\n       0.05623413, 0.05754399, 0.05888437, 0.06025596, 0.0616595 ,\n       0.06309573, 0.06456542, 0.06606934, 0.0676083 , 0.0691831 ,\n       0.07079458, 0.0724436 , 0.07413102, 0.07585776, 0.07762471,\n       0.07943282, 0.08128305, 0.08317638, 0.0851138 , 0.08709636,\n       0.08912509, 0.09120108, 0.09332543, 0.09549926, 0.09772372,\n       0.1       , 0.1023293 , 0.10471285, 0.10715193, 0.10964782,\n       0.11220185, 0.11481536, 0.11748976, 0.12022644, 0.12302688,\n       0.12589254, 0.12882496, 0.13182567, 0.13489629, 0.13803843,\n       0.14125375, 0.14454398, 0.14791084, 0.15135612, 0.15488166,\n       0.15848932, 0.16218101, 0.16595869, 0.16982437, 0.17378008,\n       0.17782794, 0.18197009, 0.18620871, 0.19054607, 0.19498446,\n       0.19952623, 0.20417379, 0.20892961, 0.21379621, 0.21877616,\n       0.22387211, 0.22908677, 0.23442288, 0.23988329, 0.24547089,\n       0.25118864, 0.25703958, 0.2630268 , 0.26915348, 0.27542287,\n       0.28183829, 0.28840315, 0.29512092, 0.30199517, 0.30902954,\n       0.31622777, 0.32359366, 0.33113112, 0.33884416, 0.34673685,\n       0.35481339, 0.36307805, 0.37153523, 0.3801894 , 0.38904514,\n       0.39810717, 0.40738028, 0.41686938, 0.42657952, 0.43651583,\n       0.44668359, 0.45708819, 0.46773514, 0.47863009, 0.48977882,\n       0.50118723, 0.51286138, 0.52480746, 0.5370318 , 0.54954087,\n       0.56234133, 0.57543994, 0.58884366, 0.60255959, 0.616595  ,\n       0.63095734, 0.64565423, 0.66069345, 0.67608298, 0.69183097,\n       0.70794578, 0.72443596, 0.74131024, 0.75857758, 0.77624712,\n       0.79432823, 0.81283052, 0.83176377, 0.85113804, 0.87096359,\n       0.89125094, 0.91201084, 0.9332543 , 0.95499259, 0.97723722,\n       1.        , 1.02329299, 1.04712855, 1.07151931, 1.0964782 ,\n       1.12201845, 1.14815362, 1.17489755, 1.20226443, 1.23026877,\n       1.25892541, 1.28824955, 1.31825674, 1.34896288, 1.38038426,\n       1.41253754, 1.44543977, 1.47910839, 1.51356125, 1.54881662,\n       1.58489319, 1.6218101 , 1.65958691, 1.69824365, 1.73780083,\n       1.77827941, 1.81970086, 1.86208714, 1.90546072, 1.9498446 ,\n       1.99526231, 2.04173794, 2.08929613, 2.13796209, 2.18776162,\n       2.23872114, 2.29086765, 2.34422882, 2.39883292, 2.45470892,\n       2.51188643, 2.57039578, 2.63026799, 2.6915348 , 2.7542287 ,\n       2.81838293, 2.8840315 , 2.95120923, 3.01995172, 3.09029543,\n       3.16227766, 3.23593657, 3.31131121, 3.38844156, 3.4673685 ,\n       3.54813389, 3.63078055, 3.71535229, 3.80189396, 3.89045145,\n       3.98107171, 4.07380278, 4.16869383, 4.26579519, 4.36515832,\n       4.46683592, 4.5708819 , 4.67735141, 4.78630092, 4.89778819,\n       5.01187234, 5.12861384, 5.2480746 , 5.37031796, 5.49540874,\n       5.62341325, 5.75439937, 5.88843655, 6.02559586, 6.16595002,\n       6.30957344, 6.45654229, 6.60693448, 6.76082975, 6.91830971,\n       7.07945784, 7.2443596 , 7.41310241, 7.58577575, 7.76247117,\n       7.94328235, 8.12830516, 8.31763771, 8.51138038, 8.7096359 ,\n       8.91250938, 9.12010839, 9.33254301, 9.54992586, 9.77237221])\n\n\n\nfrequency[0:-1] - w/(2*np.pi)\n\narray([ 0.00000000e+00, -3.98986399e-17,  3.46944695e-18,  3.46944695e-17,\n       -5.03069808e-17, -3.46944695e-17, -2.94902991e-17,  1.73472348e-18,\n       -3.12250226e-17, -1.90819582e-17,  2.42861287e-17, -3.98986399e-17,\n        2.60208521e-17, -3.12250226e-17, -5.03069808e-17, -3.98986399e-17,\n        2.77555756e-17,  2.94902991e-17,  2.08166817e-17, -1.04083409e-17,\n       -3.46944695e-17,  0.00000000e+00, -6.93889390e-18, -4.16333634e-17,\n       -5.55111512e-17, -2.77555756e-17, -3.46944695e-17,  2.42861287e-17,\n        2.77555756e-17, -5.55111512e-17,  0.00000000e+00,  6.93889390e-18,\n        0.00000000e+00, -2.42861287e-17, -3.12250226e-17,  0.00000000e+00,\n       -2.77555756e-17, -2.77555756e-17,  3.46944695e-18, -1.04083409e-17,\n        3.46944695e-18, -4.16333634e-17, -1.73472348e-17, -5.20417043e-17,\n       -5.89805982e-17, -3.12250226e-17, -5.89805982e-17, -5.20417043e-17,\n       -5.89805982e-17, -3.46944695e-18, -9.02056208e-17, -2.77555756e-17,\n       -1.38777878e-17, -5.55111512e-17, -6.24500451e-17, -4.85722573e-17,\n       -4.16333634e-17, -6.24500451e-17, -2.77555756e-17, -4.85722573e-17,\n       -3.46944695e-17, -6.24500451e-17, -4.16333634e-17, -5.55111512e-17,\n       -1.11022302e-16, -9.71445147e-17, -1.11022302e-16, -1.11022302e-16,\n       -1.52655666e-16, -1.17961196e-16, -1.45716772e-16, -8.32667268e-17,\n       -1.59594560e-16, -6.93889390e-17, -1.52655666e-16, -1.11022302e-16,\n       -9.71445147e-17, -9.71445147e-17, -1.80411242e-16, -1.17961196e-16,\n       -1.24900090e-16, -1.66533454e-16, -2.08166817e-16, -1.80411242e-16,\n       -1.24900090e-16, -2.08166817e-16, -1.80411242e-16, -1.80411242e-16,\n       -1.52655666e-16, -1.94289029e-16, -2.35922393e-16, -2.35922393e-16,\n       -1.80411242e-16, -2.77555756e-16, -2.35922393e-16, -2.91433544e-16,\n       -2.63677968e-16, -2.91433544e-16, -2.91433544e-16, -2.63677968e-16,\n       -3.05311332e-16, -4.16333634e-16,  4.16333634e-17, -6.52256027e-16,\n       -5.13478149e-16, -3.60822483e-16, -2.91433544e-16,  2.77555756e-17,\n       -3.19189120e-16, -1.66533454e-16, -7.49400542e-16, -4.16333634e-16,\n       -7.21644966e-16, -3.88578059e-16, -5.27355937e-16, -4.71844785e-16,\n       -7.21644966e-16, -7.21644966e-16, -8.04911693e-16, -1.11022302e-16,\n       -3.33066907e-16, -9.71445147e-16, -1.02695630e-15, -4.16333634e-16,\n       -5.55111512e-16, -3.05311332e-16, -3.60822483e-16, -7.49400542e-16,\n       -7.49400542e-16, -5.82867088e-16, -9.99200722e-16, -9.43689571e-16,\n       -9.71445147e-16, -1.24900090e-15, -1.27675648e-15, -9.71445147e-16,\n       -1.36002321e-15, -1.30451205e-15, -1.11022302e-15, -1.11022302e-15,\n       -1.05471187e-15, -1.33226763e-15, -1.16573418e-15, -1.55431223e-15,\n       -1.60982339e-15, -1.38777878e-15, -1.55431223e-15, -1.55431223e-15,\n       -1.60982339e-15, -1.05471187e-15, -1.94289029e-15, -1.22124533e-15,\n       -1.11022302e-15, -1.55431223e-15, -1.66533454e-15, -1.49880108e-15,\n       -1.38777878e-15, -1.55431223e-15, -2.27595720e-15, -1.66533454e-15,\n       -2.33146835e-15, -1.83186799e-15, -2.55351296e-15, -1.77635684e-15,\n       -2.16493490e-15, -2.27595720e-15, -2.16493490e-15, -2.05391260e-15,\n       -2.27595720e-15, -2.22044605e-15, -2.22044605e-15, -2.77555756e-15,\n       -2.55351296e-15, -2.66453526e-15, -2.55351296e-15, -3.10862447e-15,\n       -2.88657986e-15, -2.99760217e-15, -2.77555756e-15, -3.21964677e-15,\n       -3.33066907e-15, -3.66373598e-15, -4.10782519e-15, -3.88578059e-15,\n       -3.66373598e-15, -3.99680289e-15, -4.32986980e-15, -4.77395901e-15,\n       -4.99600361e-15, -4.99600361e-15, -4.66293670e-15, -4.55191440e-15,\n       -4.88498131e-15, -4.32986980e-15, -4.44089210e-15, -5.44009282e-15,\n       -5.66213743e-15, -4.99600361e-15, -5.88418203e-15, -5.66213743e-15,\n       -5.99520433e-15, -4.66293670e-15, -9.54791801e-15, -7.10542736e-15,\n       -5.10702591e-15, -2.88657986e-15, -2.88657986e-15, -9.10382880e-15,\n       -3.10862447e-15, -1.11022302e-14, -7.54951657e-15, -3.77475828e-15,\n       -7.32747196e-15, -3.33066907e-15, -5.10702591e-15, -4.21884749e-15,\n       -7.99360578e-15, -7.32747196e-15, -8.65973959e-15, -1.13242749e-14,\n       -1.42108547e-14, -9.54791801e-15, -1.13242749e-14, -1.44328993e-14,\n       -1.62092562e-14, -1.26565425e-14, -1.42108547e-14, -7.54951657e-15,\n       -1.84297022e-14, -1.55431223e-14, -1.06581410e-14, -9.76996262e-15,\n       -1.86517468e-14, -1.24344979e-14, -1.15463195e-14, -1.99840144e-14,\n       -1.24344979e-14, -2.30926389e-14, -1.99840144e-14, -2.08721929e-14,\n       -1.95399252e-14, -2.48689958e-14, -2.13162821e-14, -1.68753900e-14,\n       -1.64313008e-14, -2.48689958e-14, -2.53130850e-14, -2.70894418e-14,\n       -2.66453526e-14, -2.17603713e-14, -2.93098879e-14, -2.39808173e-14,\n       -3.10862447e-14, -2.75335310e-14, -2.62012634e-14, -2.66453526e-14,\n       -3.41948692e-14, -2.35367281e-14, -3.28626015e-14, -2.48689958e-14,\n       -3.33066907e-14, -3.64153152e-14, -3.46389584e-14, -3.55271368e-14,\n       -4.08562073e-14, -3.99680289e-14, -4.17443857e-14, -4.08562073e-14,\n       -4.52970994e-14, -4.17443857e-14, -4.44089210e-14, -3.81916720e-14,\n       -4.88498131e-14, -4.70734562e-14, -4.88498131e-14, -5.15143483e-14,\n       -5.24025268e-14, -4.97379915e-14, -5.15143483e-14, -5.24025268e-14,\n       -5.68434189e-14, -5.59552404e-14, -5.68434189e-14, -5.95079541e-14,\n       -5.32907052e-14, -6.03961325e-14, -5.95079541e-14, -6.75015599e-14,\n       -6.57252031e-14, -6.92779167e-14, -6.39488462e-14, -7.46069873e-14,\n       -6.92779167e-14, -7.81597009e-14, -7.46069873e-14, -7.99360578e-14,\n       -7.63833441e-14, -8.34887715e-14, -8.88178420e-14, -9.23705556e-14])\n\n\n\nnp.abs(voltage[0:-1])-10**(mag/20)\n\narray([-1.10671924e-06, -1.12132160e-06, -1.13521907e-06, -1.14837042e-06,\n       -1.16073483e-06, -1.17227210e-06, -1.18294262e-06, -1.19270739e-06,\n       -1.20152808e-06, -1.20936703e-06, -1.21618723e-06, -1.22195234e-06,\n       -1.22662672e-06, -1.23017529e-06, -1.23256359e-06, -1.23375777e-06,\n       -1.23372443e-06, -1.23243067e-06, -1.22984403e-06, -1.22593242e-06,\n       -1.22066405e-06, -1.21400742e-06, -1.20593125e-06, -1.19640444e-06,\n       -1.18539599e-06, -1.17287505e-06, -1.15881078e-06, -1.14317245e-06,\n       -1.12592933e-06, -1.10705074e-06, -1.08650608e-06, -1.06426481e-06,\n       -1.04029657e-06, -1.01457116e-06, -9.87058675e-07, -9.57729588e-07,\n       -9.26554902e-07, -8.93506268e-07, -8.58556142e-07, -8.21678031e-07,\n       -7.82846667e-07, -7.42038322e-07, -6.99231020e-07, -6.54404907e-07,\n       -6.07542555e-07, -5.58629422e-07, -5.07654102e-07, -4.54608985e-07,\n       -3.99490583e-07, -3.42300142e-07, -2.83044123e-07, -2.21734867e-07,\n       -1.58391140e-07, -9.30388975e-08, -2.57118593e-08,  4.35476721e-08,\n        1.14688172e-07,  1.87647997e-07,  2.62354710e-07,  3.38724218e-07,\n        4.16660003e-07,  4.96052209e-07,  5.76776962e-07,  6.58695502e-07,\n        7.41653336e-07,  8.25479569e-07,  9.09986104e-07,  9.94966973e-07,\n        1.08019766e-06,  1.16543452e-06,  1.25041422e-06,  1.33485323e-06,\n        1.41844752e-06,  1.50087211e-06,  1.58178091e-06,  1.66080648e-06,\n        1.73756001e-06,  1.81163126e-06,  1.88258868e-06,  1.94997959e-06,\n        2.01333036e-06,  2.07214677e-06,  2.12591435e-06,  2.17409880e-06,\n        2.21614648e-06,  2.25148491e-06,  2.27952330e-06,  2.29965302e-06,\n        2.31124827e-06,  2.31366646e-06,  2.30624880e-06,  2.28832069e-06,\n        2.25919220e-06,  2.21815830e-06,  2.16449927e-06,  2.09748074e-06,\n        2.01635393e-06,  1.92035553e-06,  1.80870764e-06,  1.68061756e-06,\n        1.53527750e-06,  1.37186406e-06,  1.18953770e-06,  9.87442109e-07,\n        7.64703358e-07,  5.20429049e-07,  2.53707263e-07, -3.63945709e-08,\n       -3.50830838e-07, -6.90579189e-07, -1.05664182e-06, -1.45004715e-06,\n       -1.87185136e-06, -2.32314011e-06, -2.80503044e-06, -3.31867259e-06,\n       -3.86525210e-06, -4.44599193e-06, -5.06215468e-06, -5.71504504e-06,\n       -6.40601236e-06, -7.13645340e-06, -7.90781530e-06, -8.72159888e-06,\n       -9.57936222e-06, -1.04827247e-05, -1.14333715e-05, -1.24330588e-05,\n       -1.34836197e-05, -1.45869710e-05, -1.57451218e-05, -1.69601825e-05,\n       -1.82343771e-05, -1.95700570e-05, -2.09697184e-05, -2.24360236e-05,\n       -2.39718274e-05, -2.55802111e-05, -2.72645240e-05, -2.90284384e-05,\n       -3.08760190e-05, -3.28118145e-05, -3.48409781e-05, -3.69694284e-05,\n       -3.92040674e-05, -4.15530793e-05, -4.40263476e-05, -4.66360462e-05,\n       -4.93974945e-05, -5.23304180e-05, -5.54608493e-05, -5.88240575e-05,\n       -6.24691539e-05, -6.64664225e-05, -7.09188148e-05, -7.59780462e-05,\n       -8.18540343e-05, -8.87210806e-05, -9.57931429e-05, -9.44902692e-05,\n       -5.31137497e-05,  4.50827102e-06,  3.65898637e-05,  5.41971212e-05,\n        6.57180738e-05,  7.44164704e-05,  8.16578091e-05,  8.80886358e-05,\n        9.40491357e-05,  9.97340360e-05,  1.05262621e-04,  1.10712162e-04,\n        1.16135148e-04,  1.21568752e-04,  1.27040312e-04,  1.32570659e-04,\n        1.38176214e-04,  1.43870362e-04,  1.49664377e-04,  1.55568074e-04,\n        1.61590271e-04,  1.67739139e-04,  1.74022472e-04,  1.80447903e-04,\n        1.87023083e-04,  1.93755853e-04,  2.00654386e-04,  2.07727346e-04,\n        2.14984039e-04,  2.22434585e-04,  2.30090107e-04,  2.37962945e-04,\n        2.46066913e-04,  2.54417608e-04,  2.63032771e-04,  2.71932741e-04,\n        2.81141011e-04,  2.90684903e-04,  3.00596428e-04,  3.10913342e-04,\n        3.21680478e-04,  3.32951414e-04,  3.44790582e-04,  3.57275915e-04,\n        3.70502212e-04,  3.84585377e-04,  3.99667801e-04,  4.15925175e-04,\n        4.33575101e-04,  4.52887991e-04,  4.74200765e-04,  4.97934052e-04,\n        5.24613580e-04,  5.54896582e-04,  5.89603865e-04,  6.29758078e-04,\n        6.76628018e-04,  7.31777754e-04,  7.97117381e-04,  8.74948958e-04,\n        9.67996427e-04,  1.07940145e-03,  1.21265870e-03,  1.37145548e-03,\n        1.55937464e-03,  1.77942394e-03,  2.03337695e-03,  2.32096092e-03,\n        2.63900690e-03,  2.98077187e-03,  3.33571053e-03,  3.68995488e-03,\n        4.02760852e-03,  4.33269791e-03,  4.59134992e-03,  4.79363233e-03,\n        4.93459136e-03,  5.01430396e-03,  5.03708520e-03,  5.01020093e-03,\n        4.94247382e-03,  4.84307518e-03,  4.72064936e-03,  4.58279036e-03,\n        4.43581352e-03,  4.28473612e-03,  4.13338407e-03,  3.98455977e-03,\n        3.84022718e-03,  3.70168830e-03,  3.56973811e-03,  3.44479360e-03,\n        3.32699725e-03,  3.21629761e-03,  3.11251086e-03,  3.01536662e-03,\n        2.92454182e-03,  2.83968496e-03,  2.76043342e-03,  2.68642544e-03,\n        2.61730809e-03,  2.55274256e-03,  2.49240722e-03,  2.43599936e-03,\n        2.38323584e-03,  2.33385305e-03,  2.28760638e-03,  2.24426949e-03,\n        2.20363323e-03,  2.16550468e-03,  2.12970593e-03,  2.09607307e-03,\n        2.06445507e-03,  2.03471275e-03,  2.00671787e-03,  1.98035217e-03,\n        1.95550656e-03,  1.93208036e-03,  1.90998057e-03,  1.88912122e-03,\n        1.86942281e-03,  1.85081173e-03,  1.83321976e-03,  1.81658367e-03,\n        1.80084475e-03,  1.78594848e-03,  1.77184417e-03,  1.75848464e-03,\n        1.74582596e-03,  1.73382721e-03,  1.72245017e-03,  1.71165919e-03,\n        1.70142097e-03,  1.69170434e-03,  1.68248016e-03,  1.67372114e-03,\n        1.66540169e-03,  1.65749783e-03,  1.64998704e-03,  1.64284818e-03])\n\n\n\n10**(mag/20)\n\narray([  9.9368309 ,   9.9344965 ,   9.93208447,   9.92959228,\n         9.9270173 ,   9.92435681,   9.92160797,   9.91876785,\n         9.9158334 ,   9.91280145,   9.90966875,   9.90643189,\n         9.90308739,   9.89963161,   9.89606084,   9.89237121,\n         9.88855876,   9.88461942,   9.88054898,   9.87634315,\n         9.87199751,   9.86750756,   9.86286868,   9.85807617,\n         9.85312525,   9.84801103,   9.84272858,   9.83727288,\n         9.83163887,   9.82582143,   9.81981543,   9.81361567,\n         9.80721697,   9.80061414,   9.793802  ,   9.78677538,\n         9.77952917,   9.77205827,   9.76435769,   9.75642247,\n         9.74824776,   9.73982882,   9.73116098,   9.72223973,\n         9.71306068,   9.70361956,   9.69391227,   9.68393484,\n         9.67368346,   9.66315448,   9.65234438,   9.6412498 ,\n         9.62986752,   9.61819442,   9.60622754,   9.59396395,\n         9.58140085,   9.56853546,   9.555365  ,   9.5418867 ,\n         9.52809772,   9.51399514,   9.49957588,   9.48483667,\n         9.46977402,   9.45438411,   9.43866278,   9.42260544,\n         9.40620702,   9.38946189,   9.3723638 ,   9.35490579,\n         9.33708014,   9.31887831,   9.30029079,   9.28130712,\n         9.26191576,   9.24210401,   9.22185797,   9.20116243,\n         9.18000084,   9.15835519,   9.13620596,   9.11353207,\n         9.09031079,   9.06651766,   9.04212648,   9.01710917,\n         8.99143578,   8.96507439,   8.93799106,   8.91014976,\n         8.88151234,   8.85203843,   8.82168543,   8.79040842,\n         8.75816013,   8.72489083,   8.69054834,   8.65507793,\n         8.61842226,   8.58052133,   8.54131243,   8.50073004,\n         8.45870581,   8.41516844,   8.37004367,   8.32325417,\n         8.27471946,   8.22435589,   8.17207649,   8.11779097,\n         8.06140556,   8.00282301,   7.94194245,   7.87865932,\n         7.8128653 ,   7.74444823,   7.67329198,   7.59927641,\n         7.52227726,   7.44216608,   7.35881012,   7.27207224,\n         7.18181087,   7.08787986,   6.99012847,   6.88840121,\n         6.78253782,   6.67237318,   6.55773725,   6.43845495,\n         6.31434621,   6.1852258 ,   6.05090339,   5.9111835 ,\n         5.76586547,   5.61474351,   5.45760681,   5.29423955,\n         5.12442118,   4.94792663,   4.76452673,   4.57398881,\n         4.37607755,   4.17055628,   3.9571888 ,   3.73574227,\n         3.50599152,   3.26772591,   3.02076031,   2.76495377,\n         2.50024204,   2.22669807,   1.94465192,   1.65494965,\n         1.35957568,   1.06337143,   0.77965851,   0.55110752,\n         0.49424884,   0.6765313 ,   0.98713649,   1.35185728,\n         1.74718689,   2.16530403,   2.60326938,   3.05996328,\n         3.53506402,   4.02865089,   4.54103069,   5.07265502,\n         5.62407851,   6.19593709,   6.78893698,   7.40384962,\n         8.0415103 ,   8.70281921,   9.38874413,  10.10032444,\n        10.8386762 ,  11.60499822,  12.40057898,  13.22680451,\n        14.08516713,  14.97727526,  15.90486414,  16.86980772,\n        17.87413175,  18.92002816,  20.00987078,  21.1462327 ,\n        22.33190522,  23.56991858,  24.8635647 ,  26.21642191,\n        27.63238196,  29.11567929,  30.67092275,  32.30312966,\n        34.01776235,  35.82076674,  37.71861285,  39.71833641,\n        41.82758078,  44.05463752,  46.40848352,  48.89881162,\n        51.53605013,  54.33136527,  57.29663783,  60.4444027 ,\n        63.78773547,  67.34006562,  71.11488908,  75.12534556,\n        79.38361718,  83.90009606,  88.68226066,  93.73319743,\n        99.04971053, 104.61998566, 110.42082634, 116.41457419,\n       122.54597091, 128.73941985, 134.89733657, 140.90047865,\n       146.61120247, 151.88036575, 156.55796603, 160.50660464,\n       163.61574972, 165.81400794, 167.07667085, 167.42683301,\n       166.93005034, 165.68413107, 163.80659245, 161.42233677,\n       158.65341023, 155.61174403, 152.39492868, 149.08453393,\n       145.74626873, 142.43128694, 139.17807522, 136.01452316,\n       132.95992594, 130.02678437, 127.22234624, 124.54988153,\n       122.00971055, 119.60001655, 117.31747748, 115.1577502 ,\n       113.11583703, 111.18635946, 109.36376004, 107.6424488 ,\n       106.01690753, 104.48176211, 103.03183092, 101.66215549,\n       100.36801792,  99.14494885,  97.98872851,  96.89538292,\n        95.8611768 ,  94.88260427,  93.95637819,  93.07941877,\n        92.2488418 ,  91.46194705,  90.71620671,  90.00925431,\n        89.33887416,  88.70299121,  88.09966157,  87.52706355,\n        86.98348931,  86.46733704,  85.97710368,  85.51137818,\n        85.06883519,  84.64822921,  84.24838927,  83.86821382,\n        83.50666613,  83.16277001,  82.83560579,  82.52430663,\n        82.2280551 ,  81.94608001,  81.67765346,  81.42208808,\n        81.17873453,  80.94697911,  80.72624158,  80.51597311])\n\n\n\nvoltage[0:-1]\n\narray([ 9.93014466e+00-3.64435752e-01j,  9.92749968e+00-3.72758127e-01j,\n        9.92476347e+00-3.81247326e-01j,  9.92193298e+00-3.89905032e-01j,\n        9.91900507e+00-3.98732851e-01j,  9.91597646e+00-4.07732313e-01j,\n        9.91284377e+00-4.16904864e-01j,  9.90960349e+00-4.26251863e-01j,\n        9.90625200e+00-4.35774574e-01j,  9.90278554e+00-4.45474161e-01j,\n        9.89920024e+00-4.55351684e-01j,  9.89549210e+00-4.65408091e-01j,\n        9.89165699e+00-4.75644210e-01j,  9.88769067e+00-4.86060744e-01j,\n        9.88358874e+00-4.96658265e-01j,  9.87934670e+00-5.07437203e-01j,\n        9.87495993e+00-5.18397842e-01j,  9.87042368e+00-5.29540309e-01j,\n        9.86573309e+00-5.40864568e-01j,  9.86088316e+00-5.52370410e-01j,\n        9.85586881e+00-5.64057447e-01j,  9.85068483e+00-5.75925100e-01j,\n        9.84532595e+00-5.87972594e-01j,  9.83978676e+00-6.00198949e-01j,\n        9.83406179e+00-6.12602969e-01j,  9.82814550e+00-6.25183238e-01j,\n        9.82203227e+00-6.37938109e-01j,  9.81571643e+00-6.50865701e-01j,\n        9.80919225e+00-6.63963889e-01j,  9.80245399e+00-6.77230298e-01j,\n        9.79549586e+00-6.90662304e-01j,  9.78831209e+00-7.04257023e-01j,\n        9.78089690e+00-7.18011312e-01j,  9.77324451e+00-7.31921769e-01j,\n        9.76534920e+00-7.45984730e-01j,  9.75720530e+00-7.60196274e-01j,\n        9.74880718e+00-7.74552224e-01j,  9.74014930e+00-7.89048153e-01j,\n        9.73122622e+00-8.03679394e-01j,  9.72203259e+00-8.18441046e-01j,\n        9.71256319e+00-8.33327989e-01j,  9.70281293e+00-8.48334895e-01j,\n        9.69277688e+00-8.63456249e-01j,  9.68245026e+00-8.78686364e-01j,\n        9.67182843e+00-8.94019406e-01j,  9.66090697e+00-9.09449414e-01j,\n        9.64968161e+00-9.24970332e-01j,  9.63814826e+00-9.40576034e-01j,\n        9.62630304e+00-9.56260359e-01j,  9.61414222e+00-9.72017138e-01j,\n        9.60166226e+00-9.87840239e-01j,  9.58885981e+00-1.00372360e+00j,\n        9.57573163e+00-1.01966126e+00j,  9.56227466e+00-1.03564741e+00j,\n        9.54848593e+00-1.05167644e+00j,  9.53436260e+00-1.06774297e+00j,\n        9.51990185e+00-1.08384189e+00j,  9.50510094e+00-1.09996841e+00j,\n        9.48995709e+00-1.11611809e+00j,  9.47446751e+00-1.13228690e+00j,\n        9.45862928e+00-1.14847125e+00j,  9.44243938e+00-1.16466803e+00j,\n        9.42589455e+00-1.18087461e+00j,  9.40899130e+00-1.19708895e+00j,\n        9.39172583e+00-1.21330954e+00j,  9.37409393e+00-1.22953547e+00j,\n        9.35609097e+00-1.24576648e+00j,  9.33771175e+00-1.26200289e+00j,\n        9.31895052e+00-1.27824569e+00j,  9.29980082e+00-1.29449651e+00j,\n        9.28025544e+00-1.31075762e+00j,  9.26030634e+00-1.32703192e+00j,\n        9.23994457e+00-1.34332294e+00j,  9.21916016e+00-1.35963481e+00j,\n        9.19794208e+00-1.37597225e+00j,  9.17627815e+00-1.39234050e+00j,\n        9.15415492e+00-1.40874531e+00j,  9.13155765e+00-1.42519292e+00j,\n        9.10847019e+00-1.44168992e+00j,  9.08487493e+00-1.45824331e+00j,\n        9.06075269e+00-1.47486034e+00j,  9.03608272e+00-1.49154847e+00j,\n        9.01084253e+00-1.50831533e+00j,  8.98500792e+00-1.52516859e+00j,\n        8.95855285e+00-1.54211589e+00j,  8.93144941e+00-1.55916477e+00j,\n        8.90366777e+00-1.57632254e+00j,  8.87517607e+00-1.59359622e+00j,\n        8.84594045e+00-1.61099241e+00j,  8.81592492e+00-1.62851720e+00j,\n        8.78509134e+00-1.64617602e+00j,  8.75339942e+00-1.66397360e+00j,\n        8.72080658e+00-1.68191379e+00j,  8.68726801e+00-1.69999947e+00j,\n        8.65273653e+00-1.71823241e+00j,  8.61716263e+00-1.73661318e+00j,\n        8.58049441e+00-1.75514096e+00j,  8.54267752e+00-1.77381349e+00j,\n        8.50365515e+00-1.79262686e+00j,  8.46336797e+00-1.81157544e+00j,\n        8.42175416e+00-1.83065167e+00j,  8.37874929e+00-1.84984598e+00j,\n        8.33428637e+00-1.86914661e+00j,  8.28829576e+00-1.88853949e+00j,\n        8.24070520e+00-1.90800802e+00j,  8.19143975e+00-1.92753300e+00j,\n        8.14042176e+00-1.94709241e+00j,  8.08757088e+00-1.96666126e+00j,\n        8.03280403e+00-1.98621141e+00j,  7.97603536e+00-2.00571141e+00j,\n        7.91717628e+00-2.02512633e+00j,  7.85613541e+00-2.04441752e+00j,\n        7.79281861e+00-2.06354248e+00j,  7.72712894e+00-2.08245463e+00j,\n        7.65896671e+00-2.10110311e+00j,  7.58822943e+00-2.11943258e+00j,\n        7.51481189e+00-2.13738302e+00j,  7.43860612e+00-2.15488945e+00j,\n        7.35950145e+00-2.17188178e+00j,  7.27738455e+00-2.18828454e+00j,\n        7.19213943e+00-2.20401663e+00j,  7.10364753e+00-2.21899112e+00j,\n        7.01178776e+00-2.23311494e+00j,  6.91643657e+00-2.24628872e+00j,\n        6.81746802e+00-2.25840642e+00j,  6.71475387e+00-2.26935517e+00j,\n        6.60816367e+00-2.27901493e+00j,  6.49756489e+00-2.28725828e+00j,\n        6.38282298e+00-2.29395011e+00j,  6.26380158e+00-2.29894736e+00j,\n        6.14036258e+00-2.30209874e+00j,  6.01236631e+00-2.30324448e+00j,\n        5.87967169e+00-2.30221601e+00j,  5.74213640e+00-2.29883571e+00j,\n        5.59961707e+00-2.29291665e+00j,  5.45196945e+00-2.28426229e+00j,\n        5.29904863e+00-2.27266621e+00j,  5.14070924e+00-2.25791186e+00j,\n        4.97680567e+00-2.23977227e+00j,  4.80719227e+00-2.21800981e+00j,\n        4.63172363e+00-2.19237593e+00j,  4.45025475e+00-2.16261089e+00j,\n        4.26264133e+00-2.12844351e+00j,  4.06873997e+00-2.08959097e+00j,\n        3.86840843e+00-2.04575850e+00j,  3.66150584e+00-1.99663919e+00j,\n        3.44789295e+00-1.94191374e+00j,  3.22743233e+00-1.88125023e+00j,\n        2.99998860e+00-1.81430388e+00j,  2.76542862e+00-1.74071685e+00j,\n        2.52362166e+00-1.66011793e+00j,  2.27443956e+00-1.57212237e+00j,\n        2.01775690e+00-1.47633159e+00j,  1.75345107e+00-1.37233291e+00j,\n        1.48140236e+00-1.25969930e+00j,  1.20149403e+00-1.13798900e+00j,\n        9.13612295e-01-1.00674526e+00j,  6.17646301e-01-8.65495911e-01j,\n        3.13488046e-01-7.13752947e-01j,  1.03224968e-03-5.51012061e-01j,\n       -3.19823823e-01-3.76752086e-01j, -6.49180602e-01-1.90434374e-01j,\n       -9.87136500e-01+8.49792674e-03j, -1.33378827e+00+2.20620697e-01j,\n       -1.68923143e+00+4.46529800e-01j, -2.05356072e+00+6.86842186e-01j,\n       -2.42687065e+00+9.42197153e-01j, -2.80925611e+00+1.21325781e+00j,\n       -3.20081300e+00+1.50071274e+00j, -3.60163896e+00+1.80527793e+00j,\n       -4.01183409e+00+2.12769898e+00j, -4.43150177e+00+2.46875357e+00j,\n       -4.86074943e+00+2.82925439e+00j, -5.29968935e+00+3.21005230e+00j,\n       -5.74843949e+00+3.61204010e+00j, -6.20712426e+00+4.03615667e+00j,\n       -6.67587515e+00+4.48339171e+00j, -7.15483141e+00+4.95479101e+00j,\n       -7.64414043e+00+5.45146254e+00j, -8.14395808e+00+5.97458310e+00j,\n       -8.65444870e+00+6.52540591e+00j, -9.17578484e+00+7.10526914e+00j,\n       -9.70814658e+00+7.71560530e+00j, -1.02517204e+01+8.35795195e+00j,\n       -1.08066972e+01+9.03396352e+00j, -1.13732704e+01+9.74542454e+00j,\n       -1.19516317e+01+1.04942645e+01j, -1.25419673e+01+1.12825741e+01j,\n       -1.31444518e+01+1.21126239e+01j, -1.37592409e+01+1.29868847e+01j,\n       -1.43864617e+01+1.39080501e+01j, -1.50262016e+01+1.48790620e+01j,\n       -1.56784932e+01+1.59031390e+01j, -1.63432967e+01+1.69838072e+01j,\n       -1.70204774e+01+1.81249353e+01j, -1.77097788e+01+1.93307727e+01j,\n       -1.84107887e+01+2.06059925e+01j, -1.91228991e+01+2.19557381e+01j,\n       -1.98452554e+01+2.33856747e+01j, -2.05766957e+01+2.49020454e+01j,\n       -2.13156765e+01+2.65117328e+01j, -2.20601812e+01+2.82223243e+01j,\n       -2.28076092e+01+3.00421824e+01j, -2.35546409e+01+3.19805178e+01j,\n       -2.42970717e+01+3.40474641e+01j, -2.50296119e+01+3.62541515e+01j,\n       -2.57456410e+01+3.86127752e+01j, -2.64369112e+01+4.11366525e+01j,\n       -2.70931871e+01+4.38402596e+01j, -2.77018112e+01+4.67392353e+01j,\n       -2.82471816e+01+4.98503338e+01j, -2.87101297e+01+5.31913006e+01j,\n       -2.90671842e+01+5.67806387e+01j, -2.92897134e+01+6.06372151e+01j,\n       -2.93429433e+01+6.47796495e+01j, -2.91848625e+01+6.92253997e+01j,\n       -2.87650504e+01+7.39894451e+01j, -2.80234982e+01+7.90824409e+01j,\n       -2.68895534e+01+8.45082046e+01j, -2.52811980e+01+9.02603864e+01j,\n       -2.31049835e+01+9.63182052e+01j, -2.02570849e+01+1.02641209e+02j,\n       -1.66260886e+01+1.09163180e+02j, -1.20982512e+01+1.15785598e+02j,\n       -6.56599046e+00+1.22371504e+02j,  5.98375510e-02+1.28741185e+02j,\n        7.83390002e+00+1.34671712e+02j,  1.67576876e+01+1.39902748e+02j,\n        2.67607906e+01+1.44150888e+02j,  3.76864428e+01+1.47133555e+02j,\n        4.92866464e+01+1.48601035e+02j,  6.12316183e+01+1.48371977e+02j,\n        7.31354694e+01+1.46364732e+02j,  8.45953480e+01+1.42616090e+02j,\n        9.52364709e+01+1.37281327e+02j,  1.04752893e+02+1.30614627e+02j,\n        1.12935023e+02+1.22934819e+02j,  1.19679300e+02+1.14585156e+02j,\n        1.24980932e+02+1.05896254e+02j,  1.28914709e+02+9.71585621e+01j,\n        1.31610428e+02+8.86068182e+01j,  1.33228639e+02+8.04154962e+01j,\n        1.33940378e+02+7.27023271e+01j,  1.33912391e+02+6.55365258e+01j,\n        1.33297784e+02+5.89488641e+01j,  1.32231147e+02+5.29416272e+01j,\n        1.30826941e+02+4.74973540e+01j,  1.29180005e+02+4.25859215e+01j,\n        1.27367257e+02+3.81699485e+01j,  1.25449956e+02+3.42087092e+01j,\n        1.23476099e+02+3.06608327e+01j,  1.21482703e+02+2.74860673e+01j,\n        1.19497860e+02+2.46463564e+01j,  1.17542499e+02+2.21064279e+01j,\n        1.15631878e+02+1.98340498e+01j,  1.13776797e+02+1.78000677e+01j,\n        1.11984588e+02+1.59783050e+01j,  1.10259911e+02+1.43453840e+01j,\n        1.08605379e+02+1.28805050e+01j,  1.07022059e+02+1.15652100e+01j,\n        1.05509857e+02+1.03831468e+01j,  1.04067827e+02+9.31984288e+00j,\n        1.02694403e+02+8.36249510e+00j,  1.01387586e+02+7.49977708e+00j,\n        1.00145078e+02+6.72166566e+00j,  9.89643970e+01+6.01928575e+00j,\n        9.78429531e+01+5.38477261e+00j,  9.67781121e+01+4.81115026e+00j,\n        9.57672414e+01+4.29222443e+00j,  9.48077429e+01+3.82248866e+00j,\n        9.38970783e+01+3.39704196e+00j,  9.30327855e+01+3.01151673e+00j,\n        9.22124904e+01+2.66201572e+00j,  9.14339142e+01+2.34505680e+00j,\n        9.06948777e+01+2.05752474e+00j,  8.99933025e+01+1.79662889e+00j,\n        8.93272112e+01+1.55986611e+00j,  8.86947260e+01+1.34498836e+00j,\n        8.80940660e+01+1.14997409e+00j,  8.75235444e+01+9.73003272e-01j,\n        8.69815646e+01+8.12435303e-01j,  8.64666169e+01+6.66789610e-01j,\n        8.59772741e+01+5.34728519e-01j,  8.55121875e+01+4.15042144e-01j,\n        8.50700834e+01+3.06635007e-01j,  8.46497584e+01+2.08514209e-01j,\n        8.42500760e+01+1.19778925e-01j,  8.38699629e+01+3.96110911e-02j,\n        8.35084055e+01-3.27328823e-02j,  8.31644462e+01-9.79294848e-02j,\n        8.28371802e+01-1.56594681e-01j,  8.25257529e+01-2.09289776e-01j,\n        8.22293564e+01-2.56526663e-01j,  8.19472271e+01-2.98772513e-01j,\n        8.16786430e+01-3.36453982e-01j,  8.14229213e+01-3.69960980e-01j,\n        8.11794162e+01-3.99650064e-01j,  8.09475165e+01-4.25847480e-01j,\n        8.07266437e+01-4.48851911e-01j,  8.05162504e+01-4.68936944e-01j])\n\n\n\nnp.abs(voltage[0:-1])\n\narray([  9.93682979,   9.93449538,   9.93208334,   9.92959113,\n         9.92701614,   9.92435564,   9.92160679,   9.91876666,\n         9.9158322 ,   9.91280024,   9.90966753,   9.90643067,\n         9.90308616,   9.89963038,   9.89605961,   9.89236998,\n         9.88855753,   9.88461818,   9.88054775,   9.87634192,\n         9.87199629,   9.86750634,   9.86286747,   9.85807498,\n         9.85312406,   9.84800986,   9.84272742,   9.83727173,\n         9.83163774,   9.82582033,   9.81981434,   9.8136146 ,\n         9.80721593,   9.80061313,   9.79380101,   9.78677443,\n         9.77952824,   9.77205738,   9.76435683,   9.75642165,\n         9.74824698,   9.73982807,   9.73116028,   9.72223908,\n         9.71306007,   9.703619  ,   9.69391176,   9.68393438,\n         9.67368306,   9.66315414,   9.6523441 ,   9.64124958,\n         9.62986736,   9.61819433,   9.60622751,   9.593964  ,\n         9.58140097,   9.56853564,   9.55536526,   9.54188704,\n         9.52809814,   9.51399564,   9.49957646,   9.48483733,\n         9.46977476,   9.45438494,   9.43866369,   9.42260644,\n         9.4062081 ,   9.38946306,   9.37236505,   9.35490712,\n         9.33708156,   9.31887981,   9.30029237,   9.28130878,\n         9.26191749,   9.24210582,   9.22185985,   9.20116438,\n         9.18000285,   9.15835726,   9.13620809,   9.11353425,\n         9.090313  ,   9.06651991,   9.04212876,   9.01711147,\n         8.99143809,   8.96507671,   8.93799337,   8.91015205,\n         8.88151459,   8.85204065,   8.82168759,   8.79041052,\n         8.75816214,   8.72489275,   8.69055015,   8.65507961,\n         8.61842379,   8.5805227 ,   8.54131362,   8.50073103,\n         8.45870657,   8.41516896,   8.37004393,   8.32325413,\n         8.27471911,   8.2243552 ,   8.17207544,   8.11778952,\n         8.06140369,   8.00282069,   7.94193964,   7.878656  ,\n         7.81286144,   7.74444378,   7.67328692,   7.59927069,\n         7.52227086,   7.44215895,   7.35880221,   7.27206352,\n         7.18180129,   7.08786938,   6.99011703,   6.88838877,\n         6.78252434,   6.6723586 ,   6.5577215 ,   6.43843799,\n         6.31432797,   6.18520623,   6.05088243,   5.91116106,\n         5.76584149,   5.61471793,   5.45757954,   5.29421052,\n         5.1243903 ,   4.94789381,   4.76449188,   4.57395184,\n         4.37603835,   4.17051472,   3.95714477,   3.73569563,\n         3.50594213,   3.26767358,   3.02070485,   2.76489495,\n         2.50017957,   2.2266316 ,   1.944581  ,   1.65487367,\n         1.35949382,   1.06328271,   0.77956271,   0.55101303,\n         0.49419572,   0.67653581,   0.98717308,   1.35191148,\n         1.74725261,   2.16537845,   2.60335104,   3.06005137,\n         3.53515807,   4.02875062,   4.54113595,   5.07276573,\n         5.62419464,   6.19605866,   6.78906402,   7.40398219,\n         8.04164848,   8.70296308,   9.3888938 ,  10.10048001,\n        10.83883779,  11.60516596,  12.40075301,  13.22698496,\n        14.08535416,  14.97746902,  15.90506479,  16.87001544,\n        17.87434674,  18.92025059,  20.01010087,  21.14647066,\n        22.33215128,  23.570173  ,  24.86382773,  26.21669384,\n        27.6326631 ,  29.11596998,  30.67122334,  32.30344057,\n        34.01808403,  35.82109969,  37.71895764,  39.71869369,\n        41.82795129,  44.0550221 ,  46.40888319,  48.89922754,\n        51.53648371,  54.33181816,  57.29711203,  60.44490063,\n        63.78826008,  67.34062052,  71.11547868,  75.12597531,\n        79.38429381,  83.90082784,  88.68305777,  93.73407238,\n        99.05067853, 104.62106507, 110.422039  , 116.41594564,\n       122.54753028, 128.74119927, 134.89936995, 140.90279961,\n       146.61384148, 151.88334652, 156.56130174, 160.5102946 ,\n       163.61977733, 165.81834064, 167.0812622 , 167.43162664,\n       166.93498493, 165.68914538, 163.81162953, 161.42734698,\n       158.65835271, 155.6165871 , 152.39964933, 149.08911672,\n       145.75070454, 142.43557168, 139.18220861, 136.01850772,\n       132.96376616, 130.03048605, 127.22591598, 124.55332632,\n       122.01303754, 119.60323285, 117.32058999, 115.16076557,\n       113.11876157, 111.18919914, 109.36652047, 107.64513523,\n       106.01952484, 104.48431485, 103.03432333, 101.66459149,\n       100.37040115,  99.1472827 ,  97.99101611,  96.89762719,\n        95.86338043,  94.88476978,  93.9585079 ,  93.08151484,\n        92.25090626,  91.46398177,  90.71821342,  90.01123466,\n        89.34082967,  88.70492329,  88.10157155,  87.52895267,\n        86.98535873,  86.46918785,  85.9789369 ,  85.51319477,\n        85.07063603,  84.65001516,  84.25016111,  83.8699723 ,\n        83.50841196,  83.16450384,  82.83732824,  82.52601829,\n        82.22975652,  81.94777172,  81.67933594,  81.4237618 ,\n        81.18039993,  80.94863661,  80.72789157,  80.51761595])",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_9.html",
    "href": "test_9.html",
    "title": "13  Test 9",
    "section": "",
    "text": "13.1 Load the net list\nR1 is commented out.\nnet_list = '''\nG1 0 1 1 0 0.6\nI1 0 1 10\nG2 1 0 1 0 0.8\n*R1 1 0 100e6\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_9.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "13  Test 9",
    "section": "13.2 Call the symbolic modified nodal analysis function",
    "text": "13.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\left(- g_{1} + g_{2}\\right) = I_{1}\\)\n\n\n\n13.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 3\nnumber of branches: 3\nnumber of nodes: 1\nnumber of unknown currents: 0\nnumber of RLC (passive components): 0\nnumber of inductors: 0\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 2\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n13.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}- g_{1} + g_{2}\\end{matrix}\\right]\\)\n\n\n\n\n13.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}\\right]\\)\n\n\n\n\n13.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{1}\\right]\\)\n\n\n\n\n13.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nG1\n0\n1\n1\n0\nNaN\n0.6\nNaN\nNaN\nNaN\n\n\n1\nI1\n0\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nG2\n1\n0\n1\n0\nNaN\n0.8\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n13.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n\n\n\n\n\n\n\n\n13.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{1}, \\  v_{1}, \\  g_{2}, \\  g_{1}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#symbolic-solution",
    "href": "test_9.html#symbolic-solution",
    "title": "13  Test 9",
    "section": "13.3 Symbolic solution",
    "text": "13.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = - \\frac{I_{1}}{g_{1} - g_{2}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#construct-a-dictionary-of-element-values",
    "href": "test_9.html#construct-a-dictionary-of-element-values",
    "title": "13  Test 9",
    "section": "13.4 Construct a dictionary of element values",
    "text": "13.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\ng1 = 0.6\nI1 = 10.0\ng2 = 0.8",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#numerical-solution",
    "href": "test_9.html#numerical-solution",
    "title": "13  Test 9",
    "section": "13.5 Numerical solution",
    "text": "13.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(10.0 = 0.2 v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1         50.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n\n  --- Operating Point ---\nV(1): 50 voltage I(I1): 10 device_current I(R1): 5e-07 device_current I(G1): 30 device_current I(G2): 40 device_current\nThe results from LTSpice agree with the SymPy results.\n\nFind the power absorbed by each source in the circuit.  \nThe results from LTSpice agree with the SymPy results.\n\nelement_values[g1]*U[v1]**2 # power through G1\n\n\\(\\displaystyle 1500.0\\)\n\n\n\nelement_values[g2]*U[v1]**2 # power through G2\n\n\\(\\displaystyle 2000.0\\)\n\n\n\nelement_values[I1]*U[v1] # power through I1\n\n\\(\\displaystyle 500.0\\)\n\n\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_10.html",
    "href": "test_10.html",
    "title": "14  Test 10",
    "section": "",
    "text": "14.1 Load the net list\nnet_list = '''\nI1 3 2 2\nI2 0 1 -3\nI3 4 0 4\nV1 2 3 -5\nV2 2 0 3\nV3 3 4 4\nV4 2 1 12\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_10.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "14  Test 10",
    "section": "14.2 Call the symbolic modified nodal analysis function",
    "text": "14.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- I_{V4} = I_{2}\\)\\(I_{V1} + I_{V2} + I_{V4} = I_{1}\\)\\(- I_{V1} + I_{V3} = - I_{1}\\)\\(- I_{V3} = - I_{3}\\)\\(v_{2} - v_{3} = V_{1}\\)\\(v_{2} = V_{2}\\)\\(v_{3} - v_{4} = V_{3}\\)\\(- v_{1} + v_{2} = V_{4}\\)\n\n\n\n14.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 7\nnumber of branches: 7\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 0\nnumber of inductors: 0\nnumber of independent voltage sources: 4\nnumber of independent current sources: 3\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n14.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 1 & 1 & 0 & 1\\\\0 & 0 & 0 & 0 & -1 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\0 & 1 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 1 & -1 & 0 & 0 & 0 & 0\\\\-1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\end{matrix}\\right]\\)\n\n\n\n\n14.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}\\right]\\)\n\n\n\n\n14.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{2}, \\  I_{1}, \\  - I_{1}, \\  - I_{3}, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}\\right]\\)\n\n\n\n\n14.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n2\n3\nNaN\nNaN\nNaN\n-5.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n2\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n3\n4\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n2\n1\nNaN\nNaN\nNaN\n12.0\nNaN\nNaN\nNaN\n\n\n4\nI1\n3\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nI2\n0\n1\nNaN\nNaN\nNaN\n-3.0\nNaN\nNaN\nNaN\n\n\n6\nI3\n4\n0\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n14.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n2\n3\n\n\n1\nV2\n2\n0\n\n\n2\nV3\n3\n4\n\n\n3\nV4\n2\n1\n\n\n\n\n\n\n\n\n\n\n14.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V4}, \\  I_{1}, \\  V_{2}, \\  I_{2}, \\  V_{1}, \\  I_{3}, \\  v_{2}, \\  I_{V1}, \\  v_{3}, \\  V_{3}, \\  V_{4}, \\  I_{V2}, \\  v_{1}, \\  I_{V3}, \\  v_{4}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#symbolic-solution",
    "href": "test_10.html#symbolic-solution",
    "title": "14  Test 10",
    "section": "14.3 Symbolic solution",
    "text": "14.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(I_{V1} = I_{1} + I_{3}\\)\\(I_{V2} = I_{2} - I_{3}\\)\\(I_{V3} = I_{3}\\)\\(I_{V4} = - I_{2}\\)\\(v_{1} = V_{2} - V_{4}\\)\\(v_{2} = V_{2}\\)\\(v_{3} = - V_{1} + V_{2}\\)\\(v_{4} = - V_{1} + V_{2} - V_{3}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#construct-a-dictionary-of-element-values",
    "href": "test_10.html#construct-a-dictionary-of-element-values",
    "title": "14  Test 10",
    "section": "14.4 Construct a dictionary of element values",
    "text": "14.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = -5.0\nV2 = 3.0\nV3 = 4.0\nV4 = 12.0\nI1 = 2.0\nI2 = -3.0\nI3 = 4.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#numerical-solution",
    "href": "test_10.html#numerical-solution",
    "title": "14  Test 10",
    "section": "14.5 Numerical solution",
    "text": "14.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-3.0 = - I_{V4}\\)\\(2.0 = I_{V1} + I_{V2} + I_{V4}\\)\\(-2.0 = - I_{V1} + I_{V3}\\)\\(-4.0 = - I_{V3}\\)\\(-5.0 = v_{2} - v_{3}\\)\\(3.0 = v_{2}\\)\\(4.0 = v_{3} - v_{4}\\)\\(12.0 = - v_{1} + v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nI_V1        6.000000\nI_V2       -7.000000\nI_V3        4.000000\nI_V4        3.000000\nv1         -9.000000\nv2          3.000000\nv3          8.000000\nv4          4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\nV(3):    8   voltage\nV(2):    3   voltage\nV(1):    -9  voltage\nV(4):    4   voltage\nI(I1):   2   device_current\nI(I2):   -3  device_current\nI(I3):   4   device_current\nI(V1):   6   device_current\nI(V2):   -7  device_current\nI(V3):   4   device_current\nI(V4):   3   device_current\nThe results from LTSpice agree with the SymPy results.\nFind the power absorbed by each source in the circuit.\nLooking at equation I_V1 = I₁ + I₃, set I_V1 to zero\n\nelement_values[I1] + element_values[I3] - 0\n\n\\(\\displaystyle 6.0\\)\n\n\nBy inspection a value of I3 = -2 will make I_V1 = 0\n\nelement_values[I1] + (-2) - 0\n\n\\(\\displaystyle 0.0\\)\n\n\nanswer is -2\nText book’s answers are: (a) 30W; (b) -2A\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_11.html",
    "href": "test_11.html",
    "title": "15  Test 11",
    "section": "",
    "text": "15.1 Load the net list\nnet_list = '''\nL1 1 0 10 \nL2 0 2 20 \nL3 4 0 30\nR2 2 0 5\nR3 4 0 10\nR1 1 3 2\nV1 3 0 10\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_11.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "15  Test 11",
    "section": "15.2 Call the symbolic modified nodal analysis function",
    "text": "15.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L2} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L3} + \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{3} = V_{1}\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s - I_{L3} M_{2} s + v_{1} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s - I_{L3} M_{3} s - v_{2} = 0\\)\\(- I_{L1} M_{2} s - I_{L2} M_{3} s - I_{L3} L_{3} s + v_{4} = 0\\)\n\n\n\n15.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 7\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 6\nnumber of inductors: 3\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 3\n\n\n\n\n\n15.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & -1 & 0\\\\- \\frac{1}{R_{1}} & 0 & \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 0 & 1\\\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & - M_{2} s\\\\0 & -1 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & - M_{3} s\\\\0 & 0 & 0 & 1 & 0 & - M_{2} s & - M_{3} s & - L_{3} s\\end{matrix}\\right]\\)\n\n\n\n\n15.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}\\right]\\)\n\n\n\n\n15.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n15.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n3\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nL1\n1\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nL2\n0\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n3\nL3\n4\n0\nNaN\nNaN\nNaN\n30.0\nNaN\nNaN\nNaN\n\n\n4\nR2\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n5\nR3\n4\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n6\nR1\n1\n3\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.2\nNaN\nL1\nL2\n\n\n8\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.8\nNaN\nL1\nL3\n\n\n9\nK3\nNaN\nNaN\nNaN\nNaN\nNaN\n0.5\nNaN\nL2\nL3\n\n\n\n\n\n\n\n\n\n\n15.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n3\n0\n\n\n1\nL1\n1\n0\n\n\n2\nL2\n0\n2\n\n\n3\nL3\n4\n0\n\n\n\n\n\n\n\n\n\n\n15.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{1}, \\  R_{2}, \\  v_{2}, \\  M_{1}, \\  v_{4}, \\  I_{L3}, \\  M_{2}, \\  I_{L2}, \\  M_{3}, \\  v_{1}, \\  R_{3}, \\  s, \\  v_{3}, \\  L_{1}, \\  I_{L1}, \\  L_{2}, \\  V_{1}, \\  L_{3}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#symbolic-solution",
    "href": "test_11.html#symbolic-solution",
    "title": "15  Test 11",
    "section": "15.3 Symbolic solution",
    "text": "15.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{L_{1} L_{2} L_{3} V_{1} s^{3} + L_{1} L_{2} R_{3} V_{1} s^{2} + L_{1} L_{3} R_{2} V_{1} s^{2} - L_{1} M_{3}^{2} V_{1} s^{3} + L_{1} R_{2} R_{3} V_{1} s - L_{2} M_{2}^{2} V_{1} s^{3} - L_{3} M_{1}^{2} V_{1} s^{3} - M_{1}^{2} R_{3} V_{1} s^{2} + 2 M_{1} M_{2} M_{3} V_{1} s^{3} - M_{2}^{2} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{2} = \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{L_{2} M_{2} R_{3} V_{1} s^{2} - M_{1} M_{3} R_{3} V_{1} s^{2} + M_{2} R_{2} R_{3} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{V1} = \\frac{- L_{2} L_{3} V_{1} s^{2} - L_{2} R_{3} V_{1} s - L_{3} R_{2} V_{1} s + M_{3}^{2} V_{1} s^{2} - R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L1} = \\frac{L_{2} L_{3} V_{1} s^{2} + L_{2} R_{3} V_{1} s + L_{3} R_{2} V_{1} s - M_{3}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L2} = \\frac{- L_{3} M_{1} V_{1} s^{2} - M_{1} R_{3} V_{1} s + M_{2} M_{3} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L3} = \\frac{- L_{2} M_{2} V_{1} s^{2} + M_{1} M_{3} V_{1} s^{2} - M_{2} R_{2} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#construct-a-dictionary-of-element-values",
    "href": "test_11.html#construct-a-dictionary-of-element-values",
    "title": "15  Test 11",
    "section": "15.4 Construct a dictionary of element values",
    "text": "15.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nL1 = 10.0\nL2 = 20.0\nL3 = 30.0\nR2 = 5.0\nR3 = 10.0\nR1 = 2.0\nK1 = 0.2\nK2 = 0.8\nK3 = 0.5\n\n\n\n15.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit.\n\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(M_1 = K1 \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = K2 \\times {\\sqrt{L_1 \\times L_3}}\\)\n\\(M_3 = K3 \\times {\\sqrt{L_2 \\times L_3}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2, K3 = symbols('K1 K2 K3')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L1] * element_values[L3])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nelement_values[M3] = element_values[K3]*np.sqrt(element_values[L2] * element_values[L3])\nprint('mutual inductance, M3 = {:.9f}'.format(element_values[M3]))\n\nmutual inductance, M1 = 2.828427125\nmutual inductance, M2 = 13.856406461\nmutual inductance, M3 = 12.247448714",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#dc-operating-point",
    "href": "test_11.html#dc-operating-point",
    "title": "15  Test 11",
    "section": "15.5 DC operating point",
    "text": "15.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\)\\(0 = - I_{L2} + 0.2 v_{2}\\)\\(0 = I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\)\\(0 = I_{L3} + 0.1 v_{4}\\)\\(10.0 = v_{3}\\)\\(0 = v_{1}\\)\\(0 = - v_{2}\\)\\(0 = v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          0.000000\nv3         10.000000\nI_V1       -5.000000\nI_L1        5.000000\nv2          0.000000\nI_L2        0.000000\nv4          0.000000\nI_L3        0.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    0   voltage\nV(2):    0   voltage\nV(4):    0   voltage\nV(3):    10  voltage\nI(L1):   5   device_current\nI(L2):   0   device_current\nI(L3):   0   device_current\nI(R2):   0   device_current\nI(R3):   0   device_current\nI(R1):   -5  device_current\nI(V1):   -5  device_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n15.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\)\\(0 = - I_{L2} + 0.2 v_{2}\\)\\(0 = I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\)\\(0 = I_{L3} + 0.1 v_{4}\\)\\(10.0 = v_{3}\\)\\(0 = - 10.0 i I_{L1} - 2.82842712474619 i I_{L2} - 13.856406460551 i I_{L3} + v_{1}\\)\\(0 = - 2.82842712474619 i I_{L1} - 20.0 i I_{L2} - 12.2474487139159 i I_{L3} - v_{2}\\)\\(0 = - 13.856406460551 i I_{L1} - 12.2474487139159 i I_{L2} - 30.0 i I_{L3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          8.002110     16.522966\nv2          1.369735     15.274587\nv3         10.000000      0.000000\nv4          7.724137    -19.105758\nI_V1        1.627911    135.653713\nI_L1        1.627911    -44.346287\nI_L2        0.273947     15.274587\nI_L3        0.772414    160.894242\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\n\n15.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\)\\(0 = - I_{L2} + 0.2 v_{2}\\)\\(0 = I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\)\\(0 = I_{L3} + 0.1 v_{4}\\)\\(10.0 = v_{3}\\)\\(0 = - 10.0 I_{L1} s - 2.82842712474619 I_{L2} s - 13.856406460551 I_{L3} s + v_{1}\\)\\(0 = - 2.82842712474619 I_{L1} s - 20.0 I_{L2} s - 12.2474487139159 I_{L3} s - v_{2}\\)\\(0 = - 13.856406460551 I_{L1} s - 12.2474487139159 I_{L2} s - 30.0 I_{L3} s + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n15.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 10*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 1, 300, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_11.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-14}\\) and \\(10^{-13}\\) for the phase indicating the numerical difference is very small.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_12.html",
    "href": "test_12.html",
    "title": "16  Test 12",
    "section": "",
    "text": "16.1 Load the net list\nnet_list = '''\nC3 2 0 3.7642\nI1 0 1 1\nC5 3 0 4.015\nC7 4 0 3.0182\nL2 1 2 0.7529\nL4 2 3 0.9276\nL6 3 4 0.9142\nRs 1 0 0.5\nRl 4 0 1\nC1 1 0 1.5948\n\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_12.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "16  Test 12",
    "section": "16.2 Call the symbolic modified nodal analysis function",
    "text": "16.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L2} + v_{1} \\left(C_{1} s + \\frac{1}{Rs}\\right) = I_{1}\\)\\(C_{3} s v_{2} - I_{L2} + I_{L4} = 0\\)\\(C_{5} s v_{3} - I_{L4} + I_{L6} = 0\\)\\(- I_{L6} + v_{4} \\left(C_{7} s + \\frac{1}{Rl}\\right) = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{2} = 0\\)\\(- I_{L4} L_{4} s + v_{2} - v_{3} = 0\\)\\(- I_{L6} L_{6} s + v_{3} - v_{4} = 0\\)\n\n\n\n16.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 10\nnumber of nodes: 4\nnumber of unknown currents: 3\nnumber of RLC (passive components): 9\nnumber of resistors: 2\nnumber of capacitors: 4\nnumber of inductors: 3\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n16.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{Rs} & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & C_{3} s & 0 & 0 & -1 & 1 & 0\\\\0 & 0 & C_{5} s & 0 & 0 & -1 & 1\\\\0 & 0 & 0 & C_{7} s + \\frac{1}{Rl} & 0 & 0 & -1\\\\1 & -1 & 0 & 0 & - L_{2} s & 0 & 0\\\\0 & 1 & -1 & 0 & 0 & - L_{4} s & 0\\\\0 & 0 & 1 & -1 & 0 & 0 & - L_{6} s\\end{matrix}\\right]\\)\n\n\n\n\n16.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{L2}, \\  I_{L4}, \\  I_{L6}\\right]\\)\n\n\n\n\n16.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{1}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n16.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nC3\n2\n0\nNaN\nNaN\nNaN\n3.7642\nNaN\nNaN\nNaN\n\n\n1\nI1\n0\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n2\nC5\n3\n0\nNaN\nNaN\nNaN\n4.015\nNaN\nNaN\nNaN\n\n\n3\nC7\n4\n0\nNaN\nNaN\nNaN\n3.0182\nNaN\nNaN\nNaN\n\n\n4\nL2\n1\n2\nNaN\nNaN\nNaN\n0.7529\nNaN\nNaN\nNaN\n\n\n5\nL4\n2\n3\nNaN\nNaN\nNaN\n0.9276\nNaN\nNaN\nNaN\n\n\n6\nL6\n3\n4\nNaN\nNaN\nNaN\n0.9142\nNaN\nNaN\nNaN\n\n\n7\nRs\n1\n0\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nRl\n4\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n9\nC1\n1\n0\nNaN\nNaN\nNaN\n1.5948\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n16.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL2\n1\n2\n\n\n1\nL4\n2\n3\n\n\n2\nL6\n3\n4\n\n\n\n\n\n\n\n\n\n\n16.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L4}, \\  Rl, \\  L_{6}, \\  C_{7}, \\  Rs, \\  v_{1}, \\  C_{3}, \\  I_{L2}, \\  L_{2}, \\  I_{1}, \\  C_{1}, \\  s, \\  C_{5}, \\  I_{L6}, \\  v_{4}, \\  L_{4}, \\  v_{3}, \\  v_{2}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#symbolic-solution",
    "href": "test_12.html#symbolic-solution",
    "title": "16  Test 12",
    "section": "16.3 Symbolic solution",
    "text": "16.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{3} C_{5} C_{7} I_{1} L_{2} L_{4} L_{6} Rl Rs s^{6} + C_{3} C_{5} I_{1} L_{2} L_{4} L_{6} Rs s^{5} + C_{3} C_{5} I_{1} L_{2} L_{4} Rl Rs s^{4} + C_{3} C_{7} I_{1} L_{2} L_{4} Rl Rs s^{4} + C_{3} C_{7} I_{1} L_{2} L_{6} Rl Rs s^{4} + C_{3} I_{1} L_{2} L_{4} Rs s^{3} + C_{3} I_{1} L_{2} L_{6} Rs s^{3} + C_{3} I_{1} L_{2} Rl Rs s^{2} + C_{5} C_{7} I_{1} L_{2} L_{6} Rl Rs s^{4} + C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{4} + C_{5} I_{1} L_{2} L_{6} Rs s^{3} + C_{5} I_{1} L_{2} Rl Rs s^{2} + C_{5} I_{1} L_{4} L_{6} Rs s^{3} + C_{5} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{2} Rl Rs s^{2} + C_{7} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{2} Rs s + I_{1} L_{4} Rs s + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{2} = \\frac{C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{4} + C_{5} I_{1} L_{4} L_{6} Rs s^{3} + C_{5} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{4} Rs s + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{3} = \\frac{C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{4} = \\frac{I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L2} = \\frac{C_{3} C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} I_{1} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} I_{1} L_{4} Rl Rs s^{3} + C_{3} C_{7} I_{1} L_{4} Rl Rs s^{3} + C_{3} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{3} I_{1} L_{4} Rs s^{2} + C_{3} I_{1} L_{6} Rs s^{2} + C_{3} I_{1} Rl Rs s + C_{5} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{5} I_{1} L_{6} Rs s^{2} + C_{5} I_{1} Rl Rs s + C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L4} = \\frac{C_{5} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{5} I_{1} L_{6} Rs s^{2} + C_{5} I_{1} Rl Rs s + C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L6} = \\frac{C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#construct-a-dictionary-of-element-values",
    "href": "test_12.html#construct-a-dictionary-of-element-values",
    "title": "16  Test 12",
    "section": "16.4 Construct a dictionary of element values",
    "text": "16.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nC3 = 3.7642\nI1 = 1.0\nC5 = 4.015\nC7 = 3.0182\nL2 = 0.7529\nL4 = 0.9276\nL6 = 0.9142\nRs = 0.5\nRl = 1.0\nC1 = 1.5948",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#dc-operating-point",
    "href": "test_12.html#dc-operating-point",
    "title": "16  Test 12",
    "section": "16.5 DC operating point",
    "text": "16.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(1.0 = I_{L2} + 2.0 v_{1}\\)\\(0 = - I_{L2} + I_{L4}\\)\\(0 = - I_{L4} + I_{L6}\\)\\(0 = - I_{L6} + 1.0 v_{4}\\)\\(0 = v_{1} - v_{2}\\)\\(0 = v_{2} - v_{3}\\)\\(0 = v_{3} - v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown         mag\n---------  --------\nv1         0.333333\nv2         0.333333\nv3         0.333333\nv4         0.333333\nI_L2       0.333333\nI_L4       0.333333\nI_L6       0.333333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    0.333333    voltage\nV(1):    0.333333    voltage\nV(3):    0.333333    voltage\nV(4):    0.333333    voltage\nI(C3):   1.25473e-12     device_current\nI(C5):   1.33833e-12     device_current\nI(C7):   1.00607e-12     device_current\nI(C1):   5.316e-13   device_current\nI(L2):   0.333333    device_current\nI(L4):   0.333333    device_current\nI(L6):   0.333333    device_current\nI(I1):   1   device_current\nI(Rs):   0.666667    device_current\nI(Rl):   0.333333    device_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n16.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(1.0 = I_{L2} + v_{1} \\cdot \\left(2.0 + 1.5948 i\\right)\\)\\(0 = - I_{L2} + I_{L4} + 3.7642 i v_{2}\\)\\(0 = - I_{L4} + I_{L6} + 4.015 i v_{3}\\)\\(0 = - I_{L6} + v_{4} \\cdot \\left(1.0 + 3.0182 i\\right)\\)\\(0 = - 0.7529 i I_{L2} + v_{1} - v_{2}\\)\\(0 = - 0.9276 i I_{L4} + v_{2} - v_{3}\\)\\(0 = - 0.9142 i I_{L6} + v_{3} - v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.247674     43.979099\nv2         0.596900   -119.590485\nv3         0.467235     71.054634\nv4         0.235668    -81.486420\nI_L2       1.112227    -34.389344\nI_L4       1.142319    155.081675\nI_L6       0.749319     -9.817657\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:     0.5969 phase:    -119.59°  voltage\nV(1):   mag:   0.247674 phase:    43.9791°  voltage\nV(3):   mag:   0.467235 phase:    71.0546°  voltage\nV(4):   mag:   0.235668 phase:   -81.4864°  voltage\nI(C3):  mag:    2.24685 phase:   -29.5905°  device_current\nI(C5):  mag:    1.87595 phase:    161.055°  device_current\nI(C7):  mag:   0.711294 phase:    8.51358°  device_current\nI(C1):  mag:   0.394991 phase:    133.979°  device_current\nI(L2):  mag:    1.11223 phase:   -34.3893°  device_current\nI(L4):  mag:    1.14232 phase:    155.082°  device_current\nI(L6):  mag:   0.749319 phase:   -9.81766°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(Rs):  mag:   0.495349 phase:    43.9791°  device_current\nI(Rl):  mag:   0.235668 phase:   -81.4864°  device_current\n\n\n\n16.5.2 AC Sweep\nLooking at node 4 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(1.0 = I_{L2} + v_{1} \\cdot \\left(1.5948 s + 2.0\\right)\\)\\(0 = - I_{L2} + I_{L4} + 3.7642 s v_{2}\\)\\(0 = - I_{L4} + I_{L6} + 4.015 s v_{3}\\)\\(0 = - I_{L6} + v_{4} \\cdot \\left(3.0182 s + 1.0\\right)\\)\\(0 = - 0.7529 I_{L2} s + v_{1} - v_{2}\\)\\(0 = - 0.9276 I_{L4} s + v_{2} - v_{3}\\)\\(0 = - 0.9142 I_{L6} s + v_{3} - v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n16.5.3 Plot the voltage at node 2\n\nH = U_ac[v4]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_12_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfrequency[0]\n\n\\(\\displaystyle 0.01\\)\n\n\n\nfrequency[-1]\n\n\\(\\displaystyle 1.0\\)\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1]) - 10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2)*180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response difference')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other, but not to the same precision as in previous tests.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#poles-and-zeros-of-the-transfer-function",
    "href": "test_12.html#poles-and-zeros-of-the-transfer-function",
    "title": "16  Test 12",
    "section": "16.6 Poles and zeros of the transfer function",
    "text": "16.6 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n16.6.0.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 7\n-0.01+0.16j Hz\n-0.01-0.16j Hz\n-0.04+0.12j Hz\n-0.04-0.12j Hz\n-0.05+0.07j Hz\n-0.05-0.07j Hz\n-0.06+0.00j Hz",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#impulse-and-step-response",
    "href": "test_12.html#impulse-and-step-response",
    "title": "16  Test 12",
    "section": "16.7 Impulse and step response",
    "text": "16.7 Impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n16.7.1 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley & Sons.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_13.html",
    "href": "test_13.html",
    "title": "17  Test 13",
    "section": "",
    "text": "17.1 Load the net list\nNode 5 added manually along with R1 = 1e-20 ohms in series with L1.\nnet_list = '''\nL1 2 4 5\nR1 4 3 1e-20\nI1 1 2 2 \nL2 0 3 3 \nL3 2 1 1 \nL4 1 0 1 \nI2 0 1 1\nI3 3 0 5\nI4 2 3 3\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_13.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "17  Test 13",
    "section": "17.2 Call the symbolic modified nodal analysis function",
    "text": "17.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- I_{L3} + I_{L4} = - I_{1} + I_{2}\\)\\(I_{L1} + I_{L3} = I_{1} - I_{4}\\)\\(- I_{L2} + \\frac{v_{3}}{R_{1}} - \\frac{v_{4}}{R_{1}} = - I_{3} + I_{4}\\)\\(- I_{L1} - \\frac{v_{3}}{R_{1}} + \\frac{v_{4}}{R_{1}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} - v_{4} = 0\\)\\(- I_{L2} L_{2} s - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{1} + v_{2} = 0\\)\\(- I_{L4} L_{4} s + v_{1} = 0\\)\n\n\n\n17.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 5\nnumber of inductors: 4\nnumber of independent voltage sources: 0\nnumber of independent current sources: 4\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n17.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0 & 0 & -1 & 1\\\\0 & 0 & 0 & 0 & 1 & 0 & 1 & 0\\\\0 & 0 & \\frac{1}{R_{1}} & - \\frac{1}{R_{1}} & 0 & -1 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{1}} & \\frac{1}{R_{1}} & -1 & 0 & 0 & 0\\\\0 & 1 & 0 & -1 & - L_{1} s & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & - L_{2} s & 0 & 0\\\\-1 & 1 & 0 & 0 & 0 & 0 & - L_{3} s & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{4} s\\end{matrix}\\right]\\)\n\n\n\n\n17.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}\\right]\\)\n\n\n\n\n17.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1} + I_{2}, \\  I_{1} - I_{4}, \\  - I_{3} + I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n17.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nL1\n2\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n4\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nI1\n1\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nL2\n0\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n4\nL3\n2\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n5\nL4\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n6\nI2\n0\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n7\nI3\n3\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n8\nI4\n2\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n17.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL1\n2\n4\n\n\n1\nL2\n0\n3\n\n\n2\nL3\n2\n1\n\n\n3\nL4\n1\n0\n\n\n\n\n\n\n\n\n\n\n17.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L4}, \\  I_{L1}, \\  L_{3}, \\  L_{2}, \\  v_{1}, \\  L_{1}, \\  I_{1}, \\  I_{L3}, \\  v_{3}, \\  R_{1}, \\  v_{2}, \\  L_{4}, \\  I_{2}, \\  s, \\  I_{3}, \\  I_{4}, \\  I_{L2}, \\  v_{4}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#symbolic-solution",
    "href": "test_13.html#symbolic-solution",
    "title": "17  Test 13",
    "section": "17.3 Symbolic solution",
    "text": "17.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- I_{1} L_{3} L_{4} s^{2} + I_{2} L_{1} L_{4} s^{2} + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{3} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{2} L_{4} s^{2} - I_{4} L_{1} L_{4} s^{2} - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{2} = \\frac{I_{1} L_{1} L_{3} s^{2} + I_{1} L_{2} L_{3} s^{2} + I_{1} L_{3} R_{1} s + I_{2} L_{1} L_{4} s^{2} + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} - I_{4} L_{1} L_{3} s^{2} - I_{4} L_{1} L_{4} s^{2} - I_{4} L_{3} R_{1} s - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{3} = \\frac{I_{1} L_{2} L_{3} s^{2} + I_{2} L_{2} L_{4} s^{2} - I_{3} L_{1} L_{2} s^{2} - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} - I_{3} L_{2} R_{1} s + I_{4} L_{1} L_{2} s^{2} + I_{4} L_{2} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{4} = \\frac{I_{1} L_{2} L_{3} s^{2} + I_{1} L_{3} R_{1} s + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{1} L_{2} s^{2} - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} + I_{4} L_{1} L_{2} s^{2} - I_{4} L_{3} R_{1} s - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} L_{3} s + I_{2} L_{4} s + I_{3} L_{2} s - I_{4} L_{2} s - I_{4} L_{3} s - I_{4} L_{4} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L2} = \\frac{- I_{1} L_{3} s - I_{2} L_{4} s + I_{3} L_{1} s + I_{3} L_{3} s + I_{3} L_{4} s + I_{3} R_{1} - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L3} = \\frac{I_{1} L_{1} s + I_{1} L_{2} s + I_{1} L_{4} s + I_{1} R_{1} - I_{2} L_{4} s - I_{3} L_{2} s - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L4} = \\frac{- I_{1} L_{3} s + I_{2} L_{1} s + I_{2} L_{2} s + I_{2} L_{3} s + I_{2} R_{1} - I_{3} L_{2} s - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#construct-a-dictionary-of-element-values",
    "href": "test_13.html#construct-a-dictionary-of-element-values",
    "title": "17  Test 13",
    "section": "17.4 Construct a dictionary of element values",
    "text": "17.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nL1 = 5.0\nR1 = 1e-20\nI1 = 2.0\nL2 = 3.0\nL3 = 1.0\nL4 = 1.0\nI2 = 1.0\nI3 = 5.0\nI4 = 3.0",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#dc-operating-point",
    "href": "test_13.html#dc-operating-point",
    "title": "17  Test 13",
    "section": "17.5 DC operating point",
    "text": "17.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = - I_{L3} + I_{L4}\\)\\(-1.0 = I_{L1} + I_{L3}\\)\\(-2.0 = - I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = v_{2} - v_{4}\\)\\(0 = - v_{3}\\)\\(0 = - v_{1} + v_{2}\\)\\(0 = v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          0.000000\nv2          0.000000\nv3          0.000000\nv4          0.000000\nI_L1        0.000000\nI_L2        2.000000\nI_L3       -1.000000\nI_L4       -2.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(2):    0   voltage\nV(3):    0   voltage\nV(1):    0   voltage\nI(L1):   -1  device_current\nI(L2):   3   device_current\nI(L3):   0   device_current\nI(L4):   -1  device_current\nI(I1):   2   device_current\nI(I2):   1   device_current\nI(I3):   5   device_current\nI(I4):   3   device_current\n\n\n17.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(-2.0 = - I_{L3} + I_{L4}\\)\\(2.0 = I_{L1} + I_{L3}\\)\\(0 = - I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - 5.0 i I_{L1} + v_{2} - v_{4}\\)\\(0 = - 3.0 i I_{L2} - v_{3}\\)\\(0 = - 1.0 i I_{L3} - v_{1} + v_{2}\\)\\(0 = - 1.0 i I_{L4} + v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.200000    -90.000000\nv2         1.600000     90.000000\nv3         0.600000     90.000000\nv4         0.600000     90.000000\nI_L1       0.200000      0.000000\nI_L2       0.200000   -180.000000\nI_L3       1.800000     -0.000000\nI_L4       0.200000   -180.000000\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: -5.15662e-19°    device_current\nI(L2):  mag:        0.2 phase:        180°  device_current\nI(L3):  mag:        1.8 phase: 5.72958e-20°     device_current\nI(L4):  mag:        0.2 phase:        180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\n\nThere are some small numeric differences in some node voltages and phases because of the series resistance. Also note the the phase of the current for L2 and L4 from LTSpice is -180 vs +180 as calculated by SymPy.\n\n\n17.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-2.0 = - I_{L3} + I_{L4}\\)\\(2.0 = I_{L1} + I_{L3}\\)\\(0 = - I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - 5.0 I_{L1} s + v_{2} - v_{4}\\)\\(0 = - 3.0 I_{L2} s - v_{3}\\)\\(0 = - 1.0 I_{L3} s - v_{1} + v_{2}\\)\\(0 = - 1.0 I_{L4} s + v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n17.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.1*2*np.pi, 10*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-1, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_13.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\). There is no difference in the phase results.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_14.html",
    "href": "test_14.html",
    "title": "18  Test 14",
    "section": "",
    "text": "18.1 Load the net list\nnet_list = '''\nI1 1 0 1 \nR1 1 0 0.05\nL1 1 2 0.025\nC1 2 0 0.25\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_14.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "18  Test 14",
    "section": "18.2 Call the symbolic modified nodal analysis function",
    "text": "18.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(C_{1} s v_{2} - I_{L1} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{2} = 0\\)\n\n\n\n18.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 4\nnumber of branches: 4\nnumber of nodes: 2\nnumber of unknown currents: 1\nnumber of RLC (passive components): 3\nnumber of inductors: 1\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n18.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & 1\\\\0 & C_{1} s & -1\\\\1 & -1 & - L_{1} s\\end{matrix}\\right]\\)\n\n\n\n\n18.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  I_{L1}\\right]\\)\n\n\n\n\n18.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1}, \\  0, \\  0\\right]\\)\n\n\n\n\n18.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nI1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n1\n0\nNaN\nNaN\nNaN\n0.05\nNaN\nNaN\nNaN\n\n\n2\nL1\n1\n2\nNaN\nNaN\nNaN\n0.025\nNaN\nNaN\nNaN\n\n\n3\nC1\n2\n0\nNaN\nNaN\nNaN\n0.25\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n18.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL1\n1\n2\n\n\n\n\n\n\n\n\n\n\n18.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{1}, \\  I_{1}, \\  v_{2}, \\  R_{1}, \\  I_{L1}, \\  v_{1}, \\  C_{1}, \\  s\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#symbolic-solution",
    "href": "test_14.html#symbolic-solution",
    "title": "18  Test 14",
    "section": "18.3 Symbolic solution",
    "text": "18.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C_{1} I_{1} L_{1} R_{1} s^{2} - I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)\\(v_{2} = - \\frac{I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)\\(I_{L1} = - \\frac{C_{1} I_{1} R_{1} s}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#construct-a-dictionary-of-element-values",
    "href": "test_14.html#construct-a-dictionary-of-element-values",
    "title": "18  Test 14",
    "section": "18.4 Construct a dictionary of element values",
    "text": "18.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nI1 = 1.0\nR1 = 0.05\nL1 = 0.025\nC1 = 0.25",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#dc-operating-point",
    "href": "test_14.html#dc-operating-point",
    "title": "18  Test 14",
    "section": "18.5 DC operating point",
    "text": "18.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = I_{L1} + 20.0 v_{1}\\)\\(0 = - I_{L1}\\)\\(0 = v_{1} - v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1         -0.050000\nv2         -0.050000\nI_L1        0.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -0.05   voltage\nV(2):    -0.05   voltage\nI(C1):   -1.25e-14   device_current\nI(L1):   -1.24345e-14    device_current\nI(I1):   1   device_current\nI(R1):   -1  device_current\n\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n18.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = I_{L1} + 20.0 v_{1}\\)\\(0 = - I_{L1} + 0.25 i v_{2}\\)\\(0 = - 0.025 i I_{L1} + v_{1} - v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.049996    179.279336\nv2         0.050310    179.279336\nI_L1       0.012578    -90.720664\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:   0.049996 phase:    179.279°  voltage\nV(2):   mag:  0.0503105 phase:    179.279°  voltage\nI(C1):  mag:  0.0125776 phase:   -90.7207°  device_current\nI(L1):  mag:  0.0125776 phase:   -90.7207°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.999921 phase:    179.279°  device_current\n\n\n\n18.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = I_{L1} + 20.0 v_{1}\\)\\(0 = - I_{L1} + 0.25 s v_{2}\\)\\(0 = - 0.025 I_{L1} s + v_{1} - v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n18.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nH\n\n\\(\\displaystyle - \\frac{8.0}{s^{2} + 2.0 s + 160.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_14.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2)[0:-1]),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(V_2)[0:-1]/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(V_2[0:-1]) - 10**(mag/20),'-k')\n#plt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2[0:-1]))-mag,'-k')\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_2[0:-1])*180/np.pi-phase,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results have small error, but not to the same precision as in previous tests.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_15.html",
    "href": "test_15.html",
    "title": "19  Test 15",
    "section": "",
    "text": "19.1 Load the net list\nnet_list = '''\nI1 1 0 1\nR1 1 0 10\nR2 2 1 10\nR3 3 2 1000\nC1 2 0 0.01\nC2 3 0 0.002\n'''",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_15.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "19  Test 15",
    "section": "19.2 Call the symbolic modified nodal analysis function",
    "text": "19.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = - I_{1}\\)\\(v_{2} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{3} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\n\n\n\n19.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 6\nnumber of branches: 6\nnumber of nodes: 3\nnumber of unknown currents: 0\nnumber of RLC (passive components): 5\nnumber of inductors: 0\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n19.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\- \\frac{1}{R_{2}} & C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & - \\frac{1}{R_{3}}\\\\0 & - \\frac{1}{R_{3}} & C_{2} s + \\frac{1}{R_{3}}\\end{matrix}\\right]\\)\n\n\n\n\n19.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}\\right]\\)\n\n\n\n\n19.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1}, \\  0, \\  0\\right]\\)\n\n\n\n\n19.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nI1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n1\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n3\nR3\n3\n2\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n4\nC1\n2\n0\nNaN\nNaN\nNaN\n0.01\nNaN\nNaN\nNaN\n\n\n5\nC2\n3\n0\nNaN\nNaN\nNaN\n0.002\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n19.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n\n\n\n\n\n\n\n\n19.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  R_{1}, \\  R_{2}, \\  s, \\  I_{1}, \\  v_{1}, \\  R_{3}, \\  C_{2}, \\  C_{1}, \\  v_{3}\\right)\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#symbolic-solution",
    "href": "test_15.html#symbolic-solution",
    "title": "19  Test 15",
    "section": "19.3 Symbolic solution",
    "text": "19.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C_{1} C_{2} I_{1} R_{1} R_{2} R_{3} s^{2} - C_{1} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)\\(v_{2} = \\frac{- C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)\\(v_{3} = - \\frac{I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#construct-a-dictionary-of-element-values",
    "href": "test_15.html#construct-a-dictionary-of-element-values",
    "title": "19  Test 15",
    "section": "19.4 Construct a dictionary of element values",
    "text": "19.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nI1 = 1.0\nR1 = 10.0\nR2 = 10.0\nR3 = 1000.0\nC1 = 0.01\nC2 = 0.002",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#dc-operating-point",
    "href": "test_15.html#dc-operating-point",
    "title": "19  Test 15",
    "section": "19.5 DC operating point",
    "text": "19.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = 0.2 v_{1} - 0.1 v_{2}\\)\\(0 = - 0.1 v_{1} + 0.101 v_{2} - 0.001 v_{3}\\)\\(0 = - 0.001 v_{2} + 0.001 v_{3}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1         -10.000000\nv2         -10.000000\nv3         -10.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -10     voltage\nV(2):    -10     voltage\nV(3):    -10     voltage\nI(C1):   -1e-13  device_current\nI(C2):   -2e-14  device_current\nI(I1):   1   device_current\nI(R1):   -1  device_current\nI(R2):   1.20082e-13     device_current\nI(R3):   2e-14   device_current\n\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n19.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = 0.2 v_{1} - 0.1 v_{2}\\)\\(0 = - 0.1 v_{1} + v_{2} \\cdot \\left(0.101 + 0.01 i\\right) - 0.001 v_{3}\\)\\(0 = - 0.001 v_{2} + v_{3} \\cdot \\left(0.001 + 0.002 i\\right)\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         9.771261    174.320654\nv2         9.642525    168.430028\nv3         4.312268    104.995079\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    9.77126 phase:    174.321°  voltage\nV(2):   mag:    9.64252 phase:     168.43°  voltage\nV(3):   mag:    4.31227 phase:    104.995°  voltage\nI(C1):  mag:  0.0964252 phase:    -101.57°  device_current\nI(C2):  mag: 0.00862454 phase:   -165.005°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.977126 phase:    174.321°  device_current\nI(R2):  mag:   0.100579 phase:    74.0313°  device_current\nI(R3):  mag: 0.00862454 phase:    14.9951°  device_current\n\n\n\n\n19.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = 0.2 v_{1} - 0.1 v_{2}\\)\\(0 = - 0.1 v_{1} + v_{2} \\cdot \\left(0.01 s + 0.101\\right) - 0.001 v_{3}\\)\\(0 = - 0.001 v_{2} + v_{3} \\cdot \\left(0.002 s + 0.001\\right)\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n19.5.3 Plot the voltage at node 3\n\nH = U_ac[v3]\nH\n\n\\(\\displaystyle - \\frac{250.0}{10.0 s^{2} + 56.0 s + 25.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_15.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\nV_3 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n    V_3[i] = LTSpice_data[i][5] + LTSpice_data[i][6]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the phase plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(V_3)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(V_3)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(V_3[0:-1])-10**(mag/20),'-k')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_3[0:-1])*180/np.pi-phase,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-14}\\) and \\(10^{-13}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation tests",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "Example-problems.html",
    "href": "Example-problems.html",
    "title": "Example problems",
    "section": "",
    "text": "The table below is a list of the example problems with a short discription.\n\n\n\n\n\n\n\nTitle\nCircuit Description\n\n\n\n\nTwo amplifier RIAA Phono Preamp\nA circuit for a phono preamp is analyzed.\n\n\nTwo port parameters\nTwo port parameters are derived from the circuit’s netlist.\n\n\nThevenin equivalent circuit\nThe Thevenin equivalent circuit is obtained from a netlist.\n\n\nState variable filter\nNetwork equations for a state variable filter are obtained from the netlist which are solved in symbolic form.\n\n\nSuperposition\nA circuit to illustrate superposition and polyphase circuit analysis.\n\n\n2nd order BRF\nWalk through of the NMA code\n\n\nElliptic Function LPF\nA circuit too complex for quick symbolic solution\n\n\nInitial conditions\nVoltage on the capacitor and current in the inductor at t=0\n\n\nTransient circuit\nExamining the transient response of a circuit\n\n\nBridge T\nInitial conditions and transient solution\n\n\nPi Filter\nTransfer function using the FACTS method\n\n\nSIDO filter\nDeriving the symbolic transfer function of a filter\n\n\nSuper node\nAnalysis of a circuit with a super node\n\n\nPhasor analysis\nAnalysis of a circuit with phasor elements\n\n\nModeling Op Amps\nAnalysis of Op Amp model and stamp\n\n\nOp Amp circuits\nTypical Op Amp circuits and the use of the Op Amp element type\n\n\nMechanical systems\nElectric circuit analogs for a translational and a rotational mechanical system\n\n\nKlon Centuar• part 1• part 2• part 3\nAnalysis of the Klon Centuar guitar pedal• Introduction and effects path linear analysis• Effects path non-linear analysis• Design review and reactive branch analysis\n\n\nWien bridge oscillator\nAnalysis of a Wien bridge oscillator circuit\n\n\nFlyback circuit\nAnalysis of a flyback switch mode power supply\n\n\nDiode circuit\nCircuit analysis with one or more diodes in the circuit\n\n\nTransistor circuit\nCircuit analysis with one or more transistors in the circuit\n\n\nBridged T-coil\nA circuit with a coupled inductor and a bridging capacitor",
    "crumbs": [
      "Example problems"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html",
    "href": "Two amplifier RIAA Phono Preamp.html",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "",
    "text": "Abstract\nThis paper analyzes the circuit for the RIAA preamp given in the Texas Instruments application note AN346, High-Performance Audio Applications of the LM833, shown in the app note as Figure 3. The schematic for the phono preamplifier was entered into LTSpice and the circuit netlist was generated. A circuit analysis method called the Modified Nodal Analysis was used to derive the symbolic circuit equations and Python libraries were used to solve the equations. The preamplifier transfer function was used to calculate the Bode, impulse and step response plots. The Python results were compared to those from LTSpice. Deviation from the RIAA response curve was also examined. The sensitivity, Monte Carlo and worst case analysis for the preamplifier circuit was performed. The JupyterLab notebook showcases the use of Python in electrical engineering and circuit analysis.\nContents\n1. Introduction\n2. RIAA pre-emphasis curve\n3. AN346 RIAA Phono Preamplifier Design Procedure\n4. Analysis of the phono preamplifier circuit\n5. Summary",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#introduction",
    "href": "Two amplifier RIAA Phono Preamp.html#introduction",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.1 Introduction",
    "text": "20.1 Introduction\nThis JupyterLab notebook uses the SymPy, NumPy,SciPy and the Python programming language libraries to analyze a phono preamplifier circuit from the Texas Instruments application note, AN346, High-Performance Audio Applications of the LM833. The purpose of this analysis is to demonstrate the capability of using the Python libraries in electrical engineering circuit analysis. The circuit chosen for this analysis is a two stage RIAA Phono Preamplifier described in the application note. The preamplifier is designed to accurately reproduce the RIAA equalization curve required for playback of Vinyl LP records. The preamplifier provides about 35 dB of gain at 1kHz along with the proper gain profile and phase response. The schematic of the circuit is shown below with each node explicitly annotated.\n\n\n\nSchematic\n\n\nThere has been a resurgence in the popularity of Vinyl LP records over the last few years. So the use of a RIAA Phono Preamplifier is still relevant in this age where most music is delivered by streaming. Two internet news stories describe the current market for Vinyl LP records:\nThey Said the Album Was Dying. They Were Wrong\n\nVinyl sales have grown steadily for 17 years, but jumped by a stunning 46% in 2020 and 51% in 2021 …\n\nWhy Vinyl Records Are Making a Comeback in 2022\n\nThis year, 2020, marks the first year in more than a generation since record sales — that is to say physical vinyl records — have surpassed CD sales. The reasons for this are twofold: CD sales have dropped dramatically in recent years, while sales of vinyl records are actually up this year. And while you might think it’s nostalgic Boomers or Gen Xers behind the renaissance of records, in fact surveys show it’s millennial consumers driving the rising trend in vinyl sales.\n\n\nSo vinyl is here to stay, it seems, despite all technological advances that would have seemed to threaten it. The same RIAA study that found records surpassing CDs also revealed that streaming music now account for more than 85% of all music enjoyed. Only 6% of music is now downloaded, even less than is physically purchased in the form of records, CDs, or the last tapes.\n\nToday there are hundreds of phono products sold on Amazon. Phono preamps range in price from $10 to $1,000 dollars.\nThe Phono Preamplifier also known as a phono stage, is an audio component that amplifies the signal from your turntable to a level that allows you to connect it to your sound system the same way you would with any other audio source. In addition to boosting the signal from the phono cartridge, the preamp applies the RIAA equalization curve to the signal, reverting it back to the shape it was on the original recording. Phono cartridge output varies depending on the type of phono cartridge. Moving Magnet (MM) or Moving Iron (MI) cartridges typically produce a maximum output of 5mV. Moving Coil (MC) cartridges produce a much lower output, typically around 0.5mV maximum. Most phono preamps have switches that allow users to select the type of coil they have installed on their turntable arm.\nTexas Instruments provided the schematic of the preamplifier in their application note to highlight the types of applications their LM833 operational amplifier can support. Application notes are sometimes part of the marketing literature provided along with component data sheets by semiconductor manufacturers.\nRIAA equalization is a specification for the recording and playback of phonograph records, established by the Recording Industry Association of America (RIAA). RIAA was formed in 1952. Its original mission was to administer recording copyright fees and problems, work with trade unions, and do research relating to the record industry and government regulations. Early RIAA standards included the RIAA equalization curve, the format of the stereophonic record groove and the dimensions of 33 1/3, 45, and 78 rpm records.\nThe purposes of the equalization are to permit greater recording times (by decreasing the mean width of each groove), to improve sound quality and to reduce the groove damage that would otherwise arise during playback. RIAA equalization is a form of pre-emphasis on recording and de-emphasis on playback. A recording is made with the low frequencies reduced and the high frequencies boosted, and on playback, the opposite occurs. The net result is a flat frequency response, but with attenuation of high-frequency noise such as hiss and clicks that arise from the recording medium. Reducing the low frequencies also limits the excursions the cutter needs to make when cutting a groove. Groove width is thus reduced, allowing more grooves to fit into a given surface area, permitting longer recording times. This also reduces physical stresses on the stylus, which might otherwise cause distortion or groove damage during playback.\n\n20.1.1 Scope\nThe analysis presented in this notebook is intended to illustrate the use of Python for circuit analysis. This is not a tutorial on how to design a better phono preamp. The circuit taken from the Texas Instruments application note is examined for what it is, which is a suggested application for the use of their audio grade op amp. However, in this analysis I don’t address the performance of the op amp relative to the implementation of the RIAA equalization curve. I’m more concerned with examining the circuit’s ability to reproduce the proper gain and phase over the audio band. The performance LM833 op amp is assumed to be sufficient for this application and in my analysis of the circuit, I’ve replaced the LM833 with an ideal op amp model. Also, it is assumed that the reader is familiar with electronic components such as resistors, capacitors and operational amplifiers also known as op amps or opamps.\n\n\n20.1.2 Methodology\nThe analysis presented in this notebook will cover topics that are often presented during a design review. Usually during a design review conformance to requirements is presented. For the phono preamp circuit, the main performance requirement is minimum deviation from the RIAA curve. The application note from TI stated that the deviation is less than 0.1 dB over the audio band when using 1% resistors.\nIn this notebook the analysis is divided into sections.\n\nThe analysis will start with a description of the circuit operation and some basic calculations.\nThere are many symbols used in the equations and these are listed in a table for reference. I also tried to be constant with variable names.\nThe RIAA pre-emphasis curve is discussed and the transfer function, pole/zero plot and amplitude and phase response is plotted.\nCalculations for the phono preamplifier design procedure as covered in the application note are presented. The element values obtained with this procedure are the ones used in the analysis.\nThe equations for the transfer function of the preamp are derived by using a technique known as modified nodal analysis.\nThe preamp poles and zeros are plotted and some comments about stability are provided.\nThe amplitude and phase response of the preamp transfer function is plotted.\nThe impulse, step and group delay are plotted\nThe amplitude and phase response of the preamp transfer function is plotted against results taken from LTSpice as a check and comparison.\nThe deviation of the amplitude and phase response from the RIAA curve is plotted.\nSensitivity analysis, component selection, Monte Carlo analysis and worst case analysis are presented.\n\n\nimport os\nimport sys\nimport random\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\nDefine a function to return the system gain at a frequency: get_gain()\n\ndef get_gain(freq_Hz, sys):\n    '''\n    freq_Hz: the frequency in Hz for which the system gain is desired\n    sys: a SciPy instance of the LTI class or a tuple describing the system\n    '''\n    f1 = freq_Hz - freq_Hz*0.1 # lower limit of the frequency range\n    f1a = freq_Hz - freq_Hz*0.01 # lower interpolation point\n    f2 = freq_Hz + freq_Hz*0.1 # upper limit of the frequency range\n    f2a = freq_Hz + freq_Hz*0.01  # upper interpolation point\n\n    x_axis_range = np.linspace(f1*2*np.pi, f2*2*np.pi, 1000, endpoint=True) # define the range frequency range\n    w, mag, phase = sys.bode(w=x_axis_range)\n\n    index_for_f1a = np.where(w &gt; f1a*2*np.pi)[0][0]\n    index_for_f2a = np.where(w &gt; f2a*2*np.pi)[0][0]\n\n    return np.interp(freq_Hz, [w[index_for_f1a]/(2*np.pi),w[index_for_f2a]/(2*np.pi)], [mag[index_for_f1a],mag[index_for_f2a]])\n\n\n\n20.1.3 Schematic and circuit description\nThe circuit from Figure 3 of AN346 was entered into LTSpice and the circuit nodes were numbered as shown above. Any schematic capture program could be used for this as long as a SPICE netlist can be generated. In the schematic, the voltage source V1, is set to 5 mV to represent the output of a Moving Magnet (MM) or Moving Iron (MI) cartridge. The input to the preamp is shunted by a capacitance, which is equal to the sum of the input cable capacitance and the cartridge. This capacitance resonates with the inductance of the moving magnet cartridge to determine the frequency response of the transducer, so when a moving magnet pickup is used, Cp should be carefully chosen so that the total capacitance is equal to the recommended load capacitance for that particular cartridge. 100 pF is used in this analysis. Rp is the recommended resistive load for the phono cartridge. In some commercial preamp designs, the value of Rp is user selectable with switches. As shown in the calculations, Cp and Rp have a resonant frequency of 33.86kHz.\n\nCp = 100e-12\nRp = 47e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Rp*Cp)))\n\nresonant frequency: 33,862.8 Hz\n\n\n33,862 Hz is well above the audio range.\nThe first operational amplifier, U1, takes care of the 50 Hz and 500 Hz breakpoints. For the analysis with Python, the Op Amp is modeled as an ideal Op Amp. There is expected to be some differences between the LTSpice results and the Python analysis. Using two amplifiers results in accurate conformance to the RIAA curve without reverting to the noisy inverting topology, as well as lower distortion due to the fact that each amplifier is operating at a lower gain than would be the case in a single-amplifier design.\nThe resistor, R1, which has a value of 80.6k\\(\\Omega\\) and the capacitor C1, which has a value of 0.039 \\(\\mu\\)Farads, form a resonant pair with frequency of 50.6 Hz.\n\nR1 = 80.6e3\nC1 = 0.039e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R1*C1)))\n\nresonant frequency: 50.6 Hz\n\n\n50 Hz is one of the RIAA time constants required by the RIAA specification.\nFrom here on, I’ll refer to resistors that have values in 1000’s of Ohms by using k for thousands of Ohms or just the numerical value if it’s less than 1000. Capacitors will have values indicated in \\(\\mu\\) for micro Farads and p for pico Farads, designated as \\(\\mu\\) or p. \n\nR2 = 8.45e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R2*C1)))\n\nresonant frequency: 482.9 Hz\n\n\nC1 and R2 have a resonant frequency of 482.94 Hz. As described later, these frequencies correspond to the time constants required by the RIAA specification.\nCo provides an AC ground for the non-inverting configuration of U1. Ro along with R1 and R2 set the low frequency gain of U1.\n\nRo = 499\nCo = 200e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Ro*Co)))\n\nresonant frequency: 1.6 Hz\n\n\nRo=499 and Co=200\\(\\mu\\) have a resonant frequency of 1.6 Hz.\n\nRf=R1+R2\nprint('low frequency voltage gain of U1: {:,.2f} or {:,.1f}dB'.format(1+Rf/Ro, 20*np.log10(1+Rf/Ro)))\n\nlow frequency voltage gain of U1: 179.46 or 45.1dB\n\n\nRo along with R1 and R2 set the low frequency gain of U1 at 45 dB.\n\nR3 = 2.37e3\nC3 = 0.033e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R3*C3)))\n\nresonant frequency: 2,035.0 Hz\n\n\nR3=2.37k and C3=0.033\\(\\mu\\) have a resonant frequency of 2034.96 Hz and corresponds to the the third time constant specified by RIAA.\nC4=2\\(\\mu\\) and R6=54.9k form a high pass filter with a corner frequency of 1.45Hz.\n\nR6 = 54.9e3\nC4 = 2e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R6*C4)))\n\nresonant frequency: 1.4 Hz\n\n\nU2, R4 and R5 form a non-inverting configuration with a voltage gain of 3.15 or 9.98 dB.\n\nR4 = 2e3\nR5 = 4.3e3\nprint('voltage gain of U2: {:,.2f} or {:,.1f}dB'.format(1+R5/R4, 20*np.log10(1+R5/R4)))\n\nvoltage gain of U2: 3.15 or 10.0dB\n\n\n\n\n20.1.4 Symbols\nIn addition to the variables listed in Chapter 1, Table 20.1 lists the variable names used in this notebook.\n\n\n\nTable 20.1: Variable names used in this notebook\n\n\n\n\n\n\n\n\n\nVariable name\ndefinition\n\n\n\n\ns\nwhen used in a polynomial: the Laplace variable equal to \\(j\\omega\\), where \\(j=\\sqrt{-1}\\)\n\n\n\\(\\mu\\)\n\\(1 \\times 10^{-6}\\) multiplier, either: \\(1 \\times 10^{-6}\\) seconds or \\(1 \\times 10^{-6}\\) Farads\n\n\nT\ntime constant: T1, T2, T3\n\n\n\\(\\omega\\)\nangular frequency, radians per second, \\(\\omega = 1/T\\)\n\n\nRIAA_num\nnumerator of the RIAA pre-emphasis transfer function\n\n\nRIAA_den\ndenominator of the RIAA pre-emphasis transfer function\n\n\nw_RIAA\nradian frequency of the RIAA pre-emphasis transfer function\n\n\nmag_RIAA\nmagnitude of the RIAA pre-emphasis transfer function\n\n\nphase_RIAA\nphase of the RIAA pre-emphasis transfer function\n\n\nRIAA_gain_1kHz\ngain of the RIAA pre-emphasis transfer function at 1kHz\n\n\npreamp_equ_sym\npreamp circuit equations with symbolic values\n\n\nU_sym\nsymbolic solution to network equations, node voltages and unknown currents\n\n\nH_sym\ntransfer function with symbolic coefficients\n\n\npreamp_equ\ncircuit equations with numeric element values\n\n\nH_preamp_num\nnumerator of the transfer function\n\n\nH_preamp_denom\ndenominator of the transfer function\n\n\npreamp_sys\nSciPy representation of the preamp system\n\n\npreamp_gain_1kHz\ngain of the preamp transfer function at 1kHz\n\n\nw_preamp\nradian frequency of the preamp transfer function\n\n\nmag_preamp\nmagnitude of the preamp transfer function\n\n\nphase_preamp\nphase of the preamp transfer function",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "href": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.2 RIAA pre-emphasis curve",
    "text": "20.2 RIAA pre-emphasis curve\nThe RIAA equalization curve was established in 1954. The equalization is defined by time constants, T1, T2 and T3. During the Phonograph record manufacturing process, a pre-emphasis is applied to the signal, which allows for longer playback times on phonograph records by decreasing the average width of the groove cut into vinyl phonograph disks. The curve attenuates low frequencies and amplifies high frequencies, relative to 1 kHz. Since low frequencies cause wide undulations in the record groove, they must be attenuated to keep the grove within its bounds. Above 1 kHz, the frequencies are amplified which helps overcome the inherent noise produced by the phonograph needle during play-back.\nThe RIAA disc recording/reproduction standard specifies the time constants of, \\(T1 = 75 \\mu s\\), \\(T2 = 318 \\mu s\\) and \\(T3 = 3180 \\mu s\\) and the pre-emphasis transfer function:\n\\(RIAA(s)=\\frac {(sT_{1}+1)(sT_{3}+1)}{(sT_{2}+1)}\\)\nThe three time constants correspond to the frequencies calculated below.\n\nT1 = 75e-6\nT2 = 318e-6\nT3 = 3180e-6\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T1*1e6,1/(T1*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T2*1e6,1/(T2*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T3*1e6,1/(T3*2*np.pi)))\n\n75 μs corresponds to 2,122.1 Hz\n318 μs corresponds to 500.5 Hz\n3180 μs corresponds to 50.0 Hz\n\n\nThe time constants are put in polynomial form using s as the Laplace variable. The numerator and denominator of the pre-emphasis transfer function is defined below.\n\ns = symbols('s')\nRIAA_num = Eq(((s*T3+1)*(s*T1+1)),0)\nRIAA_denom = Eq(s*T2+1,0)\n\nSolve for the poles and zeros of the pre-emphasis transfer function and plot the locations on the complex s-plane. The zeros of the transfer function are the roots of the numerator polynomial. The poles of the transfer function are the roots of the denominator polynomial.\n\nRIAA_zeros = solve(RIAA_num,s)\nRIAA_poles = solve(RIAA_denom,s)\n\n\nplt.plot(np.real(RIAA_zeros), np.imag(RIAA_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(RIAA_poles), np.imag(RIAA_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(RIAA_zeros)))\nfor i in RIAA_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n-2,122.07 Hz\n-50.05 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(RIAA_poles)))\nfor i in RIAA_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-500.49 Hz\n\n\nAs shown in the plot above, the poles and zeros lay on the negative real axis. The de-emphasis transfer function of the phono pre-amplifier should have poles at the zero locations and a zero in the pole location in the plot above.\nThe code below is used to convert SymPy symbolic equations to a NumPy polynomial representation. The SciPy function, TransferFunction, represents the system as the continuous-time transfer function. The NumPy function, logspace, is used to generate data points on a log scale for plotting. The SciPy function, bode, is used to generate the magnitude and phase data of a continuous-time system.\n\na = np.array(Poly(RIAA_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(RIAA_denom, s).all_coeffs(), dtype=float)\nRIAA_sys = signal.TransferFunction(a,b)\n\nx_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\nw_RIAA, mag_RIAA, phase_RIAA = RIAA_sys.bode(w=x_axis_range) # returns: rad/s, mag in dB, phase in deg\n\nFind the gain at 1kHz so the plots can be normalized for 0 dB at 1 kHz.\n\nRIAA_gain_1kHz = get_gain(1000,RIAA_sys)\n\n\nprint('The RIAA gain at 1kHz: {:.3f} dB'.format(RIAA_gain_1kHz))\n\nThe RIAA gain at 1kHz: 19.911 dB\n\n\nPlot the magnitude and phase of the RIAA curve.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_RIAA/(2*np.pi), mag_RIAA-RIAA_gain_1kHz,'-k')    # Bode magnitude plot, normalized to 0 at 1kHz\n\n# mark individual points\np3 = np.where(w_RIAA &gt; 49.9*(2*np.pi))[0][0]\np2 = np.where(w_RIAA &gt; 499.9*(2*np.pi))[0][0]\np1 = np.where(w_RIAA &gt; 2122*(2*np.pi))[0][0]\n\nplt.semilogx(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-RIAA_gain_1kHz,'^k')\n\nplt.text(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-25,'T1')\nplt.text(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-25,'T2')\nplt.text(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-25,'T3')\n\n# highlight the audio band, 20 to 20kHz\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w_RIAA/(2*np.pi), phase_RIAA,':',color='b',label='phase')  # Bode phase plot\n\n# mark individual points\nplt.semilogx(w_RIAA[p1]/(2*np.pi), phase_RIAA[p1],'xb')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), phase_RIAA[p2],'xb')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), phase_RIAA[p3],'xb')\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\nax2.set_ylim((0,100))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('RIAA pre-emphasis magnitude and frequency plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the frequency response of the RIAA curve. The frequencies corresponding to the time constants T1, T2 and T3 are plotted on the magnitude and phase curves. The audio band of 20Hz to 20kHz is highlighted. One thing to notice about this curve is that the amplitude is increasing as the frequency increases. This is not a realistic function, real circuits do not have an infinite gain as the frequency goes to infinity. Also, there is no zero at \\(j\\omega=0\\), so the pre-emphasis transfer function does not block DC.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "href": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.3 Phono Preamplifier Design Procedure",
    "text": "20.3 Phono Preamplifier Design Procedure\nThe following notebook cells walk through the design procedure given in the application note, starting on page 5.\nA design procedure is shown below with an illustrative example using 1% tolerance E96 components for close conformance to the ideal RIAA curve. Since 1% tolerance capacitors are often difficult to find except in 5% or 10% standard values, the design procedure calls for re-calculation of a few component values so that standard capacitor values can be used.\n\nChoose \\(R_o\\). \\(R_o\\) should be small for minimum noise contribution, but not so small that the feedback network excessively loads the amplifier. Example: Choose \\(R_o = 500\\)\nChoose 1 kHz gain, A1 of the first amplifier. This will typically be around 20 dB to 30 dB. Example: Choose A1 = 26 dB = 20\nCalculate \\(R_11 = 8.058 \\times R_o \\times A_1\\)\n\n\nA1 = 20\nRo = 500\nR1 = 8.058 * Ro * A1\nprint('R1={:,.0f}'.format(R1))\n\nR1=80,580\n\n\n\nCalculate C1\n\n\\(C_1 = \\frac {3.18 \\times 10^{-3}}{R_1}\\)\n\nC1 = 3.18e-3/R1\nprint('C1={:.4e}'.format(C1))\n\nC1=3.9464e-08\n\n\nThe calculated value for capacitor C1 is not a standard value, so step 5 takes care of this.\n\nIf C1 is not a convenient value, choose the nearest convenient value and calculate a new R1 from:\n\n\\(R_1 = \\frac {3.18 \\times 10^{-3}}{3.9 \\times 10^{-8}}\\)\nChoose C1 to be 0.039\\(\\mu\\), which is a standard capacitor value.\n\nC1 = 0.039e-6\nR1 = 3.18e-3/C1\nprint('R1={:,.0f}'.format(R1))\n\nR1=81,538\n\n\nNow choose a standard resistor value close to the calculated value, which is 80.6k.\nE96 resistor values are a set of preferred values for 1% resistors. When doing the calculations to determine the resistor values, the closest standard value is chosen from the E96 series. The E series of preferred numbers derived for use in electronic components. It consists of the E3, E6, E12, E24, E48, E96 and E192 series, where the number after the ‘E’ designates the quantity of logarithmic value “steps” per decade.\n\nR1 = 80.6e3\n\nCalculate a new value for Ro.\n\\(R_o=\\frac {R_1}{8.058A_1}\\)\n\nRo = R1/(8.058*A1)\nprint('R1={:,.0f}'.format(Ro))\n\nR1=500\n\n\nChoose a standard value close to this value, which is 499.\n\nRo = 499\n\n\nCalculate R2\n\\(R_2=\\frac {R_1}{9} - R_o\\)\n\n\nR2 = R1/9-Ro\nprint('R1={:,.0f}'.format(R2))\n\nR1=8,457\n\n\nChoose a standard value close to this value, which is 8.45k.\n\nR2 = 8.45e3\n\n\nChoose a convenient value for C3 in the range from 0.01 \\(\\mu\\)F to 0.05 \\(\\mu\\)F.\nExample: C3 = 0.033 \\(\\mu\\)F\n\n\nC3 = 0.033e-6\nprint('C3={:,.3f}\\u03BC'.format(C3*1e6))\n\nC3=0.033μ\n\n\n\nCalculate Rp\n\\(R_p=\\frac {75 \\mu s }{C_3}\\)\n\n\\(75 \\mu s\\) is one of the RIAA time constants.\n\nRp = 75e-6/C3\nprint('Rp={:,.0f}'.format(Rp))\n\nRp=2,273\n\n\n\nChoose a standard value for R3 that is slightly larger than Rp.\nExample: R3 = 2.37k, which is a standard resistor value.\n\n\nR3 = 2.37e3\n\n\nCalculate R6 from \\(1/R_6 = 1/R_P − 1/R_3\\)\n\n\nR6 = 1/(1/Rp-1/R3)\nprint('R6={:,.0f}'.format(R6))\n\nR6=55,374\n\n\n54.9k is the closest standard value.\n\nR6 = 54.9e3\n\n\nCalculate \\(C_4\\) for low-frequency roll off below 1 Hz from design Equation 5.\n\n\\(C_4=\\frac{1}{2\\pi f_L(R_3+R_6)}\\)\nWhere \\(f_L\\) is the low frequency -3dB corner of the second stage.\nIn the application note, there is a comment on page 4:\n&gt; If the preamplifier is to follow the IEC recommendation (IEC Publication 98, Amendment #4), fL should equal 20.2 Hz.\nThe calculations in the app note use 1 Hz.\n\nf_L = 1.0 # Hz\nC4 = 1/(2*np.pi*f_L*(R3+R6))\nprint('C4={:,.3f}\\u03BC'.format(C4*1e6))\n\nC4=2.779μ\n\n\n2\\(\\mu\\)F is a standard value close to the calculated value.\nExample: C4 = 2 \\(\\mu\\)F.\n\nChoose the gain of the second amplifier.\nExample: The 1 kHz gain up to the input of the second amplifier is about 26 dB for this example. For an overall 1 kHz gain equal to about 36 dB we choose:\n\\(A_2 = 10 dB = 3.16\\)\nChoose value for R4.\nExample: R4 = 2k\n\n\nR4 = 2e3\n\n\nCalculate \\(R_5 = (A_2 − 1) R_4\\)\n\n\nA2 = 3.16\nR5 = (A2-1)*R4\nprint('R5={:,.0f}'.format(R5))\n\nR5=4,320\n\n\n4.3k is a standard value close to the calculated value.\n\nR5 = 4.3e3\n\n\nCalculate Co for low-frequency roll off below 1 Hz from design Equation 7.\n\n\\(C_o=\\frac {1}{2\\pi f_o R_o}\\)\nwhere fo is the low-frequency −3 dB corner of the first amplifier. fo is chosen to be 1Hz for the calculations since this frequency is well below the audible frequency range.\n\nfo = 1 # 1 Hz\nCo = 1/(2*np.pi*fo*Ro)\nprint('Co={:,.3f}\\u03BC'.format(Co*1e6))\n\nCo=318.948μ\n\n\nThe value chosen in the app note for this component is 200\\(\\mu\\)F.\n\nCo = 200e-6\n\n\nprint('resonant frequency of Ro and Co: {:.2f}Hz'.format(1/(Co*Ro*2*np.pi)))\n\nresonant frequency of Ro and Co: 1.59Hz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "href": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.4 Analysis of AN-346 phono preamplifier circuit",
    "text": "20.4 Analysis of AN-346 phono preamplifier circuit\nThe schematic of the preamp was entered into LTSpice and the netlist was generated. Starting with a schematic and then using LTSpice to generate the net list eliminates errors that would occur if these circuits were analyzed by hand. For small circuits with a handful of components, symbolic solutions of the node equations can be of interest, but for larger circuits, not so much. This is because the number of symbols and equations is too large to offer in insight without some simplification.\nIn this section the modified nodal analysis method will be used to generate the circuit equations. The modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. The Python code that generates the circuit’s equations is located here.\n\n20.4.1 Modified nodal analysis\nThe preamp circuit has 15 branches, 9 nodes, 3 unknown currents, 14 passive components and 2 op amps. The net list generated by LTSpice and some edits were made to put the component values into scientific notation with units of Ohms, Farads and Henerys and the Op Amp statements were fixed. The edited netlist is:\nV1 1 0 5e-3\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\n\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\n\nnet_list = '''\nV1 1 0 5e-3\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the SMNA function. The A, X and Z are formulated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(Cp s + \\frac{1}{Rp}\\right)\\)\\(0 = I_{O2} + \\frac{v_{2}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\)\\(0 = v_{3} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Ro}\\)\\(0 = v_{4} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{3}}{Ro}\\)\\(0 = v_{3} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{5} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{6}}{R_{2}}\\)\\(0 = I_{O1} + v_{6} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{7}}{R_{3}} - \\frac{v_{5}}{R_{2}}\\)\\(0 = - C_{4} s v_{8} + v_{7} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{3}}\\)\\(0 = - C_{4} s v_{7} + v_{8} \\left(C_{4} s + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}}\\)\\(V_{1} = v_{1}\\)\\(0 = - v_{1} + v_{3}\\)\\(0 = - v_{8} + v_{9}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{5}, \\  R_{4}, \\  v_{6}, \\  v_{7}, \\  v_{2}, \\  Ro, \\  I_{V1}, \\  I_{O1}, \\  C_{4}, \\  v_{8}, \\  v_{4}, \\  v_{1}, \\  Rp, \\  s, \\  I_{O2}, \\  Cp, \\  v_{9}, \\  C_{3}, \\  R_{5}, \\  C_{1}, \\  R_{2}, \\  R_{6}, \\  R_{3}, \\  v_{3}, \\  R_{1}, \\  V_{1}, \\  Co\\right)\\)\n\n\nThese equations can be solved in their symbolic form using the solve function from SymPy. The solution time takes about 3 seconds on my i3 laptop.\n\nU_preamp_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution to the newtork equations.\n\ntemp = ''\nfor i in U_preamp_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_preamp_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{V_{1}}{Co Ro s + 1}\\)\\(v_{5} = \\frac{C_{1} Co R_{1} Ro V_{1} s^{2} + C_{1} R_{1} V_{1} s + Co R_{1} V_{1} s + Co Ro V_{1} s + V_{1}}{C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co Ro s + 1}\\)\\(v_{6} = \\frac{C_{1} Co R_{1} R_{2} V_{1} s^{2} + C_{1} Co R_{1} Ro V_{1} s^{2} + C_{1} R_{1} V_{1} s + Co R_{1} V_{1} s + Co R_{2} V_{1} s + Co Ro V_{1} s + V_{1}}{C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co Ro s + 1}\\)\\(v_{7} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} + C_{1} Co R_{1} R_{2} V_{1} s^{2} + C_{1} Co R_{1} Ro V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{4} Co R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{6} V_{1} s^{2} + C_{4} Co R_{6} Ro V_{1} s^{2} + C_{4} R_{6} V_{1} s + Co R_{1} V_{1} s + Co R_{2} V_{1} s + Co Ro V_{1} s + V_{1}}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(v_{8} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{6} V_{1} s^{2} + C_{4} Co R_{6} Ro V_{1} s^{2} + C_{4} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(v_{9} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{6} V_{1} s^{2} + C_{4} Co R_{6} Ro V_{1} s^{2} + C_{4} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(I_{V1} = \\frac{- Cp Rp V_{1} s - V_{1}}{Rp}\\)\\(I_{O1} = \\frac{- C_{1} C_{3} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{4} - C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} V_{1} s^{4} - C_{1} C_{3} C_{4} Co R_{1} R_{6} Ro V_{1} s^{4} - C_{1} C_{3} C_{4} R_{1} R_{6} V_{1} s^{3} - C_{1} C_{3} Co R_{1} R_{2} V_{1} s^{3} - C_{1} C_{3} Co R_{1} R_{3} V_{1} s^{3} - C_{1} C_{3} Co R_{1} Ro V_{1} s^{3} - C_{1} C_{3} R_{1} V_{1} s^{2} - C_{1} C_{4} Co R_{1} R_{2} V_{1} s^{3} - C_{1} C_{4} Co R_{1} R_{3} V_{1} s^{3} - C_{1} C_{4} Co R_{1} R_{6} V_{1} s^{3} - C_{1} C_{4} Co R_{1} Ro V_{1} s^{3} - C_{1} C_{4} R_{1} V_{1} s^{2} - C_{1} Co R_{1} V_{1} s^{2} - C_{3} C_{4} Co R_{1} R_{6} V_{1} s^{3} - C_{3} C_{4} Co R_{2} R_{6} V_{1} s^{3} - C_{3} C_{4} Co R_{3} R_{6} V_{1} s^{3} - C_{3} C_{4} Co R_{6} Ro V_{1} s^{3} - C_{3} C_{4} R_{6} V_{1} s^{2} - C_{3} Co R_{1} V_{1} s^{2} - C_{3} Co R_{2} V_{1} s^{2} - C_{3} Co R_{3} V_{1} s^{2} - C_{3} Co Ro V_{1} s^{2} - C_{3} V_{1} s - C_{4} Co R_{1} V_{1} s^{2} - C_{4} Co R_{2} V_{1} s^{2} - C_{4} Co R_{3} V_{1} s^{2} - C_{4} Co R_{6} V_{1} s^{2} - C_{4} Co Ro V_{1} s^{2} - C_{4} V_{1} s - Co V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(I_{O2} = \\frac{- C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} - C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} - C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} - C_{4} Co R_{1} R_{6} V_{1} s^{2} - C_{4} Co R_{2} R_{6} V_{1} s^{2} - C_{4} Co R_{6} Ro V_{1} s^{2} - C_{4} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}}\\)\n\n\n\nThe transfer function for the preamp is the equation for the output node, 2, divided by the equation for the input node 1.\n\nH_preamp_sym = U_preamp_sym[v2]/U_preamp_sym[v1]\n\nThe symbolic solution obtained by SymPy, while not being very interesting since they are unwieldy, illustrate the power of SymPy to easily obtain symbolic solutions that would be very difficult to obtain by hand.\n\nH_preamp_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{V_{1} \\left(C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}\\right)}\\)\n\n\nThe SymPy function, cancel(), can be used to put the preamp transfer function in to standard canonical form, where the polynomials are expanded with no common factors and the leading coefficients do not have denominators (i.e., are integers).\n\ncancel(H_preamp_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} C_{4} R_{1} R_{5} R_{6} + C_{4} Co R_{1} R_{4} R_{6} + C_{4} Co R_{1} R_{5} R_{6} + C_{4} Co R_{2} R_{4} R_{6} + C_{4} Co R_{2} R_{5} R_{6} + C_{4} Co R_{4} R_{6} Ro + C_{4} Co R_{5} R_{6} Ro\\right) + s \\left(C_{4} R_{4} R_{6} + C_{4} R_{5} R_{6}\\right)}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + R_{4} + s^{3} \\left(C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} Co R_{1} R_{4} Ro + C_{3} C_{4} R_{3} R_{4} R_{6} + C_{3} Co R_{3} R_{4} Ro + C_{4} Co R_{3} R_{4} Ro + C_{4} Co R_{4} R_{6} Ro\\right) + s \\left(C_{1} R_{1} R_{4} + C_{3} R_{3} R_{4} + C_{4} R_{3} R_{4} + C_{4} R_{4} R_{6} + Co R_{4} Ro\\right)}\\)\n\n\nThe Sympy function, factor(), can be used to factor the polynomials into irreducible factors over the rational numbers.\n\nH_preamp_sym.factor()\n\n\\(\\displaystyle \\frac{C_{4} R_{6} s \\left(R_{4} + R_{5}\\right) \\left(C_{1} Co R_{1} R_{2} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co R_{1} s + Co R_{2} s + Co Ro s + 1\\right)}{R_{4} \\left(C_{1} R_{1} s + 1\\right) \\left(Co Ro s + 1\\right) \\left(C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} R_{3} s + C_{4} R_{3} s + C_{4} R_{6} s + 1\\right)}\\)\n\n\nThe symbolic solutions obtained above will be used later when the sensitivity analysis of the preamp is performed. Otherwise the roots in symbolic form don’t seem to be particularly insightful, but are easily obtained by SymPy.\n\n20.4.1.1 Numerical solution\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {V1:5.0000e-03, C1:3.9000e-08, Co:2.0000e-04, Ro:4.9900e+02, R3:2.3700e+03, R1:8.0600e+04, \n    R2:8.4500e+03, Cp:1.0000e-10, Rp:4.7000e+04, C3:3.3000e-08, C4:2.0000e-06, R6:5.4900e+04, R4:2.0000e+03, R5:4.3000e+03}\n\n# put the element values into the equations\npreamp_equ = NE_sym.subs(nominal_component_value)\n\nNow we can display the network equations with values for the components instead of symbols.\n\ntemp = ''\nfor i in range(shape(preamp_equ.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(preamp_equ.rhs[i]),latex(preamp_equ.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-10} s + 2.12765957446809 \\cdot 10^{-5}\\right)\\)\\(0 = I_{O2} + 0.000232558139534884 v_{2} - 0.000232558139534884 v_{9}\\)\\(0 = v_{3} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.00201641496392288\\right) - 0.00200400801603206 v_{4} + v_{5} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right)\\)\\(0 = - 0.00200400801603206 v_{3} + v_{4} \\cdot \\left(0.0002 s + 0.00200400801603206\\right)\\)\\(0 = v_{3} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right) + v_{5} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.000130750143157091\\right) - 0.000118343195266272 v_{6}\\)\\(0 = I_{O1} - 0.000118343195266272 v_{5} + 0.000540284123536314 v_{6} - 0.000421940928270042 v_{7}\\)\\(0 = - 2.0 \\cdot 10^{-6} s v_{8} - 0.000421940928270042 v_{6} + v_{7} \\cdot \\left(2.033 \\cdot 10^{-6} s + 0.000421940928270042\\right)\\)\\(0 = - 2.0 \\cdot 10^{-6} s v_{7} + v_{8} \\cdot \\left(2.0 \\cdot 10^{-6} s + 1.82149362477231 \\cdot 10^{-5}\\right)\\)\\(0 = - 0.000232558139534884 v_{2} + 0.000732558139534884 v_{9}\\)\\(0.005 = v_{1}\\)\\(0 = - v_{1} + v_{3}\\)\\(0 = - v_{8} + v_{9}\\)\n\n\nSolve for voltages and currents.\nUsing the SymPy solve function we can solve the system of equations.\n\nU_preamp = solve(preamp_equ,X)\n\nThe values of the exponents are very large in the solution. The numerator and denominator for v2 could be normalized. Another option for avoiding large exponents is to 1st normalize the component values by frequency scaling. I suppose that large exponents don’t become a problem as long as they remain under two digits.\n\nLetting SciPy do the math and not worrying about the size of the exponents. The transfer function can be obtained by dividing the equation for node 2 by the equation for node 1. The system transfer function, is \\(H(s) = \\frac {v2}{V1}\\)\n\nH_preamp = U_preamp[v2]/U_preamp[v1]\nH_preamp\n\n\\(\\displaystyle \\frac{200.0 \\cdot \\left(2.76499422921242 \\cdot 10^{69} s^{3} + 8.80353368479522 \\cdot 10^{72} s^{2} + 4.91462150480132 \\cdot 10^{71} s\\right)}{7.65600122987477 \\cdot 10^{65} s^{4} + 1.0469819689888 \\cdot 10^{70} s^{3} + 3.44479259637884 \\cdot 10^{72} s^{2} + 6.18286042227129 \\cdot 10^{73} s + 2.84188944100537 \\cdot 10^{74}}\\)\n\n\nfactor() takes a polynomial and factors it into irreducible factors over the rational numbers. For example:\n\nH_preamp.factor()\n\n\\(\\displaystyle \\frac{6.19554973375798 s \\left(0.000314077770155853 s^{2} + 1.0 s + 0.0558255546098434\\right)}{2.69398278462456 \\cdot 10^{-9} s^{4} + 3.68410520790143 \\cdot 10^{-5} s^{3} + 0.012121487017314 s^{2} + 0.21756161 s + 1.0}\\)\n\n\n\n\n20.4.1.2 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into NumPy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_preamp_num, H_preamp_denom = fraction(H_preamp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction(), represents the system as the continuous-time transfer function and takes as inputs the coefficients of the numerator and denominator polynomials.\n\n# convert symbolic to numpy polynomial\na2 = np.array(Poly(H_preamp_num, s).all_coeffs(), dtype=float)\nb2 = np.array(Poly(H_preamp_denom, s).all_coeffs(), dtype=float)\npreamp_sys = signal.TransferFunction(a2,b2)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\npreamp_sys_zeros = np.roots(preamp_sys.num)\npreamp_sys_poles = np.roots(preamp_sys.den)\n\n\n\n\n20.4.2 Pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(preamp_sys_zeros), np.imag(preamp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(preamp_sys_poles), np.imag(preamp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(preamp_sys_zeros)))\nfor i in preamp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-506.73 Hz\n-0.01 Hz\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(preamp_sys_poles)))\nfor i in preamp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-2,122.88 Hz\n-50.63 Hz\n-1.59 Hz\n-1.39 Hz\n\n\nWe can see that the RIAA time constants, displayed in terms of frequency are present, although the values differ by a few Hz. There are two zeros and two poles at nearly zero Hz and these cancel each other.\n\n\n20.4.3 Stability\nBy inspecting the plot above, we can tell the preamplifier is stable since the phase shift at 0 dB of gain is less than 180 degrees. Additionally, all the poles of the transfer function are in the left hand plane.\nNow we can find the preamp gain at 1 kHz, so that the bode plots can be normalized.\n\npreamp_gain_1kHz = get_gain(1000, preamp_sys)\nprint('preamp gain at 1kHz: {:f} dB'.format(preamp_gain_1kHz))\n\npreamp gain at 1kHz: 34.783614 dB\n\n\n\n\n20.4.4 Bode plot, Frequency and phase response\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nextended_x_axis_range = np.logspace(-2, 8, 5000, endpoint=True)*2*np.pi\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=extended_x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b' #'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color=color,label='phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude')\n\nplt.legend(loc=0)\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe magnitude and phase plot for the preamplifier is plotted from 0.01 Hz to 100 MHz. The preamplifier circuit blocks DC because C4 is in series with the audio path.\n\n\n20.4.5 Impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n20.4.6 Group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=x_axis_range)\n\nplt.title('AN-346 phono preamplifier group delay')\nplt.semilogx(w_preamp/(2*np.pi), -np.gradient(phase_preamp*np.pi/180)/np.gradient(w_preamp),'-',label='group delay')\n\n#plt.semilogx(w_c1/(2*np.pi), -np.gradient(phase_c1)/w_c1/1e-3,'-',label='phase delay')\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies below 100 Hz, the group delay is as much as 4 ms in the audio band. According to paper, Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe preamp group delay in the low end of the audio band is of concern and some re-design should be implemented if this preamp was to be implemented. The group delay plotted above agrees with the group delay results obtained from LTSpice simulation of the preamp circuit.\n\n\n\n20.4.7 Preamplifier deviation from RIAA response\nThe plot below shows the deviation of the preamplifier from the RIAA response. The TI app note says conformance to the RIAA curve is within 0.1 dB from 20 Hz to 20 kHz. The series response of the RIAA curve with that of the preamp response curve can be obtained by adding the magnitude quantities. If the preamp response is the exact inverse of the RIAA curve, the result will be a flat line.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.2,0.1))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_RIAA+phase_preamp,':',color=color,label='phase of S2')  # Bode phase plot\n\nax2.set_ylabel('phase difference preamplifier, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude of S1')\nplt.legend(loc=0)\n\nplt.title('Preamp deviation from RIAA response')\nplt.show()\n\n\n\n\n\n\n\n\nThe calculations below will find the minimum and maximun deviation of the amplitude response from the RIAA curve.\n\nidx_low = np.where(w_preamp/(2*np.pi) &gt; 20)[0][0]\nidx_high = np.where(w_preamp/(2*np.pi) &gt; 20e3)[0][0]\nprint('preamp deviation from RIAA curve: {:.3f} to {:.3f} dB'.format(((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].min(),((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].max()))\n\npreamp deviation from RIAA curve: -0.045 to 0.066 dB\n\n\nThe calculations above show that within the audio range the deviation of the preamp amplitude response from the RIAA curve varies from -0.044 to 0.066 dB when the nominal component values are used.\n\n\n20.4.8 Sensitivity analysis\nAll circuits have characteristics that depend on the values of the component. The sensitivity of a circuit’s performance is a measure of how much a particular circuit characteristic changes as a particular component value varies. In this analysis I’ll look at the changes of each pole or zero relative to the component’s value.\nThe root sensitivity function \\(S_x^y\\) gives the change occurring in filter characteristic per \\(\\delta y/ \\delta x\\).\n\\(S_x^y\\) is read as the sensitivity of the characteristic (i.e. y = \\(\\omega_n,\\) or Q or some other characteristic) with respect to the element x.\n\\(S_x^y = \\frac {x}{y} \\frac{\\delta y}{\\delta x}\\)\nWhere x is the filter component that is varied and y is the filter characteristic (\\(\\omega_n,\\) or Q etc.) that we wish to evaluate as x is varied.\nThe preamp transfer function in symbolic form is, H_preamp_sym, and we can get the numerator and denominator with the SymPy fraction function.\n\nH_sym_num, H_sym_denom = fraction(H_preamp_sym)\n\nThe SymPy solve function is used to find the root of the numerator and denominator polynomials.\n\nH_sym_zeros = solve(H_sym_num,s)\nH_sym_poles = solve(H_sym_denom,s)\n\n\n20.4.8.1 Zeros\nHow many roots are there for the numerator polynomial?\n\nprint('there are {:d} zeros'.format(len(H_sym_zeros)))\n\nthere are 3 zeros\n\n\n\n\n20.4.8.2 Z0\nThe first zero is at DC.\n\nH_sym_Z0 = H_sym_zeros[0]\nH_sym_Z0\n\n\\(\\displaystyle 0\\)\n\n\n\n\n20.4.8.3 Z1\nThe second zero is given symbolically by the expression:\n\nH_sym_Z1 = H_sym_zeros[1]\nH_sym_Z1\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\nWhat are the components that determine Z1?\n\nprint('the components that determine Z1 are: {:s} '.format(str(H_sym_Z1.free_symbols)))\n\nthe components that determine Z1 are: {Ro, C1, R2, R1, Co} \n\n\nWhat is the locations of Z1?\n\nprint('location of zero: {:.2f} Hz'.format(N(H_sym_Z1.subs(nominal_component_value))/(2*np.pi)))\n\nlocation of zero: -506.73 Hz\n\n\nZ1 is the zero at 500 Hz and is one of the RIAA time constants.\nWe can find the sensitivity of Z1 to C1 with the following operation.\n\nS_C1_H_sym_Z1 = (C1/H_sym_Z1)*(H_sym_Z1.diff(C1))\nS_C1_H_sym_Z1\n\n\\(\\displaystyle \\frac{C_{1} \\left(- \\frac{1}{2 C_{1} Co \\left(R_{2} + Ro\\right)} - \\frac{C_{1} R_{1}^{2} + Co R_{1}^{2} - Co R_{1} R_{2} - Co R_{1} Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right) \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}} + \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)}\\right)}{- \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}}\\)\n\n\nEvaluating this numerically with the component values, we get the sensitivity of Z1 to C1.\n\nprint('the sensitivity of Z1 to C1 is: {:.2f}'.format(N(S_C1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to C1 is: -1.00\n\n\nDoing the math with SymPy, we can get the sensitivity of Z1 to the other components.\n\nS_R1_H_sym_Z1 = (R1/H_sym_Z1)*(H_sym_Z1.diff(R1))\nprint('the sensitivity of Z1 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R1 is: -0.10\n\n\n\nS_R2_H_sym_Z1 = (R2/H_sym_Z1)*(H_sym_Z1.diff(R2))\nprint('the sensitivity of Z1 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R2 is: -0.85\n\n\n\nS_Co_H_sym_Z1 = (Co/H_sym_Z1)*(H_sym_Z1.diff(Co))\nprint('the sensitivity of Z1 to Co is: {:.4f}'.format(N(S_Co_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Co is: -0.0002\n\n\n\nS_Ro_H_sym_Z1 = (Ro/H_sym_Z1)*(H_sym_Z1.diff(Ro))\nprint('the sensitivity of Z1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Ro is: -0.05\n\n\nLater, we are doing the worst case analysis, we can ignore Co. \n\n\n20.4.8.4 Z2\nThe third zero of the transfer function is Z2.\n\nH_sym_Z2 = H_sym_zeros[2]\nH_sym_Z2\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\n\nprint('the components that determine Z2 are: {:s} '.format(str(H_sym_Z2.free_symbols)))\n\nthe components that determine Z2 are: {Ro, C1, R2, R1, Co} \n\n\n\nprint('Z2: {:.3e} Hz'.format(N(H_sym_Z2.subs(nominal_component_value))/(2*np.pi)))\n\nZ2: -8.885e-3 Hz\n\n\nThe zero Z2, evaluates to a system zero at DC and is not one of the RIAA time constants.\n\nS_C1_H_sym_Z2 = (C1/H_sym_Z2)*(H_sym_Z2.diff(C1))\nprint('the sensitivity of Z2 to C1 is: {:.3e}'.format(N(S_C1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to C1 is: -1.580e-4\n\n\n\nS_Co_H_sym_Z2 = (Co/H_sym_Z2)*(H_sym_Z2.diff(Co))\nprint('the sensitivity of Z2 to Co is: {:.2f}'.format(N(S_Co_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Co is: -1.00\n\n\n\nS_R1_H_sym_Z2 = (R1/H_sym_Z2)*(H_sym_Z2.diff(R1))\nprint('the sensitivity of Z2 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R1 is: -0.90\n\n\n\nS_R2_H_sym_Z2 = (R2/H_sym_Z2)*(H_sym_Z2.diff(R2))\nprint('the sensitivity of Z2 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R2 is: -0.09\n\n\n\nS_Ro_H_sym_Z2 = (Ro/H_sym_Z2)*(H_sym_Z2.diff(Ro))\nprint('the sensitivity of Z2 to Ro is: {:.3f}'.format(N(S_Ro_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Ro is: -0.006\n\n\n\n\n20.4.8.5 Poles\nHow many poles are there in the preamp transfer function?\n\nprint('there are {:d} poles in the transfer function'.format(len(H_sym_poles)))\n\nthere are 4 poles in the transfer function\n\n\n\n\n20.4.8.6 P0\nThe first pole is:\n\nH_sym_P0 = H_sym_poles[0]\nH_sym_P0\n\n\\(\\displaystyle - \\frac{1}{C_{1} R_{1}}\\)\n\n\nThe pole P0 evaluates to one of the RIAA time constants.\n\nprint('P0: {:.2f}Hz'.format(N(H_sym_P0.subs(nominal_component_value))/(2*np.pi)))\n\nP0: -50.63Hz\n\n\n\nS_C1_H_sym_P0 = (C1/H_sym_P0)*(H_sym_P0.diff(C1))\nprint('the sensitivity of P0 to C1 is: {:.2f}'.format(N(S_C1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to C1 is: -1.00\n\n\n\nS_R1_H_sym_P0 = (R1/H_sym_P0)*(H_sym_P0.diff(R1))\nprint('the sensitivity of P0 to R1 is: {:.2f}'.format(N(S_R1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to R1 is: -1.00\n\n\n\n\n20.4.8.7 P1\nThe second pole is:\n\nH_sym_P1 = H_sym_poles[1]\nH_sym_P1\n\n\\(\\displaystyle - \\frac{1}{Co Ro}\\)\n\n\nThe pole P1 evaluates to a frequency near DC.\n\nprint('P1: {:.2f}Hz'.format(N(H_sym_P1.subs(nominal_component_value))/(2*np.pi)))\n\nP1: -1.59Hz\n\n\n\nS_Co_H_sym_P1 = (Co/H_sym_P1)*(H_sym_P1.diff(Co))\nprint('the sensitivity of P1 to Co is: {:.2f}'.format(N(S_Co_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Co is: -1.00\n\n\n\nS_Ro_H_sym_P1 = (Ro/H_sym_P1)*(H_sym_P1.diff(Ro))\nprint('the sensitivity of P1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Ro is: -1.00\n\n\n\n\n20.4.8.8 P2\nThe 3rd pole is:\n\nH_sym_P2 = H_sym_poles[2]\nH_sym_P2\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} - \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the components that determine P2 are: {:s} '.format(str(H_sym_P2.free_symbols)))\n\nthe components that determine P2 are: {C3, C4, R6, R3} \n\n\n\nprint('P2: {:.2f}Hz'.format(N(H_sym_P2.subs(nominal_component_value))/(2*np.pi)))\n\nP2: -2122.88Hz\n\n\n\nS_C3_H_sym_P2 = (C3/H_sym_P2)*(H_sym_P2.diff(C3))\nprint('the sensitivity of P2 to C3 is: {:.2f}'.format(N(S_C3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C3 is: -1.00\n\n\n\nS_C4_H_sym_P2 = (C4/H_sym_P2)*(H_sym_P2.diff(C4))\nprint('the sensitivity of P2 to C4 is: {:.3e}'.format(N(S_C4_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C4 is: -2.829e-5\n\n\n\nS_R3_H_sym_P2 = (R3/H_sym_P2)*(H_sym_P2.diff(R3))\nprint('the sensitivity of P2 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R3 is: -0.96\n\n\n\nS_R6_H_sym_P2 = (R6/H_sym_P2)*(H_sym_P2.diff(R6))\nprint('the sensitivity of P2 to R6 is: {:.3f}'.format(N(S_R6_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R6 is: -0.041\n\n\n\n\n20.4.8.9 P3\nThe 4th pole is:\n\nH_sym_P3 = H_sym_poles[3]\nH_sym_P3\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} + \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the components that determine P3 are: {:s} '.format(str(H_sym_P3.free_symbols)))\n\nthe components that determine P3 are: {C3, C4, R6, R3} \n\n\n\nprint('P3: {:.2f}Hz'.format(N(H_sym_P3.subs(nominal_component_value))/(2*np.pi)))\n\nP3: -1.39Hz\n\n\n\nS_C3_H_sym_P3 = (C3/H_sym_P3)*(H_sym_P3.diff(C3))\nprint('the sensitivity of P3 to C3 is: {:.2e}'.format(N(S_C3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C3 is: -2.83e-5\n\n\n\nS_C4_H_sym_P3 = (C4/H_sym_P3)*(H_sym_P3.diff(C4))\nprint('the sensitivity of P3 to C5 is: {:.2f}'.format(N(S_C4_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C5 is: -1.00\n\n\n\nS_R3_H_sym_P3 = (R3/H_sym_P3)*(H_sym_P3.diff(R3))\nprint('the sensitivity of P3 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R3 is: -0.04\n\n\n\nS_R6_H_sym_P3 = (R6/H_sym_P3)*(H_sym_P3.diff(R6))\nprint('the sensitivity of P3 to R6 is: {:.2f}'.format(N(S_R6_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R6 is: -0.96\n\n\nIn the worst case analysis below, the components that have sensitivities greater than 0.05 are the ones that factor into the worst case analysis.\n\n\n\n20.4.9 Component selection\nThe table below lists each of the components used in the preamp along with a link to the Digikey pages for each of the components in the preamp. Digikey is a larger distributor of electronic components in the US. All the components have operating temperature ranges that exceed the normal household environment.\nThe resistors chosen are all 1% Metal film type resistors. Metal film resistors possess good noise characteristics and low nonlinearity due to a low voltage coefficient. They are also beneficial due to long-term stability.\nThe capacitors are all polypropylene Film capacitor types. Polystyrene or polypropylene are considered the best for audio applications.\nThe Op Amp, LM833N, is a dual bipolar low noise (\\(\\frac {4.5nV}{\\sqrt{Hz}}\\)), wide bandwidth (16 MHz) audio operational amplifier from Texas Instrments.\n\n\n\nRef\nValue\nDescription\nDigikey PN\n\n\n\n\nRo\n499\n±1% 1/4W Metal Film\nRNF14FTD499RCT-ND\n\n\nRp\n47k\n±1% 1/4W Metal Film\n13-MFR-25FTE52-47KTB-ND\n\n\nR1\n80.6k\n±1% 1/4W Metal Film\n80.6KXBK-ND\n\n\nR2\n58.45k\n±1% 1/4W Metal Film\nRNF14FTD8K45CT-ND\n\n\nR3\n2.37k\n±1% 1/4W Metal Film\n13-MFR-25FBF52-2K37-ND\n\n\nR4\n2k\n±1% 1/4W Metal Film\n13-MFR-25FRF52-2KCT-ND\n\n\nR5\n4.3k\n±1% 1/4W Metal Film\nS4.3KCACT-ND\n\n\nR6\n54.9k\n±1% 1/4W Metal Film\nRNF14FTD54K9CT-ND\n\n\nCo\n200\\(\\mu\\)\n10% Film Capacitor 450V Polypropylene\n283-EFDKS45K207F064DH-ND\n\n\nCp\n100p\n10% Film Capacitor 250V Polypropylene\n399-RSBEC0100ZA00M-ND\n\n\nC1\n0.039\\(\\mu\\)\n2% Film Capacitor 25V 63V Polypropylene\nBC2066-ND\n\n\nC3\n0.033\\(\\mu\\)\n1% Film Capacitor 63V 100V Polypropylene\n399-PHE426DJ5330FR17T0CT-ND\n\n\nC4\n2\\(\\mu\\)\n10% Film Capacitor 305V 630V Polypropylene\n495-B32923P3205K000-ND\n\n\nU1, U2\nLM833N\nAudio op amp\n296-44419-5-ND\n\n\n\nThe parts in this list are considered good choices for a first pass at the bill of materials. The size of the production run and the piece part cost are also factors which must be considered if the preamp is going to be built. One thing to notice is that Co, the 200 \\(\\mu\\) F capacitor is expensive. The use of a polypropylene film capacitor for this component is consistent with the advice of keeping all capacitors in the audio path polystyrene or polypropylene.\n\n\n20.4.10 Monte Carlo simulation\nIn this analysis the circuit equations are solved after assigning random element values from within the tolerance band to the components. This simulates building a large number of circuits with components chosen at random from bins or reals of components during the board stuffing process. All the components are required to meet their specifications, but are allowed to have some variation according to their tolerance. For example a 1% 2k resistor can range from 1980 to 2020 \\(\\Omega\\). In addition to the components initial tolerance, the temperature coefficient and aging of parameters can also be included.\nIn this simulation, I’m only including the initial tolerances of parameters and I’m assuming the distribution is uniform. The NumPy function random.uniform is used to generate the random values within the tolerance range, however, for this function, the high end-point value may or may not be included in the range depending on floating-point rounding, so if this is important, some adjustments to the code are required. The NumPy function random.seed is used to re-seed the random number generator.\n\nnum = 20 # number of simulations to run\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to the hold the results of each run\nmag_ans = np.zeros(shape=(num,len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(num,len(new_x_axis_range)))\n\ncomponent_values_tol = nominal_component_value.copy() # make a copy\n\nrandom.seed(a=None, version=2) # re-seed the random number generator\n\nThe following takes about 15 seconds to run on for num=20 on an i3 machine.\n\nfor i in range(0,num):\n\n    component_values_tol[Ro] = random.uniform(nominal_component_value[Ro]-nominal_component_value[Ro]*0.01,nominal_component_value[Ro]+nominal_component_value[Ro]*0.01)\n    component_values_tol[Rp] = random.uniform(nominal_component_value[Rp]-nominal_component_value[Rp]*0.01,nominal_component_value[Rp]+nominal_component_value[Ro]*0.01)\n\n    component_values_tol[R1] = random.uniform(nominal_component_value[R1]-nominal_component_value[R1]*0.01,nominal_component_value[R1]+nominal_component_value[R1]*0.01)\n    component_values_tol[R2] = random.uniform(nominal_component_value[R2]-nominal_component_value[R2]*0.01,nominal_component_value[R2]+nominal_component_value[R2]*0.01)    \n    component_values_tol[R3] = random.uniform(nominal_component_value[R3]-nominal_component_value[R3]*0.01,nominal_component_value[R3]+nominal_component_value[R3]*0.01)\n    component_values_tol[R4] = random.uniform(nominal_component_value[R4]-nominal_component_value[R4]*0.01,nominal_component_value[R4]+nominal_component_value[R4]*0.01)    \n    component_values_tol[R5] = random.uniform(nominal_component_value[R5]-nominal_component_value[R5]*0.01,nominal_component_value[R5]+nominal_component_value[R5]*0.01)\n    component_values_tol[R6] = random.uniform(nominal_component_value[R6]-nominal_component_value[R6]*0.01,nominal_component_value[R6]+nominal_component_value[R6]*0.01)    \n\n    component_values_tol[Co] = random.uniform(nominal_component_value[Co]-nominal_component_value[Co]*0.1,nominal_component_value[Co]+nominal_component_value[Co]*0.1)\n    component_values_tol[Cp] = random.uniform(nominal_component_value[Cp]-nominal_component_value[Cp]*0.1,nominal_component_value[Cp]+nominal_component_value[Cp]*0.1)\n    component_values_tol[C1] = random.uniform(nominal_component_value[C1]-nominal_component_value[C1]*0.02,nominal_component_value[C1]+nominal_component_value[C1]*0.02)\n    component_values_tol[C3] = random.uniform(nominal_component_value[C3]-nominal_component_value[C3]*0.01,nominal_component_value[C3]+nominal_component_value[C3]*0.01)\n    component_values_tol[C4] = random.uniform(nominal_component_value[C4]-nominal_component_value[C4]*0.1,nominal_component_value[C4]+nominal_component_value[C4]*0.1)\n\n    # enter the element values\n    preamp_equ_tol = NE_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    \n    # save the results from each run\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\n\n20.4.11 Preamplifier deviation from RIAA response\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.3))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Monte Carlo runs showing deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe Monte Carlo simulation shows that the preamp amplitude response deviation from the RIAA curve can very from -0.2 to 0.3 dB over the audio band. If the performance requirement for this preamp was to be within \\(\\pm\\) 0.1 dB of the RIAA curve, then some redesign or tighter component tolerancing is required.\n\n\n20.4.12 Worst case analysis\nIn a worst case analysis, we would look at:\n\nminimum and maximum values of the initial component tolerance\n\nmaximum or minimum temperature coefficients of the parameters\n\nmaximum aging or drift of parameter values\n\nSince we usually can’t tell by inspection which combination of minimum and maximum values will give the worst case, we can run a number of simulations in which all combinations of minimum and maximum variations are included. From the family of results we can look for the worst case.\n\nprint('number of components: {:d}'.format(len(nominal_component_value)))\n\nnumber of components: 14\n\n\nHow many min and max combinations?\n\nprint('number of min and max combinations: {:,d}'.format(2**14))\n\nnumber of min and max combinations: 16,384\n\n\n16 thousand simulation runs too many. From the sensitivity analysis above, only R1, R2, R3, R6, Ro, C1 and C3 are sensitive. Running all combinations of the min and max tolerance for this set is reasonable and is \\(2^7=128\\) combinations.\nThe tolerances for each of the components is defined below:\n\nTol = {Ro:0.01,R1:0.01,R2:0.01,R3:0.01,R6:0.01,C1:0.02,C3:0.01}\n\nOnly C1 has a tolerance other than 1%.\nThe array ‘run’ is created that consists of a binary count, with leading zeros from 0 to 127. Then the zero values are replaced with -1.\n\nrun = []\nfor i in range(0,2**(len(Tol))):\n    temp = list('{:07b}'.format(i)) # include leading zeros\n    for j in range(len(temp)):\n        temp[j] = int(temp[j])\n    run.append(temp)\n\nrun = np.asarray(run)\nrun = np.where(run == 0, -1, run)\n\nThe first row of run is:\n\nrun[0]\n\narray([-1, -1, -1, -1, -1, -1, -1])\n\n\nIn the for loop below, at i = 0, run[0] would be all -1’s and this could apply the low tolerance range to the nominal component values.\n\nrun[-1]\n\narray([1, 1, 1, 1, 1, 1, 1])\n\n\nThe last time through the for loop, where i = 127, run[-1] is all 1’s and this would apply the high tolerance range to the nominal component values. Between i = 0 and i = 127, all combinations of minimum and maximum tolerance are applied.\n\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to hold the results\nmag_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\n\nThe following cell takes about 90 seconds to run on my i3-8130U 2.20GHz laptop.\n\nfor i in range(len(run)):\n    component_values_tol[Ro] = nominal_component_value[Ro]*(1+run[i][0]*Tol[Ro])\n    component_values_tol[Rp] = nominal_component_value[Rp]\n\n    component_values_tol[R1] = nominal_component_value[R1]*(1+run[i][1]*Tol[R1])\n    component_values_tol[R2] = nominal_component_value[R2]*(1+run[i][2]*Tol[R2]) \n    component_values_tol[R3] = nominal_component_value[R3]*(1+run[i][3]*Tol[R3])\n\n    component_values_tol[R4] = nominal_component_value[R4] \n    component_values_tol[R5] = nominal_component_value[R5]\n    component_values_tol[R6] = nominal_component_value[R6]*(1+run[i][4]*Tol[R6])\n\n    component_values_tol[Co] = nominal_component_value[Co]\n    component_values_tol[Cp] = nominal_component_value[Cp]\n    component_values_tol[C1] = nominal_component_value[C1]*(1+run[i][5]*Tol[C1])\n    component_values_tol[C3] = nominal_component_value[C3]*(1+run[i][6]*Tol[C3])\n    component_values_tol[C4] = nominal_component_value[C4]\n    \n    # enter the element values\n    preamp_equ_tol = NE_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.4))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Worst Case deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe results above show that the worst case tolerance conditions yield deviations of -0.19 to 0.3 dB from the RIAA curve.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#summary",
    "href": "Two amplifier RIAA Phono Preamp.html#summary",
    "title": "20  Two amplifier RIAA phono preamp",
    "section": "20.5 Summary",
    "text": "20.5 Summary\nThe circuit presented in this analysis is just one example of many circuits that can be found online. For each design to be evaluated, some type of side by side analysis should be used to down select. This notebook can be used as a template for any comparative analysis.\nThe circuit in the app note appears to have low frequency group delay that might be an issue. Also the deviation from the RIAA curve using normal component tolerances does not meet the 0.1 dB requirement. The worst case analysis also confirms this. The circuit employs an expensive 200\\(\\mu\\) Farad film capacitor. The circuit is missing a subsonic filter.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Two amplifier RIAA phono preamp</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html",
    "href": "Two port parameters.html",
    "title": "21  Two port parameters",
    "section": "",
    "text": "21.1 Introduction\nThis notebook describes the calculation of two port parameters derived from the circuit’s netlist. A Two-port network is a circuit that has two pairs of ports or terminals and the circuit is characterized by the currents and voltages at the ports by a 2 by 2 matrix. From a two port matrix the response of the network to signals applied to the ports can be calculated easily, without solving for all the internal voltages and currents in the network. For example filters, matching networks, transmission lines, and transistors are characterized by two port parameters.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#circuit-description",
    "href": "Two port parameters.html#circuit-description",
    "title": "21  Two port parameters",
    "section": "21.2 Circuit description",
    "text": "21.2 Circuit description\nThe first circuit is an attenuator, which could be easily analyzed by hand with a pencil, paper and a calculator, but here I’m using python to step through the calculations. These same steps can be applied to larger, more complex circuits which would be difficult to analyze by hand. The Sympy and SciPy libraries can be used to obtain symbolic and numerical results, however as is shown below, when the circuit is large, symbolic results are not that useful nor do they provide much insight.\nThe procedure starts by first drawing a schematic of the circuit with a schematic capture program such as EasyEDA (links to the schematics are provided below) then the netlist is generated and exported as a text file. The netlist is used to generate modified nodal equations with the python program described here. The equations are solved for voltages and currents at the port terminals by using SymPy to generate the z-paramters. Z-parameters are also known as open-circuit impedance parameters as they are calculated under open circuit conditions. Once the z-parameters are obtained, these can be converted into other parameters, such as Y, H, S or others.\nThe second circuit is a band pass filter. The filter is designed from a low pass prototype by using normalized values from a filter design handbook. Z and s-parameters are calculated and the results are plotted using Matplotlib.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n21.2.1 Pi-attenuator\nThe pi-attenuator, shown in Figure 21.1, is formed by three resistors with R1 and R3 as the shunt resistors on the input and output ports and R2 as the series resistor in a circuit topology in the shape of the greek letter pi. For R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms, the attenuation is 10 dB and the port impedance is 50 ohms. Pasternack’s Pi Attenuator Calculator (Pi pad attenuator) was used to design the attenuator.\nThe selection of which type a network parameter is somewhat a matter of convenience. However, some circuits can’t have their ports shorted or left open for proper operation, so s-parameters are the appropriate choice in this situation. Solving for the z-parameters is convenient since all we need to do is apply a voltage source to the input port, with the output port unterminated, and solve for the voltage and currents at each port. Since the output port is unterminated, the current into this port is zero and we can find z11 and z21. To find z21 and z22, the voltage source is applied to port 2 with port 1 unterminated.\nTo find Z-parameters attach voltage sources to both ports and find the node equations. LTSpice was used to draw the schematic.\n\n\n\n\n\n\nFigure 21.1: Pi attenuator schematic\n\n\n\nThe netlist for the circuit:\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\nV2 2 0 1\n\n21.2.1.1 Find z11 & z21\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\n\nnet_list = '''\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}}\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\V_{1}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  V_{1}, \\  v_{2}, \\  v_{1}, \\  R_{1}, \\  I_{V1}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p1 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p1.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p1[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{3} V_{1}}{R_{2} + R_{3}}\\)\\(I_{V1} = \\frac{- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}}{R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\nA negative sign was placed in the equation to make the direction of the current flow match the definition of the two port parameters.\n\nz11 = -U_sym_p1[v1]/U_sym_p1[I_V1]\nz11.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{2} + R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = -U_sym_p1[v2]/U_sym_p1[I_V1]\nz21.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\n\n\n21.2.1.2 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the net list.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\n\nnet_list = '''\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V2} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{2} = V_{2}\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\I_{V2} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}}\\\\v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\V_{2}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  I_{V2}, \\  V_{2}, \\  v_{2}, \\  v_{1}, \\  R_{1}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p2 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p2.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p2[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{R_{1} V_{2}}{R_{1} + R_{2}}\\)\\(v_{2} = V_{2}\\)\\(I_{V2} = \\frac{- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}}{R_{1} R_{3} + R_{2} R_{3}}\\)\n\n\n\n\\(z_{12}=\\frac{V_1}{I_2}\\text{  when  }I_1=0\\)\n\nz12 = -U_sym_p2[v1]/U_sym_p2[I_V2]\nz12.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\\(z_{22}=\\frac{V_2}{I_2}\\text{  when  }I_1=0\\)\n\nz22 = -U_sym_p2[v2]/U_sym_p2[I_V2]\nz22.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3} + R_{2} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\nThe common names for the z-parameters are:\nz11: input driving point impedance\nz12: reverse transfer impedance\nz21: forward transfer impedance\nz22: output driving point impedance\nThe elements of the matrix can be displayed:\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\frac{V_{1} \\left(R_{1} R_{2} + R_{1} R_{3}\\right)}{- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}} & - \\frac{R_{3} V_{1} \\left(R_{1} R_{2} + R_{1} R_{3}\\right)}{\\left(R_{2} + R_{3}\\right) \\left(- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}\\right)}\\\\- \\frac{R_{1} V_{2} \\left(R_{1} R_{3} + R_{2} R_{3}\\right)}{\\left(R_{1} + R_{2}\\right) \\left(- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}\\right)} & - \\frac{V_{2} \\left(R_{1} R_{3} + R_{2} R_{3}\\right)}{- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}}\\end{matrix}\\right]\\)\n\n\nActual values for each of the components can be substituted for the symbols with R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms\n\natten_values = {R1:96.25,R2:71.15,R3:96.25}\n\n\nz11_val = z11.subs(atten_values)\nz12_val = z12.subs(atten_values)\nz21_val = z21.subs(atten_values)\nz22_val = z22.subs(atten_values)\n\nThe numeric values of the impedance matrix\n\nnp.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=float)\n\narray([[61.11227005, 35.13772995],\n       [35.13772995, 61.11227005]])\n\n\n\n\n21.2.1.3 Calculate Z in and Z out, ki and kv\nA two-port circuit is typically driven at port 1 and loaded at port 2, and four equations needed to solve the four unknowns. The link here has a nice explnation of two port analysis.\n\\(\\begin{align*}\n\\begin{bmatrix} -1 & 0 & z11 & z12 \\\\\\ 0 & -1 & z21 & z22 \\\\\\ 1 & 0 & Z_S & 0 \\\\\\ 0 & 1 & 0 & Z_L\n\\end{bmatrix}\n\\begin{bmatrix}\n  V_1  \\\\\n  V_2  \\\\\n  I_1 \\\\\n  I_2\n\\end{bmatrix}\n{} &= \\begin{bmatrix}\n  0  \\\\\n  0  \\\\\n  V_g \\\\\n  0\n\\end{bmatrix}\n\\end{align*}\\)\nPutting into SymPy\n\nZ11, Z12, Z21, Z22 = symbols('Z11 Z12 Z21 Z22')\nZ_s, Z_l, Vg = symbols('Z_s Z_l Vg')\n\neqZ = Eq(Matrix([[-1,0,Z11,Z12],[0,-1,Z21,Z22],[1,0,Z_s,0],[0,1,0,Z_l]])*Matrix([V1,V2,I_V1,I_V2]),Matrix([0,0,Vg,0]))\neqZ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} Z_{11} + I_{V2} Z_{12} - V_{1}\\\\I_{V1} Z_{21} + I_{V2} Z_{22} - V_{2}\\\\I_{V1} Z_{s} + V_{1}\\\\I_{V2} Z_{l} + V_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\Vg\\\\0\\end{matrix}\\right]\\)\n\n\n\nansZ = solve(eqZ,[V1, V2, I_V1,I_V2])\nansZ\n\n\\(\\displaystyle \\left\\{ I_{V1} : \\frac{Vg Z_{22} + Vg Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  I_{V2} : - \\frac{Vg Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  V_{1} : \\frac{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  V_{2} : \\frac{Vg Z_{21} Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}\\right\\}\\)\n\n\n\n# current gain\nansZ[I_V2]/ansZ[I_V1]\n\n\\(\\displaystyle - \\frac{Vg Z_{21}}{Vg Z_{22} + Vg Z_{l}}\\)\n\n\n\n# voltage gain\nansZ[V2]/ansZ[V1]\n\n\\(\\displaystyle \\frac{Vg Z_{21} Z_{l}}{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}\\)\n\n\n\n# Z input\nansZ[V1]/ansZ[I_V1]\n\n\\(\\displaystyle \\frac{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}{Vg Z_{22} + Vg Z_{l}}\\)\n\n\n\n# Z out\nansZ[V2]/ansZ[I_V2]\n\n\\(\\displaystyle - Z_{l}\\)\n\n\nSympy returns the output impedance as simply \\(-Z_l\\), since this is the algebraic simplification of the equations. Most textbooks will give the output impedance in terms of the z-parameters and the source impedance: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\)\n\n\n21.2.1.4 Calculate input and output impedance for the attenuator\nThe input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\)\nTextbook equation: \\(Z_{in}=Z_{11}-\\frac{Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\) where \\(Z_{L}\\) is the impedance of the load connected to port two.\nThe output impedance from textbooks is: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\), where \\(Z_{S}\\) is the impedance of the source connected to port one.\n\n# Zin\nZl = 50 # load impedance\nprint('input impedance of network from z-parameters: {:.2f}'.format(np.abs((z11_val*z22_val+z11_val*Zl-z12_val*z21_val)/(z22_val+Zl))))\n\ninput impedance of network from z-parameters: 50.00\n\n\n\n# Zout\nZs = 50 # source impedance\nprint('output impedance of network from z-parameters: {:.2f}'.format(np.abs(z22_val-(z12_val*z21_val)/(z11_val+Zs))))\n\noutput impedance of network from z-parameters: 50.00\n\n\n\n\n21.2.1.5 Calculate the voltage gain for the attenuator\nVoltage gain: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), from text books: \\(K_v=\\frac{Z_{21}Z_{L}}{\\Delta _Z+Z_{11}Z_L}\\)\n\n#Kv\nprint('voltage gain of network from z-parameters: {:.2f} dB'.format(20*np.log10(float((z21_val*Zl)/(z11_val*z22_val + z11_val*Zl - z12_val*z21_val)))))\n\nvoltage gain of network from z-parameters: -10.00 dB\n\n\n\n\n21.2.1.6 Convert z-parameters to y-parameters\nThe z-parameters can be converted to admittance or y-parameters with the following code:\nFind the determinant of the z-parameter matrix:\n\ndet_z = np.linalg.det(np.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=float))\nprint('determinant = {:.2f}'.format(det_z))\n\ndeterminant = 2500.05\n\n\nDisplay the y-parameter matrix.\n\nnp.array([[z22_val/det_z,-z12_val/det_z],[-z21_val/det_z,z11_val/det_z]],dtype=float)\n\narray([[ 0.02444442, -0.01405481],\n       [-0.01405481,  0.02444442]])\n\n\n\n\n21.2.1.7 Convert z-parameters to s-parameters\nThe 2-port S-parameters have the following generic descriptions:\n\\(S_{11} \\text{ is the input port voltage reflection coefficient}\\)\n\\(S_{12} \\text{ is the reverse voltage gain}\\)\n\\(S_{21} \\text{ is the forward voltage gain}\\)\n\\(S_{22} \\text{ is the output port voltage reflection coefficient}\\)\nThe z-parameter can be converted to scattering or s-parameters with the following:\n\\(s_{11} = \\frac {(Z_{11}-Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\n\\(s_{12} = \\frac {2Z_{12}Z_o} {\\Delta Z}\\)\n\\(s_{21} = \\frac {2Z_{21}Z_o} {\\Delta Z}\\)\n\\(s_{22} = \\frac {(Z_{11}+Z_o)(Z_{22}-Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\nwhere: \\(\\Delta Z = (Z_{11}+Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}\\) and \\(Z_o\\) is the characteristic impedance.\n\nZ_o = 50 # characteristic impedance\ndel_z = (z11_val+Z_o)*(z22_val+Z_o)-z12_val*z21_val\n\nS = np.array([[((z11_val-Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z,(2*z12_val*Z_o)/del_z],\n              [(2*z21_val*Z_o)/del_z,((z11_val+Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z]],dtype=float)\nS # display the s-parameter matrix\n\narray([[-1.00004488e-01,  3.16234863e-01],\n       [ 3.16234863e-01,  4.45363654e-06]])\n\n\n\n\n21.2.1.8 Input return loss\nInput return loss \\(RL_{in}\\) indicates impedance match of the port to the source. A number of 10 dB or greater, indicates that the match is probably acceptable.\n\\(RL_{in} =-20\\log_{10}\\left|S_{11}\\right|\\)\n\nprint('Input return loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[0,0]))))\n\nInput return loss = 20.00 dB\n\n\n\n\n21.2.1.9 Insertion loss\nInsertion loss \\(IL\\) is the reciprocal of the magnitude of the transmission coefficient, S21, expressed in decibels.\n\\(IL=-20\\log _{10} \\left|S_{21} \\right|\\)\n\nprint('Insertion loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[1,0]))))\n\nInsertion loss = 10.00 dB\n\n\nThis value agrees with the design of the attenuator as being a 10 dB attenuator.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#band-pass-filter",
    "href": "Two port parameters.html#band-pass-filter",
    "title": "21  Two port parameters",
    "section": "21.3 Band Pass Filter",
    "text": "21.3 Band Pass Filter\nThe circuit in Figure 21.2 is a band pass filter designed from normalized filter design tables. The third order low pass filter prototype was transformed into a bandpass filter as shown in the figure below. Butterworth filter coefficients were chosen for this design. A Butterworth filter is a type of signal processing filter that has a flat passband response.\n\n\n\n\n\n\nFigure 21.2: Band pass filter schematic\n\n\n\nThe low pass to bandpass transformation calculations are shown below. The filter was designed to have a center frequency of 10 MHz and a 3 dB bandwidth of 1 MHz. The normalized filter values were obtained from Williams and Taylor (1995):\n3rd order Butterworth LPF prototype\nRs/Rl = 1\nC1 = 1\nL2 = 2\nC1 = 1\nThe bandpass filter has the following design parameters: The source and load impedance is 50 ohms, the filter bandwidth is 1 MHz and the center frequency is 10 MHz. Following the example from Williams and Taylor (1995) (example 5-2), but with the following changes:\n\ncenter freq = 10MHz\n\nbandwidth 1MHz\n\nRs=Rl=50\n\n\nf_center = 10e6\nf_3dB_BW = 1e6 # 3dB bandwidth\nfo = np.sqrt((f_center-f_3dB_BW/2)*(f_center+f_3dB_BW/2)) # geometric center frequency\nprint('geometric center frequency = {:.3f}MHz'.format(fo/1e6))\n\ngeometric center frequency = 9.987MHz\n\n\n\nZ = 50 # load and source resistance\nFSF = 2*np.pi*f_3dB_BW\nprint('frequency scaling factor = {:.3f}'.format(FSF))\n\nfrequency scaling factor = 6283185.307\n\n\nThe first element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled.\n\n# C1 is 1st shunt capacitor\nC1n = 1 # normalized value from the tables in the filter handbook\nC1p = C1n/(FSF*Z)\nprint('capacitor = {:.3f}nF'.format(C1p*1e9))\n\nwo = 2*np.pi*fo\nL1p = 1/(wo**2*C1p) # calculate the value of the inductor that resonates with the capacitor at the center frequency\nprint('inductor = {:.3f}nH'.format(L1p*1e9))\n\ncapacitor = 3.183nF\ninductor = 79.777nH\n\n\nThe second element in the lowpass prototype is a series capacitor and for the lowpass to bandpass transformation the capacitor is replaced by a capacitor and inductor in series with the same normalized value. The normalized values are then frequency scaled.\n\n# L2 is the 2nd series inductor\nL2n = 2 # normalized value from the tables in the filter handbook\nL2p = L2n*Z/FSF\nprint('inductor = {:.3f}uH'.format(L2p*1e6))\n\nC2p = 1/(wo**2*L2p) # calculate the value of the capacitor that resonates with the inductor at the center frequency\nprint('capacitor = {:.3f}pF'.format(C2p*1e12))\n\ninductor = 15.915uH\ncapacitor = 15.955pF\n\n\nThe last element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled. The values for this branch of the circuit are the same as for the first shunt element.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z11-and-z12",
    "href": "Two port parameters.html#find-z11-and-z12",
    "title": "21  Two port parameters",
    "section": "21.4 Find z11 and z12",
    "text": "21.4 Find z11 and z12\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations. The component values in the netlist have all been set to one. Later, the actual component values will be used.\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n\nnet_list = '''\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1} = 0\\)\\(- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s - v_{1} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{2} = 0\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1}\\\\- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right)\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2}\\\\v_{1}\\\\- I_{L1} L_{1} s - v_{1}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\\\- I_{L3} L_{3} s - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L3}, \\  C_{2}, \\  L_{1}, \\  C_{3}, \\  I_{L1}, \\  v_{3}, \\  L_{2}, \\  V_{1}, \\  I_{L2}, \\  s, \\  v_{2}, \\  C_{1}, \\  v_{1}, \\  I_{V1}, \\  L_{3}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p1 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p1.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p1[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} L_{3} V_{1} s^{2}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(v_{3} = \\frac{C_{2} L_{3} V_{1} s^{2} + C_{3} L_{3} V_{1} s^{2} + V_{1}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} V_{1} s^{6} - C_{1} C_{2} L_{1} L_{2} V_{1} s^{4} - C_{1} C_{2} L_{1} L_{3} V_{1} s^{4} - C_{1} C_{3} L_{1} L_{3} V_{1} s^{4} - C_{1} L_{1} V_{1} s^{2} - C_{2} C_{3} L_{1} L_{3} V_{1} s^{4} - C_{2} C_{3} L_{2} L_{3} V_{1} s^{4} - C_{2} L_{1} V_{1} s^{2} - C_{2} L_{2} V_{1} s^{2} - C_{2} L_{3} V_{1} s^{2} - C_{3} L_{3} V_{1} s^{2} - V_{1}}{C_{2} C_{3} L_{1} L_{2} L_{3} s^{5} + C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{3} L_{1} L_{3} s^{3} + L_{1} s}\\)\\(I_{L1} = - \\frac{V_{1}}{L_{1} s}\\)\\(I_{L2} = \\frac{C_{2} C_{3} L_{3} V_{1} s^{3} + C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(I_{L3} = - \\frac{C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\n\n\n\n\nelement_values = {L1:L1p,C1:C1p,C2:C2p,L2:L2p,L3:L1p,C3:C1p}\n\n\nU_p1 = solve(NE_sym.subs(element_values),X)\n\nSubstituting actual values for the circuit elements, we get:\n\nU_p1\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{12534954.6878233 V_{1}}{s}, \\  I_{L2} : \\frac{6.33074196165529 \\cdot 10^{60} V_{1} s^{3} + 2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  I_{L3} : - \\frac{2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  I_{V1} : \\frac{- 6.39649568809606 \\cdot 10^{83} V_{1} s^{6} - 7.58201892757332 \\cdot 10^{99} V_{1} s^{4} - 2.98577794233115 \\cdot 10^{115} V_{1} s^{2} - 3.90625 \\cdot 10^{130} V_{1}}{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{1.98886124385089 \\cdot 10^{69} V_{1} s^{2}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  v_{3} : \\frac{3.98766679392103 \\cdot 10^{71} V_{1} s^{2} + 1.5625 \\cdot 10^{87} V_{1}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}\\right\\}\\)\n\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\n\nz11 = (-U_p1[v1]/U_p1[I_V1]).cancel()\nz11 #.simplify()\n\n\\(\\displaystyle \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\)\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = (-U_p1[v2]/U_p1[I_V1]).cancel()\nz21 #.simplify()\n\n\\(\\displaystyle \\frac{3.99665323720675 \\cdot 10^{161} s^{7} + 3.1556309103651 \\cdot 10^{177} s^{5} + 6.19785984654536 \\cdot 10^{192} s^{3}}{6.44490997486657 \\cdot 10^{139} s^{10} + 1.27281032416988 \\cdot 10^{156} s^{8} + 1.00396628165841 \\cdot 10^{172} s^{6} + 3.95359126276846 \\cdot 10^{187} s^{4} + 7.77287372840943 \\cdot 10^{202} s^{2} + 6.103515625 \\cdot 10^{217}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z12-z22-1",
    "href": "Two port parameters.html#find-z12-z22-1",
    "title": "21  Two port parameters",
    "section": "21.5 Find z12 & z22",
    "text": "21.5 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the netlist.\n\nnet_list = '''\n*V1 1 0 1\nV2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - I_{L1} + I_{L2} = 0\\)\\(- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\)\\(v_{2} = V_{2}\\)\\(- I_{L1} L_{1} s - v_{1} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{2} = 0\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2}\\\\- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right)\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2}\\\\v_{2}\\\\- I_{L1} L_{1} s - v_{1}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\\\- I_{L3} L_{3} s - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L3}, \\  C_{2}, \\  L_{1}, \\  C_{3}, \\  I_{V2}, \\  I_{L1}, \\  v_{3}, \\  L_{2}, \\  I_{L2}, \\  s, \\  v_{2}, \\  C_{1}, \\  v_{1}, \\  V_{2}, \\  L_{3}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p2 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p2.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p2[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{2} L_{1} V_{2} s^{2}}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(v_{2} = V_{2}\\)\\(v_{3} = \\frac{C_{1} C_{2} L_{1} L_{2} V_{2} s^{4} + C_{2} L_{1} V_{2} s^{2} + C_{2} L_{2} V_{2} s^{2}}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{V2} = \\frac{- C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} V_{2} s^{6} - C_{1} C_{2} L_{1} L_{2} V_{2} s^{4} - C_{1} C_{2} L_{1} L_{3} V_{2} s^{4} - C_{1} C_{3} L_{1} L_{3} V_{2} s^{4} - C_{1} L_{1} V_{2} s^{2} - C_{2} C_{3} L_{1} L_{3} V_{2} s^{4} - C_{2} C_{3} L_{2} L_{3} V_{2} s^{4} - C_{2} L_{1} V_{2} s^{2} - C_{2} L_{2} V_{2} s^{2} - C_{2} L_{3} V_{2} s^{2} - C_{3} L_{3} V_{2} s^{2} - V_{2}}{C_{1} C_{2} L_{1} L_{2} L_{3} s^{5} + C_{1} L_{1} L_{3} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{2} L_{3} s^{3} + L_{3} s}\\)\\(I_{L1} = - \\frac{C_{2} V_{2} s}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{L2} = \\frac{- C_{1} C_{2} L_{1} V_{2} s^{3} - C_{2} V_{2} s}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{L3} = - \\frac{V_{2}}{L_{3} s}\\)\n\n\n\n\nU_p2 = solve(NE_sym.subs(element_values),X)\nU_p2\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  I_{L2} : \\frac{- 2.53229678466212 \\cdot 10^{59} V_{2} s^{3} - 9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  I_{L3} : - \\frac{12534954.6878233 V_{2}}{s}, \\  I_{V2} : \\frac{- 6.39649568809606 \\cdot 10^{83} V_{2} s^{6} - 7.58201892757332 \\cdot 10^{99} V_{2} s^{4} - 2.98577794233115 \\cdot 10^{115} V_{2} s^{2} - 3.90625 \\cdot 10^{130} V_{2}}{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}, \\  v_{1} : \\frac{7.95544497540356 \\cdot 10^{67} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  v_{2} : V_{2}, \\  v_{3} : \\frac{4.03027550654688 \\cdot 10^{54} V_{2} s^{4} + 1.59506671756841 \\cdot 10^{70} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}\\right\\}\\)\n\n\n\\(z_{12} = \\frac {V_1}{I_2} \\text{  when  } I_1=0\\)\n\nz12 = (-U_p2[v1]/U_p2[I_V2]).cancel()\nz12 #.simplify()\n\n\\(\\displaystyle \\frac{1.5986612948827 \\cdot 10^{160} s^{7} + 1.26225236414604 \\cdot 10^{176} s^{5} + 2.47914393861815 \\cdot 10^{191} s^{3}}{2.57796398994663 \\cdot 10^{138} s^{10} + 5.09124129667954 \\cdot 10^{154} s^{8} + 4.01586512663364 \\cdot 10^{170} s^{6} + 1.58143650510738 \\cdot 10^{186} s^{4} + 3.10914949136377 \\cdot 10^{201} s^{2} + 2.44140625 \\cdot 10^{216}}\\)\n\n\n\\(z_{22} = \\frac {V_2}{I_2} \\text{  when  } I_1=0\\)\n\nz22 = (-U_p2[v2]/U_p2[I_V2]).cancel()\nz22 #.simplify()\n\n\\(\\displaystyle \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\)\n\n\ndisplaying the z-parameter matrix\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}} & \\frac{3.99665323720675 \\cdot 10^{161} s^{7} + 3.1556309103651 \\cdot 10^{177} s^{5} + 6.19785984654536 \\cdot 10^{192} s^{3}}{6.44490997486657 \\cdot 10^{139} s^{10} + 1.27281032416988 \\cdot 10^{156} s^{8} + 1.00396628165841 \\cdot 10^{172} s^{6} + 3.95359126276846 \\cdot 10^{187} s^{4} + 7.77287372840943 \\cdot 10^{202} s^{2} + 6.103515625 \\cdot 10^{217}}\\\\\\frac{1.5986612948827 \\cdot 10^{160} s^{7} + 1.26225236414604 \\cdot 10^{176} s^{5} + 2.47914393861815 \\cdot 10^{191} s^{3}}{2.57796398994663 \\cdot 10^{138} s^{10} + 5.09124129667954 \\cdot 10^{154} s^{8} + 4.01586512663364 \\cdot 10^{170} s^{6} + 1.58143650510738 \\cdot 10^{186} s^{4} + 3.10914949136377 \\cdot 10^{201} s^{2} + 2.44140625 \\cdot 10^{216}} & \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\end{matrix}\\right]\\)\n\n\nThe complete z-parameter matrix is shown above. It’s kind of interesting that the exponents on many of the coefficients are so large. Using the SymPy function lambdify to turn the symbolic expression into a function.\n\nfunc_z11_s = lambdify(s, z11)\nfunc_z12_s = lambdify(s, z12) \nfunc_z21_s = lambdify(s, z21) \nfunc_z22_s = lambdify(s, z22) \n\nUsing the results from above, the input impedance of a two-port network is given by: The input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\), where \\(Z_{L}\\) is the impedance of the load connected to port two.\n\n# set the source and load impedance\nZl = Zs = 50\n\nw = np.linspace(9e6*2*np.pi, 11e6*2*np.pi, 1000, endpoint=True)\n\nplt.title('Input impedance')\n\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='|Zin|')\nplt.plot(w/(2*np.pi)/1e6, np.real((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Re Zin')\nplt.plot(w/(2*np.pi)/1e6, np.imag((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Im Zin')\n\nplt.ylabel('impedance, ohms')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitude of the input impedance (in blue), the real part of the input impedance (in orange) and the imaginary part of the input impedance (in green). Near 10Hz, the magnitude and real part of the input impedance is 50 ohms and the imaginary part is about zero. This shows that the design equations produced the desired results. The input impedance bandwidth of the filter is about 1 MHz.\nThe voltage gain of the filter calculated from the z-parameters is: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), which is plotted below:\n\nplt.title('Voltage gain')\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z21_s(1j*w)*Zl)/(func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))),'-',label='|Kv|')\nplt.ylabel('Kv')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the voltage gain of the filter (in blue) plotted from the z-parameters. The filter is centered at 10MHz and the bandwidth appears to be 1 MHz.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "href": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "title": "21  Two port parameters",
    "section": "21.6 Convert z-parameters to s-parameters",
    "text": "21.6 Convert z-parameters to s-parameters\nAlthough applicable at any frequency, s-parameters are mostly used for networks operating at radio frequency (RF) and microwave frequencies. The s-parameters can be calculated from the z-parameters with the following formulas:\n\nZ_o = 50 # characteristic impedance\n\nw = np.linspace(8e6*2*np.pi, 12e6*2*np.pi, 2000, endpoint=True)\ns11 = np.zeros(len(w),dtype=complex)\ns12 = np.zeros(len(w),dtype=complex)\ns21 = np.zeros(len(w),dtype=complex)\ns22 = np.zeros(len(w),dtype=complex)\n\nfor i in range(len(w)):\n    del_z = (func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i])\n    s11[i] = ((func_z11_s(1j*w[i])-Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n    s12[i] = (2*func_z12_s(1j*w[i])*Z_o)/del_z\n    s21[i] = (2*func_z21_s(1j*w[i])*Z_o)/del_z\n    s22[i] = ((func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])-Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n\nplt.title('S-parameters')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s11)),'-',label='|s11|dB')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s21)),'-',label='|s21|dB')\nplt.ylabel('|S11| & |S21|, dB')\nplt.xlabel('Frequency, MHz')\nplt.ylim((-20,1))\nplt.yticks(np.arange(-20, 1, 5))\n#plt.xlim((-1,20))\n#plt.xticks(np.arange(0, 20+1, 2.0))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitudes in dB of the input reflection coefficient (in blue) and the forward voltage gain (in orange).\nThe magnitude of the input reflection coefficient indicates the amount of energy reflected back to the source due to the impedance mismatch. The smaller the reflection coefficient the better the match, and in dB, large negative values are very small small numbers. A rule of thumb is that |S11| less than about -9.5 dB is a reasonable match, since this corresponds to about a 2:1 VSWR or a mismatch loss of about 0.5 dB. The frequency range over which this match occurs is called the impedance bandwidth.\nThe plot of |S21| shows the forward voltage gain of the filter in dB. The filter was designed to be a band pass filter with a center frequency of 10 MHz, which is clearly shown in the plot. The plot is similar to what would be seen on a network analyzer.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#summary",
    "href": "Two port parameters.html#summary",
    "title": "21  Two port parameters",
    "section": "21.7 Summary",
    "text": "21.7 Summary\nIn this notebook the parameters for two port networks were generated from the circuit’s netlist. Using python, the circuit equations were automatically generated by using modified nodal analysis, then SymPy was used to solve for the network currents and voltages. Z-parameters were calculated for the circuits, from which y and s parameters were generated. The z-parameters were used to generate input impedance and transfer functions.\nThis notebook has demonstrated that two port parameters can easily be generated from a circuit’s netlist with python.\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Two port parameters</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html",
    "href": "Thevenin equivalent circuit.html",
    "title": "22  Thevenin equivalent circuit",
    "section": "",
    "text": "22.1 Introduction\nThe Thevenin equivalent circuit is the reduction of a linear one port circuit to a single source and impedance and is based on Thevenin’s Theorem. This notebook describes solving problem 11.25, given in chapter 11 of Johnson, Hilburn, and Johnson (1978). The Python libraries of SimPy and NumPy are used to perform the math in the proposed solution. The problem asks the student to replace the circuit to the left of terminals a-b by its Thevenin equivalent and find V. The schematic was drawn using LTspice and the nodes were numbered. Terminals a-b are across the resistor R3. The circuit given in the textbook does not include a reference node, however the node at the bottom of the schematic was chosen as the reference node, ground.\nHaving drawn the circuit in LTspice, the following netlist was exported as a text file.\nThe component values for the inductors and capacitors are complex as well as the value of the current source. It is assumed that the impedance of the inductors and capacitors are at a frequency of 1 radian per second. So accordingly, the values in the net list used by the Python code to generate the network equations has been adjusted as follows:\nThe component values are not used when the symbolic network equations are generated, only the reference designators, R1, C1, L1 etc. are used.\n#import os\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#introduction",
    "href": "Thevenin equivalent circuit.html#introduction",
    "title": "22  Thevenin equivalent circuit",
    "section": "",
    "text": "Figure 22.1: Circuit for problem 11.25 of Johnson, Hilburn, and Johnson (1978)\n\n\n\n\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 j2\nL2 1 3 j3\nC1 1 2 -j3\nC2 3 0 -j2\nI1 0 1 -1-j1\n\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nI1 0 1 1",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "href": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.2 Find the open circuit voltage, Voc",
    "text": "22.2 Find the open circuit voltage, Voc\nRemoving R3 and C2 from the netlist, this gives Voc = V3. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\n*C2 3 0 0.5\nLoad the net list\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.3333333333\n*C2 3 0 0.5\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}}\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  s, \\  v_{2}, \\  I_{L2}, \\  v_{3}, \\  R_{2}\\right)\\)\n\n\nGenerate the symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} L_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} L_{2} R_{1} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\)\\(v_{2} = \\frac{I_{1} L_{1} R_{1} s}{L_{1} s + R_{1}}\\)\\(v_{3} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} R_{1}}{L_{1} s + R_{1}}\\)\\(I_{L2} = \\frac{I_{1}}{C_{1} L_{2} s^{2} + C_{1} R_{2} s + 1}\\)\n\n\nConstruct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.3333333333, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0\\right\\}\\)\n\n\nTo solve numerically, replace symbols with the element values and the Laplace variable, s, with \\(j\\omega\\) where \\(\\omega=1\\).\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.3333333333 i v_{1} - 0.3333333333 i v_{2}\\\\I_{L1} - 0.3333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.3333333333 i\\right) - 0.166666666666667 v_{3}\\\\- I_{L2} - 0.166666666666667 v_{2} + 0.166666666666667 v_{3}\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving the system of equations for the open circuit voltage at node v3.\n\nVoc = solve(NE,X)[v3]\nVoc\n\n\\(\\displaystyle -1.8 + 0.6 i\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "href": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.3 Find the short circuit current, Isc",
    "text": "22.3 Find the short circuit current, Isc\nRemove C2 and R3, set node 3 to zero, find current in L2 and R2. New net list:\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33333333333333\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right)\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  s, \\  v_{2}, \\  I_{L2}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + I_{1} L_{1} L_{2} R_{1} s^{2} + I_{1} L_{1} L_{2} R_{2} s^{2} + I_{1} L_{2} R_{1} R_{2} s}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(v_{2} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(I_{L1} = \\frac{C_{1} I_{1} L_{2} R_{1} R_{2} s^{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(I_{L2} = \\frac{C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\n\n\n\nU_sym[v2]/R2 + U_sym[I_L2]\n\n\\(\\displaystyle \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}} + \\frac{C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\n\n\nConstruct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.33333333333333, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0\\right\\}\\)\n\n\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.33333333333333 i v_{1} - 0.33333333333333 i v_{2}\\\\I_{L1} - 0.33333333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.33333333333333 i\\right)\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\nU\n\n\\(\\displaystyle \\left\\{ I_{L1} : -1.5 - 1.5 i, \\  I_{L2} : -0.5 + 1.5 i, \\  v_{1} : -4.5 - 1.5 i, \\  v_{2} : 3.0 - 3.0 i\\right\\}\\)\n\n\n\nIsc = U[v2]/6 + U[I_L2]\nIsc\n\n\\(\\displaystyle 1.0 i\\)\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\(\\displaystyle 0.6 + 1.8 i\\)\n\n\n\nCurrent in I_R2 = V2/R2\n\nIsc = U[v2]/6 + U[I_L2]\nIsc\n\n\\(\\displaystyle 1.0 i\\)\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\(\\displaystyle 0.6 + 1.8 i\\)\n\n\nVoc along with Zth are the values to the Thevenin equivalent circuit.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.4 Find V3 using the Thevenin equivalent circuit",
    "text": "22.4 Find V3 using the Thevenin equivalent circuit\nThe load attached to the Thevenin equivalent circuit is the parallel of the resistor and capacitor.\n\\(Z = \\frac{1}{\\frac{1}{R}+\\frac{1}{C}}\\)\nThe load \\(Z\\) is the parallel combination of R = 6 and C = -j2.\n\nZ = (1)/(1/(6)+1/(-2j))\nZ\n\n(0.6-1.7999999999999998j)\n\n\nUsing the values for \\(V_{oc}\\) and \\(Z_{th}\\) obtained above, we write the equation for V3 as a voltage divider and have SymPy simplify the result.\n\nsimplify(Z*Voc/(Zth+Z))\n\n\\(\\displaystyle 4.62592926927148 \\cdot 10^{-16} + 3.0 i\\)\n\n\nWe can get SymPy to ignore small numbers by using the round function set to 3 digits.\n\nsimplify(Z*Voc/(Zth+Z)).round(3)\n\n\\(\\displaystyle 3.0 i\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "title": "22  Thevenin equivalent circuit",
    "section": "22.5 Find V3 using the complete circuit",
    "text": "22.5 Find V3 using the complete circuit\nChecking the answer for V3, by solving the equations for the complete circuit. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nDeclare the symbols and equations for the complete circuit.\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.333333333333333\nC2 3 0 0.5\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  R_{3}, \\  s, \\  v_{2}, \\  I_{L2}, \\  v_{3}, \\  R_{2}, \\  C_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} C_{2} I_{1} L_{1} L_{2} R_{1} R_{2} R_{3} s^{4} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + C_{2} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{2} I_{1} L_{1} L_{2} R_{2} R_{3} s^{3} + C_{2} I_{1} L_{2} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} L_{2} R_{1} s^{2} + I_{1} L_{1} L_{2} R_{2} s^{2} + I_{1} L_{1} L_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} L_{2} R_{1} R_{2} s + I_{1} L_{2} R_{1} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{2} = \\frac{C_{1} C_{2} I_{1} L_{1} L_{2} R_{1} R_{2} R_{3} s^{4} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{3} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L1} = \\frac{C_{1} C_{2} I_{1} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} I_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} I_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} I_{1} R_{1} R_{2} R_{3} s + I_{1} R_{1} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L2} = \\frac{C_{1} C_{2} I_{1} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + C_{2} I_{1} L_{1} R_{1} R_{3} s^{2} + C_{2} I_{1} L_{1} R_{2} R_{3} s^{2} + C_{2} I_{1} R_{1} R_{2} R_{3} s + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} L_{1} R_{3} s + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\n\nU_sym[v3]\n\n\\(\\displaystyle \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\nConstruct a dictionary of element values\nelement_values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.333333333333333, \\  C_{2} : 0.5, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0, \\  R_{3} : 6.0\\right\\}\\)\n\n\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.333333333333333 i v_{1} - 0.333333333333333 i v_{2}\\\\I_{L1} - 0.333333333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.333333333333333 i\\right) - 0.166666666666667 v_{3}\\\\- I_{L2} - 0.166666666666667 v_{2} + v_{3} \\cdot \\left(0.333333333333333 + 0.5 i\\right)\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving the system of equations for v3 using the SymPy solve function.\n\nU = solve(NE,X)\nU[v3]\n\n\\(\\displaystyle 3.0 i\\)\n\n\n\nThe value obtained by solving the system equations for the complete network agrees with the Thevenin equivalent circuit solution.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Thevenin equivalent circuit</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html",
    "href": "State-variable-filter.html",
    "title": "23  State Variable Filter",
    "section": "",
    "text": "23.1 Introduction\nA state variable filter using opamps was first described by Tow (1968). The filter shown in the schematic below has low pass (LP), high pass (HP) and band pass (BP) outputs. For certain combinations of resistors and capacitors, the natural frequency and Q of filter can be independently determined. All the element values are assigned a value of 1, since they will be assigned as part of the filter design process.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#introduction",
    "href": "State-variable-filter.html#introduction",
    "title": "23  State Variable Filter",
    "section": "",
    "text": "Figure 23.1: State variable filter",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#circuit-description",
    "href": "State-variable-filter.html#circuit-description",
    "title": "23  State Variable Filter",
    "section": "23.2 Circuit description",
    "text": "23.2 Circuit description\nThe circuit in Figure 23.1 has 10 branches and eight nodes. There are two capacitors, seven resistors in the circuit and three Op Amps. The circuit has a low pass, a high pass and band pass outputs.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#circuit-analysis",
    "href": "State-variable-filter.html#circuit-analysis",
    "title": "23  State Variable Filter",
    "section": "23.3 Circuit analysis",
    "text": "23.3 Circuit analysis\nThe circuit was drawn using LTSpice and the netlist was pasted into the code. Network equations were generated using the smna() function and a symbolic solution for the equations was obtained. The characteristic equation was obtained and coeficients of the equation were extracted so that the symbols could be equated to parameters known as Q and damping ratio. These were symplified by by letting R = R1 = R3 = R4 = R5 = R6 = R7 and C = C1 = C2. By letting C = 0.1\\(\\mu\\)F, R was solved for to get a natural frequency of 1kHz. R2 was then solved for to get a Q of 3. Substituting component values into the equations, the filter was analyzed to obtain frequency and phase plots, impulse and step response and group delay.\nThe net list for the filter is:\nR3 3 1 1\nR6 6 4 1\nR7 8 7 1\nR5 4 3 1\nR2 7 5 1\nC1 7 6 1\nC2 2 8 1\nO1 3 5 4 \nO2 6 0 7 \nV1 1 0 1\nO3 8 0 2 \nR1 5 0 1\nR4 2 3 1\nThe following Python modules are used.\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#load-the-net-list",
    "href": "State-variable-filter.html#load-the-net-list",
    "title": "23  State Variable Filter",
    "section": "23.4 Load the net list",
    "text": "23.4 Load the net list\n\nnet_list = '''\nR3 3 1 1\nR6 6 4 1\nR7 8 7 1\nR5 4 3 1\nR2 7 5 1\nC1 7 6 1\nC2 2 8 1\nO1 3 5 4 \nO2 6 0 7 \nV1 1 0 1\nO3 8 0 2 \nR1 5 0 1\nR4 2 3 1\n'''",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "State-variable-filter.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "23  State Variable Filter",
    "section": "23.5 Call the symbolic modified nodal analysis function",
    "text": "23.5 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}} = 0\\)\\(- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}} = 0\\)\\(I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}} = 0\\)\\(- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}} = 0\\)\\(- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{5} = 0\\)\\(v_{6} = 0\\)\\(v_{8} = 0\\)\n\n\n\n23.5.1 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}}\\\\- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}}\\\\v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}}\\\\I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}}\\\\- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}}\\\\- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}}\\\\- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}}\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{2}, \\  R_{7}, \\  V_{1}, \\  C_{1}, \\  R_{2}, \\  R_{1}, \\  R_{5}, \\  I_{O1}, \\  v_{4}, \\  v_{5}, \\  s, \\  v_{2}, \\  I_{V1}, \\  v_{1}, \\  I_{O3}, \\  I_{O2}, \\  R_{6}, \\  v_{3}, \\  R_{3}, \\  v_{8}, \\  v_{6}, \\  v_{7}, \\  R_{4}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#symbolic-solution",
    "href": "State-variable-filter.html#symbolic-solution",
    "title": "23  State Variable Filter",
    "section": "23.6 Symbolic solution",
    "text": "23.6 Symbolic solution\nThe symbolic solution of the network equations takes about 50 seconds to solve on my laptop (i3-8130U CPU @ 2.20GHz).\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{1} R_{4} R_{5} V_{1} - R_{2} R_{4} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{3} = \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{4} = \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{5} = \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{6} = 0\\)\\(v_{7} = \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{8} = 0\\)\\(I_{V1} = \\frac{- C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{7} V_{1} s - C_{2} R_{1} R_{5} R_{7} V_{1} s - R_{1} R_{5} V_{1} - R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(I_{O1} = \\frac{C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{2} R_{1} R_{4} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(I_{O2} = \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{5} V_{1} s - C_{2} R_{2} R_{4} R_{5} V_{1} s - C_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(I_{O3} = \\frac{C_{2} R_{1} R_{4} R_{5} V_{1} s + C_{2} R_{1} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} V_{1} s + R_{1} R_{5} V_{1} + R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#low-pass",
    "href": "State-variable-filter.html#low-pass",
    "title": "23  State Variable Filter",
    "section": "23.7 Low Pass",
    "text": "23.7 Low Pass\nThe low pass transfer function.\n\nH_sym_lp = cancel(U_sym[v2]/V1,s)\nH_sym_lp\n\n\\(\\displaystyle \\frac{- R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}}{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)}\\)\n\n\n\nsym_num, sym_denom = fraction(H_sym_lp,s) #returns numerator and denominator\n\n\nsym_num\n\n\\(\\displaystyle - R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}\\)\n\n\n\n23.7.1 Characteristic equation\n\nsym_denom\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)\\)\n\n\nGet the coefficients of the Laplace variable, s, from the quadratic equation:\n\\(as^{2}+bs+c=0\\)\n\na = sym_denom.coeff(s**2)\na\n\n\\(\\displaystyle C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\)\n\n\n\nb = sym_denom.coeff(s)\nb\n\n\\(\\displaystyle C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\)\n\n\nTo find the c coefficient just subract off \\(bs\\) and \\(cs^2\\) from the quadratic equation.\n\nc = sym_denom - b*s - a*s**2\nc\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#natural-frequency-and-q-factor",
    "href": "State-variable-filter.html#natural-frequency-and-q-factor",
    "title": "23  State Variable Filter",
    "section": "23.8 Natural frequency and Q factor",
    "text": "23.8 Natural frequency and Q factor\nThe expressions for the natural frequency and Q factor are shown below:\n\\(\\omega _n = \\sqrt {\\frac {c}{a}}\\)\n\\(Q = \\omega _n \\frac {a}{b}\\)\nThese xpressions have their orgin in classical mechanics describing harmonic oscillators and are applicable to 2nd order electrical systems.\nThe damping ratio is defined by the equation:\n\\(\\zeta = \\frac {1}{2Q}\\)\n\nomega_n = sqrt(c/a)\nomega_n\n\n\\(\\displaystyle \\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}}\\)\n\n\n\nQ = (a/b)*omega_n\nQ\n\n\\(\\displaystyle \\frac{\\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right)}{C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}}\\)\n\n\nSimply the expressions for Q and \\(\\omega _n\\) by letting R = R1 = R3 = R4 = R5 = R6 = R7 and C = C1 = C2.\n\nR, C = symbols('R C')\n\n\nsimplify = {\n    R1:R,\n    R3:R,\n    R4:R,\n    R5:R,\n    R6:R,\n    R7:R,\n    C1:C,\n    C2:C}\n\n\nomega_n_simp = omega_n.subs(simplify).factor()\nomega_n_simp\n\n\\(\\displaystyle \\sqrt{\\frac{1}{C^{2} R^{2}}}\\)\n\n\n\nQ_simp = Q.subs(simplify).factor()\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nBy inspection Q could be simplified more, because C cancels out, but we will leave it.\nLet C = 0.1\\(\\mu\\)F, solve for R to get a natural frequency of 1kHz.\n\nomega_n_simp = omega_n_simp.subs({C:0.1e-6})\nomega_n_simp\n\n\\(\\displaystyle 10000000.0 \\sqrt{\\frac{1}{R^{2}}}\\)\n\n\n\nRnew = solve(Eq(omega_n_simp,1e3*2*np.pi),R)\nRnew\n\n\\(\\displaystyle \\left[ -1591.54943091895, \\  1591.54943091895\\right]\\)\n\n\n\nRnew = float(Rnew[1])\nRnew\n\n\\(\\displaystyle 1591.54943091895\\)\n\n\nWith R and C chosen,\n\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nSubstituting C=0.1\\(\\mu\\)F and R = Rnew into Q_simp\n\nQ_simp = Q_simp.subs({C:0.1e-6,R:Rnew})\nQ_simp\n\n\\(\\displaystyle 0.00020943951023932 R_{2} + 0.333333333333333\\)\n\n\nSolve for R2 for the desired Q=3.\n\nR2new = solve(Eq(Q_simp,3),R2)\nR2new = R2new[0]\nR2new\n\n\\(\\displaystyle 12732.3954473516\\)\n\n\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {\n    V1:1,\n    R3:Rnew,\n    R6:Rnew,\n    R7:Rnew,\n    R5:Rnew,\n    R2:R2new,\n    C1:0.1e-6,\n    C2:0.1e-6,\n    R1:Rnew,\n    R4:Rnew}\n\n\nQ.subs(nominal_component_value)\n\n\\(\\displaystyle 3.0\\)\n\n\n\nomega_n.subs(nominal_component_value)/(2*np.pi)\n\n\\(\\displaystyle 1000.0\\)\n\n\n\ndamping_ratio = 1/(2*Q.subs(nominal_component_value))\ndamping_ratio\n\n\\(\\displaystyle 0.166666666666667\\)\n\n\n\n23.8.1 Numerical solution\n\n# put the element values into the equations\nNE = NE_sym.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instead of symbols.\n\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.000628318530717959 v_{1} - 0.000628318530717959 v_{3}\\\\I_{O3} - 1.0 \\cdot 10^{-7} s v_{8} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right) - 0.000628318530717959 v_{3}\\\\- 0.000628318530717959 v_{1} - 0.000628318530717959 v_{2} + 0.00188495559215388 v_{3} - 0.000628318530717959 v_{4}\\\\I_{O1} - 0.000628318530717959 v_{3} + 0.00125663706143592 v_{4} - 0.000628318530717959 v_{6}\\\\0.000706858347057704 v_{5} - 7.8539816339745 \\cdot 10^{-5} v_{7}\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000628318530717959 v_{4} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-7} s v_{6} - 7.8539816339745 \\cdot 10^{-5} v_{5} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000706858347057704\\right) - 0.000628318530717959 v_{8}\\\\- 1.0 \\cdot 10^{-7} s v_{2} - 0.000628318530717959 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU = solve(NE,X)\n\n\n\n23.8.2 Low pass filter transfer function\n\nH_lp = U[v2]/U[v1]\nH_lp.factor()\n\n\\(\\displaystyle - \\frac{1.0}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\nThe SymPy function, factor(), takes a polynomial and factors it into irreducible factors over the rational numbers. Notice that the value is negative, indicating that the filter configuration is inverting.\n\n23.8.2.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_lp_num, H_lp_denom = fraction(H_lp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\nlp_a = np.array(Poly(H_lp_num, s).all_coeffs(), dtype=float)\nlp_b = np.array(Poly(H_lp_denom, s).all_coeffs(), dtype=float)\nlp_sys = signal.TransferFunction(lp_a,lp_b)\n\n\n\n\n23.8.3 High pass filter transfer function\n\nH_hp = U[v4]/U[v1]\nH_hp.factor()\n\n\\(\\displaystyle - \\frac{2.53302959105844 \\cdot 10^{-8} s^{2}}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_hp_num, H_hp_denom = fraction(H_hp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nhp_a = np.array(Poly(H_hp_num, s).all_coeffs(), dtype=float)\nhp_b = np.array(Poly(H_hp_denom, s).all_coeffs(), dtype=float)\nhp_sys = signal.TransferFunction(hp_a,hp_b)\n\n\n\n23.8.4 Band pass filter transfer function\n\nH_bp = U[v7]/U[v1]\nH_bp.factor()\n\n\\(\\displaystyle \\frac{0.000159154943091895 s}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_bp_num, H_bp_denom = fraction(H_bp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nbp_a = np.array(Poly(H_bp_num, s).all_coeffs(), dtype=float)\nbp_b = np.array(Poly(H_bp_denom, s).all_coeffs(), dtype=float)\nbp_sys = signal.TransferFunction(bp_a,bp_b)\n\n\n\n23.8.5 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nlp_sys_zeros = np.roots(lp_sys.num)\nlp_sys_poles = np.roots(lp_sys.den)\n\n\n23.8.5.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(lp_sys_zeros), np.imag(lp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(lp_sys_poles), np.imag(lp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(lp_sys_zeros)))\nfor i in lp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(lp_sys_poles)))\nfor i in lp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-166.67+986.01j Hz\n-166.67-986.01j Hz\n\n\n\n\n\n23.8.6 Stability\nBy inspecting the plot above, we can tell the filter is stable since all the poles of the transfer function are in the left hand plane.\n\n\n23.8.7 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nx_axis_range = np.logspace(2, 4, 5000, endpoint=True)*2*np.pi\nw, lp_mag, lp_phase = lp_sys.bode(w=x_axis_range)\nw, hp_mag, hp_phase = hp_sys.bode(w=x_axis_range)\nw, bp_mag, bp_phase = bp_sys.bode(w=x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# Bode magnitude plot\nplt.semilogx(w/(2*np.pi), lp_mag,'-r')\nplt.semilogx(w/(2*np.pi), hp_mag,'-b')\nplt.semilogx(w/(2*np.pi), bp_mag,'-g')\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k' #'tab:blue'\n\n# Bode phase plot\nplt.semilogx(w/(2*np.pi), lp_phase,':r',label='LP phase')\nplt.semilogx(w/(2*np.pi), hp_phase,':b',label='HP phase')\nplt.semilogx(w/(2*np.pi), bp_phase,':g',label='BP phase')\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='r', label='LP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='b', label='HP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='g', label='BP magnitude')\n\nplt.legend(loc=0)\nplt.title('Filter Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe Bode plot for the preamplifier is plotted from 100 Hz to 1 kHz.\n\n\n23.8.8 Low pass filter impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n23.8.9 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(lp_phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#summary",
    "href": "State-variable-filter.html#summary",
    "title": "23  State Variable Filter",
    "section": "23.9 Summary",
    "text": "23.9 Summary\nA state variable filter was analized. Component values for a filter of Q=3 and natural frequency of 1kHz were derived. Various typical filter performance plots were generated.\n\n\n\n\nTow, J. 1968. “Active RC Filters a State-Space Realization.” Proceedings of the IEEE 56 (6): 1137–39. https://doi.org/10.1109/PROC.1968.6502.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "Superposition.html",
    "href": "Superposition.html",
    "title": "24  Superposition",
    "section": "",
    "text": "24.1 Introduction\nThe circuit shown above is a large non-planar circuit designed to look at the problem of multiple sources with different phases and frequencies.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#circuit-description",
    "href": "Superposition.html#circuit-description",
    "title": "24  Superposition",
    "section": "24.2 Circuit description",
    "text": "24.2 Circuit description\nThe circuit in Figure 24.1 is has 23 branches and 14 nodes. There are two dependent sources. V1 is a voltage source with a DC value of 5 volts and an AC value of 7 volts which has a phase of 135 degrees with a frequency of 3 Hz. I1 is a current source with a DC value of 2 amps and an AC value of 3 amps which has a phase of 300 degrees and a frequency of 7 Hz, as shaown in Table 24.1. There are two dependent sources. H1 is a current controlled voltage source with a gain of 2 and the controlling current is the current through V2. The voltage source V2, set to a value of zero volts, was included in the circuit to provide a monitoring point for the current in R9. The other dependednt source, G1, is a voltage controlled voltage source which has a gain of 2 and is controlled by the votages on nodes 2 and 8. The circuit also has a pair of coupled inductors, two inductors, three capacitors and 11 resistors.\n\n\n\nTable 24.1: Dependent sources\n\n\n\n\n\nsource\nDC\nMagnitude @ angle\nfrequency, Hz\n\n\n\n\nV1\n5\n7 @ 135\n3\n\n\nI1\n2\n3 @ 300\n7",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#circuit-analysis",
    "href": "Superposition.html#circuit-analysis",
    "title": "24  Superposition",
    "section": "24.3 Circuit analysis",
    "text": "24.3 Circuit analysis\nThe MNA technique will be used analyze the circuit using the componet values shown in the schematic since the circuit is too large for meaninful symbolic analysis. The symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and removed the code. The analysis will cover the four areas listed below.\n\nDC operating point with \\(s=j \\omega\\) set to zero and the circuit driven by the DC values of the independent sources.\nAC analysis with V1 having a frequency of 3 Hz and I1 having a frequency of 7 Hz.\nTotal response of the DC and AC sources at the respective frequencies.\n\nThe results obtained from MNA will be compared to those obtained from LTSpice.\nThe netlist generated by LTSpice is listed below:\nV1 6 1 5 AC 7 135\nV2 10 12 0 AC 0 0\nI1 3 4 2 AC 3 300\nL3 11 14 3 Rser=0\nL1 1 5 5 Rser=0\nL4 14 13 2 Rser=0\nL2 4 8 7 Rser=0\nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\nThe following Python modules are used in this analysis.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\nIn electrical engineering, a time invarient sinusudial signals can be represented either by polar or rectangular notation. The function polar converts the polar representation, also called a phasor to rectangular notation and the second function converts rectangular notation to magnitude and phase.\n\ndef polar2rec(mag, ang, units='deg'):\n    ''' polar to rectangular conversion\n        mag: float\n            magnitude of the time invarient sinusudial signal\n        ang: float\n            the angle of the time invarient sinusudial signal\n        units: string\n            if units is set to deg, and is in degrees not radians\n        returns: complex\n            rectangular corrdinates of voltage vector\n    '''\n    if units == 'deg':\n        ang = ang * np.pi / 180\n    return mag * np.exp(1j * ang)\n\ndef rec2polar(value):\n    '''rectangular to polar conversion\n    value: complex float\n        \n    returns:\n        magnitude, phase (in degrees)\n    '''\n    return float(abs(value)), float(arg(value)*180/np.pi)\n\n\n24.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 6 1 5 \nV2 10 12 0 \nI1 3 4 2 \nL3 11 14 3 \nL1 1 5 5 \nL4 14 13 2 \nL2 4 8 7 \nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}} = - I_{1}\\)\\(- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}} = I_{1}\\)\\(- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}} = 0\\)\\(I_{H1} + \\frac{v_{7}}{R_{6}} = 0\\)\\(- I_{L2} + \\frac{v_{8}}{R_{7}} = 0\\)\\(v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}} = 0\\)\\(I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}} = 0\\)\\(I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}} = 0\\)\\(- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}} = 0\\)\\(- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}} = 0\\)\\(- v_{1} + v_{6} = V_{1}\\)\\(v_{10} - v_{12} = V_{2}\\)\\(- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14} = 0\\)\\(- I_{L2} L_{2} s + v_{4} - v_{8} = 0\\)\\(- I_{V2} h_{1} - v_{3} + v_{7} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}}\\\\- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}}\\\\- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}}\\\\I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\I_{H1} + \\frac{v_{7}}{R_{6}}\\\\- I_{L2} + \\frac{v_{8}}{R_{7}}\\\\v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}}\\\\I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}}\\\\I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}}\\\\- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}}\\\\- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right)\\\\- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14}\\\\- I_{L1} L_{1} s + v_{1} - v_{5}\\\\- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14}\\\\- I_{L2} L_{2} s + v_{4} - v_{8}\\\\- I_{V2} h_{1} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{1}\\\\I_{1}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{10}, \\  R_{10}, \\  R_{3}, \\  R_{5}, \\  R_{9}, \\  V_{2}, \\  R_{7}, \\  s, \\  I_{1}, \\  C_{3}, \\  R_{2}, \\  v_{14}, \\  I_{L3}, \\  I_{L4}, \\  L_{3}, \\  R_{11}, \\  I_{H1}, \\  R_{6}, \\  R_{8}, \\  L_{4}, \\  C_{2}, \\  v_{13}, \\  v_{11}, \\  R_{1}, \\  g_{1}, \\  I_{V2}, \\  v_{3}, \\  v_{9}, \\  R_{4}, \\  v_{2}, \\  v_{12}, \\  v_{6}, \\  I_{L2}, \\  I_{L1}, \\  I_{V1}, \\  L_{2}, \\  C_{1}, \\  V_{1}, \\  L_{1}, \\  v_{8}, \\  h_{1}, \\  v_{4}, \\  v_{5}, \\  M_{1}, \\  v_{1}, \\  v_{7}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#dc-operating-point",
    "href": "Superposition.html#dc-operating-point",
    "title": "24  Superposition",
    "section": "24.4 DC operating point",
    "text": "24.4 DC operating point\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\nK1 = symbols('K1')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.979795897\n\n\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + 0.01 v_{1} - 0.01 v_{2}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.05 v_{12} + 0.0633333333333333 v_{3} - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.0133333333333333 v_{3} + 0.0133333333333333 v_{4}\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + 0.15 v_{12} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\v_{11} - v_{14}\\\\v_{1} - v_{5}\\\\- v_{13} + v_{14}\\\\v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_dc = solve(NE_dc,X)\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown             mag\n---------  ------------\nv1         -1444.606764\nv2           701.805800\nv3           626.530983\nv4           564.749806\nv5         -1444.606764\nv6         -1439.606764\nv7           583.602732\nv8           564.749806\nv9         -1449.580366\nv10          916.447056\nv11        -1465.073530\nv12          916.447056\nv13        -1465.073530\nv14        -1465.073530\nI_V1          -0.997360\nI_V2         -21.464126\nI_L3          15.493164\nI_L1          20.466765\nI_L4           0.000000\nI_L2           2.823749\nI_H1         -11.672055\n\n\nLTSpice results:\n       --- Operating Point ---\n\nV(6):    -1439.61    voltage\nV(1):    -1444.61    voltage\nV(10):   916.447     voltage\nV(12):   916.447     voltage\nV(3):    626.531     voltage\nV(4):    564.75  voltage\nV(11):   -1465.07    voltage\nV(14):   -1465.07    voltage\nV(5):    -1444.61    voltage\nV(13):   -1465.07    voltage\nV(8):    564.75  voltage\nV(7):    583.603     voltage\nV(2):    701.806     voltage\nV(9):    -1449.58    voltage\nI(C1):   4.72012e-11     device_current\nI(C2):   1.71378e-11     device_current\nI(C3):   -3.015e-11  device_current\nI(H1):   -11.6721    device_current\nI(L3):   15.4932     device_current\nI(L1):   20.4668     device_current\nI(L4):   -4.72875e-11    device_current\nI(L2):   2.82375     device_current\nI(I1):   2   device_current\nI(R9):   -21.4641    device_current\nI(R6):   11.6721     device_current\nI(R4):   20.4668     device_current\nI(R1):   -21.4641    device_current\nI(R3):   0.823749    device_current\nI(R7):   -2.82375    device_current\nI(R11):  -238.152    device_current\nI(R5):   0.99736     device_current\nI(R10):  15.4932     device_current\nI(R8):   -14.4958    device_current\nI(R2):   -14.4958    device_current\nI(G1):   -274.112    device_current\nI(V1):   -0.99736    device_current\nI(V2):   -21.4641    device_current\nStore the results in a Pandas dataframe.\n\nsolutions = pd.DataFrame(U_dc.items(), columns=['unk', 'w=DC'])\nsolutions = solutions.set_index('unk')\nsolutions['w=DC'] = solutions['w=DC'].astype(float)\n#solutions",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#independent-sources-each-with-a-different-frequency",
    "href": "Superposition.html#independent-sources-each-with-a-different-frequency",
    "title": "24  Superposition",
    "section": "24.5 Independent sources each with a different frequency",
    "text": "24.5 Independent sources each with a different frequency\nThe independent sources V1 and I1 each have different amplitudes, phases and frequencies. First we will solve the network equations for when V1 is active and I1 is set to zero. The following code set I1 to zero and calls the function polar2rec to convert the amplitude and phase to rectangular notation.\n\nelement_values[I1] = 0\nelement_values[V1] = polar2rec(7, 135, units='deg')\n\nSolve equations for \\(\\omega\\) equal to 3 Hz. The value for \\(\\omega\\) is calculated by: \\(\\omega = 2 \\pi 3\\), then use the substitute function to set \\(s = 2 \\pi 3j\\). Then display the network equations with numerical values.\n\nomega = 2*np.pi*3\nNE_w1 = NE_sym.subs(element_values)\nNE_w1 = NE_w1.subs({s:omega*1j})\nNE_w1\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 0.429581379451868 i\\right) - 0.01 v_{2} - 0.429581379451868 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.429581379451868 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 0.429581379451868 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.159146800645552 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.159146800645552 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.238635377966681 i\\right) - 0.238635377966681 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.238635377966681 i v_{12} + 0.397782178612232 i v_{13} - 0.159146800645552 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 56.5486677646163 i I_{L3} - 18.4687175543308 i I_{L4} + v_{11} - v_{14}\\\\- 94.2477796076938 i I_{L1} + v_{1} - v_{5}\\\\- 18.4687175543308 i I_{L3} - 37.6991118430775 i I_{L4} - v_{13} + v_{14}\\\\- 131.946891450771 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\-4.94974746830583 + 4.94974746830583 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_w1 = solve(NE_w1,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.214165    -42.658172\nv2         5.054599     39.141345\nv3         1.983213    -32.248064\nv4         5.501867     67.083943\nv5         7.598113    -22.913101\nv6         5.787062    134.508799\nv7         1.977375    -35.152486\nv8         4.592470     33.669731\nv9         5.241567    168.957875\nv10        5.544043     40.383410\nv11        5.350944    172.465292\nv12        5.544043     40.383410\nv13        5.619390     60.869229\nv14        7.602773    -23.429285\nI_V1       0.330707   -109.201912\nI_V2       0.050272   -127.028107\nI_L3       0.342104     62.074687\nI_L1       0.068631     70.722730\nI_L4       0.389029   -137.950576\nI_L2       0.022962     33.669731\nI_H1       0.039547    144.847514\n\n\nThe results from LTSpice as shown below and they agree with the Python results. The DC values for the sources, V1 and I1, are set to zero.\n       --- AC Analysis ---\n\nfrequency:  3   Hz\nV(6):   mag:    5.78706 phase:    134.509°  voltage\nV(1):   mag:    1.21416 phase:   -42.6582°  voltage\nV(10):  mag:    5.54404 phase:    40.3834°  voltage\nV(12):  mag:    5.54404 phase:    40.3834°  voltage\nV(3):   mag:    1.98321 phase:   -32.2481°  voltage\nV(4):   mag:    5.50187 phase:    67.0839°  voltage\nV(11):  mag:    5.35094 phase:    172.465°  voltage\nV(14):  mag:    7.60277 phase:   -23.4293°  voltage\nV(5):   mag:    7.59811 phase:   -22.9131°  voltage\nV(13):  mag:    5.61939 phase:    60.8692°  voltage\nV(8):   mag:    4.59247 phase:    33.6697°  voltage\nV(7):   mag:    1.97737 phase:   -35.1525°  voltage\nV(2):   mag:     5.0546 phase:    39.1413°  voltage\nV(9):   mag:    5.24157 phase:    168.958°  voltage\nI(C1):  mag:   0.351813 phase:    73.2905°  device_current\nI(C2):  mag:  0.0977425 phase:   -105.008°  device_current\nI(C3):  mag:   0.474046 phase:   -131.513°  device_current\nI(H1):  mag:  0.0395475 phase:    144.848°  device_current\nI(L3):  mag:   0.342104 phase:    62.0747°  device_current\nI(L1):  mag:  0.0686314 phase:    70.7227°  device_current\nI(L4):  mag:   0.389029 phase:   -137.951°  device_current\nI(L2):  mag:  0.0229624 phase:    33.6697°  device_current\nI(I1):  mag:          0 phase:         -0°  device_current\nI(R9):  mag:  0.0502717 phase:   -127.028°  device_current\nI(R6):  mag:  0.0395475 phase:   -35.1525°  device_current\nI(R4):  mag:  0.0686314 phase:    70.7227°  device_current\nI(R1):  mag:  0.0502717 phase:   -127.028°  device_current\nI(R3):  mag:  0.0819131 phase:   -94.3412°  device_current\nI(R7):  mag:  0.0229624 phase:    -146.33°  device_current\nI(R11): mag:   0.716494 phase:   -67.4048°  device_current\nI(R5):  mag:   0.330707 phase:    70.7981°  device_current\nI(R10): mag:   0.342104 phase:    62.0747°  device_current\nI(R8):  mag:  0.0524157 phase:    168.958°  device_current\nI(R2):  mag:   0.265071 phase:   -118.698°  device_current\nI(G1):  mag:      1.304 phase:   -98.6653°  device_current\nI(V1):  mag:   0.330707 phase:   -109.202°  device_current\nI(V2):  mag:  0.0502717 phase:   -127.028°  device_current\n\nw1 = pd.DataFrame(U_w1.items(), columns=['unk', 'w=3Hz'])\nw1 = w1.set_index('unk')\nw1['w=3Hz'] = w1['w=3Hz'].astype(complex)\nsolutions['w=3Hz'] = w1['w=3Hz']\n#solutions\n\nSolve the network equations with V1 set to zero and I1 active with a frequency of 7 Hz, an amplitude of 3 at a phase angle of 300.\n\nelement_values[I1] = polar2rec(3, 300, units='deg')\nelement_values[V1] = 0 #polar2rec(7, 135, units='deg')\n\nSolve equations for \\(\\omega\\) equal to 7 Hz. The value for \\(\\omega\\) is calculated by: \\(\\omega = 2 \\pi 7\\)\n\nomega = 2*np.pi*7\nNE_w2 = NE_sym.subs(element_values)\nNE_w2 = NE_w2.subs({s:omega*1j})\nNE_w2\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 1.00235655205436 i\\right) - 0.01 v_{2} - 1.00235655205436 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 1.00235655205436 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 1.00235655205436 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.371342534839621 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.371342534839621 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.556815881922255 i\\right) - 0.556815881922255 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.556815881922255 i v_{12} + 0.928158416761876 i v_{13} - 0.371342534839621 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 131.946891450771 i I_{L3} - 43.0936742934386 i I_{L4} + v_{11} - v_{14}\\\\- 219.911485751286 i I_{L1} + v_{1} - v_{5}\\\\- 43.0936742934386 i I_{L3} - 87.9645943005142 i I_{L4} - v_{13} + v_{14}\\\\- 307.8760800518 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-1.5 + 2.59807621135332 i\\\\1.5 - 2.59807621135332 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_w2 = solve(NE_w2,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w2.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown           mag    phase, deg\n---------  ----------  ------------\nv1           9.005916    163.707427\nv2          32.516027    143.867055\nv3           7.786210    133.896662\nv4          47.805605    173.317623\nv5         269.759059     42.448864\nv6           9.005916    163.707427\nv7           7.302031    133.715779\nv8          26.042563    116.325861\nv9          27.308899    -54.477160\nv10         34.921833    143.365554\nv11         31.025759    -53.448958\nv12         34.921833    143.365554\nv13         41.722434    164.330384\nv14        269.726939     42.183778\nI_V1         3.483553    -45.280685\nI_V2         0.242382    -43.377657\nI_L3         3.753386    134.053052\nI_L1         1.248412    130.841984\nI_L4         5.167787    -51.606488\nI_L2         0.130213    116.325861\nI_H1         0.146041    -46.284221\n\n\nThe results from LTSpice as shown below and they agree with the Python results.\n       --- AC Analysis ---\n\nfrequency:  7   Hz\nV(6):   mag:    9.00592 phase:    163.707°  voltage\nV(1):   mag:    9.00592 phase:    163.707°  voltage\nV(10):  mag:    34.9218 phase:    143.366°  voltage\nV(12):  mag:    34.9218 phase:    143.366°  voltage\nV(3):   mag:    7.78621 phase:    133.897°  voltage\nV(4):   mag:    47.8056 phase:    173.318°  voltage\nV(11):  mag:    31.0258 phase:    -53.449°  voltage\nV(14):  mag:    269.727 phase:    42.1838°  voltage\nV(5):   mag:    269.759 phase:    42.4489°  voltage\nV(13):  mag:    41.7224 phase:     164.33°  voltage\nV(8):   mag:    26.0426 phase:    116.326°  voltage\nV(7):   mag:    7.30203 phase:    133.716°  voltage\nV(2):   mag:     32.516 phase:    143.867°  voltage\nV(9):   mag:    27.3089 phase:   -54.4772°  voltage\nI(C1):  mag:    4.48781 phase:    133.539°  device_current\nI(C2):  mag:    3.44327 phase:   -52.0221°  device_current\nI(C3):  mag:      8.611 phase:   -51.7727°  device_current\nI(H1):  mag:   0.146041 phase:   -46.2842°  device_current\nI(L3):  mag:    3.75339 phase:    134.053°  device_current\nI(L1):  mag:    1.24841 phase:    130.842°  device_current\nI(L4):  mag:    5.16779 phase:   -51.6065°  device_current\nI(L2):  mag:   0.130213 phase:    116.326°  device_current\nI(I1):  mag:          3 phase:        -60°  device_current\nI(R9):  mag:   0.242382 phase:   -43.3777°  device_current\nI(R6):  mag:   0.146041 phase:    133.716°  device_current\nI(R4):  mag:    1.24841 phase:    130.842°  device_current\nI(R1):  mag:   0.242382 phase:   -43.3777°  device_current\nI(R3):  mag:   0.561096 phase:  0.0650338°  device_current\nI(R7):  mag:   0.130213 phase:   -63.6741°  device_current\nI(R11): mag:    27.8613 phase:    35.1207°  device_current\nI(R5):  mag:    3.48355 phase:    134.719°  device_current\nI(R10): mag:    3.75339 phase:    134.053°  device_current\nI(R8):  mag:   0.273089 phase:   -54.4772°  device_current\nI(R2):  mag:    1.36359 phase:   -33.9423°  device_current\nI(G1):  mag:    30.5828 phase:     15.818°  device_current\nI(V1):  mag:    3.48355 phase:   -45.2807°  device_current\nI(V2):  mag:   0.242382 phase:   -43.3777°  device_current\nStore the Python results in a dataframe.\n\nw2 = pd.DataFrame(U_w2.items(), columns=['unk', 'w=7Hz'])\nw2 = w2.set_index('unk')\nw2['w=7Hz'] = w2['w=7Hz'].astype(complex)\nsolutions['w=7Hz'] = w2['w=7Hz']\n#solutions\n\n\n24.5.1 Superposition solution\nUsing the principle of superposition, we can add the results obtained above to get the solution for the unknown node voltages and inductor and source currents.\n\nsolutions['w1+w2'] = solutions['w=3Hz'] + solutions['w=7Hz']\nsolutions['dc+w1+w2'] = solutions['w1+w2'] + solutions['w=DC']\nsolutions\n\n\n\n\n\n\n\n\n\nw=DC\nw=3Hz\nw=7Hz\nw1+w2\ndc+w1+w2\n\n\nunk\n\n\n\n\n\n\n\n\n\nv1\n-1444.606764\n0.892908-0.822746j\n-8.64425300+2.52654000j\n-7.75134500+1.70379400j\n-1452.3581009+1.7037940j\n\n\nv2\n701.805800\n3.920302+3.190643j\n-26.2616000+19.1734280j\n-22.3412980+22.3640710j\n679.4645010+22.3640710j\n\n\nv3\n626.530983\n1.677294-1.058215j\n-5.39864500+5.61067700j\n-3.72135100+4.55246200j\n622.8096302+4.5524620j\n\n\nv4\n564.749806\n2.142328+5.067639j\n-47.4808370+5.5629110j\n-45.3385090+10.6305500j\n519.4112970+10.6305500j\n\n\nv5\n-1444.606764\n6.998594-2.958208j\n199.049815+182.069001j\n206.048410+179.110793j\n-1238.558355+179.110793j\n\n\nv6\n-1439.606764\n-4.056839+4.127001j\n-8.64425300+2.52654000j\n-12.7010930+6.6535420j\n-1452.3078507+6.6535420j\n\n\nv7\n583.602732\n1.616746-1.138482j\n-5.04629800+5.27773900j\n-3.42955200+4.13925700j\n580.1731709+4.1392570j\n\n\nv8\n564.749806\n3.822070+2.546088j\n-11.5492460+23.3415940j\n-7.727175+025.8876810j\n557.0226300+25.8876810j\n\n\nv9\n-1449.580366\n-5.144528+1.003921j\n15.8672200-22.2262750j\n10.7226920-21.2223540j\n-1438.857674-21.222354j\n\n\nv10\n916.447056\n4.223041+3.591982j\n-28.0233350+20.8381170j\n-23.8002940+24.4300990j\n892.6467620+24.4300990j\n\n\nv11\n-1465.073530\n-5.304742+0.701652j\n18.4770390-24.9238190j\n13.1722970-24.2221670j\n-1451.901233-24.222167j\n\n\nv12\n916.447056\n4.223041+3.591982j\n-28.0233350+20.8381170j\n-23.8002940+24.4300990j\n892.6467620+24.4300990j\n\n\nv13\n-1465.073530\n2.735545+4.908599j\n-40.1718250+11.2688080j\n-37.4362800+16.1774060j\n-1502.509810+16.177406j\n\n\nv14\n-1465.073530\n6.975936-3.022991j\n199.866246+181.124557j\n206.842182+178.101566j\n-1258.231348+178.101566j\n\n\nI_V1\n-0.997360\n-0.108769-0.312308j\n2.45114700-2.47528100j\n2.34237800-2.78759000j\n1.34501800-2.78759000j\n\n\nI_V2\n-21.464126\n-0.030274-0.040134j\n0.17617300-0.16646900j\n0.14590000-0.20660300j\n-21.31822600-0.20660300j\n\n\nI_L3\n15.493164\n0.160214+0.302269j\n-2.60981900+2.69754400j\n-2.44960500+2.99981300j\n13.04355800+2.99981300j\n\n\nI_L1\n20.466765\n0.022658+0.064783j\n-0.81643100+0.94444400j\n-0.79377300+1.00922700j\n19.67299300+1.00922700j\n\n\nI_L4\n0.000000\n-0.288881-0.260561j\n3.20950100-4.05032500j\n2.92062100-4.31088500j\n2.92062100-4.31088500j\n\n\nI_L2\n2.823749\n0.019110+0.012730j\n-0.05774600+0.11670800j\n-0.03863600+0.12943800j\n2.78511300+0.12943800j\n\n\nI_H1\n-11.672055\n-0.032335+0.022770j\n0.10092600-0.10555500j\n0.06859100-0.08278500j\n-11.60346400-0.08278500j\n\n\n\n\n\n\n\n\nDisplay the superposition results in polar form.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in solutions['dc+w1+w2'].items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown            mag    phase, deg\n---------  -----------  ------------\nv1         1452.359109    179.932785\nv2          679.832450      1.885168\nv3          622.826270      0.418799\nv4          519.520071      1.172482\nv5         1251.442158    171.771369\nv6         1452.323098    179.737509\nv7          580.187945      0.408771\nv8          557.623872      2.660912\nv9         1439.014175   -179.154980\nv10         892.981003      1.567689\nv11        1452.103269   -179.044219\nv12         892.981003      1.567689\nv13        1502.596898    179.383125\nv14        1270.773895    171.943355\nI_V1          3.095114    -64.242586\nI_V2         21.319227   -179.444743\nI_L3         13.384069     12.951908\nI_L1         19.698863      2.936707\nI_L4          5.207087    -55.882399\nI_L2          2.788119      2.660912\nI_H1         11.603759   -179.591229",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#summary",
    "href": "Superposition.html#summary",
    "title": "24  Superposition",
    "section": "24.6 Summary",
    "text": "24.6 Summary\nIn this notebook a large non-planar circuit having independent sources with different DC values, different AC amplitudes, phases and frequencies was analyzed. The results were summed to obtain a total solution by applying the superposition thereom.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html",
    "href": "2nd_order_BRF.html",
    "title": "25  2nd Order BRF",
    "section": "",
    "text": "25.1 Introduction\nThis notebook walks through the Python code used to find the transfer function of the circuit shown in Figure 25.1.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#introduction",
    "href": "2nd_order_BRF.html#introduction",
    "title": "25  2nd Order BRF",
    "section": "",
    "text": "Figure 25.1: Band reject filter schematic",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#circuit-description",
    "href": "2nd_order_BRF.html#circuit-description",
    "title": "25  2nd Order BRF",
    "section": "25.2 Circuit description",
    "text": "25.2 Circuit description\nThe circuit above is a 2nd order band reject filter, problem 13-20 from Budak (1974). The schematic of the circuit is shown with each node annotated. The problem asks to obtain the transfer function, \\(\\frac {V_2} {V_1}\\).\nThe net list for this circuit is:\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#load-the-net-list",
    "href": "2nd_order_BRF.html#load-the-net-list",
    "title": "25  2nd Order BRF",
    "section": "25.3 Load the net list",
    "text": "25.3 Load the net list\n\nnet_list = '''\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\n'''",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "2nd_order_BRF.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "25  2nd Order BRF",
    "section": "25.4 Call the symbolic modified nodal analysis function",
    "text": "25.4 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\n\n25.4.1 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = - C_{1} s v_{4} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}}\\)\\(0 = I_{O1} + \\frac{v_{2}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\)\\(0 = v_{3} \\left(C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\)\\(0 = - C_{1} s v_{1} - C_{2} s v_{5} + v_{4} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\)\\(0 = - C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{2} - v_{5}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  R_{3}, \\  R_{1}, \\  C_{2}, \\  v_{1}, \\  v_{4}, \\  s, \\  v_{2}, \\  C_{3}, \\  I_{V1}, \\  V_{1}, \\  I_{O1}, \\  v_{5}, \\  v_{3}, \\  R_{2}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#symbolic-solution",
    "href": "2nd_order_BRF.html#symbolic-solution",
    "title": "25  2nd Order BRF",
    "section": "25.5 Symbolic solution",
    "text": "25.5 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(v_{3} = \\frac{C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(v_{4} = \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} C_{3} R_{1} R_{2} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(v_{5} = \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} R_{1} R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} V_{1} s^{3} - C_{1} C_{3} R_{1} V_{1} s^{2} - C_{1} C_{3} R_{2} V_{1} s^{2} - C_{2} C_{3} R_{1} V_{1} s^{2} - C_{3} V_{1} s}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(I_{O1} = \\frac{C_{1} C_{3} R_{2} V_{1} s^{2}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\n\n\nSymbolic form of the transfer function.\n\nH_sym = (U_sym[v2]/U_sym[v1]).simplify().collect(s)\nH_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} + C_{1} C_{2} R_{1} R_{3}\\right) + s \\left(C_{1} R_{1} + C_{2} R_{1}\\right) + 1}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} + C_{1} C_{2} R_{1} R_{3} + C_{1} C_{3} R_{1} R_{2} + C_{2} C_{3} R_{1} R_{2}\\right) + s \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) + 1}\\)\n\n\nThe numerator and denominator of the transfer function can be obtained as follows:\n\nnum, den = fraction(H_sym)\n\nThe roots of the numerator can be obtained symbolically. Since the degree of the polynominal is a third order, SymPy can solve for the roots and obtain a solution very quickly. The roots expressed in symbolic form are not very useful, but are easily obtained, something that would be almost impossible to do by hand with pencil and paper.\n\nz = solve(num,s)\nz[0]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}}{3} - \\frac{R_{2} + R_{3}}{3 C_{3} R_{2} R_{3}}\\)\n\n\n\nz[1]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}}{3} - \\frac{R_{2} + R_{3}}{3 C_{3} R_{2} R_{3}}\\)\n\n\n\nz[2]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}}{3} - \\frac{R_{2} + R_{3}}{3 C_{3} R_{2} R_{3}}\\)\n\n\nThe roots of the denominator can be obtained symbolically.\n\np = solve(den,s)\np[0]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}}{3} - \\frac{C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}}{3 C_{1} C_{2} C_{3} R_{2} R_{3}}\\)\n\n\n\np[1]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}}{3} - \\frac{C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}}{3 C_{1} C_{2} C_{3} R_{2} R_{3}}\\)\n\n\n\np[2]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}}{3} - \\frac{C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}}{3 C_{1} C_{2} C_{3} R_{2} R_{3}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#numerical-solution",
    "href": "2nd_order_BRF.html#numerical-solution",
    "title": "25  2nd Order BRF",
    "section": "25.6 Numerical solution",
    "text": "25.6 Numerical solution\nConstruct a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 1.0\nO1 = nan\nC3 = 2.0\nC1 = 1.0\nC2 = 1.0\nR1 = 0.5\nR2 = 1.0\nR3 = 1.0\n\n\nPut the component values into the equations.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} - 1.0 s v_{4} + v_{1} \\cdot \\left(1.0 s + 1.0\\right) - 1.0 v_{3}\\)\\(0 = I_{O1} + 2.0 v_{2} - 2.0 v_{4}\\)\\(0 = - 1.0 v_{1} + v_{3} \\cdot \\left(2.0 s + 2.0\\right) - 1.0 v_{5}\\)\\(0 = - 1.0 s v_{1} - 1.0 s v_{5} - 2.0 v_{2} + v_{4} \\cdot \\left(2.0 s + 2.0\\right)\\)\\(0 = - 1.0 s v_{4} - 1.0 v_{3} + v_{5} \\cdot \\left(1.0 s + 1.0\\right)\\)\\(1.0 = v_{1}\\)\\(0 = v_{2} - v_{5}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\)\\(v_{3} = \\frac{s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}\\)\\(v_{4} = \\frac{s^{3} + 2.0 s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}\\)\\(v_{5} = \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\)\\(I_{V1} = - \\frac{2.0 s}{s + 1.0}\\)\\(I_{O1} = \\frac{2.0 s^{2}}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}\\)\n\n\n\n25.6.1 Plot the frequency response of the transfer function\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(s^{2} + 1.0\\right)}{s^{2} + 2.0 s + 1.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 0, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('null: {:.2f} dB at {:.3f} Hz'.format(mag.min(),w[np.argmin(mag)]/(2*np.pi)))\n\nnull: -67.66 dB at 0.159 Hz\n\n\n\n\n25.6.2 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n25.6.2.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n0.00+0.16j Hz\n0.00-0.16j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-0.16+0.00j Hz\n-0.16-0.00j Hz\n\n\n\n\n\n25.6.3 Impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nBudak, A. 1974. Passive and Active Network Analysis and Synthesis. Houghton Mifflin.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html",
    "href": "Elliptic-function-LPF.html",
    "title": "26  Elliptic Function LPF",
    "section": "",
    "text": "26.1 Introduction\nThe circuit shown above is an elliptic function low pass filter. The design of elliptic filters is somewhat complex and usually involves the use of tables found in filter design handbooks. The symbolic solution of the network equations takes about 2 hours on my i3 laptop. A symbolic solution can be obtained in a few seconds by running this notebook in Google’s Colab, see Appendix C. Initially I was thinking that with a symbolic solution of the equations and the use of SciPy’s filter functions to obtain the pole and zero locations, I could derive the element values for active elliptic filters. But since the subject of this book is MNA and not filter design, only the analysis of the filter is described.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#circuit-description",
    "href": "Elliptic-function-LPF.html#circuit-description",
    "title": "26  Elliptic Function LPF",
    "section": "26.2 Circuit description",
    "text": "26.2 Circuit description\nThe circuit in Figure 26.1 has 13 branches and 7 nodes. There are 12 passive components and one OpAmp. The circuit is from Williams and Taylor (1995), example 3-26, and is an elliptic function low pass filter with a cutoff frequency of 100 Hz. The schematic for the filter was entered into LTSpice and an the following netlist was obtained.\nR3 3 0 4750\nR4 5 0 73.2k\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10k\nC1 3 1 0.05µ\nC2 5 3 0.05µ\nC3 7 4 0.1µ\nC4 5 0 0.22µ\nC5 2 0 0.18µ\nXU1 6 5 7 opamp Aol=100K GBW=10Meg\nV1 1 0 AC 1\nR6 7 6 44.2k\nR5 6 0 10k\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n26.2.1 Network equations\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to fix up the formating of the component values and the OpAmp declaration.\n\nexample_net_list = '''\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7 \nV1 1 0 1\nR6 7 6 44.2e3\nR5 6 0 10e3\n'''\n\nCallin smna() to generate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(example_net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nequ = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\\(- C_{3} s v_{4} + I_{O1} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} + v_{6} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time.\nTurn the free symbols into SymPy variables.\n\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  I_{O1}, \\  v_{6}, \\  C_{5}, \\  v_{4}, \\  v_{1}, \\  v_{2}, \\  I_{V1}, \\  v_{7}, \\  v_{5}, \\  R_{7}, \\  v_{3}, \\  R_{5}, \\  R_{2}, \\  C_{4}, \\  V_{1}, \\  R_{3}, \\  R_{1}, \\  C_{2}, \\  R_{6}, \\  s, \\  R_{4}, \\  C_{3}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 5.0 \\cdot 10^{-8}, \\  C_{2} : 5.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-7}, \\  C_{4} : 2.2 \\cdot 10^{-7}, \\  C_{5} : 1.8 \\cdot 10^{-7}, \\  O_{1} : \\text{NaN}, \\  R_{1} : 9530.0, \\  R_{2} : 9530.0, \\  R_{3} : 4750.0, \\  R_{4} : 73200.0, \\  R_{5} : 10000.0, \\  R_{6} : 44200.0, \\  R_{7} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#symbolic-solution",
    "href": "Elliptic-function-LPF.html#symbolic-solution",
    "title": "26  Elliptic Function LPF",
    "section": "26.3 Symbolic solution",
    "text": "26.3 Symbolic solution\nThe symbolic solution takes a long time, 2 hours, on my laptop (i3-8130U CPU @ 2.20GHz), so I commended the code. A symbolic solution can be obtained running this notebook in Google’s Colab, see Appendix C.\n\n#U_sym = solve(equ,X)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#numerical-solution",
    "href": "Elliptic-function-LPF.html#numerical-solution",
    "title": "26  Elliptic Function LPF",
    "section": "26.4 Numerical solution",
    "text": "26.4 Numerical solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ_N = equ.subs(element_values)\nequ_N\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 5.0 \\cdot 10^{-8} s v_{3} + v_{1} \\cdot \\left(5.0 \\cdot 10^{-8} s + 0.000104931794333683\\right) - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(1.8 \\cdot 10^{-7} s + 0.0001\\right) - 0.0001 v_{7}\\\\- 5.0 \\cdot 10^{-8} s v_{1} - 5.0 \\cdot 10^{-8} s v_{5} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000210526315789474\\right)\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000209863588667366\\right) - 0.000104931794333683 v_{5}\\\\- 5.0 \\cdot 10^{-8} s v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(2.7 \\cdot 10^{-7} s + 0.000118592996519475\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 1.0 \\cdot 10^{-7} s v_{4} - 0.0001 v_{2} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.00012262443438914\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nU = solve(equ_N,X)\n\n\n26.4.1 Find the network transfer function \\(\\frac {v_2(s)}{v_1(s)}\\)\n\nH = (U[v2]/U[v1]).cancel()\nH\n\n\\(\\displaystyle \\frac{7.66402714932125 \\cdot 10^{50} s^{3} + 1.60840024120068 \\cdot 10^{54} s^{2} + 3.37544646631832 \\cdot 10^{57} s + 7.10620308698594 \\cdot 10^{60}}{2.49434389140272 \\cdot 10^{48} s^{4} + 7.82471226796141 \\cdot 10^{51} s^{3} + 7.48699036699101 \\cdot 10^{54} s^{2} + 5.1465987346903 \\cdot 10^{57} s + 1.65249706814803 \\cdot 10^{60}}\\)\n\n\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n26.4.2 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n26.4.2.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-334.53+0.00j Hz\n0.26+334.27j Hz\n0.26-334.27j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-335.18+0.00j Hz\n-37.83+113.63j Hz\n-37.83-113.63j Hz\n-88.42+0.00j Hz",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-analysis",
    "href": "Elliptic-function-LPF.html#ac-analysis",
    "title": "26  Elliptic Function LPF",
    "section": "26.5 AC analysis",
    "text": "26.5 AC analysis\nSolve the network equations at a frequency of 100 Hz or \\(\\omega\\) equal to 628.318 radians per second, s = 628.318j.\nLoad numerical values into the network equations.\n\nfreq_Hz = 100 #Hz\nw = 2*np.pi*freq_Hz\n\nequ_Nw = equ.subs(element_values)\nequ_Nw = equ_Nw.subs({s:1j*w})\nequ_Nw  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.000104931794333683 + 3.14159265358979 \\cdot 10^{-5} i\\right) - 3.14159265358979 \\cdot 10^{-5} i v_{3} - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(0.0001 + 0.000113097335529233 i\\right) - 0.0001 v_{7}\\\\- 3.14159265358979 \\cdot 10^{-5} i v_{1} + v_{3} \\cdot \\left(0.000210526315789474 + 6.28318530717959 \\cdot 10^{-5} i\\right) - 3.14159265358979 \\cdot 10^{-5} i v_{5}\\\\- 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(0.000209863588667366 + 6.28318530717959 \\cdot 10^{-5} i\\right) - 0.000104931794333683 v_{5} - 6.28318530717959 \\cdot 10^{-5} i v_{7}\\\\- 3.14159265358979 \\cdot 10^{-5} i v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(0.000118592996519475 + 0.000169646003293849 i\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 0.0001 v_{2} - 6.28318530717959 \\cdot 10^{-5} i v_{4} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(0.00012262443438914 + 6.28318530717959 \\cdot 10^{-5} i\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the newtork equations and list the node voltages and unknown currents.\n\nU_Nw = solve(equ_Nw,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_Nw .items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         4.264586   -108.662048\nv3         0.271069     40.463593\nv4         2.401757     -6.456457\nv5         1.187844    -60.144973\nv6         1.187844    -60.144973\nv7         6.438113    -60.144973\nI_V1       0.000150    -20.838911\nI_O1       0.000875    166.380500",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-sweep",
    "href": "Elliptic-function-LPF.html#ac-sweep",
    "title": "26  Elliptic Function LPF",
    "section": "26.6 AC Sweep",
    "text": "26.6 AC Sweep\nPlot the magnitude and phase of the filter’s transfer function.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit 1\n\nx = np.logspace(1, 3, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Magnitude and phase plot')\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#summary",
    "href": "Elliptic-function-LPF.html#summary",
    "title": "26  Elliptic Function LPF",
    "section": "26.7 Summary",
    "text": "26.7 Summary\nAn elliptic filter was analyized and a symbolic solution of the network equations takes a long time. Numerical solutions using component values are easily obtained.\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html",
    "href": "Initial_conditions.html",
    "title": "27  Initial conditions",
    "section": "",
    "text": "27.1 Introduction\nA circuit with initial conditions consisting of a capacitor with an inital voltage and an inductor with initial current is analysed.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#circuit-description",
    "href": "Initial_conditions.html#circuit-description",
    "title": "27  Initial conditions",
    "section": "27.2 Circuit description",
    "text": "27.2 Circuit description\nThe circuit in Figure 27.1 has seven branches and four nodes. Capacitor, C1, has an initial voltage at t(0) and the inductor, L1, has an initial current at t(0). The voltage source V2 represents the initial voltage on the capacitor and current source, I1, represents the initial current flowing in the inductor. The circuit has a DC voltage source, V1. There a current controlled current source, F1, that is controlled by the current in V1.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#circuit-analysis",
    "href": "Initial_conditions.html#circuit-analysis",
    "title": "27  Initial conditions",
    "section": "27.3 Circuit analysis",
    "text": "27.3 Circuit analysis\nThe circuit was drawn using LTSpice and the netlist was pasted into the code. The Heaviside function is used to define the initial current and voltage on the inductor and capacitor. The Heaviside function is named after Oliver Heaviside, who made significant contributions to electrical engineering.\nThe following Python modules are used.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\n27.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nR2 3 2 5\nC1 3 4 1\nV2 4 0 1\nL1 1 2 3 \nI1 1 2 1\nF1 2 0 V1 2\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + I_{V1} = - I_{1}\\)\\(I_{F1} - I_{L1} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}} = I_{1}\\)\\(- C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C_{1} s v_{3} + C_{1} s v_{4} + I_{V2} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{4} = V_{2}\\)\\(- I_{L1} L_{1} s + v_{1} - v_{2} = 0\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1}\\\\I_{F1} - I_{L1} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}}\\\\- C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\\\- C_{1} s v_{3} + C_{1} s v_{4} + I_{V2}\\\\v_{1}\\\\v_{4}\\\\- I_{L1} L_{1} s + v_{1} - v_{2}\\\\I_{F1} - I_{V1} f_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1}\\\\I_{1}\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( f_{1}, \\  C_{1}, \\  L_{1}, \\  I_{V1}, \\  I_{L1}, \\  v_{2}, \\  R_{2}, \\  v_{4}, \\  V_{2}, \\  v_{1}, \\  V_{1}, \\  I_{F1}, \\  s, \\  I_{V2}, \\  v_{3}, \\  I_{1}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  I_{1} : 1.0, \\  L_{1} : 3.0, \\  R_{2} : 5.0, \\  V_{1} : 1.0, \\  V_{2} : 1.0, \\  f_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#initial-conditions",
    "href": "Initial_conditions.html#initial-conditions",
    "title": "27  Initial conditions",
    "section": "27.4 Initial conditions",
    "text": "27.4 Initial conditions\nThe SymPy Heaviside function is used to define the initial current and voltage on the inductor and capacitor.\n\nelement_values[V1] = laplace_transform(Heaviside(t), t, s)[0]\nelement_values[V2] = laplace_transform(-0.2*Heaviside(t), t, s)[0]\nelement_values[I1] = laplace_transform(0.1*Heaviside(t), t, s)[0]\nNE_ic = NE_sym.subs(element_values)\nNE_ic\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1}\\\\I_{F1} - I_{L1} + 0.2 v_{2} - 0.2 v_{3}\\\\- 1.0 s v_{4} - 0.2 v_{2} + v_{3} \\cdot \\left(1.0 s + 0.2\\right)\\\\I_{V2} - 1.0 s v_{3} + 1.0 s v_{4}\\\\v_{1}\\\\v_{4}\\\\- 3.0 I_{L1} s + v_{1} - v_{2}\\\\I_{F1} - 2.0 I_{V1}\\end{matrix}\\right] = \\left[\\begin{matrix}- \\frac{0.1}{s}\\\\\\frac{0.1}{s}\\\\0\\\\0\\\\\\frac{1}{s}\\\\- \\frac{0.2}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{13.0 s^{2} + 53.0 s + 10.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(v_{3} = \\frac{- 2.0 s^{2} - 7.0 s + 10.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(v_{4} = - \\frac{0.2}{s}\\)\\(I_{V1} = \\frac{- s - 4.0}{10.0 s^{2} + 50.0 s + 10.0}\\)\\(I_{V2} = \\frac{3.0 s + 12.0}{10.0 s^{2} + 50.0 s + 10.0}\\)\\(I_{L1} = \\frac{- s - 1.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(I_{F1} = \\frac{- s - 4.0}{5.0 s^{2} + 25.0 s + 5.0}\\)\n\n\nThe voltage on node 2 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\ntemp = U_ic[v2].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{13 s^{2} + 53 s + 10}{10 s \\left(s^{2} + 5 s + 1\\right)}\\)\n\n\n\nnode_2_voltage = inverse_laplace_transform(temp, s, t)\nnode_2_voltage\n\n\\(\\displaystyle \\left(\\frac{\\sqrt{21} \\cdot \\left(3 e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} + \\sqrt{21} e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} - 3 e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}} + \\sqrt{21} e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}}\\right)}{140} + e^{5 t}\\right) e^{- 5 t}\\)\n\n\n\nfunc_node_2_voltage = lambdify(t, node_2_voltage) \n\nThe voltage on node 3 is obtained in a sumular way.\n\ntemp = U_ic[v3].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{- 2 s^{2} - 7 s + 10}{10 s \\left(s^{2} + 5 s + 1\\right)}\\)\n\n\n\nnode_3_voltage = inverse_laplace_transform(temp, s, t)\nnode_3_voltage\n\n\\(\\displaystyle \\left(\\frac{\\sqrt{21} \\left(- 2 \\sqrt{21} e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} + 9 e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} - 2 \\sqrt{21} e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}} - 9 e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}}\\right)}{70} + e^{5 t}\\right) e^{- 5 t}\\)\n\n\n\nfunc_node_3_voltage = lambdify(t, node_3_voltage) \n\nThe plot below shows the node voltages versus time.\n\nx = np.linspace(0, 10, 2000, endpoint=True)\n\nplt.title('Node voltages vs time')\n\nplt.plot(x, func_node_2_voltage(x),label='v2(t)')\nplt.plot(x, func_node_3_voltage(x),label='v3(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#summary",
    "href": "Initial_conditions.html#summary",
    "title": "27  Initial conditions",
    "section": "27.5 Summary",
    "text": "27.5 Summary\nIn this notebook, newtork equations were solved which had initial conditions, which were included in the network equations with their Laplace equilivents.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Initial conditions</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html",
    "href": "Transient_circuit.html",
    "title": "28  Transient circuit",
    "section": "",
    "text": "28.1 Introduction\nThe circuit above is a filter designed to explore transient analysis of a circuit using Python. The dependent source, V1, will be a time varying signal described below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#circuit-description",
    "href": "Transient_circuit.html#circuit-description",
    "title": "28  Transient circuit",
    "section": "28.2 Circuit description",
    "text": "28.2 Circuit description\nThe circuit in Figure 28.1 is an elliptic low pass filter with a 1 Hz cut off and 3 dB of ripple in the pass band and 40 dB of attenuation in the stop band. Three dB of ripple in the pass band was designed in so that the transient response would have some ringing. The filter design tool linked here was used to design the filter.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#circuit-analysis",
    "href": "Transient_circuit.html#circuit-analysis",
    "title": "28  Transient circuit",
    "section": "28.3 Circuit analysis",
    "text": "28.3 Circuit analysis\nThe circuit analysis follows the steps listed below.\n\nDraw circuit in LTSpice, export netlist\nGenerate network equations\nSymbolic solution\nAC sweep and plot the frequency response at the output\nTransient analysis\n\nGenerate input signal for transient analysis\nMostly following the procedure outlined here\ndisplay the results\n\n\nTransient analysis is somewhat more involved than the other types of circuit analysis, primarily because SymPy’s inverse Laplace transform is not very robust and can’t handle complicated expressions. The output equation needs to be simplified by writing some code to put the equation into forms that SymPy can deal with.\nLoad the following Python modules.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n28.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent source, V1, is set to a value of one.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1\nR2 2 0 1\nL1 3 4 0.4925\nL2 5 0 0.05081\nC2 4 5 0.09876\nL3 4 2 0.4925\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L3} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(C_{2} s v_{4} - C_{2} s v_{5} - I_{L1} + I_{L3} = 0\\)\\(- C_{2} s v_{4} + C_{2} s v_{5} + I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{3} - v_{4} = 0\\)\\(- I_{L2} L_{2} s + v_{5} = 0\\)\\(- I_{L3} L_{3} s - v_{2} + v_{4} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand. The equations are displade in matrix notation below.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\\\- I_{L3} + \\frac{v_{2}}{R_{2}}\\\\I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}}\\\\C_{2} s v_{4} - C_{2} s v_{5} - I_{L1} + I_{L3}\\\\- C_{2} s v_{4} + C_{2} s v_{5} + I_{L2}\\\\v_{1}\\\\- I_{L1} L_{1} s + v_{3} - v_{4}\\\\- I_{L2} L_{2} s + v_{5}\\\\- I_{L3} L_{3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{5}, \\  I_{V1}, \\  L_{2}, \\  I_{L3}, \\  v_{2}, \\  L_{1}, \\  v_{1}, \\  I_{L1}, \\  s, \\  I_{L2}, \\  R_{1}, \\  v_{4}, \\  C_{2}, \\  v_{3}, \\  R_{2}, \\  L_{3}, \\  V_{1}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{2} : 0.09876, \\  L_{1} : 0.4925, \\  L_{2} : 0.05081, \\  L_{3} : 0.4925, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#symbolic-solution",
    "href": "Transient_circuit.html#symbolic-solution",
    "title": "28  Transient circuit",
    "section": "28.4 Symbolic solution",
    "text": "28.4 Symbolic solution\nSince the circuit is not too large, a symbolic solution can be easily obtained.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} L_{2} R_{2} V_{1} s^{2} + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C_{2} L_{1} L_{2} V_{1} s^{3} + C_{2} L_{1} L_{3} V_{1} s^{3} + C_{2} L_{1} R_{2} V_{1} s^{2} + C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2} + L_{1} V_{1} s + L_{3} V_{1} s + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{4} = \\frac{C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2} + L_{3} V_{1} s + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{5} = \\frac{C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C_{2} L_{2} V_{1} s^{2} - C_{2} L_{3} V_{1} s^{2} - C_{2} R_{2} V_{1} s - V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{C_{2} L_{2} V_{1} s^{2} + C_{2} L_{3} V_{1} s^{2} + C_{2} R_{2} V_{1} s + V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L2} = \\frac{C_{2} L_{3} V_{1} s^{2} + C_{2} R_{2} V_{1} s}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L3} = \\frac{C_{2} L_{2} V_{1} s^{2} + V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\n\n\n\n28.4.1 AC Sweep\nAfter substituting the numeric component values for the elements, a numerical solution for the note voltages can be obtained.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\\\- I_{L3} + 1.0 v_{2}\\\\I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\\\- I_{L1} + I_{L3} + 0.09876 s v_{4} - 0.09876 s v_{5}\\\\I_{L2} - 0.09876 s v_{4} + 0.09876 s v_{5}\\\\v_{1}\\\\- 0.4925 I_{L1} s + v_{3} - v_{4}\\\\- 0.05081 I_{L2} s + v_{5}\\\\- 0.4925 I_{L3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n28.4.2 Plot the frequency response at node 2\n\nH = U_ac[v2]\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\nx = np.logspace(-1, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n28.4.3 Low pass filter impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(system,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(system,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe results obtained from SciPy’s step2 function can be compared to the transient response results obtained below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#transient-analysis",
    "href": "Transient_circuit.html#transient-analysis",
    "title": "28  Transient circuit",
    "section": "28.5 Transient Analysis",
    "text": "28.5 Transient Analysis\nThe input signal for the filter circuit is defined by using SymPy’s Heaveside function. The signal has a positive step at t=0, followed by a return to zero amplitude at t=5.\nDeclare SymPy symbols needed during the analysis.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nV1_t = 1*Heaviside(t)*(1-Heaviside(t-5))\nV1_t\n\n\\(\\displaystyle 1 - \\theta\\left(t - 5\\right)\\)\n\n\nUse the lambdify function to convert the input signal to a function for plotting.\n\nfunc_V1_t = lambdify(t, V1_t) \n\nThe time domain description of the input signal is comvertered to the frequency domain with SymPy’s Laplace transform function.\n\nV1_s = laplace_transform(V1_t, t, s, noconds=True)\nV1_s\n\n\\(\\displaystyle \\frac{1}{s} - \\frac{e^{- 5 s}}{s}\\)\n\n\nPut the component values into the network equations and set V1 equal to the Laplace of the input signal.\n\nelement_values[V1] = V1_s\nNE_trans = NE_sym.subs(element_values)\nNE_trans\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\\\- I_{L3} + 1.0 v_{2}\\\\I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\\\- I_{L1} + I_{L3} + 0.09876 s v_{4} - 0.09876 s v_{5}\\\\I_{L2} - 0.09876 s v_{4} + 0.09876 s v_{5}\\\\v_{1}\\\\- 0.4925 I_{L1} s + v_{3} - v_{4}\\\\- 0.05081 I_{L2} s + v_{5}\\\\- 0.4925 I_{L3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s} - \\frac{e^{- 5 s}}{s}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the newtork equations for the transient input and display the results.\n\nU_trans = solve(NE_trans,X)\n\ntemp = ''\nfor i in U_trans.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_trans[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s} - \\frac{e^{- 5.0 s}}{s}\\)\\(v_{2} = \\frac{1254498900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{1254498900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(v_{3} = \\frac{7224395229.0 s^{3} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{7224395229.0 s^{3}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{246250000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{246250000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(v_{4} = \\frac{12544989.0 s^{2} e^{5.0 s}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} - \\frac{12544989.0 s^{2}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} + \\frac{2500000000.0 e^{5.0 s}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} - \\frac{2500000000.0}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}}\\)\\(v_{5} = \\frac{12544989.0 s e^{5.0 s}}{146688228.0 s^{2} e^{5.0 s} + 246900000.0 s e^{5.0 s} + 5000000000.0 e^{5.0 s}} - \\frac{12544989.0 s}{146688228.0 s^{2} e^{5.0 s} + 246900000.0 s e^{5.0 s} + 5000000000.0 e^{5.0 s}}\\)\\(I_{V1} = - \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{24690000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{24690000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(I_{L1} = \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{24690000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{24690000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(I_{L2} = \\frac{61725000.0 e^{5.0 s}}{36672057.0 s^{2} e^{5.0 s} + 61725000.0 s e^{5.0 s} + 1250000000.0 e^{5.0 s}} - \\frac{61725000.0}{36672057.0 s^{2} e^{5.0 s} + 61725000.0 s e^{5.0 s} + 1250000000.0 e^{5.0 s}}\\)\\(I_{L3} = \\frac{1254498900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{1254498900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\n\n\nThe equations for the solution are complex and long, but are easy to obtain and display.\nThe voltage on node 2 is the output of the filter. The expression is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together().\n\nH = U_trans[v2].nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{100 \\cdot \\left(12544989 s^{2} e^{5 s} - 12544989 s^{2} + 2500000000 e^{5 s} - 2500000000\\right) e^{- 5 s}}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}\\)\n\n\nAll the time dealy terms are in the numerator.\nExtract the numerator and denominator and display.\n\nn, d = fraction(H)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle 1254498900 s^{2} e^{5 s} - 1254498900 s^{2} + 250000000000 e^{5 s} - 250000000000\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right) e^{5 s}\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ - \\frac{250000000000 e^{- 5 s}}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}, \\  - \\frac{1254498900 s e^{- 5 s}}{7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000}, \\  \\frac{250000000000}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}, \\  \\frac{1254498900 s}{7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nThe time delay operator \\(e^{-ts}\\) is removed from the xpression and the value of the time delay is saved in a list.\nuse the SciPy residue function to get the partial-fraction expansion residues and poles\nbuild the partial expansion terms and find the inverse Laplace of each one and save\n\n\ntime_delay = []\ndelay = []\nN = []\n\nfor i in terms:\n    # look for and remove the time delay\n    if len(i.find(exp)) == 1:\n        delay = i.find(exp).pop()\n        time_delay.append(list(delay.atoms())[0])\n        ans = i/i.find(exp).pop()\n    else:\n        ans = i\n        time_delay.append(0)\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(ans)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n    \n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i])) #.nsimplify()\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nThe time delays associated with each term are:\n\ntime_delay\n\n\\(\\displaystyle \\left[ -5, \\  -5, \\  0, \\  0\\right]\\)\n\n\nThe time domain version of each of the terms is displayed below.\n\nN\n\n\\(\\displaystyle \\left[ 1.0 \\left(\\left(0.0868202525095611 - 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(\\left(0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561563 - 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} - 0.5 + 0.489865675268769 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(-0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} - \\left(0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(- \\left(0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(-0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 0.0101343247312312 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(-0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} - \\left(0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(- \\left(0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(-0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 0.5 - 0.489865675268769 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(0.0139856047826648 - 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(\\left(0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561562 - 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} - 0.0101343247312312 e^{- 2.03045685279188 t}\\right]\\)\n\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\n\nout0 = lambdify(t, N[0])\nout1 = lambdify(t, N[1])\nout2 = lambdify(t, N[2])\nout3 = lambdify(t, N[3])\n\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 10, 2000, endpoint=True)\n\nout0a = out0(x)\nout1a = out1(x)\nout2a = out2(x)\nout3a = out3(x)\n\nThe arrays, out2a and out3a, do not have any delay so they can be summed and used to create the final array for plotting.\n\nout = out2a + out3a\n\nThe arrays, out0a and out1a, have a delay associated with them, so and offset in the time is included by shifting right by the corrrect amount.\n\noffset = 1000\nout[offset:] = out[offset:] + (out0a[0:-offset] + out1a[0:-offset])\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(out),label='v2(t)')\nplt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Transient_circuit.html#summary",
    "href": "Transient_circuit.html#summary",
    "title": "28  Transient circuit",
    "section": "28.6 Summary",
    "text": "28.6 Summary\nThe inverse Laplace transform of complicated expressions requires that they be reduced to a set of simple terms by particial fraction expansion. I’ve not yet figured a way to easily code the delay terms, so these are handled manually by a offset shift in the finaly plot output.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Transient circuit</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html",
    "href": "Bridge-T.html",
    "title": "29  Bridge-T",
    "section": "",
    "text": "29.1 Introduction\nA question posted on electronics stackexchange by Lees (2023) asked:\nFigure 29.1 shows that the independent source V1 is connected to ground by the series connection of C1, C2 and C3. Lees (2023) asked if the initial voltage on the capacitors, C1, C2 and C3 could violate Kirchhoff’s circuit laws by leading to a situation where the initial voltage on the capacitors do not sum to a value equal to V1. For example, if V1 is equal to 1 volt and the initial voltage on the capacitors are each equal to one volt, the sum of the three initial voltages on the capacitors would be 3 volts and not sum to zero around the loop. Lees (2023) provided some analysis in his question and discussed the voltage across C3 and stated that he needed to add a small series resistor to V1.\nThere were four answers provided by the comunity. The answer provided by Franc (2023) is long and detailed and in part 3 of his answer he adress the non zero initial condition and the transfer function at node 2.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#introduction",
    "href": "Bridge-T.html#introduction",
    "title": "29  Bridge-T",
    "section": "",
    "text": "I’m trying to figure out how to formulate and solve some differential equations for this circuit. … I run into an issue with the voltage/capacitor loop comprising Vin VC1 VC2 VC3 as I cannot arbitrarily assign an initial value to the voltage across C3.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#circuit-description",
    "href": "Bridge-T.html#circuit-description",
    "title": "29  Bridge-T",
    "section": "29.2 Circuit description",
    "text": "29.2 Circuit description\nThe circuit shown in Figure 29.1 has six branches and three nodes. The circuit has a three capacitor path from the independent source, V1 to ground. The circuit posted by Lees (2023) didn’t have any values for the components, so I’m going use values that are all set to one. The initial voltages on the capacitor can be set to any abritrairy value or left defaulted to zero volts. As described below, the circuit needs to be modified for the MNA.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#circuit-analysis",
    "href": "Bridge-T.html#circuit-analysis",
    "title": "29  Bridge-T",
    "section": "29.3 Circuit analysis",
    "text": "29.3 Circuit analysis\nLees (2023) asked for differential equations, but since this analysis is about using MNA, a frequency domain analysis will be presented. So I’m not going to derive the differential equations for the circuit.\n\ntransfer function at nodes 2 and 3\nSolve the equations for initial conditions\ncompare to LTSpice results\n\nVoltage sources, V2, v3 and V4 were added to the circuit shown in Figure 29.2 so that these sources can hold the capacitor’s initial voltage value at time equal to 0+. Frequency domain equivilent of C with an initial voltage condition is a series voltage source v(0+)/s\n\n\n\n\n\n\nFigure 29.2: Circuit used for MNA\n\n\n\nThe net list for the circuit is:\nV1 1 0 1\nC2 4 1 1\nC3 5 2 1\nC1 6 2 1\nL1 1 2 1\nR1 3 0 1\nV2 4 3 1\nV3 6 0 1\nV4 3 5 1\nThe following Python modules are used.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\n29.3.1 Load the netlist\nThe netlist for Figure 29.1 is pasted into the cell below and some edits were made to remove the inductor series resistance.\n\nnet_list = '''\nV1 1 0 1\nC2 3 1 1\nC3 3 2 1\nC1 0 2 1\nL 1 2 1\nR2 3 0 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{2} s v_{1} - C_{2} s v_{3} + I_{L} + I_{V1} = 0\\)\\(- C_{3} s v_{3} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{1} - C_{3} s v_{2} + v_{3} \\left(C_{2} s + C_{3} s + \\frac{1}{R_{2}}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L} L s + v_{1} - v_{2} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{2} s v_{1} - C_{2} s v_{3} + I_{L} + I_{V1}\\\\- C_{3} s v_{3} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right)\\\\- C_{2} s v_{1} - C_{3} s v_{2} + v_{3} \\left(C_{2} s + C_{3} s + \\frac{1}{R_{2}}\\right)\\\\v_{1}\\\\- I_{L} L s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  s, \\  C_{3}, \\  R_{2}, \\  C_{1}, \\  C_{2}, \\  L, \\  I_{L}, \\  v_{1}, \\  I_{V1}, \\  V_{1}, \\  v_{3}\\right)\\)\n\n\n\n\n29.3.2 Transfer function\nSolving for the transfer function at node 2. Transfer functions are normally presented in the frequency domain and are steady state responses.\n\nU_sym = solve(NE_sym,X)\n\nH2_sym = U_sym[v2]/U_sym[v1]\nH2_sym\n\n\\(\\displaystyle \\frac{C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{2} R_{2} V_{1} s + C_{3} R_{2} V_{1} s + V_{1}}{V_{1} \\left(C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1\\right)}\\)\n\n\nCollecting the s terms:\n\ncancel(H2_sym,s)\n\n\\(\\displaystyle \\frac{C_{2} C_{3} L R_{2} s^{3} + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right) + 1}{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{1} C_{3} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right) + 1}\\)\n\n\nMy transfer function equation does not agree with the answer provided by Franc (2023).\nSolving for the transfer function at node 3.\n\nH3_sym = U_sym[v3]/U_sym[v1]\nH3_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{2} L R_{2} V_{1} s^{3} + C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{2} R_{2} V_{1} s + C_{3} R_{2} V_{1} s}{V_{1} \\left(C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1\\right)}\\)\n\n\nCollecting the s terms:\n\ncancel(H3_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right)}{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{1} C_{3} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right) + 1}\\)\n\n\nMy answer for the node 3 transfer function does not agree with the 1st answer’s node 3 transfer function. SE answer: numerator\n\ns*((C3+C2)*R2+(C1+C3)*L*R2*C2*s**2)\n\n\\(\\displaystyle s \\left(C_{2} L R_{2} s^{2} \\left(C_{1} + C_{3}\\right) + R_{2} \\left(C_{2} + C_{3}\\right)\\right)\\)\n\n\n\ncancel(s*((C3+C2)*R2+(C1+C3)*L*R2*C2*s**2),s)\n\n\\(\\displaystyle s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right)\\)\n\n\nnumerator agrees\ndenominator\n\n(1+(C1+C3)*L*s**2)*(1+R2*C2*s)\n\n\\(\\displaystyle \\left(C_{2} R_{2} s + 1\\right) \\left(L s^{2} \\left(C_{1} + C_{3}\\right) + 1\\right)\\)\n\n\n\ncancel((1+(C1+C3)*L*s**2)*(1+R2*C2*s),s)\n\n\\(\\displaystyle C_{2} R_{2} s + s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + 1\\)\n\n\nDenominator does not agree\n\nSE1 = (s*((C3+C2)*R2+(C1+C3)*L*R2*C2*s**2))/((1+(C1+C3)*L*s**2)*(1+R2*C2*s))\nSE1\n\n\\(\\displaystyle \\frac{s \\left(C_{2} L R_{2} s^{2} \\left(C_{1} + C_{3}\\right) + R_{2} \\left(C_{2} + C_{3}\\right)\\right)}{\\left(C_{2} R_{2} s + 1\\right) \\left(L s^{2} \\left(C_{1} + C_{3}\\right) + 1\\right)}\\)\n\n\n\ncancel(SE1,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right)}{C_{2} R_{2} s + s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + 1}\\)\n\n\n\n\n29.3.3 Include the initial conditions\nSet initial conditions for C1, C2 and C3 by including independent voltage sources, V2, V3 and V4, and appling SymPy Heaveside function. The independent voltage source, V1 is a also a step function. Since V2, V3 and V4 are in series with capacitors, the steady state value of these sources is blocked and only the transient response is present. The netlist for Figure 29.2 is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nC2 4 1 1\nC3 5 2 1\nC1 6 2 1\nL 1 2 1\nR2 3 0 1\nV2 4 3 1\nV3 6 0 1\nV4 3 5 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_ic_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{2} s v_{1} - C_{2} s v_{4} + I_{L} + I_{V1} = 0\\)\\(- C_{1} s v_{6} - C_{3} s v_{5} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right) = 0\\)\\(- I_{V2} + I_{V4} + \\frac{v_{3}}{R_{2}} = 0\\)\\(- C_{2} s v_{1} + C_{2} s v_{4} + I_{V2} = 0\\)\\(- C_{3} s v_{2} + C_{3} s v_{5} - I_{V4} = 0\\)\\(- C_{1} s v_{2} + C_{1} s v_{6} + I_{V3} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} + v_{4} = V_{2}\\)\\(v_{6} = V_{3}\\)\\(v_{3} - v_{5} = V_{4}\\)\\(- I_{L} L s + v_{1} - v_{2} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_ic_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{2} s v_{1} - C_{2} s v_{4} + I_{L} + I_{V1}\\\\- C_{1} s v_{6} - C_{3} s v_{5} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right)\\\\- I_{V2} + I_{V4} + \\frac{v_{3}}{R_{2}}\\\\- C_{2} s v_{1} + C_{2} s v_{4} + I_{V2}\\\\- C_{3} s v_{2} + C_{3} s v_{5} - I_{V4}\\\\- C_{1} s v_{2} + C_{1} s v_{6} + I_{V3}\\\\v_{1}\\\\- v_{3} + v_{4}\\\\v_{6}\\\\v_{3} - v_{5}\\\\- I_{L} L s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\V_{3}\\\\V_{4}\\\\0\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_ic_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  C_{3}, \\  R_{2}, \\  v_{5}, \\  v_{6}, \\  C_{2}, \\  v_{1}, \\  I_{V1}, \\  V_{4}, \\  V_{1}, \\  V_{3}, \\  I_{V2}, \\  s, \\  C_{1}, \\  L, \\  I_{L}, \\  v_{4}, \\  I_{V3}, \\  V_{2}, \\  I_{V4}, \\  v_{3}\\right)\\)\n\n\nThe SymPy Heaviside function is used to define the initial current and voltage on the inductor and capacitor. The equivalent circuit in s domain has a capacitor C with impedance 1/(sC) and a voltage source v(0)/s in series.\n\nNE_ic_sym = NE_ic_sym.subs({V1:laplace_transform(V1*Heaviside(t), t, s)[0], V2:laplace_transform(V2*Heaviside(t), t, s)[0], V3:laplace_transform(V3*Heaviside(t), t, s)[0], V4:laplace_transform(V4*Heaviside(t), t, s)[0]})\nNE_ic_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{2} s v_{1} - C_{2} s v_{4} + I_{L} + I_{V1}\\\\- C_{1} s v_{6} - C_{3} s v_{5} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right)\\\\- I_{V2} + I_{V4} + \\frac{v_{3}}{R_{2}}\\\\- C_{2} s v_{1} + C_{2} s v_{4} + I_{V2}\\\\- C_{3} s v_{2} + C_{3} s v_{5} - I_{V4}\\\\- C_{1} s v_{2} + C_{1} s v_{6} + I_{V3}\\\\v_{1}\\\\- v_{3} + v_{4}\\\\v_{6}\\\\v_{3} - v_{5}\\\\- I_{L} L s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{V_{1}}{s}\\\\\\frac{V_{2}}{s}\\\\\\frac{V_{3}}{s}\\\\\\frac{V_{4}}{s}\\\\0\\end{matrix}\\right]\\)\n\n\nGenerate and display the symbolic solution.\n\nU_ic_sym = solve(NE_ic_sym,X)\n\ntemp = ''\nfor i in U_ic_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{V_{1}}{s}\\)\\(v_{2} = \\frac{C_{1} C_{2} L R_{2} V_{3} s^{3} + C_{1} C_{3} L R_{2} V_{3} s^{3} + C_{1} L V_{3} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{2} R_{2} V_{1} s - C_{3} L V_{4} s^{2} + C_{3} R_{2} V_{1} s + V_{1}}{C_{1} C_{2} L R_{2} s^{4} + C_{1} C_{3} L R_{2} s^{4} + C_{1} L s^{3} + C_{2} C_{3} L R_{2} s^{4} + C_{2} R_{2} s^{2} + C_{3} L s^{3} + C_{3} R_{2} s^{2} + s}\\)\\(v_{3} = \\frac{C_{1} C_{2} L R_{2} V_{1} s^{2} - C_{1} C_{2} L R_{2} V_{2} s^{2} + C_{1} C_{3} L R_{2} V_{3} s^{2} + C_{1} C_{3} L R_{2} V_{4} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{2} - C_{2} C_{3} L R_{2} V_{2} s^{2} + C_{2} R_{2} V_{1} - C_{2} R_{2} V_{2} + C_{3} R_{2} V_{1} + C_{3} R_{2} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(v_{4} = \\frac{C_{1} C_{2} L R_{2} V_{1} s^{3} + C_{1} C_{3} L R_{2} V_{2} s^{3} + C_{1} C_{3} L R_{2} V_{3} s^{3} + C_{1} C_{3} L R_{2} V_{4} s^{3} + C_{1} L V_{2} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{2} R_{2} V_{1} s + C_{3} L V_{2} s^{2} + C_{3} R_{2} V_{1} s + C_{3} R_{2} V_{2} s + C_{3} R_{2} V_{4} s + V_{2}}{C_{1} C_{2} L R_{2} s^{4} + C_{1} C_{3} L R_{2} s^{4} + C_{1} L s^{3} + C_{2} C_{3} L R_{2} s^{4} + C_{2} R_{2} s^{2} + C_{3} L s^{3} + C_{3} R_{2} s^{2} + s}\\)\\(v_{5} = \\frac{C_{1} C_{2} L R_{2} V_{1} s^{3} - C_{1} C_{2} L R_{2} V_{2} s^{3} - C_{1} C_{2} L R_{2} V_{4} s^{3} + C_{1} C_{3} L R_{2} V_{3} s^{3} - C_{1} L V_{4} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{2} R_{2} V_{1} s - C_{2} R_{2} V_{2} s - C_{2} R_{2} V_{4} s - C_{3} L V_{4} s^{2} + C_{3} R_{2} V_{1} s - V_{4}}{C_{1} C_{2} L R_{2} s^{4} + C_{1} C_{3} L R_{2} s^{4} + C_{1} L s^{3} + C_{2} C_{3} L R_{2} s^{4} + C_{2} R_{2} s^{2} + C_{3} L s^{3} + C_{3} R_{2} s^{2} + s}\\)\\(v_{6} = \\frac{V_{3}}{s}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} + C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} + C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} - C_{1} C_{2} L V_{1} s^{2} + C_{1} C_{2} L V_{2} s^{2} - C_{1} C_{2} R_{2} V_{1} s + C_{1} C_{2} R_{2} V_{3} s - C_{1} C_{3} R_{2} V_{1} s + C_{1} C_{3} R_{2} V_{3} s - C_{1} V_{1} + C_{1} V_{3} - C_{2} C_{3} L V_{1} s^{2} + C_{2} C_{3} L V_{2} s^{2} - C_{2} V_{1} + C_{2} V_{2} - C_{3} V_{1} - C_{3} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{V2} = \\frac{C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{1} C_{2} L V_{1} s^{2} - C_{1} C_{2} L V_{2} s^{2} + C_{2} C_{3} L V_{1} s^{2} - C_{2} C_{3} L V_{2} s^{2} - C_{2} C_{3} R_{2} V_{2} s - C_{2} C_{3} R_{2} V_{4} s + C_{2} V_{1} - C_{2} V_{2}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{V3} = \\frac{C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{1} C_{2} R_{2} V_{1} s - C_{1} C_{2} R_{2} V_{3} s - C_{1} C_{3} L V_{3} s^{2} - C_{1} C_{3} L V_{4} s^{2} + C_{1} C_{3} R_{2} V_{1} s - C_{1} C_{3} R_{2} V_{3} s + C_{1} V_{1} - C_{1} V_{3}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{V4} = \\frac{C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} - C_{1} C_{3} L V_{3} s^{2} - C_{1} C_{3} L V_{4} s^{2} - C_{2} C_{3} R_{2} V_{2} s - C_{2} C_{3} R_{2} V_{4} s - C_{3} V_{1} - C_{3} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{L} = \\frac{C_{1} C_{2} R_{2} V_{1} s - C_{1} C_{2} R_{2} V_{3} s + C_{1} C_{3} R_{2} V_{1} s - C_{1} C_{3} R_{2} V_{3} s + C_{1} V_{1} - C_{1} V_{3} + C_{2} C_{3} R_{2} V_{2} s + C_{2} C_{3} R_{2} V_{4} s + C_{3} V_{1} + C_{3} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\n\n\nNetwork equations and solution in symbolic form are seaily obtained. These equations are in the frequency domain and if transformed back to the time domain, they would be differential equations. But not necessarily in the form of state equations. In this case the equations are a little too long to provide any insight into the operation of the circuit.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#initial-conditions-with-component-values",
    "href": "Bridge-T.html#initial-conditions-with-component-values",
    "title": "29  Bridge-T",
    "section": "29.4 Initial conditions with component values",
    "text": "29.4 Initial conditions with component values\nGet element values from network dataframe. As describe above, the orginal question didn’t have values associated with the components, so I’m using a value of one for all the values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  C_{3} : 1.0, \\  L : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0, \\  V_{2} : 1.0, \\  V_{3} : 1.0, \\  V_{4} : 1.0\\right\\}\\)\n\n\n\nNE_ic = NE_ic_sym.subs(element_values)\nNE_ic\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L} + I_{V1} + 1.0 s v_{1} - 1.0 s v_{4}\\\\- I_{L} + 2.0 s v_{2} - 1.0 s v_{5} - 1.0 s v_{6}\\\\- I_{V2} + I_{V4} + 1.0 v_{3}\\\\I_{V2} - 1.0 s v_{1} + 1.0 s v_{4}\\\\- I_{V4} - 1.0 s v_{2} + 1.0 s v_{5}\\\\I_{V3} - 1.0 s v_{2} + 1.0 s v_{6}\\\\v_{1}\\\\- v_{3} + v_{4}\\\\v_{6}\\\\v_{3} - v_{5}\\\\- 1.0 I_{L} s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1.0}{s}\\\\\\frac{1.0}{s}\\\\\\frac{1.0}{s}\\\\\\frac{1.0}{s}\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{s^{3} + 2.0 s + 1.0}{3.0 s^{4} + 2.0 s^{3} + 2.0 s^{2} + s}\\)\\(v_{3} = \\frac{2.0 s^{2} + 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(v_{4} = \\frac{5.0 s^{3} + 2.0 s^{2} + 4.0 s + 1.0}{3.0 s^{4} + 2.0 s^{3} + 2.0 s^{2} + s}\\)\\(v_{5} = \\frac{- s^{3} - 2.0 s^{2} - 1.0}{3.0 s^{4} + 2.0 s^{3} + 2.0 s^{2} + s}\\)\\(v_{6} = \\frac{1}{s}\\)\\(I_{V1} = \\frac{2.0 s^{3} - 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{V2} = \\frac{- 2.0 s^{3} - 2.0 s}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{V3} = \\frac{- 2.0 s^{3} - 2.0 s^{2}}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{V4} = \\frac{- 2.0 s^{3} - 2.0 s^{2} - 2.0 s - 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{L} = \\frac{2.0 s + 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#node-2-voltage",
    "href": "Bridge-T.html#node-2-voltage",
    "title": "29  Bridge-T",
    "section": "29.5 Node 2 voltage",
    "text": "29.5 Node 2 voltage\n\nnode2 = U_ic[v2].nsimplify().simplify().expand().together()\nnode2\n\n\\(\\displaystyle \\frac{s^{3} + 2 s + 1}{s \\left(3 s^{3} + 2 s^{2} + 2 s + 1\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_2_voltage = inverse_laplace_transform(temp, s, t)\n#node_2_voltage\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(node2)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(s^{3} + 2 s + 1\\)denominator: \\(s \\left(3 s^{3} + 2 s^{2} + 2 s + 1\\right)\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{1}{s \\left(3 s^{3} + 2 s^{2} + 2 s + 1\\right)}, \\  \\frac{s^{2}}{3 s^{3} + 2 s^{2} + 2 s + 1}, \\  \\frac{2}{3 s^{3} + 2 s^{2} + 2 s + 1}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nthe SciPy function residue is used to get the residues and poles of the partial-fraction expansion\nbuild the partial expansion terms and find the inverse Laplace of each term and save\n\nReturns:\n\nr: Residues corresponding to the poles. For repeated poles, the residues are ordered to correspond to ascending by power fractions.\np: Poles ordered by magnitude in ascending order.\nk: Coefficients of the direct polynomial term.\n\nWhen computing the inverse Laplace transform, the Coefficients (k) are ignored since these transform to a Dirac delta function, \\(\\delta (t)\\) and don’t need to be plotted.\n\nN = []\n\nfor p in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node2 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node2 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(V_node2),label='v2(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#node-3-voltage",
    "href": "Bridge-T.html#node-3-voltage",
    "title": "29  Bridge-T",
    "section": "29.6 Node 3 voltage",
    "text": "29.6 Node 3 voltage\nThe voltage on node 3 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nnode3 = U_ic[v3].nsimplify().simplify().expand().together()\nnode3\n\n\\(\\displaystyle \\frac{2 \\left(s^{2} + 1\\right)}{3 s^{3} + 2 s^{2} + 2 s + 1}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_2_voltage = inverse_laplace_transform(temp, s, t)\n#node_2_voltage\n\nUsing NumPy\nExtract the numerator and denominator and display.\n\nn, d = fraction(node3)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(2 s^{2} + 2\\)denominator: \\(3 s^{3} + 2 s^{2} + 2 s + 1\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{2}{3 s^{3} + 2 s^{2} + 2 s + 1}, \\  \\frac{2 s^{2}}{3 s^{3} + 2 s^{2} + 2 s + 1}\\right]\\)\n\n\nProcess term as decribed above.\n\nN = []\n\nfor p in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nSum all the terms.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node3 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node3 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(V_node3),label='v3(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#ltspice-solution",
    "href": "Bridge-T.html#ltspice-solution",
    "title": "29  Bridge-T",
    "section": "29.7 LTSpice Solution",
    "text": "29.7 LTSpice Solution\nTo chech the Python results the circuit was simulated in LTSpice. The following schematice was used and the LTSpice results are also shown below.\n\n\n\n\n\n\nFigure 29.3: Circuit used for LTSpice analysis\n\n\n\n\n\n\n\n\n\nFigure 29.4: Plot from LTSpice of node voltages\n\n\n\nLoad the csv file LTSpice results and plot along with the results obtained from Python.\n\nfn = 'Bridge-T-LTSpice.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\nCopy the data from the csv file into NumPy arrays.\n\n# initaliase some empty arrays\ntime = np.zeros(len(LTSpice_data))\nvoltage1 = np.zeros(len(LTSpice_data))\nvoltage2 = np.zeros(len(LTSpice_data))\nvoltage3 = np.zeros(len(LTSpice_data))\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    time[i] = LTSpice_data[i][0]\n    voltage1[i] = LTSpice_data[i][1]\n    voltage2[i] = LTSpice_data[i][2]\n    voltage3[i] = LTSpice_data[i][3]\n\nPlot the LTSpice data and the Python data to see if they agree.\n\nplt.title('LTSpice')\n\nplt.plot(time, voltage1,label='LTSpice v1(t)')\nplt.plot(time, voltage2,label='LTSpice v2(t)')\nplt.plot(time, voltage3,label='LTSpice v3(t)')\n\nplt.plot(x, np.real(V_node2),label='V node 2(t)')\nplt.plot(x, np.real(V_node3),label='V node 3(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plot above, the curves superimpose.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#summary",
    "href": "Bridge-T.html#summary",
    "title": "29  Bridge-T",
    "section": "29.8 Summary",
    "text": "29.8 Summary\nIn this notebook, newtork equations were solved which had initial conditions. The independent voltage source, V1 was modeled as a step function. The initial voltages on each of the capacitors were also modeled as step functions equal to the initial voltage. The network equations were generated with MNA and SymPy was used to solve the system of equations. The results were compared to results from LTSpice and the curves superimpose.\nThe MNA procedure and LTSpice didn’t have any issues with initial conditions. At t=0, all the voltages and currents in the circuit comply with Kirchhoff’s circuit laws (KCL) since the Heavyside function at t=0 is zero. At t=0+, where the + indicates the next infinitesimal instant in time, the voltages and currents would comply with KCL and result in large current flows to accomidate the solution for the voltages. Both Python and LTSpice step through time in discreate amounts, and at each step time KCL is satisified. I don’t think this was explained in any of the answers provided.\nThe answers provide by Franc (2023) are different from the results I obtained and he did not provide a time domain solution and plots of the node voltages.\n\n\n\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nLees, Andrew. 2023. “Solution of Electrical Network Where Arbitrary Initial Conditions Cannot Be Assigned.” 2023. https://electronics.stackexchange.com/questions/682634/solution-of-electrical-network-where-arbitrary-initial-conditions-cannot-be-assi.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html",
    "href": "Pi-Filter.html",
    "title": "30  Pi Filter",
    "section": "",
    "text": "30.1 Introduction\nA question posted on Electronics Stackexchange by user15174 (2023) looked interesting, he asked:\nThe FACTS (Fast Analytical Circuits Techniques) method refers to a circuit analysis technique that enables engineers to obtain the transfer functions and input and output impedances of a circuit by inspection without resorting to too much algebra. The circuits offered as illustrations of the technique are small with one or two reactive elements. Middlebrook (1991) seems to have been the first proponent of the method and describes what he calls design oriented analysis. He talks about low entropy equations, in which the terms and elements are ordered or grouped in such a way that their physical origin, where they come from in the circuit, and what part of the circuit contributes to this part of the final expression becomes obvious. The method is also described in Middlebrook (1992).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#introduction",
    "href": "Pi-Filter.html#introduction",
    "title": "30  Pi Filter",
    "section": "",
    "text": "Am trying to apply the FACTS method to find out the transfer function for this circuit as shown below. This is a Pi-filter circuit with all its component parasitics and also including the source and load resistances. I would like to find out the transfer function of this circuit and match its plot from Mathcad with simulation.\n\n\nFirst, to find out the zeros of this transfer function by inspection, I placed all circuit elements in its high frequency state. I can observe the response Vout is still present. In that case, can I assume that this circuit has 6 zeros associated with it?\n\n\nBut as per the answer provided in this link, we have to place the other associated circuit element in its DC state and observe if the response is still present. Since this circuit has around 6 reactive elements, how do I decide which circuit element should be in DC State and which circuit element should be in high frequency state?\n\n\nI was able to follow some examples done based on 2nd and 3rd order circuits shared in the above links. But with this circuit configuration and so many reactive elements, frankly I am lost. It would be great if you could share some insight on how to derive the transfer function for this circuit including its poles and zeros.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#community-answers",
    "href": "Pi-Filter.html#community-answers",
    "title": "30  Pi Filter",
    "section": "30.2 Community answers",
    "text": "30.2 Community answers\nThere were two answers provided by the community. User Franc (2023) provided a detailed solution based on reducing the circuit to Z1, Z2 and Z3 as shown in Figure 30.2 and then substituting back into the transfer function the impedances for each of the Z’s. User Telsa23 provided a shorter answer, also based on reducing the circuit to Z1, Z2 and Z3, but where a different expression for the transfer function was obtained. Neither of these answers follow the FACTS method, since the Extra Element Theorem was not employed during the analysis.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#circuit-description",
    "href": "Pi-Filter.html#circuit-description",
    "title": "30  Pi Filter",
    "section": "30.3 Circuit description",
    "text": "30.3 Circuit description\nFigure 30.1 shows the schematic as I re-drew it in LTSpice with all the values set to one. I numbered each of the nodes and made some changes to the reference designators. In the original question, no component values were provided. user15174 (2023) stated that component parasitics are included, but he didn’t indicate which circuit elements he considered parasitic. I’m going to consider C1, L3 and C2 as the main components of the Pi-Filter. \\(R_{in}\\) and \\(R_{out}\\) are the source and load impedances. All other elements in the schematic are parasitic and the values will be assigned later in the analysis.\nWith C1, L3 and C2 being considered as the main components, the circuit is a three section low pass filter, sometimes called a Pi filter because the connection represents the greek letter \\(\\pi\\). The schematic in Figure 30.1 has 13 branches and 8 nodes.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#circuit-analysis",
    "href": "Pi-Filter.html#circuit-analysis",
    "title": "30  Pi Filter",
    "section": "30.4 Circuit analysis",
    "text": "30.4 Circuit analysis\nuser15174 (2023) asked for a FACTS analysis. However, I think the circuit has too many reactive components for a FACTS analysis since this is a 6th order circuit. Following my review of FACTS, I present a ‘brute force’ analysis followed by a rework of Franc (2023)’s solution. A MNA of the filter with the parasitic components removed is presented. This is a third order circuit and SymPy can obtain solutions for the poles of the transfer function.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#facts",
    "href": "Pi-Filter.html#facts",
    "title": "30  Pi Filter",
    "section": "30.5 FACTS",
    "text": "30.5 FACTS\nThe origin of the FACTS circuit analysis method, as stated above, is from Middlebrook (1991). IEEE technical papers and books by Basso (2016) and Vorpérian (2002) have been written on the subject, however these are not free or available to download for free. FACTS is a circuit analysis method where the transfer function is determined by applying the Extra Element Theorem. Christophe Basso, Vatché Vorpérian and others have open source content available:\n\nFast Analytical Techniques for Electrical and Electronic Circuits\nIntroduction to Fast Analytical Techniques: Application to Small-Signal Modeling\nA series of 21 YouTube videos starting with: Fast Analytical Techniques for Electrical and Electronic Circuits\nExtra Element Theorem: An Introduction (with Examples)\n\nAccording to the open source FACTS literature:\n\nThe well-known and widely used methods of nodal or loop analysis, while effective for obtaining numerical solutions, are largely ineffective for deriving analytical solutions in symbolic form, except for simple circuits. Attempting to invert a matrix with symbolic entries, even for low-order matrices, results in tedious algebra and complex, high-entropy expressions that provide little meaningful insight.\n\nThe FACTS procedure, as illustrated in the open source literature, employs example circuits that are usually of order 1 or 2. The procedure results in equations that keep circuit elements grouped together and thus the equations are more intuitive. For 3rd order and higher circuits, the procedure becomes rather involved and I didn’t see any circuit analysis examples beyond a 2nd order circuit.\nTraditional circuit analysis techniques usually don’t produce analytical answers, i.e. equations in terms of symbols. Both the FACTS procedure and the MNA Python code in this book yield analytical answers, with the FACTS results possibly being more intuitive and the MNA Python code providing an automated solution, which would then have to be algebraically manipulated to be put into a FACTS type solution. The circuit in question is a 6th order network and much too difficult to analyze by hand or with the FACTS method.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#brute-force-mna-procedure",
    "href": "Pi-Filter.html#brute-force-mna-procedure",
    "title": "30  Pi Filter",
    "section": "30.6 ‘Brute Force’ MNA procedure",
    "text": "30.6 ‘Brute Force’ MNA procedure\nDoing a so called brute force analysis. The goal is to get the transfer function, \\(H(s)=\\frac {V_2}{V_8}\\) and the poles and zeros of \\(H(s)\\). SymPy will be used to ‘brute force’ analyze the circuit and solve for the transfer function and find the poles and zeros.\nThe net list for the filter is:\nV1 8 0 1\nR_in 1 8 1\nR1 1 4 1\nRa 3 1 1\nR2 2 3 1\nR3 2 6 1\nR_out 2 0 1\nL1 4 5 1 Rser=0\nL2 3 2 1 Rser=0\nL3 6 7 1 Rser=0\nC1 5 0 1\nC2 2 3 1\nC3 7 0 1\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\nLoad the netlist generated from Figure 30.1.\n\nnet_list = '''\nV1 8 0 1\nR_in 1 8 1\nR1 1 4 1\nRa 3 1 1\nR2 2 3 1\nR3 2 6 1\nR_out 2 0 1\nL1 4 5 1 \nL2 3 2 1 \nL3 6 7 1\nC1 5 0 1\nC2 2 3 1\nC3 7 0 1\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nBuild the network equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = v_{1} \\cdot \\left(\\frac{1}{Ra} + \\frac{1}{R_{in}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{Ra} - \\frac{v_{8}}{R_{in}} - \\frac{v_{4}}{R_{1}}\\)\\(0 = - I_{L2} + v_{2} \\left(C_{2} s + \\frac{1}{R_{out}} + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) + v_{3} \\left(- C_{2} s - \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{3}}\\)\\(0 = I_{L2} + v_{2} \\left(- C_{2} s - \\frac{1}{R_{2}}\\right) + v_{3} \\left(C_{2} s + \\frac{1}{Ra} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{Ra}\\)\\(0 = I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}}\\)\\(0 = C_{1} s v_{5} - I_{L1}\\)\\(0 = I_{L3} - \\frac{v_{2}}{R_{3}} + \\frac{v_{6}}{R_{3}}\\)\\(0 = C_{3} s v_{7} - I_{L3}\\)\\(0 = I_{V1} - \\frac{v_{1}}{R_{in}} + \\frac{v_{8}}{R_{in}}\\)\\(V_{1} = v_{8}\\)\\(0 = - I_{L1} L_{1} s + v_{4} - v_{5}\\)\\(0 = - I_{L2} L_{2} s - v_{2} + v_{3}\\)\\(0 = - I_{L3} L_{3} s + v_{6} - v_{7}\\)\n\n\nAs shown above, MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time.\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  v_{1}, \\  I_{L2}, \\  I_{V1}, \\  I_{L3}, \\  v_{2}, \\  v_{4}, \\  R_{out}, \\  R_{2}, \\  C_{2}, \\  C_{3}, \\  v_{3}, \\  R_{1}, \\  v_{8}, \\  Ra, \\  R_{3}, \\  s, \\  v_{5}, \\  L_{1}, \\  L_{3}, \\  C_{1}, \\  I_{L1}, \\  v_{7}, \\  v_{6}, \\  V_{1}, \\  R_{in}\\right)\\)\n\n\nGenerate the symbolic solution, which takes a couple of minutes on my laptop (i3-8130U 2.20GHz).\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution. The espressions are long, so code to display is commented.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n# Markdown(temp)\n\nSolve for the transfer function \\(H(s)=\\frac {V_2}{V_8}\\) in symbolic form. As you can see the expression is long.\n\nH_sym = (U_sym[v2]/U_sym[v8]).simplify().collect(s)\nH_sym\n\n\\(\\displaystyle \\frac{R_{out} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} s^{6} + R_{2} + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3}\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{2} L_{1} L_{2} R_{2} + C_{1} C_{3} L_{1} L_{2} R_{3} + C_{1} C_{3} L_{1} L_{3} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} + C_{2} C_{3} L_{2} L_{3} R_{2}\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} + C_{1} C_{3} L_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{3} + C_{1} C_{3} L_{3} R_{1} R_{2} + C_{1} L_{1} L_{2} + C_{2} C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} L_{3}\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} + C_{1} L_{1} R_{2} + C_{1} L_{2} R_{1} + C_{2} L_{2} R_{2} + C_{3} L_{2} R_{3} + C_{3} L_{3} R_{2}\\right) + s \\left(C_{1} R_{1} R_{2} + C_{3} R_{2} R_{3} + L_{2}\\right)\\right)}{R_{2} R_{in} + R_{2} R_{out} + R_{2} Ra + s^{6} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} Ra\\right) + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} L_{2} L_{3} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} L_{3} Ra\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} Ra + C_{1} C_{2} L_{1} L_{2} R_{2} R_{in} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{2} L_{1} L_{2} R_{2} Ra + C_{1} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} Ra + C_{1} C_{3} L_{1} L_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{out} Ra + C_{1} C_{3} L_{1} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{3} R_{2} Ra + C_{1} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{1} Ra + C_{1} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{in} Ra + C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} + C_{2} C_{3} L_{2} L_{3} R_{2} Ra\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} R_{in} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{2} L_{2} R_{1} R_{2} Ra + C_{1} C_{2} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} L_{2} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{3} Ra + C_{1} C_{3} L_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{out} Ra + C_{1} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} Ra + C_{1} C_{3} L_{2} R_{1} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{out} Ra + C_{1} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} Ra + C_{1} C_{3} L_{2} R_{in} R_{out} Ra + C_{1} C_{3} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{3} R_{1} R_{2} Ra + C_{1} C_{3} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{3} R_{2} R_{in} Ra + C_{1} L_{1} L_{2} R_{2} + C_{1} L_{1} L_{2} R_{in} + C_{1} L_{1} L_{2} R_{out} + C_{1} L_{1} L_{2} Ra + C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{3} Ra + C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{out} Ra + C_{3} L_{2} L_{3} R_{2} + C_{3} L_{2} L_{3} R_{in} + C_{3} L_{2} L_{3} R_{out} + C_{3} L_{2} L_{3} Ra\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{3} Ra + C_{1} C_{3} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{out} Ra + C_{1} C_{3} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} R_{2} R_{3} R_{in} Ra + C_{1} C_{3} R_{2} R_{in} R_{out} Ra + C_{1} L_{1} R_{2} R_{in} + C_{1} L_{1} R_{2} R_{out} + C_{1} L_{1} R_{2} Ra + C_{1} L_{2} R_{1} R_{2} + C_{1} L_{2} R_{1} R_{in} + C_{1} L_{2} R_{1} R_{out} + C_{1} L_{2} R_{1} Ra + C_{1} L_{2} R_{2} R_{in} + C_{1} L_{2} R_{in} R_{out} + C_{1} L_{2} R_{in} Ra + C_{2} L_{2} R_{2} R_{in} + C_{2} L_{2} R_{2} R_{out} + C_{2} L_{2} R_{2} Ra + C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} R_{2} R_{out} + C_{3} L_{2} R_{3} R_{in} + C_{3} L_{2} R_{3} R_{out} + C_{3} L_{2} R_{3} Ra + C_{3} L_{2} R_{in} R_{out} + C_{3} L_{2} R_{out} Ra + C_{3} L_{3} R_{2} R_{in} + C_{3} L_{3} R_{2} R_{out} + C_{3} L_{3} R_{2} Ra\\right) + s \\left(C_{1} R_{1} R_{2} R_{in} + C_{1} R_{1} R_{2} R_{out} + C_{1} R_{1} R_{2} Ra + C_{1} R_{2} R_{in} R_{out} + C_{1} R_{2} R_{in} Ra + C_{3} R_{2} R_{3} R_{in} + C_{3} R_{2} R_{3} R_{out} + C_{3} R_{2} R_{3} Ra + C_{3} R_{2} R_{in} R_{out} + C_{3} R_{2} R_{out} Ra + L_{2} R_{2} + L_{2} R_{in} + L_{2} R_{out} + L_{2} Ra\\right)}\\)\n\n\nAs shown above the symbolic solution is long on not very insightful. The FACTS method is supposed to reveal aspects of the circuit’s operation that is hidden by the algebra. I think the Pi Filter with parasitic elements included is too complex.\nThe numerator and denominator of the transfer function can be extracted for analysis.\n\nn, d = fraction(H_sym)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle R_{out} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} s^{6} + R_{2} + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3}\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{2} L_{1} L_{2} R_{2} + C_{1} C_{3} L_{1} L_{2} R_{3} + C_{1} C_{3} L_{1} L_{3} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} + C_{2} C_{3} L_{2} L_{3} R_{2}\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} + C_{1} C_{3} L_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{3} + C_{1} C_{3} L_{3} R_{1} R_{2} + C_{1} L_{1} L_{2} + C_{2} C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} L_{3}\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} + C_{1} L_{1} R_{2} + C_{1} L_{2} R_{1} + C_{2} L_{2} R_{2} + C_{3} L_{2} R_{3} + C_{3} L_{3} R_{2}\\right) + s \\left(C_{1} R_{1} R_{2} + C_{3} R_{2} R_{3} + L_{2}\\right)\\right)\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle R_{2} R_{in} + R_{2} R_{out} + R_{2} Ra + s^{6} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} Ra\\right) + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} L_{2} L_{3} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} L_{3} Ra\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} Ra + C_{1} C_{2} L_{1} L_{2} R_{2} R_{in} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{2} L_{1} L_{2} R_{2} Ra + C_{1} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} Ra + C_{1} C_{3} L_{1} L_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{out} Ra + C_{1} C_{3} L_{1} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{3} R_{2} Ra + C_{1} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{1} Ra + C_{1} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{in} Ra + C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} + C_{2} C_{3} L_{2} L_{3} R_{2} Ra\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} R_{in} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{2} L_{2} R_{1} R_{2} Ra + C_{1} C_{2} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} L_{2} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{3} Ra + C_{1} C_{3} L_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{out} Ra + C_{1} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} Ra + C_{1} C_{3} L_{2} R_{1} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{out} Ra + C_{1} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} Ra + C_{1} C_{3} L_{2} R_{in} R_{out} Ra + C_{1} C_{3} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{3} R_{1} R_{2} Ra + C_{1} C_{3} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{3} R_{2} R_{in} Ra + C_{1} L_{1} L_{2} R_{2} + C_{1} L_{1} L_{2} R_{in} + C_{1} L_{1} L_{2} R_{out} + C_{1} L_{1} L_{2} Ra + C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{3} Ra + C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{out} Ra + C_{3} L_{2} L_{3} R_{2} + C_{3} L_{2} L_{3} R_{in} + C_{3} L_{2} L_{3} R_{out} + C_{3} L_{2} L_{3} Ra\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{3} Ra + C_{1} C_{3} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{out} Ra + C_{1} C_{3} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} R_{2} R_{3} R_{in} Ra + C_{1} C_{3} R_{2} R_{in} R_{out} Ra + C_{1} L_{1} R_{2} R_{in} + C_{1} L_{1} R_{2} R_{out} + C_{1} L_{1} R_{2} Ra + C_{1} L_{2} R_{1} R_{2} + C_{1} L_{2} R_{1} R_{in} + C_{1} L_{2} R_{1} R_{out} + C_{1} L_{2} R_{1} Ra + C_{1} L_{2} R_{2} R_{in} + C_{1} L_{2} R_{in} R_{out} + C_{1} L_{2} R_{in} Ra + C_{2} L_{2} R_{2} R_{in} + C_{2} L_{2} R_{2} R_{out} + C_{2} L_{2} R_{2} Ra + C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} R_{2} R_{out} + C_{3} L_{2} R_{3} R_{in} + C_{3} L_{2} R_{3} R_{out} + C_{3} L_{2} R_{3} Ra + C_{3} L_{2} R_{in} R_{out} + C_{3} L_{2} R_{out} Ra + C_{3} L_{3} R_{2} R_{in} + C_{3} L_{3} R_{2} R_{out} + C_{3} L_{3} R_{2} Ra\\right) + s \\left(C_{1} R_{1} R_{2} R_{in} + C_{1} R_{1} R_{2} R_{out} + C_{1} R_{1} R_{2} Ra + C_{1} R_{2} R_{in} R_{out} + C_{1} R_{2} R_{in} Ra + C_{3} R_{2} R_{3} R_{in} + C_{3} R_{2} R_{3} R_{out} + C_{3} R_{2} R_{3} Ra + C_{3} R_{2} R_{in} R_{out} + C_{3} R_{2} R_{out} Ra + L_{2} R_{2} + L_{2} R_{in} + L_{2} R_{out} + L_{2} Ra\\right)\\)\n\n\nSolve for the roots of the numerator.\n\nsolve(n,s)\n\n\\(\\displaystyle \\left[ \\frac{- C_{1} R_{1} - \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{1} R_{1} + \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{3} R_{3} - \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- C_{3} R_{3} + \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- L_{2} - \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}, \\  \\frac{- L_{2} + \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}\\right]\\)\n\n\nWe can see that there are six zeros in the transfer function. Here can see what components are influncing the zeros. One of the gaols of the FACTS method was to determine the zeros of the network and express them in terms of the components.\nSolve for the roots of the denominator\n\n#solve(d,s)\n\nSymPy could not find a solution for roots of denominator.\n\n30.6.1 Use numerical values for components\nBuilt a dictionary of element values. The LTSpice schematic had all the component values set to one.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  C_{3} : 1.0, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  L_{3} : 1.0, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{in} : 1.0, \\  R_{out} : 1.0, \\  Ra : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nIn this analysis, we are going to assum that the circuit is a low pass filter and the parasitics component values are scalled by 1000 from the value of the main components.\n\n# the values of the main components \nCa = 1 \nCb = 1\nLa = 2\nsf = 1e3 # parasitic scale factor\n\nelement_values[R1] = Ca/sf\nelement_values[Ra] = La/sf\nelement_values[R2] = La*sf\nelement_values[R3] = Cb/sf\n\nelement_values[L1] = Ca/sf\nelement_values[L2] = La\nelement_values[L3] = Cb/sf\nelement_values[C1] = Ca\nelement_values[C2] = La/sf\nelement_values[C3] = Cb\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1, \\  C_{2} : 0.002, \\  C_{3} : 1, \\  L_{1} : 0.001, \\  L_{2} : 2, \\  L_{3} : 0.001, \\  R_{1} : 0.001, \\  R_{2} : 2000.0, \\  R_{3} : 0.001, \\  R_{in} : 1.0, \\  R_{out} : 1.0, \\  Ra : 0.002, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\n\n30.6.2 Numerical solution\nDisplay the equations with component values.\n\nNE = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = 1501.0 v_{1} - 500.0 v_{3} - 1000.0 v_{4} - 1.0 v_{8}\\)\\(0 = - I_{L2} + v_{2} \\cdot \\left(0.002 s + 1001.0005\\right) + v_{3} \\left(- 0.002 s - 0.0005\\right) - 1000.0 v_{6}\\)\\(0 = I_{L2} - 500.0 v_{1} + v_{2} \\left(- 0.002 s - 0.0005\\right) + v_{3} \\cdot \\left(0.002 s + 500.0005\\right)\\)\\(0 = I_{L1} - 1000.0 v_{1} + 1000.0 v_{4}\\)\\(0 = - I_{L1} + s v_{5}\\)\\(0 = I_{L3} - 1000.0 v_{2} + 1000.0 v_{6}\\)\\(0 = - I_{L3} + s v_{7}\\)\\(0 = I_{V1} - 1.0 v_{1} + 1.0 v_{8}\\)\\(1.0 = v_{8}\\)\\(0 = - 0.001 I_{L1} s + v_{4} - v_{5}\\)\\(0 = - 2 I_{L2} s - v_{2} + v_{3}\\)\\(0 = - 0.001 I_{L3} s + v_{6} - v_{7}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{2004.0 s^{6} + 1008509.0 s^{5} + 1006517006.0 s^{4} + 3012013501.0 s^{3} + 1005009503000.0 s^{2} + 1002503000000.0 s + 501000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{2} = \\frac{2000.0 s^{6} + 4500.0 s^{5} + 4503000.0 s^{4} + 6000500.0 s^{3} + 3001500000.0 s^{2} + 1500000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{3} = \\frac{2000.0 s^{6} + 1004500.0 s^{5} + 1006503000.0 s^{4} + 3007000500.0 s^{3} + 1005001500000.0 s^{2} + 1001500000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{4} = \\frac{2004.0 s^{6} + 1006505.0 s^{5} + 1005510501.0 s^{4} + 2008507000.0 s^{3} + 1004007501000.0 s^{2} + 1002002000000.0 s + 501000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{5} = \\frac{2004000.0 s^{4} + 1006505000.0 s^{3} + 1003506501000.0 s^{2} + 1002002000000.0 s + 501000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{6} = \\frac{2000.0 s^{6} + 2500.0 s^{5} + 4500500.0 s^{4} + 3500000.0 s^{3} + 3000500000.0 s^{2} + 1000000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{7} = \\frac{2000000.0 s^{4} + 2500000.0 s^{3} + 2500500000.0 s^{2} + 1000000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{8} = 1.0\\)\\(I_{V1} = \\frac{- 2000.0 s^{6} - 4008500.0 s^{5} - 1013508000.0 s^{4} - 1006013001500.0 s^{3} - 1006003500000.0 s^{2} - 1002500000000.0 s - 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(I_{L1} = \\frac{2004000.0 s^{5} + 1006505000.0 s^{4} + 1003506501000.0 s^{3} + 1002002000000.0 s^{2} + 501000000000.0 s}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(I_{L2} = \\frac{500000.0 s^{2} + 500000.0 s + 500000000.0}{4004.0 s^{4} + 1009005.0 s^{3} + 1006007001.0 s^{2} + 1003002000.0 s + 1001000000.0}\\)\\(I_{L3} = \\frac{2000000.0 s^{5} + 2500000.0 s^{4} + 2500500000.0 s^{3} + 1000000000.0 s^{2} + 500000000000.0 s}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\n\n\n\nH = (U[v2]/U[v8]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{500 \\cdot \\left(4 s^{6} + 9 s^{5} + 9006 s^{4} + 12001 s^{3} + 6003000 s^{2} + 3000000 s + 1000000000\\right)}{4004 s^{6} + 5017009 s^{5} + 2020025006 s^{4} + 1009025015001 s^{3} + 2011013003000 s^{2} + 2005003000000 s + 1001000000000}\\)\n\n\nThe code below converst the SymPy equations into NumPy format. Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n30.6.3 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained and plotted with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n# plot the poles and zeros\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\n#plt.ylim((-2,2))\n#plt.xlim((-4,0))\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPrinting the value of the poles and zeros in radians per second.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of zeros: 6\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.125+15.811j rad/s\n-0.125-15.811j rad/s\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of poles: 6\n-1,000.000+0.000j rad/s\n-125.501+485.024j rad/s\n-125.501-485.024j rad/s\n-1.000+0.000j rad/s\n-0.499+0.865j rad/s\n-0.499-0.865j rad/s\n\n\n\n\n30.6.4 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(-2, 2, 1000, endpoint=False) #*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, radians')\n\nplt.semilogx(w, mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w, phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#re-work-of-user347817s-solution",
    "href": "Pi-Filter.html#re-work-of-user347817s-solution",
    "title": "30  Pi Filter",
    "section": "30.7 Re-work of Franc (2023)’s solution",
    "text": "30.7 Re-work of Franc (2023)’s solution\nThe solution provided by Franc (2023) is not a solution that following the FACTS method. He calculates the transfer function based on the ratio of the impedances of a voltage divider. Figure 30.2, shows the orginal circuit re-drawn with the branches replaced by their transformed impedances.\n\n\n\n\n\n\nFigure 30.2: Pi filter schematic with branch impedances replaced by Z1, Z2 and Z3\n\n\n\nThe components for the branches are replace by Z1, Z2 and Z3.\nZ1 = series connection of R1, L1 and C1\n\nZ2 = series connection of Ra and (L2 || C2 || R2)\n\nZ3 = series connection of R3, L3 and C3\n\nZ4 = Z3 || R_out\nThe following defines the SymPy symbols used in the calculations. The function symbols takes a string of variable names separated by spaces or commas, and creates Symbols out of them.\n\nL1, L2, L3, R1, R2, R3, Ra, R, R_out, R_in, C1, C2, C3, s, V1 = symbols('L1, L2, L3, R1, R2, R3, Ra, R, R_out, R_in, C1, C2, C3, s, V1')\n\n\n30.7.1 Branches of the circuit\nZ1 is the series connection of R1, C1 and L1.\n\nZ1_sym = R1+s*L1+1/(s*C1)\nZ1_sym\n\n\\(\\displaystyle L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\)\n\n\nZ2 is the series connection of Ra and the paralle connection of R2, L2 and C2\n\nZ2_sym = (Ra+1/(1/(1/(s*C2)) + 1/(s*L2) + 1/R2))\nZ2_sym\n\n\\(\\displaystyle Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\)\n\n\nZ3 is the series connection of R3, L3 and C3\n\nZ3_sym = R3+s*L3+1/(s*C3)\nZ3_sym\n\n\\(\\displaystyle L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\)\n\n\nZ4 is the parallel combination of R_out and Z3.\nZ4 = R_out || Z3\n\nZ4_sym = R_out*Z3_sym/(R_out+Z3_sym)\nZ4_sym\n\n\\(\\displaystyle \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}}\\)\n\n\nFranc (2023) provided a MatCAD like set of calculations. Using “||” to indicate a parallel combination of components and a “+” to indicate a series combination of componets, some of his calculations are shown here:\n\\(Z_1 = R_2 + sL_1 + \\frac {1}{sC_1}\\)\n\\(Z_2 = R_6 + R_3 || sL_2 || \\frac {1}{sC_2}\\)\n\\(Z_3 = R_4 + sL_3 + \\frac {1}{sC_3}\\)\n\\(Z_4 = Z_3 || R_2\\)\n\\(V_1 = \\frac {(Z_1 || (Z_2+Z_4))} {(R_1+Z_1 || (Z_2+Z_4))} V_i\\)\n\\(V_o = \\frac {Z_4} {(Z_4+Z_2)} V_1\\)\n\\(V_o = \\frac {Z_4} {(Z_4+Z_2)} \\frac {(Z_1 || (Z_2+Z_4))} {(R_1+Z_1 || (Z_2+Z_4))} V_i\\)\n\nZ1, Z2, Z3, Z4, R_in, R_out, V1 = symbols('Z1, Z2, Z3, Z4, R_in, R_out, V1')\n\nZx is the parallel combination of Z1, Z2 and Z4.\n\nZx = Z1*(Z2+Z4)/(Z1+Z2+Z4)\nZx\n\n\\(\\displaystyle \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\)\n\n\nThe voltage at node 1 is calculated by using the voltage divider formula for Zx and Rin.\n\nv_node1 = V1*Zx/(R_in+Zx)\nv_node1\n\n\\(\\displaystyle \\frac{V_{1} Z_{1} \\left(Z_{2} + Z_{4}\\right)}{\\left(R_{in} + \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\right) \\left(Z_{1} + Z_{2} + Z_{4}\\right)}\\)\n\n\nVout is the voltage divider of Z2 and Z4.\n\nV_out =  v_node1*Z4/(Z2+Z4)\nV_out\n\n\\(\\displaystyle \\frac{V_{1} Z_{1} Z_{4}}{\\left(R_{in} + \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\right) \\left(Z_{1} + Z_{2} + Z_{4}\\right)}\\)\n\n\nThe trasfer function is Vout/Vin. H_franc_sym\n\nH_franc_z = V_out/V1\nH_franc_z\n\n\\(\\displaystyle \\frac{Z_{1} Z_{4}}{\\left(R_{in} + \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\right) \\left(Z_{1} + Z_{2} + Z_{4}\\right)}\\)\n\n\n\nH_franc_z.simplify()\n\n\\(\\displaystyle \\frac{Z_{1} Z_{4}}{R_{in} \\left(Z_{1} + Z_{2} + Z_{4}\\right) + Z_{1} \\left(Z_{2} + Z_{4}\\right)}\\)\n\n\nRepeating the calculations from above, but using symbolic expressions for Z1, Z2, Z3 and Z4.\nZx is the combination of Z’s looking towards the output of the filter. Zx = Z1 || (Z2+Z4)\n\nZx_sym = Z1_sym*(Z2_sym+Z4_sym)/(Z1_sym+Z2_sym+Z4_sym)\nZx_sym\n\n\\(\\displaystyle \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\)\n\n\nThe voltage at node 1 is\nv_node1 = V1*Zx/(R_in+Zx)\n\nv_node1_sym = V1*Zx_sym/(R_in+Zx_sym)\nv_node1_sym\n\n\\(\\displaystyle \\frac{V_{1} \\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{\\left(R_{in} + \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\right) \\left(L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}\\right)}\\)\n\n\nV_out is the output of the voltage divider circuit formed by Z2 and Z4\n\nV_out_sym =  v_node1_sym*Z4_sym/(Z2_sym+Z4_sym)\nV_out_sym\n\n\\(\\displaystyle \\frac{R_{out} V_{1} \\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{\\left(R_{in} + \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\right) \\left(L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}\\right) \\left(L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}\\right)}\\)\n\n\n\n\n30.7.2 H_franc_sym\nThe transfer function as determined by taking the impedance of branches and combining by series and parallel combinations can be expressed below.\n\nH_franc_sym = V_out_sym/V1\nH_franc_sym\n\n\\(\\displaystyle \\frac{R_{out} \\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{\\left(R_{in} + \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\right) \\left(L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}\\right) \\left(L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}\\right)}\\)\n\n\nThe expression above, probably comes closest to the reults that would be obtained from a FACTS analysis.\n\nH_franc_sym_1a = H_franc_sym.simplify()\nH_franc_sym_1a\n\n\\(\\displaystyle \\frac{R_{out} \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)}{R_{in} \\left(C_{1} L_{2} R_{2} s^{2} \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + C_{1} R_{out} s \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + C_{1} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(L_{1} s + R_{1} + Ra\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right) + \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(L_{2} R_{2} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + R_{out} \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + Ra \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right)}\\)\n\n\n\nn, d = fraction(H_franc_sym_1a)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle R_{out} \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle R_{in} \\left(C_{1} L_{2} R_{2} s^{2} \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + C_{1} R_{out} s \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + C_{1} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(L_{1} s + R_{1} + Ra\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right) + \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(L_{2} R_{2} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + R_{out} \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + Ra \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right)\\)\n\n\nSolve for the roots of the numberator.\n\nn.simplify().expand()\n\n\\(\\displaystyle C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} s^{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} s^{5} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} s^{4} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} s^{4} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} s^{2} + C_{1} L_{1} L_{2} R_{out} s^{3} + C_{1} L_{1} R_{2} R_{out} s^{2} + C_{1} L_{2} R_{1} R_{out} s^{2} + C_{1} R_{1} R_{2} R_{out} s + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} s^{4} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} s^{3} + C_{2} L_{2} R_{2} R_{out} s^{2} + C_{3} L_{2} L_{3} R_{out} s^{3} + C_{3} L_{2} R_{3} R_{out} s^{2} + C_{3} L_{3} R_{2} R_{out} s^{2} + C_{3} R_{2} R_{3} R_{out} s + L_{2} R_{out} s + R_{2} R_{out}\\)\n\n\n\nsolve(n.simplify().expand(),s)\n\n\\(\\displaystyle \\left[ \\frac{- C_{1} R_{1} - \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{1} R_{1} + \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{3} R_{3} - \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- C_{3} R_{3} + \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- L_{2} - \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}, \\  \\frac{- L_{2} + \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}\\right]\\)\n\n\nWe can see that there are six zeros in the transfer function. Here can see what components are influncing the zeros. Once of the gaols of the FACTS method was to determine the zeros of the network.\nSolve for the roots of the denominator\n\nd.simplify().expand().together()\n\n\\(\\displaystyle C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{in} s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} Ra s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{in} s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} Ra s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{in} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{out} Ra s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{in} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} Ra s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} Ra s^{5} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{in} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} Ra s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{in} R_{out} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{out} Ra s^{4} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} R_{out} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} Ra s^{4} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} Ra s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{in} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} Ra s^{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{in} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} Ra s^{3} + C_{1} C_{2} L_{2} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{2} L_{2} R_{2} R_{in} Ra s^{3} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{2} s^{5} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{in} s^{5} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} s^{5} + C_{1} C_{3} L_{1} L_{2} L_{3} Ra s^{5} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{in} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{3} Ra s^{4} + C_{1} C_{3} L_{1} L_{2} R_{in} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{out} Ra s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{in} s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} Ra s^{4} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{in} s^{3} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{1} R_{2} R_{3} Ra s^{3} + C_{1} C_{3} L_{1} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{1} R_{2} R_{out} Ra s^{3} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{2} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{in} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{1} Ra s^{4} + C_{1} C_{3} L_{2} L_{3} R_{2} R_{in} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{in} R_{out} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{in} Ra s^{4} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{in} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{3} Ra s^{3} + C_{1} C_{3} L_{2} R_{1} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{out} Ra s^{3} + C_{1} C_{3} L_{2} R_{2} R_{3} R_{in} s^{3} + C_{1} C_{3} L_{2} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{3} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{3} R_{in} Ra s^{3} + C_{1} C_{3} L_{2} R_{in} R_{out} Ra s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{in} s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} Ra s^{3} + C_{1} C_{3} L_{3} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{3} R_{2} R_{in} Ra s^{3} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{in} s^{2} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} s^{2} + C_{1} C_{3} R_{1} R_{2} R_{3} Ra s^{2} + C_{1} C_{3} R_{1} R_{2} R_{in} R_{out} s^{2} + C_{1} C_{3} R_{1} R_{2} R_{out} Ra s^{2} + C_{1} C_{3} R_{2} R_{3} R_{in} R_{out} s^{2} + C_{1} C_{3} R_{2} R_{3} R_{in} Ra s^{2} + C_{1} C_{3} R_{2} R_{in} R_{out} Ra s^{2} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{in} s^{3} + C_{1} L_{1} L_{2} R_{out} s^{3} + C_{1} L_{1} L_{2} Ra s^{3} + C_{1} L_{1} R_{2} R_{in} s^{2} + C_{1} L_{1} R_{2} R_{out} s^{2} + C_{1} L_{1} R_{2} Ra s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{in} s^{2} + C_{1} L_{2} R_{1} R_{out} s^{2} + C_{1} L_{2} R_{1} Ra s^{2} + C_{1} L_{2} R_{2} R_{in} s^{2} + C_{1} L_{2} R_{in} R_{out} s^{2} + C_{1} L_{2} R_{in} Ra s^{2} + C_{1} R_{1} R_{2} R_{in} s + C_{1} R_{1} R_{2} R_{out} s + C_{1} R_{1} R_{2} Ra s + C_{1} R_{2} R_{in} R_{out} s + C_{1} R_{2} R_{in} Ra s + C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} s^{4} + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} s^{4} + C_{2} C_{3} L_{2} L_{3} R_{2} Ra s^{4} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} s^{3} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} s^{3} + C_{2} C_{3} L_{2} R_{2} R_{3} Ra s^{3} + C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} s^{3} + C_{2} C_{3} L_{2} R_{2} R_{out} Ra s^{3} + C_{2} L_{2} R_{2} R_{in} s^{2} + C_{2} L_{2} R_{2} R_{out} s^{2} + C_{2} L_{2} R_{2} Ra s^{2} + C_{3} L_{2} L_{3} R_{2} s^{3} + C_{3} L_{2} L_{3} R_{in} s^{3} + C_{3} L_{2} L_{3} R_{out} s^{3} + C_{3} L_{2} L_{3} Ra s^{3} + C_{3} L_{2} R_{2} R_{3} s^{2} + C_{3} L_{2} R_{2} R_{out} s^{2} + C_{3} L_{2} R_{3} R_{in} s^{2} + C_{3} L_{2} R_{3} R_{out} s^{2} + C_{3} L_{2} R_{3} Ra s^{2} + C_{3} L_{2} R_{in} R_{out} s^{2} + C_{3} L_{2} R_{out} Ra s^{2} + C_{3} L_{3} R_{2} R_{in} s^{2} + C_{3} L_{3} R_{2} R_{out} s^{2} + C_{3} L_{3} R_{2} Ra s^{2} + C_{3} R_{2} R_{3} R_{in} s + C_{3} R_{2} R_{3} R_{out} s + C_{3} R_{2} R_{3} Ra s + C_{3} R_{2} R_{in} R_{out} s + C_{3} R_{2} R_{out} Ra s + L_{2} R_{2} s + L_{2} R_{in} s + L_{2} R_{out} s + L_{2} Ra s + R_{2} R_{in} + R_{2} R_{out} + R_{2} Ra\\)\n\n\n\n#solve(d,s)\n\nSymPy could not find a solution for roots of denominator.\n\n\n30.7.3 Use numerical values for components\nThe element vaules can be put into the equation.\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1, \\  C_{2} : 0.002, \\  C_{3} : 1, \\  L_{1} : 0.001, \\  L_{2} : 2, \\  L_{3} : 0.001, \\  R_{1} : 0.001, \\  R_{2} : 2000.0, \\  R_{3} : 0.001, \\  R_{in} : 1.0, \\  R_{out} : 1.0, \\  Ra : 0.002, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\nH_franc = H_franc_sym.subs(element_values)\nH_franc\n\n\\(\\displaystyle \\frac{1.0 \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)^{2}}{\\left(\\frac{\\left(0.001 s + 0.001 + \\frac{1}{s}\\right) \\left(\\frac{1.0 \\cdot \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)}{0.001 s + 1.001 + \\frac{1}{s}} + 0.002 + \\frac{1}{0.002 s + 0.0005 + \\frac{1}{2 s}}\\right)}{0.001 s + \\frac{1.0 \\cdot \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)}{0.001 s + 1.001 + \\frac{1}{s}} + 0.003 + \\frac{1}{0.002 s + 0.0005 + \\frac{1}{2 s}} + \\frac{1}{s}} + 1.0\\right) \\left(0.001 s + 1.001 + \\frac{1}{s}\\right) \\left(0.001 s + \\frac{1.0 \\cdot \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)}{0.001 s + 1.001 + \\frac{1}{s}} + 0.003 + \\frac{1}{0.002 s + 0.0005 + \\frac{1}{2 s}} + \\frac{1}{s}\\right)}\\)\n\n\nSimplifying the expression.\n\nH_franc = H_franc.nsimplify().simplify().expand().together()\nH_franc\n\n\\(\\displaystyle \\frac{500 \\cdot \\left(4 s^{6} + 9 s^{5} + 9006 s^{4} + 12001 s^{3} + 6003000 s^{2} + 3000000 s + 1000000000\\right)}{4004 s^{6} + 5017009 s^{5} + 2020025006 s^{4} + 1009025015001 s^{3} + 2011013003000 s^{2} + 2005003000000 s + 1001000000000}\\)\n\n\n\n\n30.7.4 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_franc_num, H_franc_denom = fraction(H_franc) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_franc_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_franc_denom, s).all_coeffs(), dtype=float)\nfranc_sys = signal.TransferFunction(a,b)\n\n\nfranc_sys_zeros = np.roots(franc_sys.num)\nfranc_sys_poles = np.roots(franc_sys.den)\n\n\n\n30.7.5 Pole zero plot\nThe poles and zeros of the function are plotted on the complex plane.\n\nplt.plot(np.real(franc_sys_zeros), np.imag(franc_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(franc_sys_poles), np.imag(franc_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\n#plt.ylim((-2,2))\n#plt.xlim((-2,0))\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPrinting the value of the poles and zeros in radians per second.\n\nprint('number of zeros: {:d}'.format(len(franc_sys_zeros)))\nfor i in franc_sys_zeros:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of zeros: 6\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.125+15.811j rad/s\n-0.125-15.811j rad/s\n\n\n\nprint('number of poles: {:d}'.format(len(franc_sys_poles)))\nfor i in franc_sys_poles:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of poles: 6\n-1,000.000+0.000j rad/s\n-125.501+485.024j rad/s\n-125.501-485.024j rad/s\n-1.000+0.000j rad/s\n-0.499+0.865j rad/s\n-0.499-0.865j rad/s\n\n\n\n\n30.7.6 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(-2, 2, 1000, endpoint=False) #*2*np.pi\nw_franc, mag_franc, phase_franc = signal.bode(franc_sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, radians')\n\nplt.semilogx(w_franc, mag_franc,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_franc, phase_franc,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#comapring-solutions",
    "href": "Pi-Filter.html#comapring-solutions",
    "title": "30  Pi Filter",
    "section": "30.8 Comapring solutions",
    "text": "30.8 Comapring solutions\nLoad the csv file from LTSpice.\n\nfn = 'Pi-Filter-LTSpice.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # LTSpice magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # MNA magnitude plot\nplt.semilogx(w_franc/(2*np.pi), mag_franc,'-r')    # FACTS magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color='k',label='LTSpice')  # LTSpice phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='b',label='MNA')  # MNA phase plot\nplt.semilogx(w_franc/(2*np.pi), phase_franc,':',color='r',label='Franc')  # FACTS phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='LTSpice')\nax2.plot(np.NaN, np.NaN, color='b', label='MNA')\nax2.plot(np.NaN, np.NaN, color='r', label='Franc')\n\nplt.legend()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nLTSpice, SMNA and Franc results agree.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#community-answers-1",
    "href": "Pi-Filter.html#community-answers-1",
    "title": "30  Pi Filter",
    "section": "30.9 Community answers",
    "text": "30.9 Community answers\nBoth comunity answers did not provide a solution based on the FACTS method. Missing was the steps to extract the time constants of the circuit and from there find the zeros of the network.\nThe answer from Franc (2023) replaces each leg of the filter with Z’s and then uses series and parallel equalivent conbinations. As shown above this analysis provides only an approximate solution and probably would not cut the mustard in an acedemic or critical design reviwe.\nThe answer provided by Tesla23 is also suspect and seems wrong. The following calculations walk through some of his steps.\nR, Z1, Z2, Z3 = symbols(‘R Z1 Z2 Z3’)\n\nH_telsa23 = ((R*Z1*Z3)/(R*((Z2+2*Z1)*Z3 + Z1*Z2) + R**2*(Z3+Z2+Z1) + Z1*Z2*Z3)).subs({R:1})\nH_telsa23\n\n\\(\\displaystyle \\frac{Z_{1} Z_{3}}{Z_{1} Z_{2} Z_{3} + Z_{1} Z_{2} + Z_{1} + Z_{2} + Z_{3} \\cdot \\left(2 Z_{1} + Z_{2}\\right) + Z_{3}}\\)\n\n\n\nH_telsa23.simplify()\n\n\\(\\displaystyle \\frac{Z_{1} Z_{3}}{Z_{1} Z_{2} Z_{3} + Z_{1} Z_{2} + Z_{1} + Z_{2} + Z_{3} \\cdot \\left(2 Z_{1} + Z_{2}\\right) + Z_{3}}\\)\n\n\nComparing the results above to my rendition of FACTS, you can see that they are not the same.\n\nH_franc_z.simplify()\n\n\\(\\displaystyle \\frac{Z_{1} Z_{4}}{R_{in} \\left(Z_{1} + Z_{2} + Z_{4}\\right) + Z_{1} \\left(Z_{2} + Z_{4}\\right)}\\)\n\n\nIt’s not worth my time to analyze Tesla23’s answer to determine why there is a difference, especially since the thrust of these notebooks is MNA.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#reduced-complexity-circuit-with-source-and-load-impedance",
    "href": "Pi-Filter.html#reduced-complexity-circuit-with-source-and-load-impedance",
    "title": "30  Pi Filter",
    "section": "30.10 Reduced complexity circuit with source and load impedance",
    "text": "30.10 Reduced complexity circuit with source and load impedance\nThe following analysis finds the transfer function for the circuit below. The parasitic components have been removed from the schematic. The circuit is now a third order circuit. As shown below the poles of the transferfunction expressed symbolically are long and complex. It’s hard to see how a FACTS solution would yield design oriented results.\n\n\n\n\n\n\nFigure 30.3: Pi filter with out parasitics\n\n\n\n\nnet_list = '''\nV1 3 0 1\nR_in 1 3 1\nR_out 2 0 1\nC1 1 0 1\nC2 2 0 1\nL1 1 2 1\n'''\n\n\n30.10.1 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formulated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{L1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{in}}\\right) - \\frac{v_{3}}{R_{in}}\\)\\(0 = - I_{L1} + v_{2} \\left(C_{2} s + \\frac{1}{R_{out}}\\right)\\)\\(0 = I_{V1} - \\frac{v_{1}}{R_{in}} + \\frac{v_{3}}{R_{in}}\\)\\(V_{1} = v_{3}\\)\\(0 = - I_{L1} L_{1} s + v_{1} - v_{2}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  v_{1}, \\  I_{V1}, \\  L_{1}, \\  C_{1}, \\  I_{L1}, \\  v_{2}, \\  C_{2}, \\  R_{out}, \\  V_{1}, \\  v_{3}, \\  R_{in}\\right)\\)\n\n\n\n\n30.10.2 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{2} L_{1} R_{out} V_{1} s^{2} + L_{1} V_{1} s + R_{out} V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\\(v_{2} = \\frac{R_{out} V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\\(v_{3} = V_{1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} L_{1} R_{out} V_{1} s^{3} - C_{1} L_{1} V_{1} s^{2} - C_{1} R_{out} V_{1} s - C_{2} R_{out} V_{1} s - V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\\(I_{L1} = \\frac{C_{2} R_{out} V_{1} s + V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\n\n\n\n\n30.10.3 Transfer function\n\nH_sym_1  = (U_sym[v2]/U_sym[v3]).simplify()\nH_sym_1\n\n\\(\\displaystyle \\frac{R_{out}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\n\n\n\nn, d = fraction(H_sym_1)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle R_{out}\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}\\)\n\n\nSolve for the roots of the denominator\n\nd.simplify().expand().together()\n#d.simplify().expand()\n\n\\(\\displaystyle C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}\\)\n\n\n\nsolve(d,s)\n\n\\(\\displaystyle \\left[ - \\frac{- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}}{3} - \\frac{C_{1} R_{in} + C_{2} R_{out}}{3 C_{1} C_{2} R_{in} R_{out}}, \\  - \\frac{- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}}{3} - \\frac{C_{1} R_{in} + C_{2} R_{out}}{3 C_{1} C_{2} R_{in} R_{out}}, \\  - \\frac{- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}}{3} - \\frac{C_{1} R_{in} + C_{2} R_{out}}{3 C_{1} C_{2} R_{in} R_{out}}\\right]\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#summary",
    "href": "Pi-Filter.html#summary",
    "title": "30  Pi Filter",
    "section": "30.11 Summary",
    "text": "30.11 Summary\n\nFACTS method is applicable to low order circuits, since for higher order circuits, say N greater than 2 or 3, N-element Extra Element Theorem requires a lot of steps. The resultant analytical expression might be useful and insightful since series and parallel combinations of components and their grouping, or the circuit’s time constants, could be preserived in a relational way in the equation.\n\nIn Figure 30.1, a 6th order circuit, analytic expressions for the roots of the poles and zeros would be very long and of doubious utility.\nThe brute force solution for the transfer function of Figure 30.1, was a long expression. SymPy could solve for the roots of the numerator, but not for the denominator.\n\nThe assurtion that brute force is complicated and error prone is not true if computer algebra tools are used. Some of the same proported advantages of using FACTS, that is, less math, less algebra and some insight into the circuit operation are available with SMNA, since the computer does all the heavy lifting.\nPython based symbolic MNA code provides an easy and less error prone method of obtaining analytic solutions to circuit problems.\n\n\n\n\n\nBasso, Christophe. 2016. “Introduction to Fast Analytical Techniques: Application to Small-Signal Modeling.” 2016. https://www.powersimtof.com/Downloads/PPTs/Chris%20Basso%20APEC%20seminar%202016.pdf.\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nMiddlebrook, R. D. 1991. “Low-Entropy Expressions: The Key to Design-Oriented Analysis.” In Proceedings Frontiers in Education Twenty-First Annual Conference. Engineering Education in a New World Order, 399–403. https://doi.org/10.1109/FIE.1991.187513.\n\n\n———. 1992. “Methods of Design-Oriented Analysis: The Quadratic Equation Revisited.” In Proceedings. Twenty-Second Annual Conference Frontiers in Education, 95–102. https://doi.org/10.1109/FIE.1992.683365.\n\n\nuser15174. 2023. “How to Find Transfer Function for This Pi-Filter Using FACTS Method with 6 Reactive Elements?” https://electronics.stackexchange.com/questions/681002/how-to-find-transfer-function-for-this-pi-filter-using-facts-method-with-6-react/681087#681087.\n\n\nVorpérian, Vatché. 2002. Fast Analytical Techniques for Electrical and Electronic Circuits. Cambridge University Press. https://www.cambridge.org/core/books/fast-analytical-techniques-for-electrical-and-electronic-circuits/17845BA88A05A1645A8409D6739A475A#fndtn-information.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "SIDO-low-pass-filter.html",
    "href": "SIDO-low-pass-filter.html",
    "title": "31  SIDO-low-pass-filter",
    "section": "",
    "text": "31.1 Introduction\nThe circuit shown in Figure 31.1, is from an electronics stackexchange question, where user349644 (2023) asks for help in determining the transfer function of the circuit. The circuit appears to be a low pass filter for the differential input to a following stage. I’m calling this circuit a Single-In-Dual-Out (SIDO) filter, where the output is the voltage across C3. An interesting response to the question was provided by Franc (2023), who has provided some interesting solutions to other circuit analysis questions. Usually his solutions are in the from of an image captured from a MathCAD type program consisting of equations, diagrams and plots.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>SIDO-low-pass-filter</span>"
    ]
  },
  {
    "objectID": "SIDO-low-pass-filter.html#circuit-description",
    "href": "SIDO-low-pass-filter.html#circuit-description",
    "title": "31  SIDO-low-pass-filter",
    "section": "31.2 Circuit description",
    "text": "31.2 Circuit description\nThe circuit has nine branches, five nodes and was interned into LTSpice in order to capture the schematic and generate the netlist.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>SIDO-low-pass-filter</span>"
    ]
  },
  {
    "objectID": "SIDO-low-pass-filter.html#circuit-analysis",
    "href": "SIDO-low-pass-filter.html#circuit-analysis",
    "title": "31  SIDO-low-pass-filter",
    "section": "31.3 Circuit analysis",
    "text": "31.3 Circuit analysis\nThe following analysis was performed.\n\nsolve network equations for the transfer function\npole, zero plot\nfrequency response plot\nstep and impusle response\ngroup delay\n\nThe net list for the filter is:\nV1 1 0 1\nC1 1 0 2.2n\nC2 4 5 330p\nC3 2 3 100p\nR1 1 0 100k\nR2 4 1 4.7k\nR3 5 0 4.7k\nR4 2 4 10k\nR5 3 5 10k\nThe following Python modules are used.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n31.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nC1 1 0 2.2e-9\nC2 4 5 330e-12\nC3 2 3 100e-12\nR1 1 0 100e3\nR2 4 1 4.7e3\nR3 5 0 4.7e3\nR4 2 4 10e3\nR5 3 5 10e3\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(- C_{3} s v_{3} + v_{2} \\left(C_{3} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(- C_{3} s v_{2} + v_{3} \\left(C_{3} s + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{R_{5}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}}\\\\- C_{3} s v_{3} + v_{2} \\left(C_{3} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}}\\\\- C_{3} s v_{2} + v_{3} \\left(C_{3} s + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{R_{5}}\\\\- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{2}}\\\\- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{5}}\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{5}, \\  R_{2}, \\  v_{4}, \\  v_{3}, \\  I_{V1}, \\  s, \\  V_{1}, \\  v_{2}, \\  C_{1}, \\  v_{5}, \\  C_{2}, \\  R_{4}, \\  C_{3}, \\  R_{3}, \\  v_{1}, \\  R_{1}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.2 \\cdot 10^{-9}, \\  C_{2} : 3.3 \\cdot 10^{-10}, \\  C_{3} : 1.0 \\cdot 10^{-10}, \\  R_{1} : 100000.0, \\  R_{2} : 4700.0, \\  R_{3} : 4700.0, \\  R_{4} : 10000.0, \\  R_{5} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nGenerate the symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s + C_{3} R_{5} V_{1} s + V_{1}}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(v_{3} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s + C_{3} R_{5} V_{1} s}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(v_{4} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s + C_{3} R_{4} V_{1} s + C_{3} R_{5} V_{1} s + V_{1}}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(v_{5} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} R_{1} R_{2} R_{4} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{2} R_{5} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} R_{4} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} R_{5} V_{1} s^{3} - C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} - C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{2} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{3} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{4} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{5} V_{1} s^{2} - C_{1} R_{1} V_{1} s - C_{2} C_{3} R_{1} R_{4} V_{1} s^{2} - C_{2} C_{3} R_{1} R_{5} V_{1} s^{2} - C_{2} C_{3} R_{2} R_{4} V_{1} s^{2} - C_{2} C_{3} R_{2} R_{5} V_{1} s^{2} - C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} - C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} - C_{2} R_{1} V_{1} s - C_{2} R_{2} V_{1} s - C_{2} R_{3} V_{1} s - C_{3} R_{1} V_{1} s - C_{3} R_{2} V_{1} s - C_{3} R_{3} V_{1} s - C_{3} R_{4} V_{1} s - C_{3} R_{5} V_{1} s - V_{1}}{C_{2} C_{3} R_{1} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{1} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{1} R_{3} R_{5} s^{2} + C_{2} R_{1} R_{2} s + C_{2} R_{1} R_{3} s + C_{3} R_{1} R_{2} s + C_{3} R_{1} R_{3} s + C_{3} R_{1} R_{4} s + C_{3} R_{1} R_{5} s + R_{1}}\\)\n\n\nTransfer function\n\nH_sym = ((U_sym[v2]-U_sym[v3])/U_sym[v1]).nsimplify().simplify().expand().together()\nH_sym\n\n\\(\\displaystyle \\frac{1}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\n\n\n\ncancel(H_sym,s)\n\n\\(\\displaystyle \\frac{1}{s^{2} \\left(C_{2} C_{3} R_{2} R_{4} + C_{2} C_{3} R_{2} R_{5} + C_{2} C_{3} R_{3} R_{4} + C_{2} C_{3} R_{3} R_{5}\\right) + s \\left(C_{2} R_{2} + C_{2} R_{3} + C_{3} R_{2} + C_{3} R_{3} + C_{3} R_{4} + C_{3} R_{5}\\right) + 1}\\)\n\n\n\nH_sym_num, H_sym_denom = fraction(H_sym) #returns numerator and denominator\n\n\nsolve(H_sym_denom,s)\n\n\\(\\displaystyle \\left[ \\frac{- C_{2} R_{2} - C_{2} R_{3} - C_{3} R_{2} - C_{3} R_{3} - C_{3} R_{4} - C_{3} R_{5} - \\sqrt{C_{2}^{2} R_{2}^{2} + 2 C_{2}^{2} R_{2} R_{3} + C_{2}^{2} R_{3}^{2} + 2 C_{2} C_{3} R_{2}^{2} + 4 C_{2} C_{3} R_{2} R_{3} - 2 C_{2} C_{3} R_{2} R_{4} - 2 C_{2} C_{3} R_{2} R_{5} + 2 C_{2} C_{3} R_{3}^{2} - 2 C_{2} C_{3} R_{3} R_{4} - 2 C_{2} C_{3} R_{3} R_{5} + C_{3}^{2} R_{2}^{2} + 2 C_{3}^{2} R_{2} R_{3} + 2 C_{3}^{2} R_{2} R_{4} + 2 C_{3}^{2} R_{2} R_{5} + C_{3}^{2} R_{3}^{2} + 2 C_{3}^{2} R_{3} R_{4} + 2 C_{3}^{2} R_{3} R_{5} + C_{3}^{2} R_{4}^{2} + 2 C_{3}^{2} R_{4} R_{5} + C_{3}^{2} R_{5}^{2}}}{2 C_{2} C_{3} \\left(R_{2} R_{4} + R_{2} R_{5} + R_{3} R_{4} + R_{3} R_{5}\\right)}, \\  \\frac{- C_{2} R_{2} - C_{2} R_{3} - C_{3} R_{2} - C_{3} R_{3} - C_{3} R_{4} - C_{3} R_{5} + \\sqrt{C_{2}^{2} R_{2}^{2} + 2 C_{2}^{2} R_{2} R_{3} + C_{2}^{2} R_{3}^{2} + 2 C_{2} C_{3} R_{2}^{2} + 4 C_{2} C_{3} R_{2} R_{3} - 2 C_{2} C_{3} R_{2} R_{4} - 2 C_{2} C_{3} R_{2} R_{5} + 2 C_{2} C_{3} R_{3}^{2} - 2 C_{2} C_{3} R_{3} R_{4} - 2 C_{2} C_{3} R_{3} R_{5} + C_{3}^{2} R_{2}^{2} + 2 C_{3}^{2} R_{2} R_{3} + 2 C_{3}^{2} R_{2} R_{4} + 2 C_{3}^{2} R_{2} R_{5} + C_{3}^{2} R_{3}^{2} + 2 C_{3}^{2} R_{3} R_{4} + 2 C_{3}^{2} R_{3} R_{5} + C_{3}^{2} R_{4}^{2} + 2 C_{3}^{2} R_{4} R_{5} + C_{3}^{2} R_{5}^{2}}}{2 C_{2} C_{3} \\left(R_{2} R_{4} + R_{2} R_{5} + R_{3} R_{4} + R_{3} R_{5}\\right)}\\right]\\)\n\n\n\n\n31.3.2 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(2.2 \\cdot 10^{-9} s + 0.000222765957446809\\right) - 0.000212765957446809 v_{4}\\\\- 1.0 \\cdot 10^{-10} s v_{3} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-10} s + 0.0001\\right) - 0.0001 v_{4}\\\\- 1.0 \\cdot 10^{-10} s v_{2} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-10} s + 0.0001\\right) - 0.0001 v_{5}\\\\- 3.3 \\cdot 10^{-10} s v_{5} - 0.000212765957446809 v_{1} - 0.0001 v_{2} + v_{4} \\cdot \\left(3.3 \\cdot 10^{-10} s + 0.000312765957446809\\right)\\\\- 3.3 \\cdot 10^{-10} s v_{4} - 0.0001 v_{3} + v_{5} \\cdot \\left(3.3 \\cdot 10^{-10} s + 0.000312765957446809\\right)\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\nU\n\n\\(\\displaystyle \\left\\{ I_{V1} : \\frac{- 1.452 \\cdot 10^{18} s^{3} - 1.49089787234043 \\cdot 10^{24} s^{2} - 2.86214893617021 \\cdot 10^{29} s - 1.06382978723394 \\cdot 10^{33}}{6.6 \\cdot 10^{26} s^{2} + 6.42765957446809 \\cdot 10^{32} s + 1.06382978723404 \\cdot 10^{38}}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{660000000.0 s^{2} + 642765957446809.0 s + 2.12765957446809 \\cdot 10^{20}}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}, \\  v_{3} : \\frac{660000000.0 s^{2} + 642765957446809.0 s}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}, \\  v_{4} : \\frac{330000000.0 s^{2} + 427765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}, \\  v_{5} : \\frac{330000000.0 s^{2} + 215000000000000.0 s}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}\\right\\}\\)\n\n\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{660000000.0 s^{2} + 642765957446809.0 s + 2.12765957446809 \\cdot 10^{20}}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}\\)\\(v_{3} = \\frac{660000000.0 s^{2} + 642765957446809.0 s}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}\\)\\(v_{4} = \\frac{330000000.0 s^{2} + 427765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}\\)\\(v_{5} = \\frac{330000000.0 s^{2} + 215000000000000.0 s}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}\\)\\(I_{V1} = \\frac{- 1.452 \\cdot 10^{18} s^{3} - 1.49089787234043 \\cdot 10^{24} s^{2} - 2.86214893617021 \\cdot 10^{29} s - 1.06382978723394 \\cdot 10^{33}}{6.6 \\cdot 10^{26} s^{2} + 6.42765957446809 \\cdot 10^{32} s + 1.06382978723404 \\cdot 10^{38}}\\)\n\n\n\nH = ((U[v2]-U[v3])/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{10638297872340450000}{66000000 s^{2} + 64276595744681 s + 10638297872340450000}\\)\n\n\n\n31.3.2.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n\n31.3.3 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n31.3.3.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-121,354.74 Hz\n-33,644.32 Hz\n\n\n\n\n\n31.3.4 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nx = np.logspace(3, 8, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n31.3.5 Filter impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n31.3.6 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nuser349644. 2023. “Transfer Function of the Below Circuit.” https://electronics.stackexchange.com/questions/682389/transfer-function-of-the-below-circuit.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>SIDO-low-pass-filter</span>"
    ]
  },
  {
    "objectID": "Super-node.html",
    "href": "Super-node.html",
    "title": "32  Super node",
    "section": "",
    "text": "32.1 Load the net list\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\nnet_list = '''\nV1 1 3 36\nI1 0 1 12\nI2 2 0 18\nI3 0 3 24\nR1 1 0 4\nR4 3 0 6\nR2 2 1 12\nR3 3 2 15\n'''",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Super node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "Super-node.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "32  Super node",
    "section": "32.2 Call the symbolic modified nodal analysis function",
    "text": "32.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = I_{1}\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = - I_{2}\\)\\(- I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = I_{3}\\)\\(v_{1} - v_{3} = V_{1}\\)\n\n\n\n32.2.1 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\- I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}}\\\\v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\- I_{2}\\\\I_{3}\\\\V_{1}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{3}, \\  v_{2}, \\  I_{2}, \\  I_{1}, \\  R_{2}, \\  R_{4}, \\  V_{1}, \\  I_{3}, \\  v_{3}, \\  v_{1}, \\  R_{1}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Super node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#symbolic-solution",
    "href": "Super-node.html#symbolic-solution",
    "title": "32  Super node",
    "section": "32.3 Symbolic solution",
    "text": "32.3 Symbolic solution\nThe newtork equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{I_{1} R_{1} R_{4} - I_{2} R_{1} R_{4} + I_{3} R_{1} R_{4} + R_{1} V_{1}}{R_{1} + R_{4}}\\)\\(v_{2} = \\frac{I_{1} R_{1} R_{2} R_{4} + I_{1} R_{1} R_{3} R_{4} - I_{2} R_{1} R_{2} R_{3} - I_{2} R_{1} R_{2} R_{4} - I_{2} R_{1} R_{3} R_{4} - I_{2} R_{2} R_{3} R_{4} + I_{3} R_{1} R_{2} R_{4} + I_{3} R_{1} R_{3} R_{4} + R_{1} R_{3} V_{1} - R_{2} R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(v_{3} = \\frac{I_{1} R_{1} R_{4} - I_{2} R_{1} R_{4} + I_{3} R_{1} R_{4} - R_{4} V_{1}}{R_{1} + R_{4}}\\)\\(I_{V1} = \\frac{I_{1} R_{1} R_{2} + I_{1} R_{1} R_{3} - I_{2} R_{1} R_{3} + I_{2} R_{2} R_{4} - I_{3} R_{2} R_{4} - I_{3} R_{3} R_{4} - R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1} - R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Super node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#construct-a-dictionary-of-element-values",
    "href": "Super-node.html#construct-a-dictionary-of-element-values",
    "title": "32  Super node",
    "section": "32.4 Construct a dictionary of element values",
    "text": "32.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 12.0, \\  I_{2} : 18.0, \\  I_{3} : 24.0, \\  R_{1} : 4.0, \\  R_{2} : 12.0, \\  R_{3} : 15.0, \\  R_{4} : 6.0, \\  V_{1} : 36.0\\right\\}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Super node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#numerical-solution",
    "href": "Super-node.html#numerical-solution",
    "title": "32  Super node",
    "section": "32.5 Numerical solution",
    "text": "32.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.333333333333333 v_{1} - 0.0833333333333333 v_{2}\\\\- 0.0833333333333333 v_{1} + 0.15 v_{2} - 0.0666666666666667 v_{3}\\\\- I_{V1} - 0.0666666666666667 v_{2} + 0.233333333333333 v_{3}\\\\v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}12.0\\\\-18.0\\\\24.0\\\\36.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution. Six significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          57.600000\nv2         -78.400000\nv3          21.600000\nI_V1       -13.733333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\n\n\n\n\nMalek, Ihdene. 2020. “Eliminating Ideal Voltage Source for Node Analysis.” Electrical Engineering Stack Exchange. https://electronics.stackexchange.com/q/479528.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Super node</span>"
    ]
  },
  {
    "objectID": "Phasor-analysis.html",
    "href": "Phasor-analysis.html",
    "title": "33  Phasor analysis",
    "section": "",
    "text": "33.0.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\ncomponet values are set to 1, later to values used in the problem\nnet_list = '''\nV1 1 0 1\nV2 0 3 1\nV3 5 0 1\nR1 2 1 1\nR2 4 2 1\nR3 3 2 1\nR4 0 4 1\nR5 5 4 1\n'''\nGenerate the network equations.\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- I_{V2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{3}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{5}} - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V3} - \\frac{v_{4}}{R_{5}} + \\frac{v_{5}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} = V_{2}\\)\\(v_{5} = V_{3}\\)\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\\\- I_{V2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{3}}{R_{3}}\\\\v_{4} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{5}} - \\frac{v_{2}}{R_{2}}\\\\I_{V3} - \\frac{v_{4}}{R_{5}} + \\frac{v_{5}}{R_{5}}\\\\v_{1}\\\\- v_{3}\\\\v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\V_{3}\\end{matrix}\\right]\\)\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{5}, \\  R_{2}, \\  V_{3}, \\  v_{4}, \\  v_{3}, \\  I_{V3}, \\  R_{5}, \\  V_{2}, \\  V_{1}, \\  R_{1}, \\  R_{3}, \\  I_{V1}, \\  R_{4}, \\  v_{2}, \\  v_{1}, \\  I_{V2}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Phasor analysis</span>"
    ]
  },
  {
    "objectID": "Phasor-analysis.html#symbolic-solution",
    "href": "Phasor-analysis.html#symbolic-solution",
    "title": "33  Phasor analysis",
    "section": "33.1 Symbolic solution",
    "text": "33.1 Symbolic solution\nThe newtork equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{1} R_{2} R_{4} V_{2} - R_{1} R_{2} R_{5} V_{2} + R_{1} R_{3} R_{4} V_{3} - R_{1} R_{4} R_{5} V_{2} + R_{2} R_{3} R_{4} V_{1} + R_{2} R_{3} R_{5} V_{1} + R_{3} R_{4} R_{5} V_{1}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(v_{3} = - V_{2}\\)\\(v_{4} = \\frac{R_{1} R_{2} R_{4} V_{3} + R_{1} R_{3} R_{4} V_{3} - R_{1} R_{4} R_{5} V_{2} + R_{2} R_{3} R_{4} V_{3} + R_{3} R_{4} R_{5} V_{1}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(v_{5} = V_{3}\\)\\(I_{V1} = \\frac{- R_{2} R_{4} V_{1} - R_{2} R_{4} V_{2} - R_{2} R_{5} V_{1} - R_{2} R_{5} V_{2} - R_{3} R_{4} V_{1} + R_{3} R_{4} V_{3} - R_{3} R_{5} V_{1} - R_{4} R_{5} V_{1} - R_{4} R_{5} V_{2}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(I_{V2} = \\frac{- R_{1} R_{4} V_{2} - R_{1} R_{4} V_{3} - R_{1} R_{5} V_{2} - R_{2} R_{4} V_{1} - R_{2} R_{4} V_{2} - R_{2} R_{5} V_{1} - R_{2} R_{5} V_{2} - R_{4} R_{5} V_{1} - R_{4} R_{5} V_{2}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(I_{V3} = \\frac{- R_{1} R_{2} V_{3} - R_{1} R_{3} V_{3} - R_{1} R_{4} V_{2} - R_{1} R_{4} V_{3} - R_{2} R_{3} V_{3} + R_{3} R_{4} V_{1} - R_{3} R_{4} V_{3}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Phasor analysis</span>"
    ]
  },
  {
    "objectID": "Phasor-analysis.html#phasor-analysis",
    "href": "Phasor-analysis.html#phasor-analysis",
    "title": "33  Phasor analysis",
    "section": "33.2 Phasor analysis",
    "text": "33.2 Phasor analysis\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{4} : 1.0, \\  R_{5} : 1.0, \\  V_{1} : 1.0, \\  V_{2} : 1.0, \\  V_{3} : 1.0\\right\\}\\)\n\n\n\nelement_values[V1] = polar2rec(10, 0, units='deg')\nelement_values[V2] = polar2rec(10, 30, units='deg')\nelement_values[V3] = polar2rec(5, 0, units='deg')\n\nelement_values[R1] = 10\nelement_values[R2] = 4+4j\nelement_values[R3] = 5j\nelement_values[R4] = 6-8j\nelement_values[R5] = 5\n\nSolve equations for \\(\\omega\\) equal to 1. Then display the network equations with numerical values.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{10} - \\frac{v_{2}}{10}\\\\- \\frac{v_{1}}{10} + v_{2} \\cdot \\left(\\frac{1}{10} - 0.2 i + 0.03125 \\cdot \\left(4.0 - 4.0 i\\right)\\right) + 0.2 i v_{3} - 0.03125 v_{4} \\cdot \\left(4.0 - 4.0 i\\right)\\\\- I_{V2} + 0.2 i v_{2} - 0.2 i v_{3}\\\\- 0.03125 v_{2} \\cdot \\left(4.0 - 4.0 i\\right) + v_{4} \\cdot \\left(\\frac{1}{5} + 0.03125 \\cdot \\left(4.0 - 4.0 i\\right) + 0.01 \\cdot \\left(6.0 + 8.0 i\\right)\\right) - \\frac{v_{5}}{5}\\\\I_{V3} - \\frac{v_{4}}{5} + \\frac{v_{5}}{5}\\\\v_{1}\\\\- v_{3}\\\\v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\8.66025403784439 + 5.0 i\\\\5.0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU = solve(NE,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1         10.000000      0.000000\nv2          4.574219    124.771754\nv3         10.000000   -150.000000\nv4          3.594255     41.498814\nv5          5.000000      0.000000\nI_V1        1.315666    163.405921\nI_V2        2.128974    145.354766\nI_V3        0.663289    134.101376\n\n\nThe LTSpice circuit was re-drawn with the components indicated. Inductor series resistance was set to zero.\n\n\n\n\n\n\nFigure 33.2: restated circuit\n\n\n\nV1 1 0 AC 10 0\nV2 0 3 AC 10 30\nV3 5 0 AC 5 0\nR1 2 1 10\nR2 6 2 4\nR4 7 4 6\nR5 5 4 5\nL1 2 3 5 Rser=0\nL2 6 4 4 Rser=0\nC1 7 0 0.125\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:         10 phase: -2.54444e-15°    voltage\nV(3):   mag:         10 phase:       -150°  voltage\nV(5):   mag:          5 phase: -5.08889e-15°    voltage\nV(2):   mag:    4.57422 phase:    124.772°  voltage\nV(6):   mag:   0.770294 phase:    147.035°  voltage\nV(7):   mag:     2.8754 phase:    4.62894°  voltage\nV(4):   mag:    3.59425 phase:    41.4988°  voltage\nI(C1):  mag:   0.359425 phase:    94.6289°  device_current\nI(L1):  mag:    2.12897 phase:   -34.6452°  device_current\nI(L2):  mag:   0.968091 phase:     120.45°  device_current\nI(R1):  mag:    1.31567 phase:    163.406°  device_current\nI(R2):  mag:   0.968091 phase:   -59.5504°  device_current\nI(R4):  mag:   0.359425 phase:   -85.3711°  device_current\nI(R5):  mag:   0.663289 phase:   -45.8986°  device_current\nI(V1):  mag:    1.31567 phase:    163.406°  device_current\nI(V2):  mag:    2.12897 phase:    145.355°  device_current\nI(V3):  mag:   0.663289 phase:    134.101°  device_current\n\n\n\n\n\nuser69860. 2016. “Nodal Analysis - Deriving Equations at Each Node.” https://electronics.stackexchange.com/q/192420.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Phasor analysis</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html",
    "href": "Modeling Op Amps.html",
    "title": "34  Modeling Op Amps",
    "section": "",
    "text": "34.1 Introduction\nThe Operational Amplifier or Op Amp, is type of electronic amplifier that has two input terminals, amplifies the voltage difference between the two input terminals while suppresses any voltage common to the two inputs and is usually operated with negative feedback to control the gain of the amplifier. The amplifier typically has a very high differential mode gain, high input impedance and low output impedance. Today Op Amps are commonly impemnted in an intergrated circuit that can contain hundreds of transistors. The Op Amp is included in my sysmbolic MNA code as one of the element types along with resistors, capacitors, inductors, dependent sources and independednt sources.\nThe schematic symbol for an Op Amp is shown in Figure 34.1. The two input terminals are labled \\(V-\\) and \\(V+\\). The \\(V-\\) terminal is called the inverting input and \\(V+\\) is called the non-inverting input. \\(V_{out}\\) is the output terminal of the amplifier. An input on the \\(V+\\) terminal causes an in phase output and an input on the \\(V-\\) terminal causes an out of phase output. Not shown, but implied, are power supply and or ground connections. The datasheet for the particular model of Op Amp will show other connections.\nOp Amps are very versitile and are used in many types of circuits. A web search will uncover many examples and a few are listed below:\nThe first mass-produced Op Amp, in 1953, was the vacuum tube-based K2-W from GAP/R. The first widely available integrated circuit Op Amp was the Fairchild μA709 operational amplifier, designed by Bob Widlar in 1965. In 1968, the μA709 was replaced by the μA741, which offered better performance while being more stable and easier to setup. A modern version of the μA741 is produced by Texas Instruments, with the part number LM741.\nThere are more than 30 semiconductor manufactures making general purpose Op Amps priced as low as $0.30 each in small quantities. Under the general purpose catagory, there are thousands of part numbers avaliable from distributers such as Digikey. The world wide market for Op Amps is about $6 billion dollars.\nOp Amps can be configured to operate in circuits without feedback, which is how a comparitor works. Some applications configure the Op Amp to have positive feedback and Schmitt trigger is an example of this type of configureation. When the Op Amp is used without feedback or with positive feedback, the amplifier is operating as a non-linear device and non-linear circuits cannot be analyized with the Python MNA code presented in this book.\nOnly negative feedback Op Amp circuits are supported by the Python MNA code. These circuit configurations typically use resistors to connect the output terminal of the Op Amp to the inverting terminal of the Op Amp. When Op Amps are included in circuits to be analyzed using MNA, the Op Amp model used has negative feed back implied, reguardless of whether such feedback is actually present in the circuit. This is discussed below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#introduction",
    "href": "Modeling Op Amps.html#introduction",
    "title": "34  Modeling Op Amps",
    "section": "",
    "text": "Operational Amplifier Applications\nAmplifier Circuit Collection\nCollection of Amp Applications\nHandbook of Operational Amplifier Applications\nOp Amps for Everyone, Ron Mancini",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#the-ideal-op-amp",
    "href": "Modeling Op Amps.html#the-ideal-op-amp",
    "title": "34  Modeling Op Amps",
    "section": "34.2 The ideal Op Amp",
    "text": "34.2 The ideal Op Amp\nThe concept of an ideal Op Amp is used when performance limitations of real Op Amps are ignored in order to symplify the circuit analysis. Often the performance limitions of real Op Amps have only minor effects on the operation of the circuit and the engineer will use their judgment to decide if the second order effects of these limitions need to be considered. The ideal Op Amp is described by Equation 34.1. The Op Amp’s inputs consist of a non-inverting input \\(V+\\) and an inverting input \\(V-\\), as shown in Figure 34.1. The Op Amp amplifies only the difference in voltage between the two inputs, which is called the differential input voltage. The power supply terminals of a real Op Amp are not included in the model of an ideal Op Amp.\nThe output voltage of the Op Amp \\(V_{out}\\) is given by the equation:\n\\[V_{out} = A_{OL}(V_+ - V_-) \\tag{34.1}\\]\nWhere \\(A_{OL}\\) is the open-loop gain of the amplifier. The value of the open loop gain in real Op Amps is very large, sometimes on the order of 100 dB. The value of \\(A_{OL}\\) in ideal Op Amps is not needed when the Op Amp is configured with negative feedback. The components in the feedback path determine the gain of the Op Amp circuit independednt of \\(A_{OL}\\).\nThe ideal Op Amp has other charasterics such as:\n\nInfinite gain and bandwidth\nZero output impedance\nInfinite input impedance\nZero volts between the two inputs\nInfinite output voltage range\nInfinite bandwidth with zero phase shift and infinite slew rate\nZero noise\nInfinite common-mode rejection ratio",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#mna-op-amp-stamp",
    "href": "Modeling Op Amps.html#mna-op-amp-stamp",
    "title": "34  Modeling Op Amps",
    "section": "34.3 MNA Op Amp stamp",
    "text": "34.3 MNA Op Amp stamp\nMNA is an algorithic procedure for generating network equations. When there is an element type ‘O’, in the netlist, three connection nodes are required. The first node is the inverting input, the second node is the non inverting input and the third node is the output node. The Python code, then makes entries into the B and C matricies based simply on the node numbers of the Op Amp terminals. This is called stamping the matrix, because for each component type a specific template is used.\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The Op Amp model has one unknown current for the output current. In the code that builds the B matrix, a value of 1 is included in the matrix at the index position given by the Op Amp output node number. The snippit of code that performes this operation is shown below.\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    :\n    :\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    :\n    :\nEach Op Amp the entry in the B matrix lines up with an unknown current in the X vector.\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements. The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and for Op Amps, a 1 is inserted for the non-inverting node and a -1 for the inverting node, unless the terminal is connected to ground. The code snippit is shown below.\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    :\n    :\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n    :\n    :\nThe above code mathematically equates the voltages at the input input terminals equal to each other, \\(v_n = v_m\\), where n and m are the node numbers. By default, the MNA Op Amp model is operating as if negative feedback is present in the circuit, reguardless of whether such feedback is actually present in the surrounding network. The Python MNA code does not verify that the Op Amp has negative feedback applied by the surrounding network. Consequencely, the Python MNA code is agnostic with reguard to feedback and which input terminal is used. The Python MNA code Op Amp model should be used with some care and the results need to be checked.\nThe Nullor is a two port device which can be used to model ideal Op Amps. The Python NMA Op Amp and the Nullor have the same NMA stamp and are equalivent.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#op-amp-feedback-test-circuit",
    "href": "Modeling Op Amps.html#op-amp-feedback-test-circuit",
    "title": "34  Modeling Op Amps",
    "section": "34.4 Op Amp feedback test circuit",
    "text": "34.4 Op Amp feedback test circuit\nThe circuit in Figure 34.2 is used to examine various Op Amp feedback connections. The following Op Amp circuits with various elements in the feedback path are examined below.\n\nNo feedback\nR in the feed back path\nSwap Op Amp input connections\nC in feedback path\nC and R in parallel in feedback path\n5a. C and R in series in feedback path\nL in feedback path\nL and R in series in the feedback path\nL and R in parallel in the feedback path\n\nThe following Python modules are used in this notebook.\n\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#op-amp-test-circuit",
    "href": "Modeling Op Amps.html#op-amp-test-circuit",
    "title": "34  Modeling Op Amps",
    "section": "34.5 Op Amp test circuit",
    "text": "34.5 Op Amp test circuit\nAn Op Amp test circuit, shown below, is used to explore various feedback configurations. A resistor is used to terminate each Op Amp terminal. A DC voltage source, V1, is used as the stimulus to the circuit and all the resistor values are set to one.\n\n\n\n\n\n\nFigure 34.2: Op Amp test circuit",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-1-no-feedback",
    "href": "Modeling Op Amps.html#case-1-no-feedback",
    "title": "34  Modeling Op Amps",
    "section": "34.6 Case 1: No feedback",
    "text": "34.6 Case 1: No feedback\nThe net list for Figure 34.2 was obtained from LTSpice.\n\nnet_list1 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A1, X1, Z1 = SymMNA.smna(net_list1)\n\n# Put matricies into SymPy \nX1 = Matrix(X1)\nZ1 = Matrix(Z1)\n\nNE1_sym = Eq(A1*X1,Z1)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X1)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A1*X1)[i:i+1][0],Z1[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(- \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nShown above are the six equations generatated by NMA. The last three equations are rather simple.\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE1_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  v_{1}, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nAttemp to solve the equations.\n\nU1_sym = solve(NE1_sym,X1)\nU1_sym\n\n\\(\\displaystyle \\left[ \\right]\\)\n\n\nNo solution is found. By inspection we can see that there are three equations:\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(- \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\nand four knowns: \\(v_2\\), \\(v_3\\), \\(I_{V1}\\) and \\(I_{O1}\\).\nSo without a connection from node 2 to the rest of the network, the voltage and current at node 2 cannot be solved for.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-2-r-in-the-feed-back-path",
    "href": "Modeling Op Amps.html#case-2-r-in-the-feed-back-path",
    "title": "34  Modeling Op Amps",
    "section": "34.7 Case 2: R in the feed back path",
    "text": "34.7 Case 2: R in the feed back path\nR added to network between nodes 2 and 3, by manually editing the netlist below.\n\nnet_list2 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A2, X2, Z2 = SymMNA.smna(net_list2)\n\n# Put matricies into SymPy \nX2 = Matrix(X2)\nZ2 = Matrix(Z2)\n\nNE2_sym = Eq(A2*X2,Z2)\n\nBoth case 1 and case 2 have a 6 by 6 A matrix, but R shows up in the off diagonal in case 2.\n\nA2\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0\\\\0 & \\frac{1}{R_{3}} + \\frac{1}{R} & - \\frac{1}{R} & 0 & 0 & 1\\\\- \\frac{1}{R_{1}} & - \\frac{1}{R} & \\frac{1}{R_{1}} + \\frac{1}{R} & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{2}} & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 1 & -1 & 0 & 0\\end{matrix}\\right]\\)\n\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X2)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A2*X2)[i:i+1][0],Z2[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE2_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU2_sym = solve(NE2_sym,X2)\n\ntemp = ''\nfor i in U2_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U2_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{R V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{R V_{1} + R_{3} V_{1}}{R_{1} R_{3}}\\)\n\n\nNotice that \\(v_3\\) and \\(v_4\\) are both zero volts. There is no current flowing into the Op Amp input terminals.\nSolving for the transfer function at node 2.\n\nH2_sym = U2_sym[v2]/U2_sym[v1]\nH2_sym #.simplify()\n\n\\(\\displaystyle - \\frac{R}{R_{1}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-3-swap-op-amp-input-connections",
    "href": "Modeling Op Amps.html#case-3-swap-op-amp-input-connections",
    "title": "34  Modeling Op Amps",
    "section": "34.8 Case 3: Swap Op Amp input connections",
    "text": "34.8 Case 3: Swap Op Amp input connections\nAs discussed above, the MNA code equates the voltages at the Op Amps input terminals. This implies that there is negative feedback present in the circuit. Because the voltage at thes terminal are equal, there is no distinction between the two as far as a mathematical solution to the network equations is concerned. This is illustrated below.\n\nnet_list3 = '''\nV1 1 0 1\n*O1 3 4 2\nO1 4 3 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A3, X3, Z3 = SymMNA.smna(net_list3)\n\n# Put matricies into SymPy \nX3 = Matrix(X3)\nZ3 = Matrix(Z3)\n\nNE3_sym = Eq(A3*X3,Z3)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X3)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A3*X3)[i:i+1][0],Z3[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} + v_{4} = 0\\)\n\n\nLast equation,\n\\(- v_{3} + v_{4} = 0\\)\nis identical anlgebracily to the equation generated in Case 1 above, which is:\n\\(v_{3} - v_{4} = 0\\)\nThis shows that because the Op Amp model defines \\(V+\\) and \\(V-\\) to be equal, the terminals of the NMA Op Amp model can be swapped.\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE3_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU3_sym = solve(NE3_sym,X3)\n\ntemp = ''\nfor i in U3_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U3_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{R V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{R V_{1} + R_{3} V_{1}}{R_{1} R_{3}}\\)\n\n\nNotice that \\(v_3\\) and \\(v_4\\) are both zero volts. There is no current flowing into the Op Amp input terminals.\nSolving for the transfer function at node 2.\n\nH3_sym = U3_sym[v2]/U3_sym[v1]\nH3_sym #.simplify()\n\n\\(\\displaystyle - \\frac{R}{R_{1}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-4-c-in-feedback-path",
    "href": "Modeling Op Amps.html#case-4-c-in-feedback-path",
    "title": "34  Modeling Op Amps",
    "section": "34.9 Case 4: C in feedback path",
    "text": "34.9 Case 4: C in feedback path\n\nnet_list4 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nC 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A4, X4, Z4 = SymMNA.smna(net_list4)\n\n# Put matricies into SymPy \nX4 = Matrix(X4)\nZ4 = Matrix(Z4)\n\nNE4_sym = Eq(A4*X4,Z4)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X4)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A4*X4)[i:i+1][0],Z4[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C s v_{3} + I_{O1} + v_{2} \\left(C s + \\frac{1}{R_{3}}\\right) = 0\\)\\(- C s v_{2} + v_{3} \\left(C s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE4_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  C, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU4_sym = solve(NE4_sym,X4)\n\ntemp = ''\nfor i in U4_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U4_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{V_{1}}{C R_{1} s}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{C R_{3} V_{1} s + V_{1}}{C R_{1} R_{3} s}\\)\n\n\nSolving for the transfer function at node 2.\n\nU4_sym[v2]/U4_sym[v1]\n\n\\(\\displaystyle - \\frac{1}{C R_{1} s}\\)\n\n\nSeems correct.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-5-c-and-r-in-parallel-in-feedback-path",
    "href": "Modeling Op Amps.html#case-5-c-and-r-in-parallel-in-feedback-path",
    "title": "34  Modeling Op Amps",
    "section": "34.10 Case 5: C and R in parallel in feedback path",
    "text": "34.10 Case 5: C and R in parallel in feedback path\n\nnet_list5 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nC 2 3 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A5, X5, Z5 = SymMNA.smna(net_list5)\n\n# Put matricies into SymPy \nX5 = Matrix(X5)\nZ5 = Matrix(Z5)\n\nNE5_sym = Eq(A5*X5,Z5)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X5)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A5*X5)[i:i+1][0],Z5[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\left(C s + \\frac{1}{R_{3}} + \\frac{1}{R}\\right) + v_{3} \\left(- C s - \\frac{1}{R}\\right) = 0\\)\\(v_{2} \\left(- C s - \\frac{1}{R}\\right) + v_{3} \\left(C s + \\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE5_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  C, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU5_sym = solve(NE5_sym,X5)\n\ntemp = ''\nfor i in U5_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U5_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{R V_{1}}{C R R_{1} s + R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{C R R_{3} V_{1} s + R V_{1} + R_{3} V_{1}}{C R R_{1} R_{3} s + R_{1} R_{3}}\\)\n\n\nSolving for the transfer function at node 2.\n\nU5_sym[v2]/U5_sym[v1]\n\n\\(\\displaystyle - \\frac{R}{C R R_{1} s + R_{1}}\\)\n\n\nAt \\(s=0\\) the transfer function reduces correctly to the DC case. For \\(s=\\infty\\), the capacitor is a short and equation is not correct, but then the circuit now has a short accross R and this is not reflected in the netlist. So at \\(s=\\infty\\), the solution needs some interperation and maybe the netlist needs to edited to correctly reflect the value of \\(Z_c\\) at \\(\\infty\\).\nThe result seems correct for \\(s \\ne \\infty\\).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-5a-c-and-r-in-series-in-feedback-path",
    "href": "Modeling Op Amps.html#case-5a-c-and-r-in-series-in-feedback-path",
    "title": "34  Modeling Op Amps",
    "section": "34.11 Case 5a: C and R in series in feedback path",
    "text": "34.11 Case 5a: C and R in series in feedback path\n\nnet_list5a = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nC 2 5 1\nR 3 5 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A5a, X5a, Z5a = SymMNA.smna(net_list5a)\n\n# Put matricies into SymPy \nX5a = Matrix(X5a)\nZ5a = Matrix(Z5a)\n\nNE5a_sym = Eq(A5a*X5a,Z5a)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X5a)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A5a*X5a)[i:i+1][0],Z5a[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C s v_{5} + I_{O1} + v_{2} \\left(C s + \\frac{1}{R_{3}}\\right) = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{5}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(- C s v_{2} + v_{5} \\left(C s + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE5a_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  v_{4}, \\  V_{1}, \\  C, \\  R_{1}, \\  v_{5}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU5a_sym = solve(NE5a_sym,X5a)\n\ntemp = ''\nfor i in U5a_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U5a_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C R V_{1} s - V_{1}}{C R_{1} s}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(v_{5} = - \\frac{R V_{1}}{R_{1}}\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{C R V_{1} s + C R_{3} V_{1} s + V_{1}}{C R_{1} R_{3} s}\\)\n\n\nSolving for the transfer function at node 2.\n\n(U5a_sym[v2]/U5a_sym[v1]).simplify()\n\n\\(\\displaystyle - \\frac{R}{R_{1}} - \\frac{1}{C R_{1} s}\\)\n\n\nThe result seems correct.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-6-l-in-feedback-path",
    "href": "Modeling Op Amps.html#case-6-l-in-feedback-path",
    "title": "34  Modeling Op Amps",
    "section": "34.12 Case 6: L in feedback path",
    "text": "34.12 Case 6: L in feedback path\n\nnet_list6 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nL 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A6, X6, Z6 = SymMNA.smna(net_list6)\n\n# Put matricies into SymPy \nX6 = Matrix(X6)\nZ6 = Matrix(Z6)\n\nNE6_sym = Eq(A6*X6,Z6)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X6)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A6*X6)[i:i+1][0],Z6[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L} + I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(- I_{L} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\\(- I_{L} L s + v_{2} - v_{3} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE6_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R_{2}, \\  L, \\  I_{L}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU6_sym = solve(NE6_sym,X6)\n\ntemp = ''\nfor i in U6_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U6_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{L V_{1} s}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{L V_{1} s + R_{3} V_{1}}{R_{1} R_{3}}\\)\\(I_{L} = - \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\nU6_sym[v2]/U6_sym[v1]\n\n\\(\\displaystyle - \\frac{L s}{R_{1}}\\)\n\n\nAt \\(s=0\\) the transfer function does not reduce correctly to the DC case. For \\(s=\\infty\\), the inductor is an open and equation is correct.\nThe result seems correct for \\(s \\ne 0\\).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-7-l-and-r-in-series-in-the-feedback-path",
    "href": "Modeling Op Amps.html#case-7-l-and-r-in-series-in-the-feedback-path",
    "title": "34  Modeling Op Amps",
    "section": "34.13 Case 7: L and R in series in the feedback path",
    "text": "34.13 Case 7: L and R in series in the feedback path\n\nnet_list7 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nL 2 5 1\nR 3 5 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A7, X7, Z7 = SymMNA.smna(net_list7)\n\n# Put matricies into SymPy \nX7 = Matrix(X7)\nZ7 = Matrix(Z7)\n\nNE7_sym = Eq(A7*X7,Z7)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X7)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A7*X7)[i:i+1][0],Z7[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L} + I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{5}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(- I_{L} - \\frac{v_{3}}{R} + \\frac{v_{5}}{R} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\\(- I_{L} L s + v_{2} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE7_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  L, \\  I_{L}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  v_{4}, \\  V_{1}, \\  R_{1}, \\  v_{5}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU7_sym = solve(NE7_sym,X7)\n\ntemp = ''\nfor i in U7_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U7_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- L V_{1} s - R V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(v_{5} = - \\frac{R V_{1}}{R_{1}}\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{L V_{1} s + R V_{1} + R_{3} V_{1}}{R_{1} R_{3}}\\)\\(I_{L} = - \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\n(U7_sym[v2]/U7_sym[v1]).simplify()\n\n\\(\\displaystyle \\frac{- L s - R}{R_{1}}\\)\n\n\nThe result seems correct for \\(s \\ne \\infty\\).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-8-l-and-r-in-parallel-in-the-feedback-path",
    "href": "Modeling Op Amps.html#case-8-l-and-r-in-parallel-in-the-feedback-path",
    "title": "34  Modeling Op Amps",
    "section": "34.14 Case 8: L and R in parallel in the feedback path",
    "text": "34.14 Case 8: L and R in parallel in the feedback path\n\nnet_list8 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nL 2 3 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A8, X8, Z8 = SymMNA.smna(net_list8)\n\n# Put matricies into SymPy \nX8 = Matrix(X8)\nZ8 = Matrix(Z8)\n\nNE8_sym = Eq(A8*X8,Z8)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X8)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A8*X8)[i:i+1][0],Z8[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L} + I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(- I_{L} + v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\\(- I_{L} L s + v_{2} - v_{3} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE8_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  L, \\  I_{L}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve the equations.\n\nU8_sym = solve(NE8_sym,X8)\n\ntemp = ''\nfor i in U8_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U8_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{L R V_{1} s}{L R_{1} s + R R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{L R V_{1} s + L R_{3} V_{1} s + R R_{3} V_{1}}{L R_{1} R_{3} s + R R_{1} R_{3}}\\)\\(I_{L} = - \\frac{R V_{1}}{L R_{1} s + R R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\n(U8_sym[v2]/U8_sym[v1]).simplify()\n\n\\(\\displaystyle - \\frac{L R s}{R_{1} \\left(L s + R\\right)}\\)\n\n\nThe result seems correct for \\(s \\ne \\infty\\) or \\(s \\ne 0\\).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#summary",
    "href": "Modeling Op Amps.html#summary",
    "title": "34  Modeling Op Amps",
    "section": "34.15 Summary",
    "text": "34.15 Summary\n\nResistors in the feedback path seem to give the correct results\nInductors and capacitors in the feedback path seem to work as long as \\(s \\ne \\infty \\space \\text {or} \\space \\ne 0\\).\nIf a solution is only desired for non-zero or non-infinit requencies, then the results seem correct.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html",
    "href": "Op Amp circuits.html",
    "title": "35  Op Amp circuits",
    "section": "",
    "text": "35.1 Introduction\nSome typical Op Amp circuits are presented to explore the use of the Op Amp element type using symbolic MNA. These examples represent some very common applications of Op Amps ranging from a buffer amplifier to a dual Op Amp active band pass filter. The following Op Amp circuits are analyzed below.\nTwo good Op Amp references are Stout (1976) and Franco (2002).\nThe following Python libraries are used:\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#introduction",
    "href": "Op Amp circuits.html#introduction",
    "title": "35  Op Amp circuits",
    "section": "",
    "text": "Voltage follower\nNon-inverting amplifier\nInverting amplifier\nDifferential amplifier\nSumming amplifier\nIntegrator\nDifferentiator\nGeneralized Impedance Converter\nGeneralized Impedance Converter Filter\nDual amplifier band pass filter\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe Op Amp integrator, Generalized Impedance Converter Filter and Dual amplifier band pass filter have non-resistive elements in the Op Amp feedback path. As shown below, the MNA Op Amp model gives correct results. Nevertheless, care should be taken when using the MNA Op Amp model.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#voltage-follower",
    "href": "Op Amp circuits.html#voltage-follower",
    "title": "35  Op Amp circuits",
    "section": "35.2 Voltage follower",
    "text": "35.2 Voltage follower\n\n\n\n\n\n\nFigure 35.1: Op Amp voltage follower\n\n\n\nThe Op Amp configured as a voltage follower is shown above. In this configuration, the output of the output Op Amp is connected to the negative input of the Op Amp. This causes the output voltage to be equal to the input voltage and this arrangement is called a voltage follower because the output voltage follows the input voltage. In this configuration, the Op Amp is used to as buffer amplifier or isolation amplifier since the amplifier provids a high input impedance and a low out put impedance. The gain of the amplifier is one. The circuit contains just one component, the Op Amp.\nIn a real Op Amp, the input terminals are a differential inputs, and a signal fed to the inverting input will cause the output signal to swing in the oposit direction. When the output is connected to the inverting input by a direct connection (a wire), the voltage at the inverting input is equal to the voltage at the out put. Since a change in voltage at the inverting input will casue the output to move in the opposit direction, the contribution of the inverting input signal to the output of the Op Amp is cancelled. A signal on the non-inverting input will cause the output signal to move in the same direction. Since the Op Amp amplifies the difference between the input terminals, an Op Amp connected as shown in Figure 35.1, will produce an output that is equal to the signal at the non-inverting input.\nThe Op Amp model used in the MNA network equations, is defined to equate the inverting and non-inverting termainals to each other. This equality is defined in the network equations reguardless of anyother connections in the circuit. This implies that the Op Amp is only operating in a negative feedback mode. The output therminal of the Op Amp is assigned in the network equations as an unknown current. Since the Op Amp’s input terminals are equal (by definition) and the output is connected to the inverting input, the output voltage is the same as the voltage at the non-inverting input. In the Op Amp model used in the MNA network equations, there is no distintion between the non-inverting and inverting inputs, other than node number and an arbitrary convention of treating the first node in the Op Amp netlist line as the positive node. This means that as described by the MNA network equations, the Op Amp’s inputs can be swapped without affecting the solution. This is not the case with real Op Amps, so good practice is draw the circuit schematic with the Op Amp’s input terminals going to the intended nodes.\nThe netlist for Figure 35.1 was obtained from LTSpice:\nV1 1 0 1\nXU1 2 1 2\nThe reference designaltor for the Op Amp was changed from XU1 to O1 and the text was assinged to the net_list variable.\n\nnet_list = '''\nV1 1 0 1\nO1 2 1 2 \n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} = 0\\)\\(I_{O1} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{2} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(I_{V1} = 0\\)\\(I_{O1} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{2} = V_{1}\\)\n\n\nThe voltage at node 2 is simply equal to the input voltage, \\(v_2 = V_1\\).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#non-inverting-amplifier",
    "href": "Op Amp circuits.html#non-inverting-amplifier",
    "title": "35  Op Amp circuits",
    "section": "35.3 Non-inverting amplifier",
    "text": "35.3 Non-inverting amplifier\n\n\n\n\n\n\nFigure 35.2: Non-inverting amplifier configuration.\n\n\n\nThe schematic for a non-inverting Op Amp configuration is shown above. Resistors Rf and R1 form a voltage divider circuit from the Op Amp out put terminal to the inverting input termial at node 4. Resistor Rp is some times included in Op Amp circuits as an impedance maching element that matches the source impedance from the driving circuit, Rs. Rp and Rs are usually equal in value and serve to balance the impedance seen at each of the input terminals. In a real Op Amp a very small amount of leakage current and a very small offest voltage is present at the input pins.\nThe schematic for the circuit was entered into LTSpice and the netlist was generated.\nV1 1 0 1\nXU1 4 3 2 opamp Aol=100K GBW=10Meg\nRs 3 1 100\nR1 0 5 2k\nRf 2 5 2k\nRp 4 5 100\nAs shown below, some edits were made to the netlist.\n\nnet_list = '''\nV1 1 0 1\nO1 4 3 2 \nRs 3 1 100\nR1 0 5 2e3\nRf 2 5 2e3\nRp 4 5 100\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{Rs} - \\frac{v_{3}}{Rs} = 0\\)\\(I_{O1} + \\frac{v_{2}}{Rf} - \\frac{v_{5}}{Rf} = 0\\)\\(- \\frac{v_{1}}{Rs} + \\frac{v_{3}}{Rs} = 0\\)\\(\\frac{v_{4}}{Rp} - \\frac{v_{5}}{Rp} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{Rp} + \\frac{1}{Rf} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Rp} - \\frac{v_{2}}{Rf} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} + v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  Rs, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  Rf, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  Rp, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{1} V_{1} + Rf V_{1}}{R_{1}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = V_{1}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = 0\\)\\(I_{O1} = - \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.expand()\n\n\\(\\displaystyle 1 + \\frac{Rf}{R_{1}}\\)\n\n\nFrom the transfer function we can see that the voltage gain of non-inverting Op Amp configuration is always greater than one.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#inverting-amplifier",
    "href": "Op Amp circuits.html#inverting-amplifier",
    "title": "35  Op Amp circuits",
    "section": "35.4 Inverting amplifier",
    "text": "35.4 Inverting amplifier\n\n\n\n\n\n\nFigure 35.3: Inverting amplifier configuration.\n\n\n\nThe schematic above shows a the typical connection for an inverting amplifier. This configuratin is called an inverting amplifier since the output signal is inverted with respect to the input signal. Resistors Rf and R1 set the gain of the amplifier. Resistor Rp is sometime used to balance the impedance as seen from the Op Amps two inputs. Usually the value of Rp is chosen to be equal to the paralled combination of R1 and Rf.\nThe schematic for the circuit was entered into LTSpice and the following netlist was generated.\nV1 1 0 1\nXU1 3 4 2 opamp Aol=100K GBW=10Meg\nR1 3 1 2k\nRp 0 4 1k\nRf 3 2 2k\nA few edits were made to the netlist.\n\nnet_list = '''\nV1 1 0 1\nO1 3 4 2 \nR1 3 1 2e3\nRp 0 4 1e3\nRf 3 2 2e3\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{Rf} - \\frac{v_{3}}{Rf} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{Rf} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{Rf} - \\frac{v_{1}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{Rp} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  Rf, \\  R_{1}, \\  v_{4}, \\  v_{3}, \\  Rp, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{Rf V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.simplify()\n\n\\(\\displaystyle - \\frac{Rf}{R_{1}}\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#differential-amplifier",
    "href": "Op Amp circuits.html#differential-amplifier",
    "title": "35  Op Amp circuits",
    "section": "35.5 Differential amplifier",
    "text": "35.5 Differential amplifier\n\n\n\n\n\n\nFigure 35.4: Differential amplifier configuration.\n\n\n\nThe circuit shown above is a differential amplifier, where the circuit outputs the difference between V1 and V2, while rejecting any voltage from V3. All the resistors in Figure 35.4 have been set a value of 1k, whcih makes the gain applied to V1 and V2 equal to one, but the values of the reistors don’t have to be equal, which would make the gains something else.\nThe schematic for the circuit was entered into LTSpice and the following netlist was exported:\nXU1 4 5 2 opamp Aol=100K GBW=10Meg\nV1 1 6 1\nR1 4 1 1k\nR3 2 4 1k\nR4 0 5 1k\nR2 5 3 1k\nV2 3 6 3\nV3 6 0 10\nA few edits to the netlist were made to change the Op Amp designation and the values of the resistors to scientific notation.\n\nnet_list = '''\nO1 4 5 2\nV1 1 6 1\nR1 4 1 1e3\nR3 2 4 1e3\nR4 0 5 1e3\nR2 5 3 1e3\nV2 3 6 3\nV3 6 0 100\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(I_{V2} + \\frac{v_{3}}{R_{2}} - \\frac{v_{5}}{R_{2}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{3}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{V1} - I_{V2} + I_{V3} = 0\\)\\(v_{1} - v_{6} = V_{1}\\)\\(v_{3} - v_{6} = V_{2}\\)\\(v_{6} = V_{3}\\)\\(v_{4} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{3}, \\  R_{2}, \\  I_{V2}, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  V_{3}, \\  v_{6}, \\  I_{V3}, \\  R_{4}, \\  v_{4}, \\  R_{1}, \\  R_{3}, \\  V_{1}, \\  v_{1}, \\  V_{2}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1} + V_{3}\\)\\(v_{2} = \\frac{R_{1} R_{4} V_{2} + R_{1} R_{4} V_{3} - R_{2} R_{3} V_{1} - R_{2} R_{3} V_{3} - R_{3} R_{4} V_{1} + R_{3} R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\\(v_{3} = V_{2} + V_{3}\\)\\(v_{4} = \\frac{R_{4} V_{2} + R_{4} V_{3}}{R_{2} + R_{4}}\\)\\(v_{5} = \\frac{R_{4} V_{2} + R_{4} V_{3}}{R_{2} + R_{4}}\\)\\(v_{6} = V_{3}\\)\\(I_{V1} = \\frac{- R_{2} V_{1} - R_{2} V_{3} - R_{4} V_{1} + R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\\(I_{V2} = \\frac{- V_{2} - V_{3}}{R_{2} + R_{4}}\\)\\(I_{V3} = \\frac{- R_{1} V_{2} - R_{1} V_{3} - R_{2} V_{1} - R_{2} V_{3} - R_{4} V_{1} + R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\\(I_{O1} = \\frac{R_{2} V_{1} + R_{2} V_{3} + R_{4} V_{1} - R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\n\n\n\nU_sym[v2]\n\n\\(\\displaystyle \\frac{R_{1} R_{4} V_{2} + R_{1} R_{4} V_{3} - R_{2} R_{3} V_{1} - R_{2} R_{3} V_{3} - R_{3} R_{4} V_{1} + R_{3} R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\n\n\n\nU_sym[v2].subs({R1:1e3,R2:1e3,R3:1e3,R4:1e3})\n\n\\(\\displaystyle - 1.0 V_{1} + 1.0 V_{2}\\)\n\n\nWhen equal values are put in for the resistors, the output voltage reduces to the difference between the input voltages.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#summing-amplifier",
    "href": "Op Amp circuits.html#summing-amplifier",
    "title": "35  Op Amp circuits",
    "section": "35.6 Summing amplifier",
    "text": "35.6 Summing amplifier\n\n\n\n\n\n\nFigure 35.5: summing amplifier circuit\n\n\n\nA summing amplifier outputs a voltage that is the sum of the input voltages. The schematic shown in Figure 35.5 has two input voltages, V1 and V2. Feedback provide by Rf along with R1 sets the gain of the amplifier. An abritray number of input can be configuted by duplicating V1 and R2 and connecting to node number 5.\nThere are other Op Amp summing configurations that have an inverting configuration.\nXU1 4 5 2 opamp Aol=100K GBW=10Meg\nV1 1 0 1\nR1 4 0 1k\nRf 2 4 2k\nR4 0 5 1k\nR3 5 3 1k\nV2 3 0 3\nR2 5 1 1k\n\nnet_list = '''\nO1 4 5 2\nV1 1 0 1\nR1 4 0 1e3\nRf 2 4 2e3\nR4 0 5 1e3\nR3 5 3 1e3\nV2 3 0 3\nR2 5 1 1e3\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{2}} - \\frac{v_{5}}{R_{2}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{Rf} - \\frac{v_{4}}{Rf} = 0\\)\\(I_{V2} + \\frac{v_{3}}{R_{3}} - \\frac{v_{5}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{Rf} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{Rf} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} = V_{2}\\)\\(v_{4} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  I_{V2}, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  Rf, \\  R_{4}, \\  v_{4}, \\  R_{3}, \\  v_{3}, \\  R_{1}, \\  V_{1}, \\  v_{1}, \\  V_{2}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{1} R_{2} R_{4} V_{2} + R_{1} R_{3} R_{4} V_{1} + R_{2} R_{4} Rf V_{2} + R_{3} R_{4} Rf V_{1}}{R_{1} R_{2} R_{3} + R_{1} R_{2} R_{4} + R_{1} R_{3} R_{4}}\\)\\(v_{3} = V_{2}\\)\\(v_{4} = \\frac{R_{2} R_{4} V_{2} + R_{3} R_{4} V_{1}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(v_{5} = \\frac{R_{2} R_{4} V_{2} + R_{3} R_{4} V_{1}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(I_{V1} = \\frac{- R_{3} V_{1} - R_{4} V_{1} + R_{4} V_{2}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(I_{V2} = \\frac{- R_{2} V_{2} + R_{4} V_{1} - R_{4} V_{2}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(I_{O1} = \\frac{- R_{2} R_{4} V_{2} - R_{3} R_{4} V_{1}}{R_{1} R_{2} R_{3} + R_{1} R_{2} R_{4} + R_{1} R_{3} R_{4}}\\)\n\n\n\nU_sym[v2]\n\n\\(\\displaystyle \\frac{R_{1} R_{2} R_{4} V_{2} + R_{1} R_{3} R_{4} V_{1} + R_{2} R_{4} Rf V_{2} + R_{3} R_{4} Rf V_{1}}{R_{1} R_{2} R_{3} + R_{1} R_{2} R_{4} + R_{1} R_{3} R_{4}}\\)\n\n\n\nU_sym[v2].subs({R1:1e3,R2:1e3,R3:1e3,R4:1e3,Rf:2e3})\n\n\\(\\displaystyle 1.0 V_{1} + 1.0 V_{2}\\)\n\n\nWhen all the resistor values are equal, except for \\(R_f\\) which is set to twice the value, the gain of the circuit is unity and the output voltage is the sum of \\(V_1\\) and \\(V_2\\), as shown above.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#integrator",
    "href": "Op Amp circuits.html#integrator",
    "title": "35  Op Amp circuits",
    "section": "35.7 Integrator",
    "text": "35.7 Integrator\n\n\n\n\n\n\nFigure 35.6: Integrator circuit\n\n\n\nThe schematic of the circuit shown above is an example of an Op Amp integrator and produces an output voltage which is proportional to the negative of the integral of the input voltage. The circuit is from Stout (1976), Chapter 15, Figure 15.3, with the switches omited, which are used to reset the integrator. The current through R1 and Cf is almost the same, since the current in Rf is small. Rf sets the low frequency gain of the circuit and prevents saturation of the Op Amp. The resistors R2 and Rp balance any offset voltages and currents at the input terminals of the Op Amp. The capacitor Cp is used to by pass any thermal noise from Rp.\nThe intergrator circuit is essentially a low pass filter and acts as an integrator for most of the frequency range up to the pole set by the values of R1 and Cf. The rule of thumb is to choose a time constant, \\(\\tau = R_1 C_f\\), such that \\(\\tau\\) is larger than the period of the input signal, but much smaller than the duration of interest for integration.\nThe schematic for the integrator was entered into LTSpice and the netlist was was obtained. In the LTSpice simulation, the voltage source, V1, was configured as pulse voltage source inorder to test the circuit. For the symbolic analysis, V1 is defined as a voltage source.\nV1 1 0 PULSE(0 1 1m 2m 0 0 5m) AC 1\nXU1 4 5 2 opamp Aol=100K GBW=10Meg\nR1 3 1 1k\nR2 4 3 100\nRp 0 5 100\nRf 3 2 100k\nCf 2 3 1µ\nCp 5 0 0.1µ\nA few edits were made and the netlist is assigned to the net_list variable.\n\nnet_list = '''\nV1 1 0 1\nOU1 4 5 2\nR1 3 1 1e3\nR2 4 3 100\nRp 0 5 100\nRf 3 2 100e3\nCf 2 3 1e-6\nCp 5 0 0.1e-6\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{Ou1} + v_{2} \\left(Cf s + \\frac{1}{Rf}\\right) + v_{3} \\left(- Cf s - \\frac{1}{Rf}\\right) = 0\\)\\(v_{2} \\left(- Cf s - \\frac{1}{Rf}\\right) + v_{3} \\left(Cf s + \\frac{1}{Rf} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{5} \\left(Cp s + \\frac{1}{Rp}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(v_{4} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  s, \\  Cp, \\  I_{Ou1}, \\  v_{2}, \\  v_{5}, \\  Rf, \\  R_{1}, \\  v_{4}, \\  v_{3}, \\  Cf, \\  V_{1}, \\  v_{1}, \\  Rp\\right)\\)\n\n\nSolve and display the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{Rf V_{1}}{Cf R_{1} Rf s + R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(v_{5} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{Ou1} = \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2. Transfer functions are normally presented in the frequency domain and are steady state responses.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.simplify()\n\n\\(\\displaystyle - \\frac{Rf}{R_{1} \\left(Cf Rf s + 1\\right)}\\)\n\n\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ Cf : 1.0 \\cdot 10^{-6}, \\  Cp : 1.0 \\cdot 10^{-7}, \\  Ou_{1} : \\text{NaN}, \\  R_{1} : 1000.0, \\  R_{2} : 100.0, \\  Rf : 100000.0, \\  Rp : 100.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nIn the circuit, the values of R1 and Cf produce a time constant calculated below.\n\nprint('integrator time constant: {:.1f}ms'.format(element_values[R1]*element_values[Cf]*1e3))\n\nintegrator time constant: 1.0ms\n\n\nThis means the integrator circuit will produce reasonable results for input signals having frequencies of less than 5 Hz over an integration period of less than 10 ms.\nSubstiuting the element values into the network equations gives the following equations.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\I_{Ou1} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-6} s + 1.0 \\cdot 10^{-5}\\right) + v_{3} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right)\\\\- 0.001 v_{1} + v_{2} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right) + v_{3} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.01101\\right) - 0.01 v_{4}\\\\- 0.01 v_{3} + 0.01 v_{4}\\\\v_{5} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.01\\right)\\\\v_{1}\\\\v_{4} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving for the unknow node voltages and source currents.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = - \\frac{1000.0}{s + 10.0}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = -0.001\\)\\(I_{Ou1} = 0.001\\)\n\n\nThe voltage transferfunction of the integrator is shown below.\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle - \\frac{1000}{s + 10}\\)\n\n\nConvert transfer function to SciPy system. Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-1.59 Hz\n\n\nUse the SciPy function bode to plot the magnitude and phase of the intrgrator circuit.\n\nx = np.logspace(0, 5, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step responce for the integrator circuit is an exponential function, but over the initial time segment of zero to about 10ms, the response is approximately a straight line and value at point is equal to the area under the step at each point in time.\n** Ramp input to integrator**\nThe following cells step through the calcuations to solve for the voltage at node 2. The following cells analyze the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\nelement_values[V1] = 500/(s**2)\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\I_{Ou1} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-6} s + 1.0 \\cdot 10^{-5}\\right) + v_{3} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right)\\\\- 0.001 v_{1} + v_{2} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right) + v_{3} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.01101\\right) - 0.01 v_{4}\\\\- 0.01 v_{3} + 0.01 v_{4}\\\\v_{5} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.01\\right)\\\\v_{1}\\\\v_{4} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{500}{s^{2}}\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{500.0}{s^{2}}\\)\\(v_{2} = - \\frac{500000.0}{s^{3} + 10.0 s^{2}}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = - \\frac{0.5}{s^{2}}\\)\\(I_{Ou1} = \\frac{0.5}{s^{2}}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 500.0 t\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle - \\frac{500000.0}{s^{3} + 10.0 s^{2}}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\nnode_v2 = inverse_laplace_transform(node_v2_s, s, t)\nnode_v2\n\n\\(\\displaystyle - 50000.0 t + 5000.0 - 5000.0 e^{- 10.0 t}\\)\n\n\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.002, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, node_v2)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\nPlot the final combined result.\n\nplt.title('Integrator output voltage vs time')\n\nplt.plot(x*1e3, np.real(V_node2),label='v2(t)')\nplt.plot(x*1e3, np.real(V_node1),label='v1(t)')\n#plt.plot(x*1e3, np.real(V_node2)+V_node1*x/2/(element_values[R1]*element_values[Cf]),label='error')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that the output of the Op Amp integrator, v2, is an exponential function in response to a voltage ramp scaled by the values of \\(R_1\\) and \\(C_f\\). The value of v2 is the area under the ramp at each x.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#differentiator",
    "href": "Op Amp circuits.html#differentiator",
    "title": "35  Op Amp circuits",
    "section": "35.8 Differentiator",
    "text": "35.8 Differentiator\n\n\n\n\n\n\nFigure 35.7: Differentiator circuit.\n\n\n\nFigure 35.7 implements a circuit which produces an output proporational to the derivative of the input voltage. The circuit is from Stout (1976), chapter 15, Fig 15.1. C1, Rf and the Op Amp implement the differentiator function. R1 and Cf help stabalized the feedback loop. Rp helps balance the Op Amps offset currents and Cp is used to bypass the thermal noise of Rp to ground. A more compresive description of the circuit can be found in the referenced hadbook.\nThe schamitic for the circuit was entered into LTSpice and the netlist was exported.\nXU1 5 4 2 opamp Aol=100K GBW=10Meg\nV1 1 0 PULSE(0 1 1m 1m 0.5m 1m 5m) AC 1\nR1 3 1 100\nRf 2 5 200k\nRp 0 4 200k\nC1 5 3 0.01µ\nCf 2 5 70p\nCp 0 4 0.1µ\nThe netlist was editited as shown below.\n\nnet_list = '''\nO1 5 4 2\nV1 1 0 1\nR1 3 1 100\nRf 2 5 200e3\nRp 0 4 200e3\nC1 5 3 0.01e-6\nCf 2 5 50e-12\nCp 0 4 0.1e-6\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\left(Cf s + \\frac{1}{Rf}\\right) + v_{5} \\left(- Cf s - \\frac{1}{Rf}\\right) = 0\\)\\(- C_{1} s v_{5} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{4} \\left(Cp s + \\frac{1}{Rp}\\right) = 0\\)\\(- C_{1} s v_{3} + v_{2} \\left(- Cf s - \\frac{1}{Rf}\\right) + v_{5} \\left(C_{1} s + Cf s + \\frac{1}{Rf}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  s, \\  Cp, \\  v_{2}, \\  I_{O1}, \\  C_{1}, \\  v_{5}, \\  Rf, \\  v_{1}, \\  R_{1}, \\  v_{4}, \\  v_{3}, \\  Cf, \\  V_{1}, \\  Rp\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{C_{1} Rf V_{1} s}{C_{1} Cf R_{1} Rf s^{2} + C_{1} R_{1} s + Cf Rf s + 1}\\)\\(v_{3} = \\frac{V_{1}}{C_{1} R_{1} s + 1}\\)\\(v_{4} = 0\\)\\(v_{5} = 0\\)\\(I_{V1} = - \\frac{C_{1} V_{1} s}{C_{1} R_{1} s + 1}\\)\\(I_{O1} = \\frac{C_{1} V_{1} s}{C_{1} R_{1} s + 1}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.simplify()\n\n\\(\\displaystyle - \\frac{C_{1} Rf s}{C_{1} Cf R_{1} Rf s^{2} + C_{1} R_{1} s + Cf Rf s + 1}\\)\n\n\nSubstituting values for the component reference designators.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  Cf : 5.0 \\cdot 10^{-11}, \\  Cp : 1.0 \\cdot 10^{-7}, \\  O_{1} : \\text{NaN}, \\  R_{1} : 100.0, \\  Rf : 200000.0, \\  Rp : 200000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.01 v_{1} - 0.01 v_{3}\\\\I_{O1} + v_{2} \\cdot \\left(5.0 \\cdot 10^{-11} s + 5.0 \\cdot 10^{-6}\\right) + v_{5} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 0.01 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 0.01\\right)\\\\v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{3} + v_{2} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right) + v_{5} \\cdot \\left(1.005 \\cdot 10^{-8} s + 5.0 \\cdot 10^{-6}\\right)\\\\v_{1}\\\\- v_{4} + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = - \\frac{200000000.0 s}{s^{2} + 1100000.0 s + 100000000000.0}\\)\\(v_{3} = \\frac{1000000.0}{s + 1000000.0}\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = - \\frac{s}{100.0 s + 100000000.0}\\)\\(I_{O1} = \\frac{s}{100.0 s + 100000000.0}\\)\n\n\nTransfer function:\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle - \\frac{200000000 s}{s^{2} + 1100000 s + 100000000000}\\)\n\n\nConvert transfer function to SciPy system. Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 1\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-159,154.94 Hz\n-15,915.49 Hz\n\n\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(0, 5, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe impulse and step response maximum values are for an ideal Op Amp. A real Op Amp’s maximum output voltage would be limited to the supply rails.\nThe following cells analyize the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\nelement_values[V1] = 1e3/(s**2)   # ramp of 1 volt per 1 ms \nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.01 v_{1} - 0.01 v_{3}\\\\I_{O1} + v_{2} \\cdot \\left(5.0 \\cdot 10^{-11} s + 5.0 \\cdot 10^{-6}\\right) + v_{5} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 0.01 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 0.01\\right)\\\\v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{3} + v_{2} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right) + v_{5} \\cdot \\left(1.005 \\cdot 10^{-8} s + 5.0 \\cdot 10^{-6}\\right)\\\\v_{1}\\\\- v_{4} + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1000.0}{s^{2}}\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1000.0}{s^{2}}\\)\\(v_{2} = - \\frac{200000000000.0}{s^{3} + 1100000.0 s^{2} + 100000000000.0 s}\\)\\(v_{3} = \\frac{1000000000.0}{s^{3} + 1000000.0 s^{2}}\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = - \\frac{10.0}{s^{2} + 1000000.0 s}\\)\\(I_{O1} = \\frac{10.0}{s^{2} + 1000000.0 s}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 1000.0 t\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle - \\frac{200000000000.0}{s^{3} + 1100000.0 s^{2} + 100000000000.0 s}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\nnode_v2 = inverse_laplace_transform(node_v2_s, s, t)\nnode_v2\n\n\\(\\displaystyle -2.0 - 0.222222222222222 e^{- 1000000.0 t} + 2.22222222222222 e^{- 100000.0 t}\\)\n\n\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.001, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, node_v2)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\n\nplt.title('Differentiator output voltage vs time')\n\nplt.plot(x, np.real(V_node2),label='v2(t)')\nplt.plot(x, np.real(V_node1),label='v1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that the output of the Op Amp differentiator, v2, is a constant value in response to a voltage ramp scaled by the values of \\(R_1\\) and \\(C_f\\). The value of v2 is the slope of the ramp at each x.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#generalized-impedance-converter-gic-circuit",
    "href": "Op Amp circuits.html#generalized-impedance-converter-gic-circuit",
    "title": "35  Op Amp circuits",
    "section": "35.9 Generalized Impedance Converter (GIC) circuit",
    "text": "35.9 Generalized Impedance Converter (GIC) circuit\n\n\n\n\n\n\nFigure 35.8: Schematic for a Generalized Impedance Converter circuit.\n\n\n\nThe schematic shown above is from Williams and Taylor (1995), Figure 3-31, and is known as a generalized impedance converter (GIC). The circuit is attributed to Antoniou (1969) and used by Bruton (1978) to realize active filters from ladder topologies as describe in Section 35.10.\nThe schematic for the circuit shown above was entered into LTSpice and the following net list was generated.\nXU2 3 1 4 opamp Aol=100K GBW=10Meg\nV1 1 0 1\nXU1 3 5 2 opamp Aol=100K GBW=10Meg\nR2 2 3 1\nR4 4 5 1\nR5 5 0 1\nR1 1 2 1\nR3 3 4 1\n\n35.9.1 Basic GIC\nThe circuit for the basic GIC is analyzed below using resistors in all the elements.\n\nnet_list = '''\nO2 3 1 4 \nV1 1 0 1\nO1 3 5 2\nR1 1 2 1\nR2 2 3 1\nR3 3 4 1\nR4 4 5 1\nR5 5 0 1\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{O2} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{3}}{R_{3}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{3} = 0\\)\\(v_{3} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{1}, \\  R_{3}, \\  v_{3}, \\  v_{4}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{2} R_{4} V_{1} + R_{3} R_{5} V_{1}}{R_{3} R_{5}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{R_{4} V_{1} + R_{5} V_{1}}{R_{5}}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{R_{2} R_{4} V_{1}}{R_{1} R_{3} R_{5}}\\)\\(I_{O2} = \\frac{- R_{3} V_{1} - R_{4} V_{1}}{R_{3} R_{5}}\\)\\(I_{O1} = \\frac{R_{1} R_{4} V_{1} + R_{2} R_{4} V_{1}}{R_{1} R_{3} R_{5}}\\)\n\n\nSolving for the impedance at node 1.\n\nZ_sym = U_sym[v1]/(U_sym[I_V1])\nZ_sym\n\n\\(\\displaystyle - \\frac{R_{1} R_{3} R_{5}}{R_{2} R_{4}}\\)\n\n\nIf you replace any of the R’s with \\(Ls\\) or \\(\\frac {1}{Cs}\\), then you can see that a new complex impedance is obtained. This is illustrated in the two examples below.\n\n\n35.9.2 Inductor\nBy substituting a capacitor for R4, the impedance of a grounded inductor can be synthesized.\n\n# inductor\nnet_list = '''\nO2 3 1 4 \nV1 1 0 1\nO1 3 5 2\nR1 1 2 1\nR2 2 3 1\nR3 3 4 1\n*R4 4 5 1\nC 4 5 1\nR5 5 0 1\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C s v_{5} + I_{O2} + v_{4} \\left(C s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}} = 0\\)\\(- C s v_{4} + v_{5} \\left(C s + \\frac{1}{R_{5}}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{3} = 0\\)\\(v_{3} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  s, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  I_{O2}, \\  R_{5}, \\  C, \\  R_{1}, \\  R_{3}, \\  v_{3}, \\  v_{4}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C R_{3} R_{5} V_{1} s - R_{2} V_{1}}{C R_{3} R_{5} s}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{C R_{5} V_{1} s + V_{1}}{C R_{5} s}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{R_{2} V_{1}}{C R_{1} R_{3} R_{5} s}\\)\\(I_{O2} = \\frac{- C R_{3} V_{1} s - V_{1}}{C R_{3} R_{5} s}\\)\\(I_{O1} = \\frac{R_{1} V_{1} + R_{2} V_{1}}{C R_{1} R_{3} R_{5} s}\\)\n\n\nSolving for the impedance at node 1.\n\nZ_sym = U_sym[v1]/(U_sym[I_V1])\nZ_sym #.simplify()\n\n\\(\\displaystyle - \\frac{C R_{1} R_{3} R_{5} s}{R_{2}}\\)\n\n\nThe sign of the impedance is negative which accounts for the direction of the current flowing in V1.\nThe value of the synthesized inductor is:\n\\(\\frac {C R_1 R_3 R_5}{R_2}\\)\n\n\n35.9.3 D element - frequency dependent negative resistor\nBy substituting a capacitor for R1 and R3, a frequency-dependent negative resistor impedances can be synthenzisied.\n\n# D element - frequency dependent negative resistor\nnet_list = '''\nO2 3 1 4 \nV1 1 0 1\nO1 3 5 2\n*R1 1 2 1\nC1 1 2 1\nR2 2 3 1\n*R3 3 4 1\nC3 3 4 1\nR4 4 5 1\nR5 5 0 1\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{V1} = 0\\)\\(- C_{1} s v_{1} + I_{O1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- C_{3} s v_{4} + v_{3} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C_{3} s v_{3} + I_{O2} + v_{4} \\left(C_{3} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{3} = 0\\)\\(v_{3} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  s, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  v_{4}, \\  v_{3}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{3} R_{2} R_{4} V_{1} s + R_{5} V_{1}}{R_{5}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{R_{4} V_{1} + R_{5} V_{1}}{R_{5}}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{C_{1} C_{3} R_{2} R_{4} V_{1} s^{2}}{R_{5}}\\)\\(I_{O2} = \\frac{- C_{3} R_{4} V_{1} s - V_{1}}{R_{5}}\\)\\(I_{O1} = \\frac{C_{1} C_{3} R_{2} R_{4} V_{1} s^{2} + C_{3} R_{4} V_{1} s}{R_{5}}\\)\n\n\nSolving for the impedance, \\(\\frac {v_1}{I_{V1}}\\), at node 1.\n\nZ_sym = U_sym[v1]/(U_sym[I_V1])\nZ_sym #.simplify()\n\n\\(\\displaystyle - \\frac{R_{5}}{C_{1} C_{3} R_{2} R_{4} s^{2}}\\)\n\n\nThe frequency dependent negative resistor can be used to convert ladder filters into active filters as desribed below.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#sec-GIC-LP-filter",
    "href": "Op Amp circuits.html#sec-GIC-LP-filter",
    "title": "35  Op Amp circuits",
    "section": "35.10 Generalized Impedance Converter Filter",
    "text": "35.10 Generalized Impedance Converter Filter\n\n\n\n\n\n\nFigure 35.9: GIC-LP-filter\n\n\n\nThe filter shown above is from Williams and Taylor (1995), Figure 3-33. The filter is an active low-pass filter with a 3 dB cut off at 400 Hz, with at least 20 dB attenuation at 1200 Hz. Resistors Ra and Rb are included in the schematic to provide a DC path to ground since real Op Amps have some leakage current from the input terminals and this would cause a build up voltage on C2 if not for a DC ground path provided by Ra or Rb. Refere to Williams and Taylor (1995) for a more detailed description of the filter design procedure.\nThe net list for the filter was obtained from LTSpice.\nXU2 6 4 7 opamp Aol=100K GBW=10Meg\nV1 1 0 AC 1\nXU1 6 8 5 opamp Aol=100K GBW=10Meg\nC1 3 1 0.01µ\nC2 5 4 0.01µ\nC3 7 6 0.01µ\nC4 0 2 0.01µ\nR2 5 6 40.2k\nR3 7 8 41.2k\nR4 8 0 40.2k\nR1 4 3 22.1k\nR5 2 4 97.6k\nRb 2 0 1Meg\nThe netlist was editied to fix Op Amp designators and to comment out Rb, which not needed for a symbolic solution.\n\nnet_list = '''\nO2 6 4 7\nV1 1 0 1\nO1 6 8 5\nC1 3 1 0.01e-6\nC2 5 4 0.01e-6\nC3 7 6 0.01e-6\nC4 0 2 0.01e-6\nR2 5 6 40.2e3\nR3 7 8 41.2e3\nR4 8 0 40.2e3\nR1 4 3 22.1e3\nR5 2 4 97.6e3\n*Rb 2 0 1e6\n'''\n\nGenerate markdown text to display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{3} + I_{V1} = 0\\)\\(v_{2} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) - \\frac{v_{4}}{R_{5}} = 0\\)\\(- C_{1} s v_{1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C_{2} s v_{4} + I_{O1} + v_{5} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{2}} = 0\\)\\(- C_{3} s v_{7} + v_{6} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{3} s v_{6} + I_{O2} + v_{7} \\left(C_{3} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{8}}{R_{3}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{3}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{6} = 0\\)\\(v_{6} - v_{8} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  C_{4}, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  v_{8}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  v_{7}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nSolving for the transfer function at node 2.\n\nU_sym = solve(NE_sym,X)\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym\n\n\\(\\displaystyle \\frac{C_{1} R_{4}}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5} s^{3} + C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{4} s + C_{1} C_{4} R_{4} R_{5} s + C_{1} R_{4} + C_{2} C_{3} C_{4} R_{2} R_{3} R_{5} s^{2} + C_{2} C_{3} R_{2} R_{3} s + C_{4} R_{4}}\\)\n\n\nThe roots of the denominator can be obtained symbolically. Since the degree of the polynominal is a third order, SymPy can solve for the roots and obtain a solution very quickly. The roots expressed in symbolic form are not very useful, but are easily obtained, something that would be almost impossible to do by hand with pencil and paper.\n\nnum, den = fraction(H_sym)\np = solve(den,s)\np[0]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}}{3} - \\frac{C_{1} R_{1} + C_{4} R_{5}}{3 C_{1} C_{4} R_{1} R_{5}}\\)\n\n\n\np[1]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}}{3} - \\frac{C_{1} R_{1} + C_{4} R_{5}}{3 C_{1} C_{4} R_{1} R_{5}}\\)\n\n\n\np[2]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}}{3} - \\frac{C_{1} R_{1} + C_{4} R_{5}}{3 C_{1} C_{4} R_{1} R_{5}}\\)\n\n\nIncluding Rb in the circuit and changing the value to 1M.\n\nnet_list = '''\nO2 6 4 7\nV1 1 0 1\nO1 6 8 5\nC1 3 1 0.01e-6\nC2 5 4 0.01e-6\nC3 7 6 0.01e-6\nC4 0 2 0.01e-6\nR2 5 6 40.2e3\nR3 7 8 41.2e3\nR4 8 0 40.2e3\nR1 4 3 22.1e3\nR5 2 4 97.6e3\nRb 2 0 1e6\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{3} + I_{V1} = 0\\)\\(v_{2} \\left(C_{4} s + \\frac{1}{Rb} + \\frac{1}{R_{5}}\\right) - \\frac{v_{4}}{R_{5}} = 0\\)\\(- C_{1} s v_{1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C_{2} s v_{4} + I_{O1} + v_{5} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{2}} = 0\\)\\(- C_{3} s v_{7} + v_{6} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{3} s v_{6} + I_{O2} + v_{7} \\left(C_{3} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{8}}{R_{3}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{3}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{6} = 0\\)\\(v_{6} - v_{8} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  C_{4}, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  v_{8}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  v_{7}, \\  Rb, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-8}, \\  C_{4} : 1.0 \\cdot 10^{-8}, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 22100.0, \\  R_{2} : 40200.0, \\  R_{3} : 41200.0, \\  R_{4} : 40200.0, \\  R_{5} : 97600.0, \\  Rb : 1000000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 \\cdot 10^{-8} s v_{1} - 1.0 \\cdot 10^{-8} s v_{3}\\\\v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 1.12459016393443 \\cdot 10^{-5}\\right) - 1.02459016393443 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 4.52488687782805 \\cdot 10^{-5}\\right) - 4.52488687782805 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 1.02459016393443 \\cdot 10^{-5} v_{2} - 4.52488687782805 \\cdot 10^{-5} v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-8} s + 5.54947704176248 \\cdot 10^{-5}\\right)\\\\I_{O1} - 1.0 \\cdot 10^{-8} s v_{4} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right) - 2.48756218905473 \\cdot 10^{-5} v_{6}\\\\- 1.0 \\cdot 10^{-8} s v_{7} - 2.48756218905473 \\cdot 10^{-5} v_{5} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-8} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.42718446601942 \\cdot 10^{-5}\\right) - 2.42718446601942 \\cdot 10^{-5} v_{8}\\\\- 2.42718446601942 \\cdot 10^{-5} v_{7} + 4.91474665507414 \\cdot 10^{-5} v_{8}\\\\v_{1}\\\\- v_{4} + v_{6}\\\\v_{6} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{2.79920457659434 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{3} = \\frac{2.48756218905472 \\cdot 10^{46} s^{4} + 2.79748796998614 \\cdot 10^{49} s^{3} + 3.35064787818341 \\cdot 10^{53} s^{2} + 3.13426936441268 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{4} = \\frac{2.73202366675606 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{5} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{3} + 1.46619200612885 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{6} = \\frac{2.73202366675606 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{7} = \\frac{5.53200812124237 \\cdot 10^{53} s^{2} + 6.22124191995455 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{8} = \\frac{2.73202366675606 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(I_{V1} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{4} - 1.26583166062721 \\cdot 10^{53} s^{3} - 2.79920457659434 \\cdot 10^{56} s^{2} - 2.79920457659434 \\cdot 10^{58} s}{2.48756218905472 \\cdot 10^{54} s^{4} + 1.40534254770211 \\cdot 10^{58} s^{3} + 4.61647953881062 \\cdot 10^{61} s^{2} + 5.93347394100702 \\cdot 10^{64} s + 2.79920457659434 \\cdot 10^{66}}\\)\\(I_{O2} = \\frac{- 2.18748785506742 \\cdot 10^{62} s^{3} - 7.76946386696064 \\cdot 10^{65} s^{2} - 5.97094011052149 \\cdot 10^{68} s}{1.943407960199 \\cdot 10^{63} s^{4} + 1.09792386539227 \\cdot 10^{67} s^{3} + 3.6066246396958 \\cdot 10^{70} s^{2} + 4.63552651641173 \\cdot 10^{73} s + 2.18687857546433 \\cdot 10^{75}}\\)\\(I_{O1} = \\frac{1.75874023547421 \\cdot 10^{48} s^{4} + 6.35283767986486 \\cdot 10^{51} s^{3} + 4.9200546510697 \\cdot 10^{54} s^{2}}{3.886815920398 \\cdot 10^{52} s^{4} + 2.19584773078454 \\cdot 10^{56} s^{3} + 7.2132492793916 \\cdot 10^{59} s^{2} + 9.27105303282346 \\cdot 10^{62} s + 4.37375715092865 \\cdot 10^{64}}\\)\n\n\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{174950286037146250000000 s}{15547263681592 s^{4} + 87833909231381875 s^{3} + 288529971175663750000 s^{2} + 370842121312938125000000 s + 17495028603714625000000000}\\)\n\n\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 1\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-278.58+446.47j Hz\n-278.58-446.47j Hz\n-334.18+0.00j Hz\n-7.80+0.00j Hz\n\n\nThe SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(1, 5, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nStep response as a check of the network equations\n\nnet_list = '''\nO2 6 4 7\nV1 1 0 1\nO1 6 8 5\nC1 3 1 0.01e-6\nC2 5 4 0.01e-6\nC3 7 6 0.01e-6\nC4 0 2 0.01e-6\nR2 5 6 40.2e3\nR3 7 8 41.2e3\nR4 8 0 40.2e3\nR1 4 3 22.1e3\nR5 2 4 97.6e3\nRb 2 0 1e6\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{3} + I_{V1} = 0\\)\\(v_{2} \\left(C_{4} s + \\frac{1}{Rb} + \\frac{1}{R_{5}}\\right) - \\frac{v_{4}}{R_{5}} = 0\\)\\(- C_{1} s v_{1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C_{2} s v_{4} + I_{O1} + v_{5} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{2}} = 0\\)\\(- C_{3} s v_{7} + v_{6} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{3} s v_{6} + I_{O2} + v_{7} \\left(C_{3} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{8}}{R_{3}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{3}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{6} = 0\\)\\(v_{6} - v_{8} = 0\\)\n\n\nget the element values from thge netlist.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-8}, \\  C_{4} : 1.0 \\cdot 10^{-8}, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 22100.0, \\  R_{2} : 40200.0, \\  R_{3} : 41200.0, \\  R_{4} : 40200.0, \\  R_{5} : 97600.0, \\  Rb : 1000000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  C_{4}, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  v_{8}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  v_{7}, \\  Rb, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nThe following cells analyize the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\n#element_values[V1] = 1/(s**2)   # ramp of 1 volt per 1 s\nelement_values[V1] = 1/(s)   # step function\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 \\cdot 10^{-8} s v_{1} - 1.0 \\cdot 10^{-8} s v_{3}\\\\v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 1.12459016393443 \\cdot 10^{-5}\\right) - 1.02459016393443 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 4.52488687782805 \\cdot 10^{-5}\\right) - 4.52488687782805 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 1.02459016393443 \\cdot 10^{-5} v_{2} - 4.52488687782805 \\cdot 10^{-5} v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-8} s + 5.54947704176248 \\cdot 10^{-5}\\right)\\\\I_{O1} - 1.0 \\cdot 10^{-8} s v_{4} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right) - 2.48756218905473 \\cdot 10^{-5} v_{6}\\\\- 1.0 \\cdot 10^{-8} s v_{7} - 2.48756218905473 \\cdot 10^{-5} v_{5} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-8} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.42718446601942 \\cdot 10^{-5}\\right) - 2.42718446601942 \\cdot 10^{-5} v_{8}\\\\- 2.42718446601942 \\cdot 10^{-5} v_{7} + 4.91474665507414 \\cdot 10^{-5} v_{8}\\\\v_{1}\\\\- v_{4} + v_{6}\\\\v_{6} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{2.79920457659434 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{3} = \\frac{2.48756218905472 \\cdot 10^{46} s^{3} + 2.79748796998614 \\cdot 10^{49} s^{2} + 3.35064787818341 \\cdot 10^{53} s + 3.13426936441268 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{4} = \\frac{2.73202366675606 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{5} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{2} + 1.46619200612885 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{6} = \\frac{2.73202366675606 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{7} = \\frac{5.53200812124237 \\cdot 10^{53} s + 6.22124191995455 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{8} = \\frac{2.73202366675606 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(I_{V1} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{3} - 1.26583166062721 \\cdot 10^{53} s^{2} - 2.79920457659434 \\cdot 10^{56} s - 2.79920457659434 \\cdot 10^{58}}{2.48756218905472 \\cdot 10^{54} s^{4} + 1.40534254770211 \\cdot 10^{58} s^{3} + 4.61647953881062 \\cdot 10^{61} s^{2} + 5.93347394100702 \\cdot 10^{64} s + 2.79920457659434 \\cdot 10^{66}}\\)\\(I_{O2} = \\frac{- 2.18748785506742 \\cdot 10^{62} s^{2} - 7.76946386696064 \\cdot 10^{65} s - 5.97094011052149 \\cdot 10^{68}}{1.943407960199 \\cdot 10^{63} s^{4} + 1.09792386539227 \\cdot 10^{67} s^{3} + 3.6066246396958 \\cdot 10^{70} s^{2} + 4.63552651641173 \\cdot 10^{73} s + 2.18687857546433 \\cdot 10^{75}}\\)\\(I_{O1} = \\frac{1.75874023547421 \\cdot 10^{48} s^{3} + 6.35283767986486 \\cdot 10^{51} s^{2} + 4.9200546510697 \\cdot 10^{54} s}{3.886815920398 \\cdot 10^{52} s^{4} + 2.19584773078454 \\cdot 10^{56} s^{3} + 7.2132492793916 \\cdot 10^{59} s^{2} + 9.27105303282346 \\cdot 10^{62} s + 4.37375715092865 \\cdot 10^{64}}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 1\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle \\frac{2.79920457659434 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_v2 = inverse_laplace_transform(node_v2_s, s, t)\n#node_v2\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\n\nn, d = fraction(node_v2_s)\nn = n.expand()\nd = d.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(2.79920457659434 \\cdot 10^{56}\\)denominator: \\(2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}\\)\n\n\nUse the SciPy residue function to do the inverse Laplace transform.\n\ncn = Poly(n, s).all_coeffs()\ncd = Poly(d, s).all_coeffs()\nr, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n# build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\nz = 0\nfor i in range(len(r)):\n    m = (r[i]/(s-p[i]))\n    z += inverse_laplace_transform(m, s, t)\n\nEach of the terms came be converted to a function using SymPy’s lambdify function. Define the values for the x-axis of the plot and put each one into an array for plotting.\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.2, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, z)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x*1e3, np.real(V_node2),label='v2(t)')\n#plt.plot(x, np.real(V_node1),label='v1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#dual-amplifier-band-pass-filter",
    "href": "Op Amp circuits.html#dual-amplifier-band-pass-filter",
    "title": "35  Op Amp circuits",
    "section": "35.11 Dual amplifier band pass filter",
    "text": "35.11 Dual amplifier band pass filter\n\n\n\n\n\n\nFigure 35.10: Dual amplifier band pass filter with compoenet values set to 1\n\n\n\nThe Dual Amplifier Bandpass (DABP) filter shown above is from Williams and Taylor (1995), Figure 5-27. The filter was first described by Sedra and Espinoza (1975). The filter uses two Op Amps and has eight branches and 6 nodes. The DABP configuration has been found very useful for designs covering a wide range of Qs and frequencies. Component sensitivity is small, resonant frequency and Q are easily adjustable, and the element spread is low.\nThe schematic was entered into LTSpice and the netlist was exported as shown below.\nXU1 5 4 2 opamp Aol=100K GBW=10Meg\nXU2 5 6 3 opamp Aol=100K GBW=10Meg\nR1 4 1 10\nR2 4 3 1\nR3 5 2 1\nR5 6 2 1\nR4 6 0 1\nC2 5 3 1\nC1 0 4 1\nV1 1 0 AC 1\nThe netlist was modified and equated to the net list variable shown below.\n\nnet_list = '''\nO1 5 4 2\nO2 5 6 3\nR1 4 1 1\nR2 4 3 1\nR3 5 2 1\nR5 6 2 1\nR4 6 0 1\nC2 5 3 1\nC1 0 4 1\nV1 1 0 1\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{5}}{R_{3}} = 0\\)\\(- C_{2} s v_{5} + I_{O2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{5} = 0\\)\\(v_{5} - v_{6} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  C_{1}, \\  v_{5}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nSolve the network equations for the unknown node voltages and currents.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s + C_{2} R_{2} R_{3} R_{5} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{3} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s - R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{4} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{5} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{6} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} R_{2} R_{3} R_{4} V_{1} s^{2} - R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(I_{O1} = \\frac{- C_{2} R_{2} R_{3} V_{1} s - C_{2} R_{2} R_{5} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(I_{O2} = \\frac{C_{2} R_{2} R_{5} V_{1} s + R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.cancel()\n\n\\(\\displaystyle \\frac{C_{2} R_{2} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{5} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\n\n\nUsing the function fraction() extract the numerator and denomiator of the transferfunction.\n\nnum, den = fraction(H_sym.cancel())\n\nThe denominator is a second order function of the Laplace variable s shown below.\n\nden\n\n\\(\\displaystyle C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}\\)\n\n\nThe following code extracts the coefficients of s and these are assigned to variables, a, b and c.\n\np = Poly(den, s)\na, b, c, = p.coeffs()\n\nOmega, \\(\\omega\\), is the natural freguency of system and is determined by the following expression:\n\nomega = sqrt(c/a)\nomega\n\n\\(\\displaystyle \\sqrt{\\frac{R_{5}}{C_{1} C_{2} R_{2} R_{3} R_{4}}}\\)\n\n\nQ is a parameter that relates the damping ratio to the natural frequency.\n\nQ = omega/(b/a)\nQ\n\n\\(\\displaystyle C_{1} R_{1} \\sqrt{\\frac{R_{5}}{C_{1} C_{2} R_{2} R_{3} R_{4}}}\\)\n\n\nThe design of a band pass filter can be accomplished by letting \\(C1 = C2 = Cn = 0.1\\mu\\)F, \\(R4 = R5 = Rp = 10\\)k and \\(R2 = R3 = R\\). We can then solve for R at the desired \\(\\omega\\) and \\(\\zeta\\). For example, if we desire a band pass filter with a center frequency of 10 Hz, \\(\\omega = 2 \\pi 10\\) and a damping ratio of \\(\\zeta = 0.5\\), we can solve for the value of R that gives an \\(\\omega = 2 \\pi 10\\)\n\nR = Symbol('R')\nfreq = 10 #Hz\nCn = 0.1e-6\nRp = 10e3\nomega_n = omega.subs({R2:R,R3:R,C1:Cn,C2:Cn,R5:Rp,R4:Rp})\nomega_n\n\n\\(\\displaystyle 10000000.0 \\sqrt{\\frac{1}{R^{2}}}\\)\n\n\nSolve for R with \\(\\omega = 10\\)Hz.\n\nRn = solve(omega_n-freq*2*pi,R)\nRn = float(Rn[1])\nRn\n\n\\(\\displaystyle 159154.943091895\\)\n\n\nSolve for R with \\(R2=R3=Rn\\),\n\nQ_n = Q.subs({R2:Rn,R3:Rn,C1:Cn,C2:Cn,R5:Rp,R4:Rp})\nQ_n\n\n\\(\\displaystyle 6.28318530717959 \\cdot 10^{-6} R_{1}\\)\n\n\nThe damping ratio is a system parameter, denoted by \\(\\zeta\\)\n\nunderdamped: \\(\\zeta \\gt 1\\), roots of the demoninator are real\ncritically damped: \\(\\zeta = 1\\)\noverdamped: \\(\\zeta \\lt 1\\), roots of the demoninator are complex\n\nQ factor is another non-dimensional characterization of the amount of damping; high Q indicates slow damping relative to the oscillation.\n\\(Q = \\frac {1}{2 \\zeta}\\)\n\nzeta = 0.5\nq_factor = 1/(2*zeta)\nR1n = solve(Q_n - q_factor,R1)\nR1n = float(R1n[0])\nR1n\n\n\\(\\displaystyle 159154.943091895\\)\n\n\nUsing the component values calculated above, these are substituted into the network equations.\n\nNE = NE_sym.subs({V1:1.0, R1:R1n, R2:Rn, R3:Rn, R5:Rp, R4:Rp, C2:Cn, C1:Cn})\n\nThe equations are quickly solved by SymPy and the solution is displayed.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{1.25663706143592 \\cdot 10^{28} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{3} = \\frac{6.28318530717959 \\cdot 10^{27} s - 3.94784176043575 \\cdot 10^{29}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{4} = \\frac{6.28318530717959 \\cdot 10^{27} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{5} = \\frac{6.28318530717959 \\cdot 10^{27} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{6} = \\frac{6.28318530717959 \\cdot 10^{27} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(I_{V1} = \\frac{- 6.28318530717959 \\cdot 10^{40} s^{2} - 1.25663706143592 \\cdot 10^{28} s - 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{2} + 6.28318530717961 \\cdot 10^{47} s + 3.94784176043575 \\cdot 10^{49}}\\)\\(I_{O1} = - \\frac{6.67796948322322 \\cdot 10^{30} s}{1.0 \\cdot 10^{33} s^{2} + 6.28318530717961 \\cdot 10^{34} s + 3.94784176043575 \\cdot 10^{36}}\\)\\(I_{O2} = \\frac{3.94784176043575 \\cdot 10^{42} s + 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{2} + 6.28318530717961 \\cdot 10^{47} s + 3.94784176043575 \\cdot 10^{49}}\\)\n\n\nThe transfer function is v2/v1 and some simplication is performed by the operations of nsimplify().simplify().expand().together().\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{1256637061435920 s}{10000000000000 s^{2} + 628318530717961 s + 39478417604357500}\\)\n\n\n\n35.11.0.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values units in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 1\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-5.00+8.66j Hz\n-5.00-8.66j Hz\n\n\nThe SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(-2, 4, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nStep response as a check of the network equations\n\nnet_list = '''\nO1 5 4 2\nO2 5 6 3\nR1 4 1 1\nR2 4 3 1\nR3 5 2 1\nR5 6 2 1\nR4 6 0 1\nC2 5 3 1\nC1 0 4 1\nV1 1 0 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{5}}{R_{3}} = 0\\)\\(- C_{2} s v_{5} + I_{O2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{5} = 0\\)\\(v_{5} - v_{6} = 0\\)\n\n\nget the element values from thge netlist.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{4} : 1.0, \\  R_{5} : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  C_{1}, \\  v_{5}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nThe following cells analyize the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\n#element_values[V1] = 1/(s**2)   # ramp of 1 volt per 1 s\n#element_values[V1] = 1/(s)   # step function\nNE = NE_sym.subs({V1:1/(s), R1:R1n, R2:Rn, R3:Rn, R5:Rp, R4:Rp, C2:Cn, C1:Cn})\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 6.28318530717959 \\cdot 10^{-6} v_{1} - 6.28318530717959 \\cdot 10^{-6} v_{4}\\\\I_{O1} + 0.00010628318530718 v_{2} - 6.28318530717959 \\cdot 10^{-6} v_{5} - 0.0001 v_{6}\\\\I_{O2} - 1.0 \\cdot 10^{-7} s v_{5} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 6.28318530717959 \\cdot 10^{-6}\\right) - 6.28318530717959 \\cdot 10^{-6} v_{4}\\\\- 6.28318530717959 \\cdot 10^{-6} v_{1} - 6.28318530717959 \\cdot 10^{-6} v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 1.25663706143592 \\cdot 10^{-5}\\right)\\\\- 1.0 \\cdot 10^{-7} s v_{3} - 6.28318530717959 \\cdot 10^{-6} v_{2} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-7} s + 6.28318530717959 \\cdot 10^{-6}\\right)\\\\- 0.0001 v_{2} + 0.0002 v_{6}\\\\v_{1}\\\\- v_{4} + v_{5}\\\\v_{5} - v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{1.25663706143592 \\cdot 10^{28}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{3} = \\frac{6.28318530717959 \\cdot 10^{27} s - 3.94784176043575 \\cdot 10^{29}}{1.0 \\cdot 10^{26} s^{3} + 6.28318530717961 \\cdot 10^{27} s^{2} + 3.94784176043575 \\cdot 10^{29} s}\\)\\(v_{4} = \\frac{6.28318530717959 \\cdot 10^{27}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{5} = \\frac{6.28318530717959 \\cdot 10^{27}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{6} = \\frac{6.28318530717959 \\cdot 10^{27}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(I_{V1} = \\frac{- 6.28318530717959 \\cdot 10^{40} s^{2} - 1.25663706143592 \\cdot 10^{28} s - 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{3} + 6.28318530717961 \\cdot 10^{47} s^{2} + 3.94784176043575 \\cdot 10^{49} s}\\)\\(I_{O1} = - \\frac{6.67796948322322 \\cdot 10^{30}}{1.0 \\cdot 10^{33} s^{2} + 6.28318530717961 \\cdot 10^{34} s + 3.94784176043575 \\cdot 10^{36}}\\)\\(I_{O2} = \\frac{3.94784176043575 \\cdot 10^{42} s + 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{3} + 6.28318530717961 \\cdot 10^{47} s^{2} + 3.94784176043575 \\cdot 10^{49} s}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 1\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle \\frac{1.25663706143592 \\cdot 10^{28}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_v2 = inverse_laplace_transform(node_v2_s, s, t)\n#node_v2\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\n\nn, d = fraction(node_v2_s)\nn = n.expand()\nd = d.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(1.25663706143592 \\cdot 10^{28}\\)denominator: \\(1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}\\)\n\n\nUse the SciPy residue function to do the inverse Laplace transform.\n\ncn = Poly(n, s).all_coeffs()\ncd = Poly(d, s).all_coeffs()\nr, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n# build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\nz = 0\nfor i in range(len(r)):\n    m = (r[i]/(s-p[i]))\n    z += inverse_laplace_transform(m, s, t)\n\nEach of the terms came be converted to a function using SymPy’s lambdify function. Define the values for the x-axis of the plot and put each one into an array for plotting.\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.2, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, z)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x*1e3, np.real(V_node2),label='v2(t)')\n#plt.plot(x, np.real(V_node1),label='v1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nAntoniou, Andreas. 1969. “Realization of Gyrators Using Operational Amplifiers and Their Use in RC-Active-Network Synthesis.” In. https://api.semanticscholar.org/CorpusID:64381922.\n\n\nBruton, L. 1978. “Multiple-Amplifier RC-Active Filter Design with Emphasis on GIC Realizations (Invited Paper).” IEEE Transactions on Circuits and Systems.\n\n\nFranco, Sergio. 2002. Design with Operational Amplifiers and Analog Integrated Circuits, 3rd Edition. McGraw-Hill.\n\n\nSedra, A., and J. Espinoza. 1975. “Sensitivity and Frequency Limitations of Biquadratic Active Filters.” IEEE Transactions on Circuits and Systems.\n\n\nStout, D. 1976. Handbook of Operational Amplifier Circuit Design. McGraw-Hill.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Op Amp circuits</span>"
    ]
  },
  {
    "objectID": "mech-sys.html",
    "href": "mech-sys.html",
    "title": "36  Mechanical systems",
    "section": "",
    "text": "36.1 Translational mechanical system\nThe first example in Akbaba et al. (2022), is a translational mechanical system shown in Figure 36.1. The mechaninical system consists of masses, springs, damping elements and sliding friction.\nThe system parameters for mechanical system given in Figure 1 are:\nThe equalivent electrical circuit was entered into LTSpice so that a net list could be generated. The circuit has 16 branches and 11 nodes. The capacitor values in Figure 36.2 have entered as equations. For example, the value for \\(C_1\\) is {1/500}, for which LTSpice will calculate a value of 0.002.\nThe net list for the circuit is listed below.\nTransient analysis is somewhat more involved than the other types of circuit analysis, primarily because SymPy’s inverse Laplace transform is not very robust and can’t handle complicated expressions. The output equation needs to be simplified by writing some code to put the equation into forms that SymPy can deal with.\nLoad the following Python modules.\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\nLoad the netlist generated by LTSpice.\nThe element values in the net list have been set to one. In the code cells below, the correct values will be substituted into the network equations.\nnet_list = '''\nV1 1 0 1\nC1 1 2 1\nCeq 3 4 1\nC4 4 5 1\nC5 7 8 1\nC6 9 10 1\nR1 2 0 1\nR2 5 0 1\nR3 3 4 1\nR4 7 4 1\nR5 8 6 1\nR7 11 8 1\nR6 11 10 1\nL1 1 3 1\nL3 3 9 1\nL2 6 5 1\n'''\nGenerate and display the network equations.\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L1} + I_{V1} = 0\\)\\(- C_{1} s v_{1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) = 0\\)\\(- I_{L1} + I_{L3} + v_{3} \\left(Ceq s + \\frac{1}{R_{3}}\\right) + v_{4} \\left(- Ceq s - \\frac{1}{R_{3}}\\right) = 0\\)\\(- C_{4} s v_{5} + v_{3} \\left(- Ceq s - \\frac{1}{R_{3}}\\right) + v_{4} \\left(C_{4} s + Ceq s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{4}} = 0\\)\\(- C_{4} s v_{4} - I_{L2} + v_{5} \\left(C_{4} s + \\frac{1}{R_{2}}\\right) = 0\\)\\(I_{L2} + \\frac{v_{6}}{R_{5}} - \\frac{v_{8}}{R_{5}} = 0\\)\\(- C_{5} s v_{8} + v_{7} \\left(C_{5} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(- C_{5} s v_{7} + v_{8} \\left(C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{11}}{R_{7}} - \\frac{v_{6}}{R_{5}} = 0\\)\\(- C_{6} s v_{10} + C_{6} s v_{9} - I_{L3} = 0\\)\\(- C_{6} s v_{9} + v_{10} \\left(C_{6} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{11}}{R_{6}} = 0\\)\\(v_{11} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{10}}{R_{6}} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s + v_{3} - v_{9} = 0\\)\\(- I_{L2} L_{2} s - v_{5} + v_{6} = 0\\)\nAs shown above MNA generated many equations and these would be difficult to solve by hand.\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  I_{L1}, \\  v_{11}, \\  L_{1}, \\  v_{6}, \\  R_{3}, \\  v_{10}, \\  v_{5}, \\  C_{6}, \\  v_{7}, \\  I_{L2}, \\  L_{2}, \\  I_{L3}, \\  v_{2}, \\  R_{1}, \\  Ceq, \\  v_{4}, \\  R_{6}, \\  v_{3}, \\  v_{9}, \\  V_{1}, \\  C_{4}, \\  R_{2}, \\  v_{8}, \\  s, \\  R_{5}, \\  R_{7}, \\  C_{5}, \\  L_{3}, \\  v_{1}, \\  C_{1}, \\  R_{4}\\right)\\)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Mechanical systems</span>"
    ]
  },
  {
    "objectID": "mech-sys.html#translational-mechanical-system",
    "href": "mech-sys.html#translational-mechanical-system",
    "title": "36  Mechanical systems",
    "section": "",
    "text": "Figure 36.1: The mechanical and electrical schematic for the mechanical system under consideration is shown. The Figure is from Akbaba et al. (2022), licensed under Creative Commons Attribution-Non Commercial-No Derivatives 4.0 License.\n\n\n\n\n\n\nMechanical Load Masses: M1 = 100 kg, M2 = 40 kg, M3 = 80 kg\nStiffness Elements: K1 = 500 N/m, K2 = 250 N/m, K3 = 150 N/m, K4 = 300 N/m, K5 = 200 N/m, K6 = 180 N/m, Keq = k1 + k2\nViscous Friction elements: B1 = 80 N.s/m, B2 = 30 N.s/m, B3 = 50 N.s/m, B4 = 40 N.s/m, B5 = 10 N.s/m, B6 = 30 N.s/m, B7 = 20 N.s/m\nThe applied force: \\(F(t) = 400sin(4t)e^{-0.1 t}\\) is changed to a unit step function, \\(\\frac {1}{s}\\).\n\n\n\n\n\n\n\n\nFigure 36.2: Schematic\n\n\n\n\nV1 1 0 PULSE(0 1 1 1e-10 0 20 100 2)\nC1 1 2 {1/500}\nCeq 3 4 {1/(500+250)}\nC4 4 5 {1/300}\nC5 7 8 {1/200}\nC6 9 10 {1/180}\nR1 2 0 80\nR2 5 0 30\nR3 3 4 50\nR4 7 4 40\nR5 8 6 10\nR7 11 8 20\nR6 11 10 30\nL1 1 3 100\nL3 3 9 80\nL2 6 5 40\n\n\n\n\n\n\n\n\n\n\n\n\n36.1.1 Symbolic solution\nSince the circuit is large, a symbolic solution takes a long time, so code is commented out.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)\n\n\n\n36.1.2 Numerical solution\nBuilt a dictionary of element values.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{4} : 1.0, \\  C_{5} : 1.0, \\  C_{6} : 1.0, \\  Ceq : 1.0, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  L_{3} : 1.0, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{4} : 1.0, \\  R_{5} : 1.0, \\  R_{6} : 1.0, \\  R_{7} : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nR’s\n(B1 = 80 N.s/m, B2 = 30 N.s/m, B3 = 50 N.s/m, B4 = 40 N.s/m, B5 = 10 N.s/m, B6 = 30 N.s/m, B7 = 20 N.s/m)\n(R1 = 80, R2 = 30, R3 = 50, R4 = 40, R5 = 10, R6 = 30, R7 = 20)\n\nB1 = 80\nB2 = 30\nB3 = 50\nB4 = 40\nB5 = 10\nB6 = 30\nB7 = 20\nelement_values[R1] = B1\nelement_values[R2] = B2\nelement_values[R3] = B3\nelement_values[R4] = B4\nelement_values[R5] = B5\nelement_values[R6] = B6\nelement_values[R7] = B7\n\nL’s\n(M1 = 100 kg, M2 = 40 kg, M3 = 80 kg)\n(L1 = 100, L2 = 40, L3 = 80)\n\nM1 = 100\nM2 = 40\nM3 = 80\nelement_values[L1] = M1\nelement_values[L2] = M2\nelement_values[L3] = M3\n\nUsing C = 1/K\n1/K = C\n(K1 = 500 N/m, K2 = 250 N/m, K3 = 150 N/m, K4 = 300 N/m, K5 = 200 N/m, K6 = 180 N/m, Keq = k1 + k2 )\n(C1 = 500, C2 = 250, C3 = 150, C4 = 300, C5 = 200, C6 = 180, Ceq = k1 + k2 )\n\nK1 = 500\nK2 = 250\nK3 = 150\nK4 = 300\nK5 = 200\nK6 = 180\nKeq = K1 + K2 \n\nelement_values[C1] = 1/K1\nelement_values[C4] = 1/K4\nelement_values[C5] = 1/K5\nelement_values[C6] = 1/K6\nelement_values[Ceq] = 1/Keq\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.002, \\  C_{4} : 0.00333333333333333, \\  C_{5} : 0.005, \\  C_{6} : 0.00555555555555556, \\  Ceq : 0.00133333333333333, \\  L_{1} : 100, \\  L_{2} : 40, \\  L_{3} : 80, \\  R_{1} : 80, \\  R_{2} : 30, \\  R_{3} : 50, \\  R_{4} : 40, \\  R_{5} : 10, \\  R_{6} : 30, \\  R_{7} : 20, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\n\n36.1.3 Mechanical Analogies\nAkbaba et al. (2022) stated that the inductor current is equalivent to the velocity of the mass in a translational mechanical system. Displacement is equalivent to the charge in a capacitor. In the mechanical system shown in Figure 36.1, we will look at the velocity of mass, M3, and its displacement in response to a step function. In the example, Akbaba et al. (2022), uses a dampled sinusoidal function as the driving force, here I’m going to drive the system with a step function. In the cell below, the dampled sinusoidal function is has been commented out and V1 is a unit step function.\n\n#element_values[V1] = laplace_transform(400*exp(-0.1*t)*sin(4*t), t, s)[0] # driving function in example\nelement_values[V1] = laplace_transform(1*Heaviside(t), t, s)[0] # step function as a test\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1} + 0.002 s v_{1} - 0.002 s v_{2}\\\\- 0.002 s v_{1} + v_{2} \\cdot \\left(0.002 s + \\frac{1}{80}\\right)\\\\- I_{L1} + I_{L3} + v_{3} \\cdot \\left(0.00133333333333333 s + \\frac{1}{50}\\right) + v_{4} \\left(- 0.00133333333333333 s - \\frac{1}{50}\\right)\\\\- 0.00333333333333333 s v_{5} + v_{3} \\left(- 0.00133333333333333 s - \\frac{1}{50}\\right) + v_{4} \\cdot \\left(0.00466666666666667 s + \\frac{9}{200}\\right) - \\frac{v_{7}}{40}\\\\- I_{L2} - 0.00333333333333333 s v_{4} + v_{5} \\cdot \\left(0.00333333333333333 s + \\frac{1}{30}\\right)\\\\I_{L2} + \\frac{v_{6}}{10} - \\frac{v_{8}}{10}\\\\- 0.005 s v_{8} - \\frac{v_{4}}{40} + v_{7} \\cdot \\left(0.005 s + \\frac{1}{40}\\right)\\\\- 0.005 s v_{7} - \\frac{v_{11}}{20} - \\frac{v_{6}}{10} + v_{8} \\cdot \\left(0.005 s + \\frac{3}{20}\\right)\\\\- I_{L3} - 0.00555555555555556 s v_{10} + 0.00555555555555556 s v_{9}\\\\- 0.00555555555555556 s v_{9} + v_{10} \\cdot \\left(0.00555555555555556 s + \\frac{1}{30}\\right) - \\frac{v_{11}}{30}\\\\- \\frac{v_{10}}{30} + \\frac{v_{11}}{12} - \\frac{v_{8}}{20}\\\\v_{1}\\\\- 100 I_{L1} s + v_{1} - v_{3}\\\\- 80 I_{L3} s + v_{3} - v_{9}\\\\- 40 I_{L2} s - v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{4.0}{4.0 s + 25.0}\\)\\(v_{3} = \\frac{96.0 s^{6} + 5028.0 s^{5} + 28443.0 s^{4} + 125715.0 s^{3} + 226350.0 s^{2} + 240300.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{4} = \\frac{96.0 s^{6} + 2628.0 s^{5} + 22743.0 s^{4} + 82140.0 s^{3} + 199350.0 s^{2} + 172800.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{5} = \\frac{96.0 s^{5} + 1668.0 s^{4} + 6063.0 s^{3} + 28710.0 s^{2} + 37350.0 s + 67500.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{6} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 22743.0 s^{3} + 64470.0 s^{2} + 105750.0 s + 67500.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{7} = \\frac{96.0 s^{6} + 2628.0 s^{5} + 22983.0 s^{4} + 67440.0 s^{3} + 188190.0 s^{2} + 140400.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{8} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 22983.0 s^{3} + 68640.0 s^{2} + 114690.0 s + 84600.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{9} = \\frac{96.0 s^{6} + 2628.0 s^{5} + 24483.0 s^{4} + 76515.0 s^{3} + 154350.0 s^{2} + 240300.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{10} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 24483.0 s^{3} + 71115.0 s^{2} + 145440.0 s + 129600.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{11} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 23583.0 s^{3} + 69630.0 s^{2} + 126990.0 s + 102600.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(I_{V1} = \\frac{- 320.0 s^{7} - 5912.0 s^{6} - 31286.0 s^{5} - 168111.0 s^{4} - 427825.0 s^{3} - 1029450.0 s^{2} - 1042800.0 s - 1287000.0}{25600.0 s^{8} + 612480.0 s^{7} + 4847040.0 s^{6} + 22550440.0 s^{5} + 82088700.0 s^{4} + 161215500.0 s^{3} + 244899000.0 s^{2} + 133110000.0 s + 81000000.0}\\)\\(I_{L1} = \\frac{32.0 s^{5} + 556.0 s^{4} + 2021.0 s^{3} + 9570.0 s^{2} + 12450.0 s + 22500.0}{3200.0 s^{7} + 56560.0 s^{6} + 252380.0 s^{5} + 1241430.0 s^{4} + 2502150.0 s^{3} + 4513500.0 s^{2} + 2403000.0 s + 1620000.0}\\)\\(I_{L3} = \\frac{60.0 s^{3} + 99.0 s^{2} + 1230.0 s + 1800.0}{640.0 s^{7} + 11312.0 s^{6} + 50476.0 s^{5} + 248286.0 s^{4} + 500430.0 s^{3} + 902700.0 s^{2} + 480600.0 s + 324000.0}\\)\\(I_{L2} = \\frac{24.0 s^{3} + 417.0 s^{2} + 894.0 s + 1710.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\n\n\n\n\n36.1.4 Velocity of \\(M_3\\)\nThe current in L3 is equalivent to the velocity of \\(M_3\\) and the following cells compute the current in the inductor. The current through L3 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nL3_current_s = U[I_L3].nsimplify().simplify().expand().together()\nL3_current_s\n\n\\(\\displaystyle \\frac{3 \\cdot \\left(20 s^{3} + 33 s^{2} + 410 s + 600\\right)}{2 \\cdot \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#L3_current = inverse_laplace_transform(L3_current_s, s, t)\n#L3_current\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(L3_current_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(60 s^{3} + 99 s^{2} + 1230 s + 1800\\)denominator: \\(640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{1800}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}, \\  \\frac{60 s^{3}}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}, \\  \\frac{99 s^{2}}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}, \\  \\frac{1230 s}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nthe SciPy function residue is used to get the residues and poles of the partial-fraction expansion\nbuild the partial expansion terms and find the inverse Laplace of each term and save\n\nReturns:\n\nr: Residues corresponding to the poles. For repeated poles, the residues are ordered to correspond to ascending by power fractions.\np: Poles ordered by magnitude in ascending order.\nk: Coefficients of the direct polynomial term.\n\nWhen computing the inverse Laplace transform, the Coefficients (k) are ignored since these transform to a Dirac delta function, \\(\\delta (t)\\) and don’t need to be plotted.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node2 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node2 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Inductor current vs time')\n\nplt.plot(x, np.real(V_node2),label='i(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n36.1.5 Displacement of \\(M_3\\)\nThe displacement of \\(M_3\\) is equalavent to the charge on C6 which is proportional to the voltage difference between nodes 9 and 10.\n\nC6_voltage_s = (U[v9] - U[v10]).nsimplify().simplify().expand().together()\nC6_voltage_s\n\n\\(\\displaystyle \\frac{270 \\cdot \\left(20 s^{3} + 33 s^{2} + 410 s + 600\\right)}{s \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#C6_voltage = inverse_laplace_transform(C6_voltage_s, s, t)\n#C6_voltage\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(C6_voltage_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(5400 s^{3} + 8910 s^{2} + 110700 s + 162000\\)denominator: \\(s \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{162000}{s \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)}, \\  \\frac{5400 s^{2}}{320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000}, \\  \\frac{8910 s}{320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000}, \\  \\frac{110700}{320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node2 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node2 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Voltage vs time')\n\nplt.plot(x, np.real(V_node2),label='v(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Mechanical systems</span>"
    ]
  },
  {
    "objectID": "mech-sys.html#rotational-mechanical-system",
    "href": "mech-sys.html#rotational-mechanical-system",
    "title": "36  Mechanical systems",
    "section": "36.2 Rotational mechanical system",
    "text": "36.2 Rotational mechanical system\n\n\n\n\n\n\nFigure 36.3: The mechanical and electrical schematic for the mechanical system under consideration is shown. The Figure is from Akbaba et al. (2022), licensed under Creative Commons Attribution-Non Commercial-No Derivatives 4.0 License.\n\n\n\nThe second example in Akbaba et al. (2022), is a rotational mechanical system shown in Figure 36.3. The conversion of the mechanical parameters:\n\nthe moment of inertia\nrotational stiffness or rotational spring element\nrotational viscous friction or rotational damper element\n\nto electrical elements in the equalivent circuit is not include in my calculations. All the electrical elment values are set to one. The reason for this is the converseion is not straight forward and somewhat outside the scope of circuit analysis.\nThe circuit was drawn in LTSpice so that the netlist could be obtained.\n\n\n\n\n\n\nFigure 36.4: Schematic\n\n\n\nLoad the netlist. The value of \\(V_L\\) is set to zero.\n\nnet_list = '''\nVa 1 0 1\nVL 14 0 0\nLa 1 2 1\nLm 5 6 1\nL1 7 8 1\nL2 9 10 1\nL5 0 10 1\nL6 11 0 1\nL3 11 12 1\nL4 13 14 1\nRa 3 0 1\nRmb 5 4 1\nR1 7 6 1\nR4 13 12 1\nC1 9 0 1\nC2 12 0 1\nHa 2 3 V1 1\nHm 4 0 Va 1\nV1 9 8 0\nK1 L5 L6 0.5\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{La} + I_{Va} = 0\\)\\(I_{Ha} - I_{La} = 0\\)\\(- I_{Ha} + \\frac{v_{3}}{Ra} = 0\\)\\(I_{Hm} + \\frac{v_{4}}{Rmb} - \\frac{v_{5}}{Rmb} = 0\\)\\(I_{Lm} - \\frac{v_{4}}{Rmb} + \\frac{v_{5}}{Rmb} = 0\\)\\(- I_{Lm} + \\frac{v_{6}}{R_{1}} - \\frac{v_{7}}{R_{1}} = 0\\)\\(I_{L1} - \\frac{v_{6}}{R_{1}} + \\frac{v_{7}}{R_{1}} = 0\\)\\(- I_{L1} - I_{V1} = 0\\)\\(C_{1} s v_{9} + I_{L2} + I_{V1} = 0\\)\\(- I_{L2} - I_{L5} = 0\\)\\(I_{L3} + I_{L6} = 0\\)\\(- I_{L3} + v_{12} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{13}}{R_{4}} = 0\\)\\(I_{L4} - \\frac{v_{12}}{R_{4}} + \\frac{v_{13}}{R_{4}} = 0\\)\\(- I_{L4} + I_{Vl} = 0\\)\\(v_{1} = Va\\)\\(v_{14} = Vl\\)\\(- v_{8} + v_{9} = V_{1}\\)\\(- I_{La} La s + v_{1} - v_{2} = 0\\)\\(- I_{Lm} Lm s + v_{5} - v_{6} = 0\\)\\(- I_{L1} L_{1} s + v_{7} - v_{8} = 0\\)\\(- I_{L2} L_{2} s - v_{10} + v_{9} = 0\\)\\(- I_{L5} L_{5} s - I_{L6} M_{1} s - v_{10} = 0\\)\\(- I_{L5} M_{1} s - I_{L6} L_{6} s + v_{11} = 0\\)\\(- I_{L3} L_{3} s + v_{11} - v_{12} = 0\\)\\(- I_{L4} L_{4} s + v_{13} - v_{14} = 0\\)\\(- I_{V1} ha + v_{2} - v_{3} = 0\\)\\(- I_{Va} hm + v_{4} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand.\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L4}, \\  ha, \\  I_{L1}, \\  L_{1}, \\  v_{14}, \\  v_{6}, \\  Rmb, \\  L_{4}, \\  v_{10}, \\  hm, \\  L_{5}, \\  v_{2}, \\  I_{Vl}, \\  R_{1}, \\  v_{12}, \\  I_{Lm}, \\  v_{8}, \\  La, \\  L_{6}, \\  I_{Va}, \\  I_{V1}, \\  Ra, \\  v_{13}, \\  v_{11}, \\  Vl, \\  I_{Hm}, \\  v_{5}, \\  v_{7}, \\  I_{L2}, \\  L_{2}, \\  I_{L5}, \\  I_{L3}, \\  I_{L6}, \\  v_{4}, \\  I_{La}, \\  C_{2}, \\  Lm, \\  v_{3}, \\  v_{9}, \\  V_{1}, \\  s, \\  M_{1}, \\  L_{3}, \\  Va, \\  v_{1}, \\  C_{1}, \\  R_{4}, \\  I_{Ha}\\right)\\)\n\n\nSince the circuit is large, a symbolic solution takes a long time, so code is commented out.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  K_{1} : 0.5, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  L_{3} : 1.0, \\  L_{4} : 1.0, \\  L_{5} : 1.0, \\  L_{6} : 1.0, \\  La : 1.0, \\  Lm : 1.0, \\  R_{1} : 1.0, \\  R_{4} : 1.0, \\  Ra : 1.0, \\  Rmb : 1.0, \\  V_{1} : 0.0, \\  Va : 1.0, \\  Vl : 0.0, \\  ha : 1.0, \\  hm : 1.0\\right\\}\\)\n\n\nThe mutual inductance between L1 and L2 is calculated from the coupling coeeficient.\n\\(M = k\\sqrt{L_1L_2}\\)\n\nK1 = symbols('K1')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L5] * element_values[L6])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.500000000\n\n\nRe-define the symbol \\(t\\) for time and define \\(V_a\\) to be a voltage step.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nelement_values[Va] = laplace_transform(1*Heaviside(t), t, s)[0]\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{La} + I_{Va}\\\\I_{Ha} - I_{La}\\\\- I_{Ha} + 1.0 v_{3}\\\\I_{Hm} + 1.0 v_{4} - 1.0 v_{5}\\\\I_{Lm} - 1.0 v_{4} + 1.0 v_{5}\\\\- I_{Lm} + 1.0 v_{6} - 1.0 v_{7}\\\\I_{L1} - 1.0 v_{6} + 1.0 v_{7}\\\\- I_{L1} - I_{V1}\\\\I_{L2} + I_{V1} + 1.0 s v_{9}\\\\- I_{L2} - I_{L5}\\\\I_{L3} + I_{L6}\\\\- I_{L3} + v_{12} \\cdot \\left(1.0 s + 1.0\\right) - 1.0 v_{13}\\\\I_{L4} - 1.0 v_{12} + 1.0 v_{13}\\\\- I_{L4} + I_{Vl}\\\\v_{1}\\\\v_{14}\\\\- v_{8} + v_{9}\\\\- 1.0 I_{La} s + v_{1} - v_{2}\\\\- 1.0 I_{Lm} s + v_{5} - v_{6}\\\\- 1.0 I_{L1} s + v_{7} - v_{8}\\\\- 1.0 I_{L2} s - v_{10} + v_{9}\\\\- 1.0 I_{L5} s - 0.5 I_{L6} s - v_{10}\\\\- 0.5 I_{L5} s - 1.0 I_{L6} s + v_{11}\\\\- 1.0 I_{L3} s + v_{11} - v_{12}\\\\- 1.0 I_{L4} s + v_{13} - v_{14}\\\\- 1.0 I_{V1} + v_{2} - v_{3}\\\\- 1.0 I_{Va} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{30.0 s^{6} + 75.0 s^{5} + 122.0 s^{4} + 140.0 s^{3} + 95.0 s^{2} + 52.0 s + 12.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{3} = \\frac{30.0 s^{6} + 60.0 s^{5} + 107.0 s^{4} + 109.0 s^{3} + 79.0 s^{2} + 40.0 s + 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{4} = \\frac{- 30.0 s^{6} - 60.0 s^{5} - 107.0 s^{4} - 109.0 s^{3} - 79.0 s^{2} - 40.0 s - 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{5} = \\frac{- 30.0 s^{6} - 45.0 s^{5} - 92.0 s^{4} - 78.0 s^{3} - 63.0 s^{2} - 28.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{6} = \\frac{- 15.0 s^{6} - 30.0 s^{5} - 61.0 s^{4} - 62.0 s^{3} - 51.0 s^{2} - 24.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{7} = \\frac{- 15.0 s^{5} - 15.0 s^{4} - 46.0 s^{3} - 31.0 s^{2} - 35.0 s - 12.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{8} = \\frac{- 15.0 s^{3} - 15.0 s^{2} - 23.0 s - 8.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{9} = \\frac{- 15.0 s^{3} - 15.0 s^{2} - 23.0 s - 8.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{10} = \\frac{- 7.0 s^{3} - 7.0 s^{2} - 11.0 s - 4.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{11} = \\frac{2.0 s^{3} + 2.0 s^{2} + 4.0 s + 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{12} = \\frac{2.0 s + 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{13} = \\frac{2.0 s}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{14} = 0.0\\)\\(I_{Va} = \\frac{- 30.0 s^{6} - 60.0 s^{5} - 107.0 s^{4} - 109.0 s^{3} - 79.0 s^{2} - 40.0 s - 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{Vl} = \\frac{2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{V1} = \\frac{15.0 s^{5} + 15.0 s^{4} + 31.0 s^{3} + 16.0 s^{2} + 12.0 s + 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{La} = \\frac{30.0 s^{6} + 60.0 s^{5} + 107.0 s^{4} + 109.0 s^{3} + 79.0 s^{2} + 40.0 s + 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{Lm} = \\frac{- 15.0 s^{5} - 15.0 s^{4} - 31.0 s^{3} - 16.0 s^{2} - 12.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L1} = \\frac{- 15.0 s^{5} - 15.0 s^{4} - 31.0 s^{3} - 16.0 s^{2} - 12.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L2} = \\frac{- 8.0 s^{3} - 8.0 s^{2} - 12.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L5} = \\frac{8.0 s^{3} + 8.0 s^{2} + 12.0 s + 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L6} = \\frac{- 2.0 s^{2} - 2.0 s - 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{L3} = \\frac{2.0 s^{2} + 2.0 s + 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{L4} = \\frac{2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{Ha} = \\frac{30.0 s^{6} + 60.0 s^{5} + 107.0 s^{4} + 109.0 s^{3} + 79.0 s^{2} + 40.0 s + 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{Hm} = \\frac{15.0 s^{5} + 15.0 s^{4} + 31.0 s^{3} + 16.0 s^{2} + 12.0 s + 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\n\n\n\n36.2.1 Va current\nThe current from Va is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nVa_current_s = U[I_Va].nsimplify().simplify().expand().together()\nVa_current_s\n\n\\(\\displaystyle \\frac{- 30 s^{6} - 60 s^{5} - 107 s^{4} - 109 s^{3} - 79 s^{2} - 40 s - 8}{s \\left(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#Va_current = inverse_laplace_transform(Va_current_s, s, t)\n#Va_current\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(Va_current_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(- 30 s^{6} - 60 s^{5} - 107 s^{4} - 109 s^{3} - 79 s^{2} - 40 s - 8\\)denominator: \\(s \\left(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\right)\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ - \\frac{8}{s \\left(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\right)}, \\  - \\frac{109 s^{2}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{107 s^{3}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{79 s}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{60 s^{4}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{40}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{30 s^{5}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nVa_current = np.zeros(len(x),dtype = complex)\nfor p in N:\n    Va_current += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Current vs time')\n\nplt.plot(x, np.real(Va_current),label='I_Va(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n36.2.2 Node 12 voltage\nThe voltage at node 12 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nnode12_voltage_s = U[v12].nsimplify().simplify().expand().together()\nnode12_voltage_s\n\n\\(\\displaystyle \\frac{2 \\left(s + 1\\right)}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node12_voltage = inverse_laplace_transform(node12_voltage_s, s, t)\n#node12_voltage\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(node12_voltage_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(2 s + 2\\)denominator: \\(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{2}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  \\frac{2 s}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node12 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node12 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Voltage vs time')\n\nplt.plot(x, np.real(V_node12),label='v12(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Mechanical systems</span>"
    ]
  },
  {
    "objectID": "mech-sys.html#summary",
    "href": "mech-sys.html#summary",
    "title": "36  Mechanical systems",
    "section": "36.3 Summary",
    "text": "36.3 Summary\nAs show above, when a mechanical system is drawn as an electrical schematic, MNA can be applied to obtain a solution. The procedure to express a mechanical system as an equalivent circuit is outside the scope of this book.\nHere are a few links to an interesting related video and papers:\n\nThe Genius Device That Rocked F1 | An Interview With Its Inventor\nSynthesis of Mechanical Networks: The Inerter\nThe Inerter: A Retrospective\n\n\n\n\n\nAkbaba, Mehmet, Omar Dakkak, Byung-Seo Kim, Adnan Cora, and Shahrudin Awang Nor. 2022. “Electric Circuit-Based Modeling and Analysis of the Translational, Rotational Mechanical and Electromechanical Systems Dynamics.” IEEE Access. https://doi.org/10.1109/ACCESS.2022.3185422.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Mechanical systems</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html",
    "href": "Klon Centaur part 1.html",
    "title": "37  Klon Centaur, part 1",
    "section": "",
    "text": "37.1 Introduction\nThis analysis will illustrate the application of MNA, Python programming and LTSpice to an interesting circuit called the Klon Centaur. The schematics shown in this notebook were drawn using LTSpice and from those schematics, LTSpice was used to generate the netlists. Python and the MNA code was used to generate network equations from the netlists and obtain solutions for unknown voltages and currents. Transient analysis of the circuit was performed using LTSpice using device models for the diodes and Op Amps. This notebook will attempt to analyze and describe the operation of the various parts of the circuit, with the exception of the power supply.\nAs an electrical engineer, I’ve been curious about the workings of the electric guitar and the operation of the effects boxes. My motivation in writing this paper was to learn a little about the topic. I don’t play the guitar and I’m not a musician, so I’ll be looking at this topic from the point of view of signals and circuits.\nFollowing the introduction section about the characteristics of the electric guitar and associated equipment, a description of the electrical schematic and the interfaces to the circuit (knobs and jacks) is provided. There are some on-line sources that are referenced which provide an analysis of the circuit, primarily utilizing LTSpice. These analyses are interesting since the perspective is somewhat different from what is provided in this notebook. A few words are provided about current price and availability of the pedal, the Klon KTR and Klon Centaur clones.\nThe analysis provided in this notebook is a deep dive into the operation of the circuit from the perspective of traditional linear circuit analysis taught in electrical engineering schools. The focus is on circuit analysis and not circuit design. This means looking at how the circuit works, since this is what circuit analysis is all about. The designers of the Klon Centaur were looking for a particular sound or tone profile and in some places I’ll comment on reasons why the designers might have developed these circuits; but for the most part I’ll not be looking at why the circuit works in a particular way, but how it works.\nThe Klon Centaur is an overdrive pedal and the top of the pedal is shown in Figure 37.1. The Klon Centaur is widely used in many genres of music, including blues, rock and country. An overdrive pedal is a piece of electronic equipment used by guitarists to alter the sound of the guitar. It’s essentially a box containing a circuit that is connected between the guitar and the amplifier, often with other pedals in series, and these pedals control the amount of gain, distortion, tone and output level delivered to the amplifier.\nBill Finnegan, owner of Klon LLC, and the Klon Centaur creator, wanted to make a pedal that would recreate the sound of a guitar amplifier’s distortion at high volume. Finnegan wasn’t a fan of the sound of the popular Ibanez Tube Screamer, which many guitarists use for overdrive. He felt it sounded too artificial and buzzy. So he set out to create a pedal that would deliver a more natural, tube-like overdrive sound with rich harmonics. The pedal was designed to have a “big, open” sound with “a hint of tube clipping” that wouldn’t sound like it was made by a pedal. Just to clarify, Klon is the company name and Centuar is the name of the pedal and since the Klon only had one product, the product became known as the Klon Centaur. Over the production life of the Centaur, the color of the case and the centaur logo has changed.\nFinnegan worked with MIT graduate Fred Fenning and other electrical engineer friends for four and a half years to create prototype pedals. A Germanium diode was chosen by Finnegan for the circuit and he bought as many as he could, since these were a special type that he determined sounded more musical than others he tested. These diodes are no longer in production. The components of the circuit were coated in epoxy resin to make reverse engineering of the circuit more difficult. The Klon Centaur was first sold in late 1994. Finnegan personally built, tested and shipped the pedals from his house, where he was inundated with orders. Many of the components, including the cast enclosure and knobs were custom manufactured. Over the course of 15 years, Finnegan sold about 8,000 pedals. See The Klon Centaur Guide for a thorough and informative history of the Klon.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#introduction",
    "href": "Klon Centaur part 1.html#introduction",
    "title": "37  Klon Centaur, part 1",
    "section": "",
    "text": "Note\n\n\n\nNotebook organization: The analysis of the Klon Centaur circuits ended up being rather long. Navigating and rendering of the notebook became a bit sluggish on my laptop, so I decided to break up the notebook into three parts.\n\nKlon Centaur, part 1: Introduction and Effects path linear analysis\nKlon Centaur, part 2: Effects path nonlinear analysis\nKlon Centaur, part 3: Design Review and Reactive branch analysis",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#electric-guitar-characteristics",
    "href": "Klon Centaur part 1.html#electric-guitar-characteristics",
    "title": "37  Klon Centaur, part 1",
    "section": "37.2 Electric guitar characteristics",
    "text": "37.2 Electric guitar characteristics\nAn electric guitar is a type of guitar that relies on electrical amplification to produce sound. Electric guitars are known for the wide variety of tones they can produce. By using effects pedals and manipulating the knobs on the guitar and amplifier, musicians can create sounds ranging from clean and bright to distorted and heavy. This versatility has made the electric guitar a popular instrument in many genres of music, including rock, blues, country and jazz.\nAn electric guitar isn’t just the guitar. While the wooden body, neck and strings are essential components, they only produce a very faint sound on their own. The essential parts for the electric guitar are:\n\nThe Guitar: This is where the musical performance originates. The player’s technique, the strings’ vibration and the guitar’s construction all contribute to the initial sound. However, the sound produced by the guitar alone is very quiet and lacks the power and character we associate with electric guitars.\nThe Amplifier: This electronic device takes the tiny electrical signals from the guitar’s pickups and boosts them to a much higher volume level. It also shapes the sound, adding characteristics like warmth, brightness, or distortion.\nThe Speaker: This is the final link in the chain, converting the amplified electrical signal into sound waves that we can hear. Different speakers produce different tones and the size and design of the speaker cabinet significantly impacts the overall sound.\n\nIn essence, the electric guitar, amplifier and speaker work together as a system to produce the rich, varied and powerful sounds that define this instrument. Each component plays a crucial role in shaping the final sound. The combination of these elements is what makes the electric guitar such a versatile and expressive instrument.\nJim Lill, a Nashville musician, has an informative series of videos exploring this topic, starting with Tested: Where Does The Tone Come From In An Electric Guitar?. The components of an electric guitar, all of which contribute to the tone are described below in more detail:\n\n37.2.1 Body\nThe electric guitar body is the foundation of the instrument, providing a sturdy platform for attaching the neck, strings, pickups, electronics and bridge. Electric guitar bodies come in a wide variety of shapes, each with its own distinct look and tonal characteristics. Some of the most popular and iconic shapes include:\n\nStratocaster: Contoured double-cutaway body with three pickups. Known for its bright, twangy sound and versatility across various genres.\nTelecaster: Solid body with a single-cutaway design and typically two pickups. Known for its twangy, bright tone and bite.\nLes Paul: Solid body with a carved top, typically two humbucker pickups. Known for its warm, thick and sustain-rich tone.\nGibson SG: Solid body with a “horns” design and typically two humbucker pickups. Known for its comfortable, lightweight design and bright, punchy tone.\n\nThe type of wood used for the guitar body plays a significant role in its tone. Some of the most common body woods include:\n\nMahogany: A popular choice for both solid and semi-hollow bodies, known for its warm, woody tone with good sustain.\nAlder: A popular choice for Stratocasters and Telecasters, known for its bright, balanced tone.\nAsh: Lighter than mahogany with a brighter, more scooped tone. Often used on Fender guitars.\nBasswood: A lightweight wood often used on budget guitars, with a neutral tone that can take EQ well.\nPoplar: Another affordable wood with a neutral tone, commonly used on budget guitars.\n\nElectric guitar bodies can be constructed in two main ways:\n\nSolid body: The most common type, made from a single piece of wood or laminated pieces of wood. Offers good sustain and resonance.\nSemi-hollow body: Has a hollow core with solid wood tops and backs. Offers a warmer, more resonant tone than solid bodies, but with less sustain.\n\n\n\n37.2.2 Strings\nThe electric guitar uses pickups to convert the vibrations of the steel strings into electrical signals. There are many different types of electric guitar strings available, each with its own unique sound. Some of the most common types of strings include:\n\nRound wound strings: These are the most popular type of electric guitar string. They have a bright, clear sound and are very versatile.\nFlat wound strings: These strings have a smooth, mellow sound. They are often used by jazz guitarists.\nNickel-plated steel strings: These strings are bright and warm-sounding. They are a popular choice for many different genres of music.\nStainless steel strings: These strings are bright and have a long lifespan. They are often used by rock and metal guitarists.\n\nWhen a string is strummed or plucked, it vibrates and interactacts with the magnetic field of the pickup. The vibrations and movement of the steel string in close proximity to the ends of the magnets in the pickup cause the vibrations to be impressed on the magnetic field which causes a voltage to be induced in the wire wound around the magnets. The strings vibrate at different frequencies depending on their thickness, length and tension. The thicker the string, the lower the pitch and frequency. An electric guitar typically has six strings. The thickest string is the low E string and the thinnest string is the high E string. The fundamental of the low E string is about 80 Hz. The frequency range of interest would start at 80 Hz and go up to the sixth harmonic of the highest note on the high E string, or about 7.8kHz. Guitar Frequency Range Chart talks about using an equalized frequency range of 150 Hz up to 5 to 8 kHz. In the analysis that follows an audio range of 80 to 8kHz will be highlighted as the electric guitar audio band.\n\n\n37.2.3 Pickups\nThere are different types of pickups, each with its own sound. There are two main types of electric guitar pickups: single-coil and Humbucker.\n\nSingle-coil pickups are known for their bright, clear and often crisp sound. However, they are also susceptible to electrical hum, which is a low-level buzzing sound that can be caused by electromagnetic interference.\nHumbucker pickups are made with two coils that are wired out of phase with each other. This helps to cancel out the hum that is common with single-coil pickups. Humbuckers tend to have a thicker, fuller sound than single-coils.\n\nThe position of a pickup in the guitar also affects its sound. Pickups that are closer to the bridge tend to have a brighter sound, while pickups that are closer to the neck tend to have a warmer, fuller sound. Electric guitar pickups come in a wide variety of styles and designs, each with its own unique sound. Some of the most popular brands of electric guitar pickups include Seymour Duncan, DiMarzio, EMG and Fender.\nElectric guitar pickups typically have a high impedance, around 10kΩ, which can make them susceptible to noise pickup over long cables. Most electric guitars use passive pickups, which rely on the vibration of the strings to induce a current in the pickup coil. This results in a relatively weak signal with low output voltage.\n\n\n37.2.4 Controls\nElectric guitars typically have pickup selector switches and tone/volume knobs.\n\nPickup selector switch: This switch allows you to select which pickups will be active and sent to the amplifier. The most common types of pickup selector switches are 3-way and 5-way switches.\n\n3-way switch: This is commonly found on Gibson Les Paul guitars. It typically has positions for the bridge pickup only, neck pickup only and both pickups combined.\n5-way switch: This is commonly found on Fender Stratocaster guitars. It typically has positions for the bridge pickup only, bridge and middle pickups combined, middle pickup only, neck and middle pickups combined and neck pickup only.\n\nTone/Volume knobs: These are knobs that allow you to control the volume and tone of the signal sent from the pickups to the amplifier.\n\nVolume knob: This knob controls the overall output level of the guitar. Turning it up increases the volume and turning it down decreases the volume.\nTone knob: This knob controls the treble (high frequencies) of the signal. Turning it up allows more treble to pass through, resulting in a brighter sound. Turning it down cuts the treble, resulting in a warmer sound. Some guitars may have multiple tone knobs, allowing for independent control over the treble of different pickups.\n\n\nThese switches and knobs are crucial for shaping the electric guitar’s sound. By manipulating the pickup selection and tone/volume controls, guitarists can create a wide variety of tones, from bright and twangy to warm and thick.\n\n\n37.2.5 Amplifier\nAn electric guitar amplifier, often simply called an amp, is an electronic device that takes the weak electrical signal produced by an electric guitar’s pickups and amplifies the signal such that it can be heard through a speaker. There are two main types of electric guitar amplifiers:\n\nTube amplifiers: These classic amps use vacuum tubes to pre-amplify and power the signal. Tube amps are prized for their warm, rich sound and responsiveness to playing dynamics. However, they tend to be more expensive, heavier and more delicate than solid-state amps.\nSolid-state amplifiers: These amps use transistors to amplify the signal. Solid-state amps are generally more affordable, lighter and more durable than tube amps. They can also produce a wide variety of tones, making them versatile for many genres of music.\nModeling amps: These amps use digital technology to model the sound of classic tube amps and other effects pedals. Modeling amps are very versatile and can be a great way to get a wide variety of tones without having to buy a lot of equipment.\nCombo amps: These amps combine the amplifier and speaker in a single unit. They are typically more portable and affordable than stacks, making them a good choice for beginners and practice.\n\n\n\n37.2.6 Cabinet\nAn electric guitar cabinet, also known as a speaker cabinet or simply a cab, is an enclosure that houses one or more loudspeakers. It is an essential component of an electric guitar amplifier setup. The Cabinet is the housing that encloses the speakers. The cabinet is typically made of wood, such as plywood or MDF (medium-density fiberboard) and is designed to resonate at certain frequencies to color the sound of the speakers. There are Open-back and Closed-back cabinets. Open-back cabinets tend to produce a brighter, more airy sound, while closed-back cabinets produce a tighter, more focused sound with more bass. The number of speakers in a cabinet affects its overall volume and tone. A 4x12 cabinet with four 12-inch speakers is a popular choice for rock and metal guitarists who need a lot of volume and bottom end. A 1x12 cabinet with a single 12-inch speaker is a more portable option that is still loud enough for practice and small gigs.\n\n\n37.2.7 Tone\nThe electric guitar tone is the overall sound produced by the instrument, influenced by a combination of factors including:\n\nElectric guitar components:\n\nPickups: These magnetic devices convert the vibrations of the strings into an electrical signal.\nEffects: Electric guitar effects are electronic devices that modify the sound of an electric guitar. They can be used to create a wide variety of tones, from subtle to extreme. Effects pedals are typically individual units that are controlled by foot switches. They can be chained together to create complex effects. Multi-effects processors combine the functionality of many different pedals into a single unit.\nAmp: Tube amps are known for their warm, rich sound and responsiveness to playing dynamics, while solid-state amps are more versatile and can produce a wider variety of tones. The settings on the amplifier, such as gain, EQ and reverb, will significantly impact the overall tone.\nCabinet: An electric guitar cabinet, also known as a speaker cabinet or simply a cab, is a wooden enclosure that houses one or more loudspeakers. It is designed to project the amplified sound of an electric guitar. Guitar cabinets are passive devices, meaning that they don’t require their own power source to function. Instead, they rely on the power from an electric guitar amplifier.\n\nPlaying technique:\n\nPicking technique: How you pick the strings (pickups closer to the bridge or neck, pick attack strength) can affect the brightness, attack and overall character of the tone.\nString bending: Bending strings adds pitch variations and vibrato to your sound.\nEffects pedals: These electronic devices can add a wide variety of effects to your tone, such as distortion, overdrive, chorus, delay and reverb.\n\nMicrophone: Miking an electric guitar cab involves placing a microphone in front of the speaker cabinet to capture the sound of the amplified guitar. This technique is commonly used in live performances and studio recordings to capture the full body and character of the electric guitar tone.\nMixing console: Live performance mixing consoles, also known as live sound mixers, are electronic devices used to control and manipulate the sounds of multiple microphones and instruments during a live performance. They are the central hub of a sound system for concerts, public speeches, theatrical productions and other live events.\n\nHere are some common electric guitar tones and how they are achieved:\n\nClean tone: A bright, clear tone with minimal distortion or amplification. Achieved with low gain settings on the amp and single-coil pickups.\nOverdrive: A warmer, more saturated tone than clean, with a slight amount of grit and breakup. Achieved with higher gain settings on the amp or with overdrive pedals.\nDistortion: A heavily amplified and distorted sound, often used for rock and metal music. Achieved with high gain settings on the amp or with distortion pedals.\nBlues tone: Often characterized by a clean or slightly overdriven tone with a warm midrange emphasis. Achieved with single-coil pickups and tube amps with moderate gain settings.\n\n\n\n37.2.8 Effects\nElectric guitar effects pedals are electronic devices that alter the electrical signal of the guitar to create new and unique sounds. They are inserted between the guitar and your amplifier, allowing modification of the basic sound of the instrument in a variety of ways. There are a vast number of different effects pedals available, but some of the most common and popular types include:\n\nDistortion and overdrive pedals: These pedals add grit, saturation and sustain to the guitar sound. Distortion is generally heavier than overdrive, but both can be used to create a wide range of rock and metal tones.\nFuzz pedals: These pedals create a thick, fuzzy distortion sound that is often associated with psychedelic rock and garage rock.\nWah-wah pedals: These pedals create a vocal-like “wah-wah” sound by sweeping a band of frequencies up and down as the pedal is rocked. They are often used in funk, blues and rock music.\nDelay pedals: These pedals create echo effects by recording a short sample of the signal and then playing it back a few milliseconds later. Delay pedals can be used to add depth, space and atmosphere to the sound.\nReverb pedals: These pedals simulate the natural reverberation of sound in a room or hall. Reverb can add depth, ambience and atmosphere to the sound.\nChorus pedals: These pedals create a lush, shimmering sound by duplicating the signal and slightly detuning it. Chorus is often used to add thickness and body to clean tones.\nFlanger pedals: These pedals create a swirling, jet-like sound by splitting your signal and delaying one side slightly. Flangers are often used to add texture and movement to the sound.\nPhaser pedals: These pedals create a phasing effect by splitting the signal and feeding it through two slightly out-of-phase filters. Phasers can create a subtle warbling or pulsating sound.\nEqualizer (EQ) pedals: These pedals allow you to boost or cut specific frequencies in your signal. EQ pedals can be used to shape the tone and correct for tonal imbalances.\n\nThe Klon Centaur is a type of distortion pedal. Distortion is usually achieved by some type of nonlinear signal processing such as clipping or limiting the amplitude of the guitar signal, which creates harmonic overtones. The amount of distortion that a pedal creates puts it into a typical category or type. An overdrive pedal creates a relatively moderate amount of distortion. A pedal producing a bit more distortion is called a distortion pedal and a pedal producing an extreme amount of distortion is called a fuzz pedal.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#klon-centaur-schematic",
    "href": "Klon Centaur part 1.html#klon-centaur-schematic",
    "title": "37  Klon Centaur, part 1",
    "section": "37.3 Klon Centaur schematic",
    "text": "37.3 Klon Centaur schematic\nThe Klon Centaur circuit board was originally covered with a black epoxy resin to prevent people from replicating it. The community at freestompboxes.org bought a Centaur and sent it to Martin Chittum to analyze. Martin was able to remove the black epoxy resin, trace the circuit and identify all of the components. The schematic was publicly released online in April 2008. Several modifications needed to be made to the schematic, with a final corrected version released in May 2009. Martin Chittum’s Klon Centaur schematic is regarded as accurate. Production of the Klon Centaur stopped soon after Martin Chittum’s schematic was published and clones became available.\n\n\n\n\n\n\nFigure 37.2: Martin Chittum’s Klon Centaur schematic\n\n\n\nThe Op Amp U2A is configured as a summing amplifier that combines the signal from two clean paths and the path containing the diodes, D2 and D3. The paths have reactive components that are shaping the frequency response of the signal and it is not obvious how these circuits are shaping the tone. This is one reason why this pedal has a mystic surrounding it and almost a cult following.\n\n37.3.1 Klon Centaur interface\nThe Klon Centaur has a simple yet effective control layout.\n\nKnobs, these correspond to P1, P2 and P3 in the schematic, Figure 37.2.\n\nGAIN: This control significantly influences the pedal’s tone and character. At low gain settings it provides clean boost. At medium Gain Settings the overdrive is increased. At high gain setting the overdrive is more aggressive.\nTREBLE: The treble control boosts or cuts frequencies above 200Hz.\nOUTPUT: The output control on a Klon Centaur is primarily used to adjust the overall volume level of the pedal.\n\nSwitch S1 is the bypass ON or effects ON switch.\nRed LED, D1 in the schematic: illuminated when the effect is on.\n\nThe Klon Centaur uses a standard 9-volt battery as the internal power source, but also has a jack for external 9 volt power. This is indicated as BAT1 in the schematic.\nThere are three jacks on the Klon Centaur chassis, these are:\n\nIN (J1 in the schematic): The signal input. This is a standard 1/4-inch guitar input jack.\nOUT (J2 in the schematic): This is also a standard 1/4-inch output jack, used to connect the pedal to the amplifier or other effects.\n9V (The DC jack in the schematic): The Klon Centaur uses a unique 1/8” (3.5mm) mini jack power connector for external power (if a battery is not used). This is different from the standard center-negative 2.1mm barrel jack found on most pedals.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#sec-web_circuit_analysis",
    "href": "Klon Centaur part 1.html#sec-web_circuit_analysis",
    "title": "37  Klon Centaur, part 1",
    "section": "37.4 Klon Centaur Circuit analysis, blog/forum pages",
    "text": "37.4 Klon Centaur Circuit analysis, blog/forum pages\nThere are a variety of online sites that explain how the circuit operates, among these are:\n\nElectroSmash: This website provides a detailed breakdown of the Klon Centaur circuit, highlighting unique features and explaining how different sections contribute to the overall sound.\nKlon Centaur circuit analysis: Circuit description.\nDIYstompboxes forum: While discussions here acknowledge the complexity of the circuit and the lack of a purely mathematical approach, some users delve into specific aspects and component functions.\nBuilder Profile: Klon’s Bill Finnegan: Interview and design history.\n\nThe Klon Centaur’s design is thought to be a mixture of basic circuit design known for its blend of theoretical understandingand “ear-based” adjustments. So, while the resources above offer valuable insights, the complete picture might involve a combination of electrical theory and the designer’s experimentation. I could not find a good description of the signal path for what I’m calling the clean tone path 2, see Section 37.11.2.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#klon-centaur-price-and-availability",
    "href": "Klon Centaur part 1.html#klon-centaur-price-and-availability",
    "title": "37  Klon Centaur, part 1",
    "section": "37.5 Klon Centaur price and availability",
    "text": "37.5 Klon Centaur price and availability\nThe initial price of a Klon Centaur in 1994 was 225 dollars. The price increased over time and by 2007 a Klon Centaur cost 329 dollars. The price of used Klon Centaur pedals began to increase because people did not want to wait for a new one. Currently used Klon Centaurs are selling for thousands of dollars on eBay.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#the-klon-ktr-a-pedalboard-friendly-redesign",
    "href": "Klon Centaur part 1.html#the-klon-ktr-a-pedalboard-friendly-redesign",
    "title": "37  Klon Centaur, part 1",
    "section": "37.6 The Klon KTR: A Pedalboard-Friendly Redesign",
    "text": "37.6 The Klon KTR: A Pedalboard-Friendly Redesign\nThe Klon KTR is a redesigned version of the Klon Centaur overdrive pedal, released in 2014 by Bill Finnegan. Finnegan’s aim with the KTR was to create a pedal that retained the sound of the original Centaur while addressing some of the production and practicality issues of the original design. One of his main goals was to make the KTR easier to manufacture, so he opted for a design that could be built by a contracted manufacturing firm. This involved using surface-mount components for most of the parts, with the exception of the germanium clipping diodes. He also wanted to make the KTR more pedalboard-friendly, so he chose a smaller enclosure than the original Centaur. The KTR features a standard DC jack and a switchable buffer bypass. Importantly, Finnegan maintained the use of the original Klon Centaur germanium clipping diodes in the KTR. The KTR initially sold for $269. Finnegan included the text “Kindly remember: The ridiculous hype that offends so many is not of my making” on the pedal. The Klon KTR is no longer in production.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#klon-centaur-clones",
    "href": "Klon Centaur part 1.html#klon-centaur-clones",
    "title": "37  Klon Centaur, part 1",
    "section": "37.7 Klon Centaur clones",
    "text": "37.7 Klon Centaur clones\nThe Klon Centaur is a legendary overdrive pedal widely regarded as the “holy grail” of overdrive by many guitarists. There are many Klon Centaur clones available on the market that try to capture the sound of the original. Here are some of the popular Klon Centaur clones:\n\nMosky Silver Horse Overdrive Boost-Function: This is a budget-friendly option that captures the Klon Centaur’s warm overdrive sound. It has gain and sustain, making it great for solos. Prices are typically $48.\nWarm Audio Centavo Overdrive Pedal: This clone is known for its high quality and accurate reproduction of the Klon Centaur sound. It also includes a mod switch for extending the low-end response. It currently costs $179.\nTone City Bad Horse Overdrive: This is another well-regarded Klon clone that is known for its accurate sound and small size. It has a rating of 4.80 out of 5 based on 51 user reviews and currently costs $54.\nStewMac Ghost Drive Pedal Kit: This is a great option for those who want to build their own Klon clone. It has a rating of 4.91 out of 5 based on 210 user reviews and costs $125.\nMosky Golden Horse: This is a popular Klon clone that is known for its transparent overdrive sound and ease of use. It is also very compact. Prices typically are around $39.\nClown Centurion: A DIY implementation with some circuit simplification.\nNOTAKLÖN: A kit for a no-solder clone for $99.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#analysis-methodology",
    "href": "Klon Centaur part 1.html#analysis-methodology",
    "title": "37  Klon Centaur, part 1",
    "section": "37.8 Analysis methodology",
    "text": "37.8 Analysis methodology\n\n\n\n\n\n\nFigure 37.3: Schematic used for the Python analysis\n\n\n\nThe analysis of the circuit in Figure 37.3 will use some symbolic analysis and primarily numerical methods to solve a system of equations to obtain solutions of the node voltages. The circuit analysis relies on using Laplace transformed circuit elements. This means that the analysis is performed in the frequency domain where linear algebra and matrix inversions are used to solve for the unknown voltages and currents. This method avoids having to deal with differential equations.\nLTSpice was used to draw the schematics of the circuits and generate the netlist. This helps to ensure that the netlist is correct. The component values in the netlist were manually edited to use scientific notation and the Op Amp entries were fixed to use the Op Amp component type.\nThe analysis begins with generating the network equations from the circuit’s netlist by calling:\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\nThe function SymMNA.smna() is described in Chapter 4 and the source listing is shown in Appendix A.\nKey techniques used in the analysis are described in the following sections:\n\n\n37.8.1 Frequency Response Plot\nA frequency response plot is a graphical representation of how a system responds to different input frequencies. It’s a valuable tool in various fields, including engineering, audio, and signal processing. Typically, a frequency response plot shows two key characteristics of a system:\n\nMagnitude Response: This indicates how much the system amplifies or attenuates different frequencies. It’s often plotted in decibels (dB) on a logarithmic scale.\nPhase Response: This shows the phase shift introduced by the system at different frequencies. It’s usually plotted in degrees or radians.\n\nBy analyzing a frequency response plot, you can determine:\n\nBandwidth: The range of frequencies a system can process effectively.\nGain: The amount of amplification or attenuation at specific frequencies.\nPhase shift: The delay introduced by the system at different frequencies.\nResonance: Peaks in the magnitude response indicating frequencies where the system amplifies strongly.\nStability: Whether a system is stable or unstable based on the phase margin.\n\n\n\n37.8.2 The Complex Frequency Plane\nThe complex frequency plane is a two-dimensional space where complex numbers represent frequency. Unlike the real-world concept of frequency, which is a scalar value representing the rate of oscillation, complex frequency adds a dimension of complexity. It’s represented by the symbol \\(s\\) and is defined as:\n\\(s=\\sigma+j\\omega\\)\nWhere:\n\n\\(\\sigma\\) is the real part, representing exponential growth or decay.\n\\(j\\) is the imaginary unit \\(\\sqrt{-1}\\).\n\\(\\omega\\) is the imaginary part, representing the angular frequency (related to the frequency in Hertz).\n\nThe complex frequency plane is divided into four quadrants:\n\nRight half-plane (RHP): \\(\\sigma \\gt 0\\), representing exponentially growing signals.\nLeft half-plane (LHP): \\(\\sigma \\lt 0\\), representing exponentially decaying signals.\nImaginary axis: \\(\\sigma = 0\\), representing sinusoidal signals with constant amplitude.\n\nThe complex frequency plane is crucial in various fields, including:\n\nControl systems: Analyzing system stability, designing controllers.\nSignal processing: Representing signals and systems in the frequency domain.\nElectrical engineering: Analyzing circuits and systems.\nPhysics: Describing damped oscillations and resonances.\n\nBy plotting poles and zeros of a system on this plane, you can gain insights into its behavior, stability, and frequency response.\n\n\n37.8.3 Pole-Zero Diagram\nA pole–zero plot is a graphical representation of a system’s transfer function in the complex plane. It provides valuable insights into the system’s behavior, stability, and frequency response. The diagram is plotted on the complex plane, with the real part on the horizontal axis (\\(\\sigma\\)) and the imaginary part on the vertical axis (\\(j\\omega\\)).\n\nPoles: These are the values of the complex variable ‘s’ that make the transfer function infinite. They are represented by ‘x’ on the diagram.\nZeros: These are the values of ‘s’ that make the transfer function zero. They are represented by ‘o’ on the diagram.\n\n\n37.8.3.1 Relative Count of Zeros vs. Poles\nThe relative count of zeros and poles in a transfer function significantly impacts the shape of the frequency response.\n\nPoles:\n\nEach pole introduces a downward slope of -20 dB/decade. Multiple poles at the same frequency amplify this effect.\nEach pole contributes a phase shift of -90 degrees. Multiple poles at the same frequency amplify this effect.\n\n\nZeros:\n\nEach zero introduces an upward slope of +20 dB/decade. Multiple zeros at the same frequency amplify this effect.\nEach zero contributes a phase shift of +90 degrees. Multiple zeros at the same frequency amplify this effect.\n\nOverall Slope:\n\nIf the number of zeros exceeds the number of poles, the magnitude plot will have a net upward slope.\nIf the number of poles exceeds the number of zeros, the magnitude plot will have a net downward slope.\nA balanced number of zeros and poles can lead to a flat magnitude plot over certain frequency ranges.\n\nHigh-Frequency Asymptote:\n\nThe high-frequency asymptote of the magnitude plot is determined by the difference between the number of zeros and poles.\nA larger number of zeros compared to poles will result in a steeper upward slope at high frequencies.\nA larger number of poles compared to zeros will result in a steeper downward slope at high frequencies.\n\nPhase Shift:\n\nThe total phase shift at any frequency is the sum of the phase shifts contributed by each pole and zero.\nA larger number of zeros compared to poles will result in a larger positive phase shift.\nA larger number of poles compared to zeros will result in a larger negative phase shift.\n\n\nThe location of poles and zeros on the complex plane provides information about:\n\nStability: If all poles are in the left half of the plane (LHP), the system is stable. If any pole is in the right half of the plane (RHP), the system is unstable.\nFrequency response: The distance of poles and zeros from the imaginary axis affects the system’s gain and phase response at different frequencies.\nTime-domain behavior: The location of poles and zeros can influence the system’s transient response and steady-state behavior.\n\n\n\n\n37.8.4 Impulse Response\nThe impulse response of a system is its output when presented with a brief input signal called an impulse. An impulse is an idealized signal that has infinite amplitude and infinitely short duration, but with a total area of one. The impulse response can be obtained from the transfer function by using the SciPy function impulse. However, for the analysis of the Klon Centaur, I don’t find the impulse response of the transfer functions to be that informative. Using SciPy, the impulse response is easy to calculate and plot, but I couldn’t relate the shape of the impulse response back to the circuit in an intuitive way. All the impulse responses looked very similar and they were not insightful. Additionally, using the impulse response along with the convolution function did not produce correct results since the SciPy convolve and Numpy convolve functions seemed to treat the signal and circuit as a discrete time system. For this reason, the impulse of the transfer functions are not included in the analysis.\n\n\n\n37.8.5 Step response\nThe step response of a system is its output when the input is a sudden change from zero to a constant value. This constant value is often referred to as a “step” input. The system’s behavior as it transitions from its initial state to a new steady-state condition is captured by the step response.\nSeveral parameters are used to characterize a step response:\n\nRise time: The time it takes for the output to go from 10% to 90% of its final value.\nOvershoot: The maximum amount by which the output exceeds the final value.\nSettling time: The time it takes for the output to settle within a specified percentage (e.g., 2%) of the final value.\nSteady-state error: The difference between the final value of the output and the desired output.\n\nThe step response provides valuable insights into a system’s behavior:\n\nStability: A stable system will eventually reach a steady-state value.\nSpeed of response: The rise time indicates how quickly the system reacts to changes.\nDamping: Overshoot and settling time reveal information about the system’s damping characteristics.\n\nThe step response is calculated by using the SciPy function lsim, which can be used to simulate output of a continuous-time linear system from the continuous-time linear time invariant system base class. The function lsim allows us to evaluate the performance characteristics of the circuit to square wave or arbitrary input signal input.\n\n\n37.8.6 Group Delay\nGroup delay is a measure of the time delay experienced by a group of frequencies as they pass through a system. It’s essentially the rate of change of the phase response with respect to frequency. Group Delay is important for the following reasons:\n\nSignal distortion: Variations in group delay across different frequencies can cause signal distortion, affecting the quality of audio, video, and data transmission.\nSystem design: Understanding group delay is crucial for designing systems with linear phase characteristics, which minimize distortion.\nPulse propagation: In fields like optics and telecommunications, group delay affects the shape and timing of pulses.\n\nGroup delay (\\(\\tau_g\\)) is calculated as the negative derivative of the phase response (\\(\\phi\\)) with respect to angular frequency (\\(\\omega\\)):\n\\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega)}{d\\omega}\\)\nA system with a constant group delay is called a linear phase system. These systems introduce a pure time delay to all frequency components without altering their relative phase relationships, preserving the original waveform shape. According to Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#sec-Bypass_path",
    "href": "Klon Centaur part 1.html#sec-Bypass_path",
    "title": "37  Klon Centaur, part 1",
    "section": "37.9 Bypass path",
    "text": "37.9 Bypass path\nThe bypass path is controlled by the effect on/off switch S1A and S1B. The effect on/off switch is a DPDT (double pole, double throw, On-On, type, which are two switches operated by the same actuator). Figure 37.4 shows the bypass signal path highlighted. When switch S1A is in the effect-on position, R27 is shorted and the wiper contact of P3 is directly connected to the output jack J2. Switch S1B controls the current in D1, a red LED (Light Emitting Diode) that indicates the position of S1A. S1B also grounds the distortion diodes D2 and D3 when the switch is in the effects off (bypass) position. However, the effects signal can still travel to the output via the connections to U2A, see Section 37.11.1 and Section 37.11.2. When S1A is in the bypass position, R26 is shorted and the bypass signal is directly connected to the output jack.\nThis is not a true bypass, since the signal is buffered by Op Amp U1A and AC coupled by C1 and C2. The bypass signal is resistively summed with the signal from the wiper terminal of P3, the output level potentiometer. S1A either shorts R26 or R27. In either case, the bypass signal or the effects signal is attenuated by 20dB or more depending on the rotational position of P3.\nThe analysis below will look at:\n\nbypass path frequency response\neffect signal leakage into bypass path\neffects path frequency response from U2B to the output\nbypass signal leakage into effects path\n\n\n\n\n\n\n\n\nFigure 37.4: Klon Centaur schematic with bypass circuit highlighted.\n\n\n\n\n37.9.1 Bypass path frequency response\nThe schematic below, Figure 37.5 shows the essential parts of the bypass circuit. We can look at this path independently of the rest of the circuit because the Op Amps, U1A and U2B, control the voltage at circuit nodes connected to their output terminals. The circuit branches that start with components C3 and R5 || C4 can be ignored when analyzing the bypass path since the voltage at this node is controlled by the output of U1A. The current from the output of U1A is the sum of currents in the branch connected to the node. Superposition allows us to analyze these other currents independently. Since we are only interested in the bypass path we can ignore the other paths while keeping in mind that when we do this the current from U1A is missing the current from the other paths, but the voltage at this node is correct. Op Amp U2B can be replaced with the voltage source, V2.\nThe signal path, either the bypass signal or the effects signal, is a high pass filter with a very low corner frequency, which essentially blocks DC and passes audio frequencies higher than about 3 Hz.\nThe operation of S1A is accounted for by changing the values of R26 and R27. Depending on the position of S1A, the value of R26 and R27 are alternatively either 0.01 or 68K \\(\\Omega\\). V1 is the bypass signal and V2 is the effects signal. From the way the schematic has been redrawn, it should be clear that both the bypass and the effects signal are always connected to the output, by either 68k or the on position switch resistance, modeled here as a 0.01 \\(\\Omega\\) resistor.\nR1 is a 10K \\(\\Omega\\) resistor and in some builds of the Klon Centaur, R1 is a wire jumper, and R2 is a 1000K \\(\\Omega\\) and connects the non-inverting input of Op Amp U1A to the virtual ground \\(V_g=4.5 V_{dc}\\) and biases the input signal to the midpoint of U1A’s power supply rails. C1 is a 100n Farad capacitor who’s function in the circuit is to block bias voltage from the virtual ground or any residual DC voltage present at the input jack, J1. R1, C1 and R2 form a high pass filter. C1 will prevent the bias voltage, \\(V_g\\), from getting to J1 and adversely affecting any equipment that plugs into J1. The Centaur schematic indicates the value of R1 as 10k \\(\\Omega\\), but the value of 10k or sometimes zero if it is a jumper, is small when compared to the value of R2, which is 1000K \\(\\Omega\\), and the high pass corner frequency controlled by the value of R1, R2 and C1 is not influenced significantly by the value of R1.\nV1 is a voltage source that represents the input signal from the guitar or another pedal. The amplitude of this signal from the guitar pickups can range from almost zero to 0.5 Volts peak to peak depending on how the guitar’s strings are strummed or plucked. The frequency range is from 80 Hz to 8 kHz.\nU1A is a TL072 Op Amp described in Section 38.1 and modeled in this section as an ideal Op Amp. The output of U1A is connected to C2, which continues the bypass path. C2 is a 4.7\\(\\mu\\) Farad capacitor together with R3, a 100k \\(\\Omega\\) resistor, forms a high pass filter who’s corner frequency is \\(\\omega=\\frac{1}{R_3C_3}\\).\nThe output of Op Amp U1A is also connected to the circuit branches of C3 and R5||C4 (|| is used to denote the parallel connection of the components) as well as C2. Since the Op Amp output is modeled as a voltage source, each of the connecting branches sees the same node voltage, labeled as node 5 below. We can employ the principle of superposition and ignore the branch currents in C3 and R5||C4. While U1A will source current equal to the sum of the connecting branch currents, the current in branches of C3 and R5||C4 doesn’t affect the node voltages along the path starting with the C2 branch. The principle of superposition is described in more detail in Section 37.11.\nThe output control, P3, is modeled as a voltage divider consisting of resistors with reference designators of Rp3a and Rp3b. The value of Rp3a is controlled by the equation \\(Rp3a=100k-R_{output}\\) and the value of Rp3b is controlled by the equation \\(Rp3b=R_{output}\\), with the variable \\(R_{output}\\) indicating the value of the potentiometer set by the rotational position of the knob.\nR4 is a 560 \\(\\Omega\\) resistor that isolates the output of U1A from any short circuits to ground that might inadvertently be connected to the output jack, J2. R28 is a 100k \\(\\Omega\\) resistor used to provide a DC path to ground to discharge any stray voltage that might be present on the output jack from external equipment. It also prevents transients from occurring when S1A is toggled. R26 and R27 are 68k \\(\\Omega\\) resistors that are alternately shorted by S1A. When the pedal is bypass mode, R26 is shorted and in the equations below, the value of R26 is set to 0.01 \\(\\Omega\\), which is the value being used in this analysis for the On resistance of S1A. In the bypass mode, R27 isolates the effects signal present at the wiper contact of P3. As described below, there is a small amount of signal leakage from the effects path into the bypass path.\nThe Output level is controlled by P3, a 100k \\(\\Omega\\) potentiometer. In the circuit analysis presented below, I’m assuming that P3 has an audio taper, also described below. This makes the output level somewhat linear to the ear as P3 is rotated. R25 is a 560 \\(\\Omega\\) resistor that isolates the output of U2B from any short circuits to ground that might inadvertently be connected to the output jack, J2. C15 is a 4.7\\(\\mu\\) Farad capacitor together with R25 and P3, form a high pass filter who’s corner frequency is \\(\\omega=\\frac{1}{R_{25} P_3 C_3}\\). V2 is a voltage source that represents the effects signal from the pedal.\nThe output of Op Amp U2B is the final amplifier in the effects signal path. In Figure 37.5, the output of U2B is replaced by V2 for analysis. The output of U2B is a voltage source and controls the voltage at node 11. When analyzing the bypass path, V2 is set to zero. Later I’ll look at the leakage of the effects signal into the bypass path by setting V1 to zero and examining the transfer function from V2 to node 2, the output.\n\n\n\n\n\n\nFigure 37.5: The LTSpice schematic of the bypass path which generated the netlist.\n\n\n\n\n37.9.1.1 Symbolic solution\nThe following section of this notebook presents calculations that are used to find the poles and zeros of the system using symbolic calculations. This allows us to determine which components influence the values of the poles and zeros. The netlist for the schematic in Figure 37.5 was generated by LTSpice and shown below. Notice that the value of the Level control potentiometer is set in a position where the values of Rp3a and Rp3b are equal and have a value of 5k. As described later, I will assume that P3 has a logarithmic taper and this type of pot is usually called an audio pot. Notice that in the netlist, V2 is assigned a value of zero.\n\nbypass_v1_net_list = '''\n* Klon-Centaur_bypass_v1.asc\nV1 1 0 1\nR1 3 1 10e3\nR2 0 4 1000e3\nC1 4 3 100e-9\nO1a 5 4 5\nR3 6 0 100e3\nR4 7 6 560\nR28 0 2 100e3\nC2 5 6 4.7e-6\nR27 2 9 68e3\nRp3b 9 0 5e3\nRp3a 8 9 5e3\nR25 8 10 560\nC15 11 10 4.7e-6\nV2 11 0 0\nR26 2 7 0.01\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(bypass_v1_net_list)\n\nThe element values can be loaded into a Python dictionary variable.\n\nelement_values = SymMNA.get_part_values(network_df)\n\nBuild and display the network equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = v_{2} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{9}}{R_{27}} - \\frac{v_{7}}{R_{26}}\\)\\(0 = - C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}}\\)\\(0 = - C_{1} s v_{3} + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}}\\right)\\)\\(0 = C_{2} s v_{5} - C_{2} s v_{6} + I_{O1a}\\)\\(0 = - C_{2} s v_{5} + v_{6} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{4}}\\)\\(0 = v_{7} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{6}}{R_{4}} - \\frac{v_{2}}{R_{26}}\\)\\(0 = v_{8} \\cdot \\left(\\frac{1}{Rp3a} + \\frac{1}{R_{25}}\\right) - \\frac{v_{9}}{Rp3a} - \\frac{v_{10}}{R_{25}}\\)\\(0 = v_{9} \\cdot \\left(\\frac{1}{Rp3b} + \\frac{1}{Rp3a} + \\frac{1}{R_{27}}\\right) - \\frac{v_{8}}{Rp3a} - \\frac{v_{2}}{R_{27}}\\)\\(0 = - C_{15} s v_{11} + v_{10} \\left(C_{15} s + \\frac{1}{R_{25}}\\right) - \\frac{v_{8}}{R_{25}}\\)\\(0 = - C_{15} s v_{10} + C_{15} s v_{11} + I_{V2}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{11}\\)\\(0 = - v_{4} + v_{5}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{5}, \\  Rp3a, \\  V_{1}, \\  R_{1}, \\  v_{2}, \\  v_{3}, \\  I_{O1a}, \\  Rp3b, \\  C_{15}, \\  R_{28}, \\  v_{7}, \\  C_{2}, \\  R_{27}, \\  R_{3}, \\  V_{2}, \\  v_{6}, \\  v_{4}, \\  v_{10}, \\  I_{V1}, \\  R_{25}, \\  v_{1}, \\  R_{26}, \\  I_{V2}, \\  C_{1}, \\  R_{4}, \\  v_{11}, \\  v_{9}, \\  R_{2}, \\  s, \\  v_{8}\\right)\\)\n\n\nThe network equations can be solved symbolically using the SymPy function, solve. The solution takes about one minute on my i3 laptop.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution.\n\n\"\"\"\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\"\"\"\n\"\"\"output too long, uncomment to display the equations\"\"\"\n\n'output too long, uncomment to display the equations'\n\n\nThe equations generated for the solution of the node voltages and unknown currents are long and not very insightful, so the code to display the equations has been commented out.\nThe voltage transfer function from the input (V1) to the output, node 2, which is the voltage across R28 is \\(H_{sym}=\\frac{v2}{v1}\\). \\(H_{sym}\\) is computed below and is used to examine the poles and zeros of a system and describe the operation of the circuit in the frequency domain.\n\nH_sym = U_sym[v2]/U_sym[v1]\n#H_sym\n\"\"\"output too long, uncomment to display the equations\"\"\"\n\n'output too long, uncomment to display the equations'\n\n\nThe numerator and denominator of \\(H_{sym}\\) are assigned to the variables sym_num and sym_denom.\n\nsym_num, sym_denom = fraction(H_sym) #returns numerator and denominator\n\nSymPy can solve for the roots of the numerator. The roots of the numerator are called the zeros of the transfer function. These correspond to the capacitors, C1, C2 and C3 which are in series along the signal paths and block the flow of DC current.\nSymPy can determine the degree of the numerator and denominator polynomials.\n\nprint('degree of numerator polynomial: {:d}'.format(int(degree(sym_num,gen=s))))\nprint('degree of denominator polynomial: {:d}'.format(int(degree(sym_denom,gen=s))))\n\ndegree of numerator polynomial: 3\ndegree of denominator polynomial: 3\n\n\n\n\n\n37.9.1.2 Numerical solution\nThe following section of this notebook presents calculations that are used to find the frequency, impulse and step response, and the poles and zeros of the bypass circuit using numerical methods.\n\n37.9.1.2.1 Output control\nThe output control is the potentiometer, P3 in Figure 37.3, and modeled as resistors, Rp3a and Rp3b in Figure 37.5. I’m going to assume that this component has an audio taper similar to PTV09, which can be found at Digikey. I don’t know the actual Klon part number used for P3 and online references are not clear about the type, so the PTV09 is being used as a stand-in.\nA potentiometer is essentially a variable resistor and is usually a three-terminal component with a sliding or rotating contact that allows the resistance to be adjusted. Two terminals are fixed at the ends of a resistive element, and the third terminal is connected to a movable wiper. As the wiper is moved, the resistance between the wiper and each end terminal changes. Let’s say the pins are numbered 1, 2, and 3. Pins 1 and 3 are connected to the end points of the resistive element and pin 2 is connected to the wiper. Full CW rotation of the shaft sets the resistance between pins 1 and 3 to the value of potentiometer.\nThe following function describes the taper from the figure in the datasheet for A series tapers. Data point values for the taper were eyeballed and the curve shown below approximates the curve shown in the datasheet. The equation used for modeling the taper was obtained from the following references, Formula for Logarithmic (audio taper) pot and Modeling logarithmic potentiometer laws.\n\ndef audio_pot_10k(rotation):\n    '''\n    defines the resistance of an audio taper potentiometer as a function of rotation.\n    The value for the rotation should be a number between 0 and 100, which corresponds to 0 to 100 percent.\n    ref: 1) https://electronics.stackexchange.com/questions/304692/formula-for-logarithmic-audio-taper-pot, \n    2) https://benholmes.co.uk/posts/2017/11/logarithmic-potentiometer-laws\n    '''\n    mid = 0.2 # define the factor of resistance at the middle pot position, at the mid postion\n    # of the pot's rotation, the resistance value of the wiper will be 0.2 * 10k = 2k  \n    b = (1/mid - 1)**2 # b is the base of the exponential equation\n    a = 1/(b-1) # a is the multiple and also the offset\n    return 10e3*(a*b**(rotation/100) - a)\n\nThe plot below shows the value of resistance between pins 1 and 3 as a function of wiper position.\n\np3_value = 10e3 # full scale value of potentiometer\npotentiometer_rotation = np.linspace(0,1,51)*100\n\nplt.plot(potentiometer_rotation,audio_pot_10k(potentiometer_rotation)/1e3,'-')\n\nplt.ylabel('resistance between pins 1 and 3, k\\u03A9')\nplt.xlabel('rotational travel, %')\nplt.grid()\nplt.title('Output potentiometer taper')\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the resistance value between pins 1 and 2 is an exponential function of pot rotation. If a linear Pot was used, the spacing of the output level in some of the frequency response plots below would be compressed in a narrow dB range that didn’t look correct.\nPlot the frequency response of the bypass circuit, \\(H(s)=\\frac {v_2} {V_1}\\), for various settings of P3.\n\noutput_setting = np.array([1,25,50,75,99])\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\nfor i in range (len(output_setting)):\n    \n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i])\n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n\n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n    \n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n    \n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.set_ylim((-0.5,0))\nax1.grid()\nplt.title('Magnitude and phase response at various rotational positions')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.6: Bypass path magnitude and phase response\n\n\n\n\n\nThe plot above shows the frequency response for the bypass circuit. The highlighted frequency range of 80 to 8,000 Hz is the audio range of a typical electric guitar. The gain is flat across this range and there is a small amount of insertion loss of about 0.2 dB across the guitar audio band. P3 has only a very small effect on the gain. The annotation for the plot shows the position of P3 at various rotation displacements from 1 to 99 percent.\n\n\n\n37.9.1.3 Pole / zero plot\nThe following calculations solve for the pole and zero locations for the bypass circuit with the wiper position on P3 set to \\(5k\\Omega\\).\n\n# output_setting = 50%, knob position as a percent of full rotation\nelement_values[Rp3a] = 5e3\nelement_values[Rp3b] = 5e3\n\nThe element values are substituted into the equations, solutions are obtained and the ratio \\(H = \\frac {v_2}{v_1}\\) is formulated. Then the coefficients of the numerator and denominator polynomials are saved to variables a and b.\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nUse the SciPy function TransferFunction to represent the system as the continuous-time transfer function.\n\nsys_tf = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above and printed below, there are three zeros and three poles in the transfer function. The plotted position of the poles and zeros are in units of radian frequency. There are two zeros at 0 Hz and one at 3.3 Hz. The position of zeros at 0 Hz indicates that the transfer function is a high pass filter and the equal count of poles and zeros indicate the system has a flat frequency response over some frequencies. The pole zero pair near 3.3 Hz tend to cancel since they are very close in frequency. The system zeros stem from C1 and C2, which block the direct current path. One of the system poles stems from C1 , R1 and R2. The other system pole stems from C2 and primarily R3.\nThe following cells print the zero and pole values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 3\nz0: -3.31 Hz\nz1: 0.00 Hz\nz2: 0.00 Hz\nnumber of poles: 3\np0: -3.34 Hz\np1: -1.58 Hz\np2: -1.12 Hz\n\n\n\n\n37.9.1.4 Step response\nThe step response of the is calculated using the SciPy function lsim, which can be used to simulate output of a continuous-time linear system from the continuous-time linear time invariant system base class. The function lsim allows us to evaluate the performance characteristics of the circuit to square wave input. A square wave with a frequency of 500 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\nIf we didn’t already know from the schematic that the bypass path is AC coupled, the step response would show us that for large values of time, the response is zero, therefore DC is being blocked. The input signal for the step response is 0.1 volt step. The circuit responds to the rising edge of the square wave and tracks the leading edge of the input. This is because at time zero, the capacitors in the circuit are at their initial condition which is zero volts. At this instant, the output voltage is almost 0.1 volts, since the value of the resistors along the path don’t present much of a voltage divider. As time increases, the voltage on the capacitors will approach their final values according to Kirchhoff’s Current Law, which results in a final output voltage of zero for time greater than about one second.\n\n# define the time interval and create a square wave step waveform.\nt = np.linspace(0, 5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*0.5*t, duty=0.5)/20+1/20\n\n# call lsim to generate the response signal\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth = 1.0, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe square wave response shows about 10% overshoot and a settling time of about 1 second with no ringing. This is a result of series connection of C1 and C2 in the path which equate to a zero at DC and two low frequency poles at 1.1 and 1.6 Hz. The location of these poles result from the relatively large time constants produced by C2 and R3 as well as from C15 and R28.\nYou would expect the transient step response to be an exponential decay function, asymptotically approaching zero volts. The bypass network has three capacitors, C1, C2 and C15. This makes the circuit a third order system. From the plot above, we can see that there is some overshoot, but no ringing in the step response. This implies that the damping ratio is between 0.7 and 1. We can approximate the damping ratio by considering the two dominant poles of the system and ignoring the highest frequency pole.\nAs calculated above, the transfer function of the bypass circuit for P3 at 50% is \\(H(s)\\).\n\nH\n\n\\(\\displaystyle \\frac{1.0 \\cdot \\left(2.31889927274817 \\cdot 10^{77} s^{3} + 4.82878561580902 \\cdot 10^{78} s^{2}\\right)}{2.37377342819845 \\cdot 10^{77} s^{3} + 9.00095037426057 \\cdot 10^{78} s^{2} + 1.00954261077259 \\cdot 10^{80} s + 3.47583640381444 \\cdot 10^{80}}\\)\n\n\nAs calculated above, the system poles are:\n\nprint(sys_poles)\n\n[-20.9622128   -9.9009901   -7.05511848]\n\n\nWe can have NumPy to generate the system polynomial.\n\nsys_poly = np.poly(sys_poles)\nprint(sys_poly)\n\n[1.00000000e+00 3.79183214e+01 4.25290215e+02 1.46426629e+03]\n\n\nNormalize the system polynomial on the second order term by dividing the polynomial coefficients by the second order coefficient.\n\nnorm_sys_poly = sys_poly/sys_poly[1]\nprint(norm_sys_poly)\n\n[2.63724755e-02 1.00000000e+00 1.12159557e+01 3.86163267e+01]\n\n\nThis puts the pronominal into the form:\n\\(as^3 + s^{2}+\\frac {\\omega _N}{Q}s + \\omega _N^2\\)\nWe are going to ignore the \\(as^3\\) term and only consider the other terms:\n\\(s^{2}+\\frac {\\omega _N}{Q}s + \\omega _N^2\\)\nThe natural frequency can be found from the last term in the normalized system polynomial.\n\nw_n = np.sqrt(norm_sys_poly[3])\nw_n\n\n\\(\\displaystyle 6.21420362662557\\)\n\n\nThe damping ratio can be found solving for the damping ratio, \\(\\delta\\), in the equation:\n\\(\\frac {\\omega _N}{Q} = 2 \\delta \\omega _N\\)\n\ndamp_ratio = norm_sys_poly[2]/(2*w_n)\nprint('damping ratio = {:.2f}'.format(damp_ratio))\n\ndamping ratio = 0.90\n\n\nThe damping ratio is less than between 0.7 and 1, leading to the behavior shown in the step response.\nThe transient behavior of the circuit in Figure 37.5 with a square wave input was simulated in LTSpice and the results are a close match with the Python results as shown in the plot below.\n\nfn = 'Klon-Centaur_bypass_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\nCopy the data from the csv file into NumPy arrays.\n\n# initialize some empty arrays\ntime = np.zeros(len(LTSpice_data))\nvoltage1 = np.zeros(len(LTSpice_data))\nvoltage2 = np.zeros(len(LTSpice_data))\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    time[i] = LTSpice_data[i][0]\n    voltage1[i] = LTSpice_data[i][1]\n    voltage2[i] = LTSpice_data[i][2]\n\nPlot the LTSpice data and the Python data to see if they agree.\n\nplt.title('LTSpice')\n\n#plt.plot(time, voltage1, 'g', alpha = 1.0, linewidth=1, label='LTSpice v1(t)')\nplt.plot(time, voltage2, '-.r', alpha = 1.0, linewidth=2, label='LTSpice v2(t)')\n\n#plt.plot(t_step, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', alpha = 1.0, linewidth = 1.0, label='Python result')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, there is a one to one correspondence.\n\n\n37.9.1.5 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,2))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.\n\n\n37.9.1.6 Effect signal leakage into bypass path\nThe frequency response plot below shows the signal gain from the effects path into the output when the switch is in the bypass position. The transfer function, \\(H(s)=\\frac {v_2} {v_{11}}\\), is plotted for various settings of P3, with \\(V_1=0\\), \\(R_{26}=68k\\Omega\\) and \\(R_{27}=0.01\\Omega\\). Since the bypass switch doesn’t break the connection between the bypass and effects path, it is informative to look at the leakage of one path into the other.\n\nelement_values[V1] = 0\nelement_values[V2] = 1\nelement_values[R26] = 0.01\nelement_values[R27] = 68e3\n\noutput_setting = np.array([1,25,50,75,99])\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\nfor i in range(len(output_setting)):\n    \n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i])\n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v11]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.7: Effect signal leakage into bypass path magnitude and phase response\n\n\n\n\n\nThe plot above shows that the effects signal is isolated from the bypass signal by more than 40 dB over the audio band of the guitar.\n\n\n\n37.9.2 Effects path output frequency response\nThe signal through the effects path is analyzed from C15 to the output at J2. In Figure 37.5, the output of U2A is replaced by \\(V_2\\) at node 11. The frequency response for the transfer function, \\(H(s)=\\frac{v_2}{v_{11}}\\) is plotted below. \\(V_1\\) has been set to zero, \\(R_{26}=68k\\Omega\\) and \\(R_{27}=0.01\\Omega\\)\n\nelement_values[V1] = 0\nelement_values[V2] = 1\nelement_values[R26] = 68e3\nelement_values[R27] = 0.01\n\noutput_setting = np.array([1,25,50,75,99])\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\nfor i in range(len(output_setting)):\n\n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i])\n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v11]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.8: Effect output path magnitude and phase response\n\n\n\n\n\nThe gain of the output circuit for the effects path can be adjusted by P3 to have a gain of a bit less than 0 dB to about -55 dB.\n\n37.9.2.1 Poles and zeros\nSetting the wiper position of P3 to a position that puts \\(5k\\Omega\\) on each side of the wiper, the poles and zeros for the output circuit are calculated.\n\n# output_setting = 50%, knob position as a percent of full rotation\nelement_values[Rp3a] = 5e3\nelement_values[Rp3b] = 5e3\n\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v11]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted below. As indicated in the legend, the location of the zeros are marked with blue circles and the location of the poles are marked with red x’s.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nIn the plot above, the units of frequency are in radians, cycles per 1 radian, or \\(2\\pi\\) degrees. There is a zero at 0 Hz, which is from C15. The second zero is from C2. The two poles are also from C15 and C2 combined with various resistors in the network.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 2\nz0: -0.83 Hz\nz1: 0.00 Hz\nnumber of poles: 2\np0: -3.40 Hz\np1: -0.80 Hz\n\n\n\n\n37.9.2.2 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 500 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*0.5*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero. There is a relatively small spike in the output at each square wave edge. The step response of this path could be explored in more detail during prototype testing.\n\n\n37.9.2.3 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,2))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.\n\n\n37.9.2.4 Bypass signal leakage into effects path\nThe frequency response of the bypass signal leakage into the effects path is shown below. The bypass switch is simulated by setting the values of \\(R_{26}\\) and \\(R_{27}\\)\n\nelement_values[V1] = 1\nelement_values[V2] = 0\nelement_values[R26] = 68e3\nelement_values[R27] = 0.01\n\noutput_setting = np.array([1,25,50,75,99])\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(output_setting)):\n\n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i]) \n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.9: Bypass signal leakage into effects path magnitude and phase response\n\n\n\n\n\nThe gain of the output circuit for the bypass path to the output with the bypass switch off varies as a function of P3 position. As shown above the maximum leakage for the values plotted is at a rotational position of 75%.\nThe signal leakage into the other path, while not zero, is very small and not a concern.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#treble-control",
    "href": "Klon Centaur part 1.html#treble-control",
    "title": "37  Klon Centaur, part 1",
    "section": "37.10 Treble control",
    "text": "37.10 Treble control\nThe treble control circuit is highlighted in the schematic below and can be analyzed independently from the rest of the Klon Centaur circuit if we consider the sub circuit from the output of U2A to the output of U2B. The isolation and buffering provided by the Op Amp allows us to analyze this part of the pedal without having to consider other parts of the circuit.\n\n\n\n\n\n\nFigure 37.10: Schematic of Klon Centaur treble circuit highlighted.\n\n\n\nThe circuit for the treble control was drawn using LTSpice and shown below. The treble control allows the frequency response of the pedal to be adjusted. The treble circuit resembles the treble portion of the classic Baxandall tone control circuit. As shown in the circuit analysis below, the circuit can cut or boost the treble frequencies with a single potentiometer control. The capacitor, C14, is connected from the inverting terminal of U2B to the wiper contact of potentiometer P2. This places a frequency dependent negative feedback network around the Op Amp.\nThere are several interesting online references for audio tone control circuits:\n\ntone circuit calculator\nAmplifier Controls\nAudio Tone Control Using The TLC074 Operational Amplifier\nJames tone stack\nJames Tone Stack - Analysis\n\n\n\n\n\n\n\nFigure 37.11: LTSpice schematic of the treble circuit.\n\n\n\nV1 is the input signal for circuit and for frequency analysis the value is 1.\nTwo resistors, R21, a 1.8K \\(\\Omega\\) resistor and R23, a 4.7K \\(\\Omega\\) resistor, sit on either side of the treble potentiometer and skew the treble control towards treble boost at the control mid point of rotation, since R21 is a lower value. R21 and R23 also limit the amount of boost and cut provided by the treble circuit.\nR22 is a 100K \\(\\Omega\\) resistor and with R241 sets the DC gain of the Op Amp circuit.\nThe treble control, potentiometer P2, is modeled as a voltage divider consisting of resistors with reference designators of Rp2a and Rp2b. The value of Rp2a is controlled by the equation \\(Rp2a=10k-R_{treble}\\) and the value of Rp2b is controlled by the equation \\(Rp2b=R_{treble}\\), with the variable \\(R_{treble}\\) indicating the value of the potentiometer set by the rotational position of the knob.\nC14 is a 3.9n Farad capacitor and one end is connected to the inverting input of the Op Amp, which is a virtual ground. The other end is connected to the wiper terminal of P2.\nR21, Rp2a and C14 form a low pass network, since C14 is shunting the input signal to the virtual ground. This puts a zero in the voltage transfer function. The output signal from the Op Amp is fed back to the inverting input through the network of R23, Rp2b and C14 and because these components put a pole in the voltage transfer function. The relative pole and zero location in the complex frequency plane determine if the circuit will provide boost or cut to the treble frequencies.\nR241 is a 100K \\(\\Omega\\) resistor in the negative feedback path of the Op Amp along with the components R23, Rp2b and C14. R241 along with R22, P2, R21 and R23 set the DC gain for the circuit.\nU2B is an ideal Op Amp in this analysis.\nLoad the net list for the treble control circuit.\n\ntreble_v2_net_list = '''\nV1 1 0 1\nR21 1 4 1.8e3\nR22 3 1 100e3\nRp2a 4 5 5e3\nRp2b 5 6 5e3\nC14 3 5 3.9e-9\nR241 2 3 100e3\nR23 2 6 4.7e3\nO2b 3 0 2\n'''\n\nCall the symbolic modified nodal analysis function to generate the network matrices and databases.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(treble_v2_net_list)\n\nBuild the network equations and display the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{22}} + \\frac{1}{R_{21}}\\right) - \\frac{v_{3}}{R_{22}} - \\frac{v_{4}}{R_{21}}\\)\\(0 = I_{O2b} + v_{2} \\cdot \\left(\\frac{1}{R_{241}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{241}} - \\frac{v_{6}}{R_{23}}\\)\\(0 = - C_{14} s v_{5} + v_{3} \\left(C_{14} s + \\frac{1}{R_{241}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{2}}{R_{241}} - \\frac{v_{1}}{R_{22}}\\)\\(0 = v_{4} \\cdot \\left(\\frac{1}{Rp2a} + \\frac{1}{R_{21}}\\right) - \\frac{v_{5}}{Rp2a} - \\frac{v_{1}}{R_{21}}\\)\\(0 = - C_{14} s v_{3} + v_{5} \\left(C_{14} s + \\frac{1}{Rp2b} + \\frac{1}{Rp2a}\\right) - \\frac{v_{6}}{Rp2b} - \\frac{v_{4}}{Rp2a}\\)\\(0 = v_{6} \\cdot \\left(\\frac{1}{Rp2b} + \\frac{1}{R_{23}}\\right) - \\frac{v_{5}}{Rp2b} - \\frac{v_{2}}{R_{23}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{3}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( Rp2b, \\  R_{22}, \\  v_{5}, \\  R_{241}, \\  V_{1}, \\  v_{2}, \\  v_{3}, \\  Rp2a, \\  I_{O2b}, \\  v_{6}, \\  v_{4}, \\  I_{V1}, \\  v_{1}, \\  R_{21}, \\  C_{14}, \\  R_{23}, \\  s\\right)\\)\n\n\nGet the element values from the network database.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n\n37.10.1 Symbolic solution\nThe network equations can be solved symbolically and the solution to the node voltages and unknown currents is displayed.\n\nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{14} R_{21} R_{23} R_{241} V_{1} s - C_{14} R_{21} R_{241} Rp2b V_{1} s - C_{14} R_{22} R_{23} R_{241} V_{1} s - C_{14} R_{22} R_{241} Rp2b V_{1} s - C_{14} R_{23} R_{241} Rp2a V_{1} s - C_{14} R_{241} Rp2a Rp2b V_{1} s - R_{21} R_{241} V_{1} - R_{23} R_{241} V_{1} - R_{241} Rp2a V_{1} - R_{241} Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(v_{3} = 0\\)\\(v_{4} = \\frac{C_{14} R_{22} R_{23} Rp2a V_{1} s + C_{14} R_{22} R_{241} Rp2a V_{1} s + C_{14} R_{22} Rp2a Rp2b V_{1} s - R_{21} R_{241} V_{1} + R_{22} R_{23} V_{1} + R_{22} Rp2a V_{1} + R_{22} Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(v_{5} = \\frac{- R_{21} R_{241} V_{1} + R_{22} R_{23} V_{1} + R_{22} Rp2b V_{1} - R_{241} Rp2a V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(v_{6} = \\frac{- C_{14} R_{21} R_{241} Rp2b V_{1} s - C_{14} R_{22} R_{241} Rp2b V_{1} s - C_{14} R_{241} Rp2a Rp2b V_{1} s - R_{21} R_{241} V_{1} + R_{22} R_{23} V_{1} - R_{241} Rp2a V_{1} - R_{241} Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(I_{V1} = \\frac{- C_{14} R_{21} R_{23} V_{1} s - C_{14} R_{21} R_{241} V_{1} s - C_{14} R_{21} Rp2b V_{1} s - C_{14} R_{22} R_{23} V_{1} s - C_{14} R_{22} R_{241} V_{1} s - C_{14} R_{22} Rp2b V_{1} s - C_{14} R_{23} Rp2a V_{1} s - C_{14} R_{241} Rp2a V_{1} s - C_{14} Rp2a Rp2b V_{1} s - R_{21} V_{1} - R_{22} V_{1} - R_{23} V_{1} - R_{241} V_{1} - Rp2a V_{1} - Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(I_{O2b} = \\frac{C_{14} R_{21} R_{23} V_{1} s + C_{14} R_{21} R_{241} V_{1} s + C_{14} R_{21} Rp2b V_{1} s + C_{14} R_{22} R_{23} V_{1} s + C_{14} R_{22} R_{241} V_{1} s + C_{14} R_{22} Rp2b V_{1} s + C_{14} R_{23} Rp2a V_{1} s + C_{14} R_{241} Rp2a V_{1} s + C_{14} Rp2a Rp2b V_{1} s + R_{21} V_{1} + R_{22} V_{1} + R_{23} V_{1} + R_{241} V_{1} + Rp2a V_{1} + Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\n\n\n\n\n37.10.2 Transfer function\nThe transfer function, \\(H(s)=\\frac{v_2}{v_1}\\), can be expressed in symbolic form and is displayed below.\n\nH_sym = cancel(U_sym[v2]/U_sym[v1])\nH_sym\n\n\\(\\displaystyle \\frac{- C_{14} R_{21} R_{23} R_{241} s - C_{14} R_{21} R_{241} Rp2b s - C_{14} R_{22} R_{23} R_{241} s - C_{14} R_{22} R_{241} Rp2b s - C_{14} R_{23} R_{241} Rp2a s - C_{14} R_{241} Rp2a Rp2b s - R_{21} R_{241} - R_{23} R_{241} - R_{241} Rp2a - R_{241} Rp2b}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\n\n\n\n\n37.10.3 DC gain\nThe gain of the treble circuit at zero frequency can be calculated by putting the component values into \\(H(s)\\) and setting \\(s=0\\) as shown below.\n\nH_sym.subs({s:0}).subs(element_values)\n\n\\(\\displaystyle -1.0\\)\n\n\nThe DC gain of the treble circuit is -1.\n\n\n37.10.4 Solve P2 position for flat treble response\nThe position of P2 that gives a flat treble response can be calculated. A flat frequency response occurs when the numerator of \\(H(s)\\) equal to the denominator. Another way of saying this is, the frequency response is flat when the system pole and zero are at the same frequency. Since \\(R_{21}\\) and \\(R_{23}\\) have different values, a flat frequency response will not occur at the rotational mid point of P2.\nIn the cells that follow, the SymPy symbols \\(P2a\\) and \\(P2b\\) are defined and are substituted into the system transfer function. This is done for two reasons, first to make it clear that we are solving for the value of P2 sections ‘a’ and ‘b’. Second, we want to substitute numerical values for the symbols and we don’t want to overwrite the values of Rp2a and Rp2b. The modified \\(H_{sym}\\) is displayed below.\n\nP2a, P2b = symbols('P2a P2b')\n\nH_sym1 = H_sym.subs({𝑅𝑝2𝑏:P2b,Rp2a:P2a})\nH_sym1\n\n\\(\\displaystyle \\frac{- C_{14} P2a P2b R_{241} s - C_{14} P2a R_{23} R_{241} s - C_{14} P2b R_{21} R_{241} s - C_{14} P2b R_{22} R_{241} s - C_{14} R_{21} R_{23} R_{241} s - C_{14} R_{22} R_{23} R_{241} s - P2a R_{241} - P2b R_{241} - R_{21} R_{241} - R_{23} R_{241}}{C_{14} P2a P2b R_{22} s + C_{14} P2a R_{22} R_{23} s + C_{14} P2a R_{22} R_{241} s + C_{14} P2b R_{21} R_{22} s + C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + P2a R_{22} + P2b R_{22} + R_{21} R_{22} + R_{22} R_{23}}\\)\n\n\nThe numerator and denominator of \\(H_{sym}\\) can be extracted and saved off as new variables, num_sym and denom_sym.\n\nnum_sym, denom_sym = fraction(H_sym1)\nnum_sym\n\n\\(\\displaystyle - C_{14} P2a P2b R_{241} s - C_{14} P2a R_{23} R_{241} s - C_{14} P2b R_{21} R_{241} s - C_{14} P2b R_{22} R_{241} s - C_{14} R_{21} R_{23} R_{241} s - C_{14} R_{22} R_{23} R_{241} s - P2a R_{241} - P2b R_{241} - R_{21} R_{241} - R_{23} R_{241}\\)\n\n\nThe root of the numerator polynomial is solved for and displayed.\n\nnum_root_sym = solve(num_sym,s)[0]\nnum_root_sym\n\n\\(\\displaystyle \\frac{- P2a - P2b - R_{21} - R_{23}}{C_{14} \\left(P2a P2b + P2a R_{23} + P2b R_{21} + P2b R_{22} + R_{21} R_{23} + R_{22} R_{23}\\right)}\\)\n\n\nDisplay the denominator polynomial.\n\ndenom_sym\n\n\\(\\displaystyle C_{14} P2a P2b R_{22} s + C_{14} P2a R_{22} R_{23} s + C_{14} P2a R_{22} R_{241} s + C_{14} P2b R_{21} R_{22} s + C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + P2a R_{22} + P2b R_{22} + R_{21} R_{22} + R_{22} R_{23}\\)\n\n\nThe root of the denominator polynomial is solved for and displayed.\n\ndenom_root_sym = solve(denom_sym,s)[0]\ndenom_root_sym\n\n\\(\\displaystyle \\frac{- P2a - P2b - R_{21} - R_{23}}{C_{14} \\left(P2a P2b + P2a R_{23} + P2a R_{241} + P2b R_{21} + R_{21} R_{23} + R_{21} R_{241}\\right)}\\)\n\n\nNumerical values are substituted into the expressions for the roots, while leaving P2a and P2b as variables.\n\nnum_root = num_root_sym.subs(element_values)\nnum_root\n\n\\(\\displaystyle \\frac{256410256.410256 \\left(- P2a - P2b - 6500.0\\right)}{P2a P2b + 4700.0 P2a + 101800.0 P2b + 478460000.0}\\)\n\n\n\ndenom_root = denom_root_sym.subs(element_values)\ndenom_root\n\n\\(\\displaystyle \\frac{256410256.410256 \\left(- P2a - P2b - 6500.0\\right)}{P2a P2b + 104700.0 P2a + 1800.0 P2b + 188460000.0}\\)\n\n\nPymPy can be used to solve the equations:\n\\(P2_a+P2_b = 10k\\Omega\\)\n\\(numerator_{root} = denominator_{root}\\)\nRearranging the equations to put zero on the right hand side of the equal sign and using SymPy to solve for P2a nd P2b, we get:\n\nP2_a, P2_b = solve([num_root-denom_root,P2a+P2b-10000],P2a,P2b)[0]\nprint('solution: P2a = {:,.0f} and p2b = {:,.0f} ohms'.format(P2_a, P2_b))\n\nsolution: P2a = 6,450 and p2b = 3,550 ohms\n\n\nThis means that for a rotational displacement of 35.5% on P2, the treble response will be flat.\n\n\n37.10.5 Frequency response vs P2\nThe frequency response of the treble circuit as a function of P2 for selected positions is plotted below.\nFigure 37.12\n\nP2_setting = np.array([1,25,35.5,50,75,99])/100\nP2_value = 10e3\n\ntf_num_coef_list = []\ntf_denom_coef_list = []\n\ncolor_list = ['tab:blue','tab:red','tab:purple','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(P2_setting)):\n    element_values[Rp2a] = P2_value - P2_setting[i]*P2_value \n    element_values[Rp2b] = P2_setting[i]*P2_value \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    tf_num_coef_list.append(a)\n    tf_denom_coef_list.append(b)\n    \n    x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude, P2 at {:.0f}%'.format(P2_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P2 at {:.0f}%'.format(P2_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Treble magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.12: Treble path magnitude and phase response as a function of treble setting (P2). Solid lines are the magnitude responses at various settings of P2 and the dashed lines are the phase responses.\n\n\n\n\n\n\n\n37.10.6 Step response at P2=50%\nSetting the value of P2 to the midpoint, P2 = 50%, the transfer function is computed.\n\nP2_setting = 0.5 # percentage of rotation\n\nelement_values[Rp2a] = P2_setting*P2_value\nelement_values[Rp2b] = P2_value - P2_setting*P2_value\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 500 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.005, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*500*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal*1e3, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step*1e3,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts, mV')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response has a rather long decay time and asymptomatically approaches zero and -1 indicating the DC gain is -1.\n\n37.10.6.1 Group delay\nThe following python code calculates and plots the group delay. Notice that the scale for the vertical axis is msec.\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1e3,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((-0.25,0.25))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.\n\n\n\n37.10.7 Pole/zero locus plot\nThe plot below shows the frequency locations for the treble control pole and zero locations as a function of P2 rotation. Since the poles and zeros don’t have imaginary parts, the complex frequency is plotted on the vertical axis versus the treble control rotational position, from 1 to 99 percent. The plot provides a visual indication of how the poles and zeros change as a function P2.\n\nsym_num, sym_denom = fraction(H_sym) #returns numerator and denominator\n\np2_value = 10e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp2a] = p2_value - i*p2_value\n    element_values[Rp2b] = i*p2_value\n    num_roots.append(solve(sym_num.subs(element_values),s))\n    denom_roots.append(solve(sym_denom.subs(element_values),s))\n\nplt.plot(np.linspace(1,99,len(np.array(num_roots).flatten())),-np.array(num_roots).flatten()/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='zero')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots).flatten())),-np.array(denom_roots).flatten()/(2*np.pi)/1e3,'x-r',label='pole')\n\nplt.ylim((0,4))\nplt.legend(loc='upper left')\nplt.title('Treble control pole & zero frequency plot vs treble rotation %')\nplt.xlabel('Treble rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs P2 is rotated, the frequency location of the pole and zero move in opposite directions. At a low P2 rotation percentage, the pole has a lower frequency location than the zero, and above 35.5% rotation the pole has a higher frequency location than the zero.\nSince each zero has the effect of adding a -20 dB slope contribution to the frequency response and each pole has the effect of adding a +20 dB slope contribution to the frequency response, at low rotation percentage, there is a negative slope in the frequency response plot from the pole frequency to the zero frequency, where the slope is canceled by the zero. The designers of the Klon, either by accident or design chose to give the treble control more boost than cut over the rotational range.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#sec-effects_paths_linear_analysis",
    "href": "Klon Centaur part 1.html#sec-effects_paths_linear_analysis",
    "title": "37  Klon Centaur, part 1",
    "section": "37.11 Effects path linear analysis",
    "text": "37.11 Effects path linear analysis\nWhen the bypass switch, S1A/B is in the effect on position, R27 is shorted by the switch and the output jack is connected to the wiper terminal of P3 and the bypass signal is isolated by R26. The operation of the effects path is somewhat complicated and the function and purpose of some of the reactive branches in the circuit path are not obvious. The Chittum Klon Centaur schematic is shown below with parts of the circuit highlighted in different colors.\n\n\n\n\n\n\nFigure 37.13: Schematic of the Klon Centaur with the signal paths highlighted.\n\n\n\nThe red highlight is the node connected to the output of U1A. From this node, the guitar signal will travel forward in the circuit to C2, C3 and R5||C4. The path starting with C2, which is not highlighted, is the bypass path described in Section 37.9. The component, C3, also not highlighted, because it is common to the green highlighted path and the brown highlighted path, is the start of one path leading to the summing amplifier, U2A, highlighted in yellow. The inverting input of U2A is where the effects paths are summed together. Each path is described below:\n\nThe green highlighted path, which I’ve named, clean tone path 1, see Section 37.11.1, is a low pass filter with components R7 and C16. R19 can be considered part of the summing amplifier and sets the DC gain for this path with R20. One side of R7 is connected to C3 and C5||R6 and these components present a complex impedance seen by the R7 and C16 low pass filter, so we can’t just ignore these and analyze the low pass filter in isolation. C3 blocks the DC bias from the output of U1A, in addition to any other impedance effects it might be adding to the circuit’s operation.\nThe brown highlighted path, which I named, distortion path part A, see Section 37.11.3, consists of a reactive branch composed of C5||R6 and the gain control potentiometer P1B. The gain control potentiometer is a dual gang 100K \\(\\Omega\\) device. The wiper terminal of P1B is connected to ground and when P1B is fully CCW, the input to U1B is grounded, which effectively blocks the signal from traversing this path in the pedal. The operation of the reactive branches R11||C7 and R12||C8 are described below.\nThe gray highlighted path, named, distortion path part B, see Section 37.11.4, consists of DC blocking capacitors, C9 and C10, R13 and the clipping diodes D2 and D3. R13 softens the clipping action of the diodes and limits the diode current. D2 and D3 are not highlighted since they are omitted in the linear circuit analysis, described later. R16 is included in this path since it can be considered the summing input for this path. The reactive branch C11 and R15 is not highlighted since it is common to the purple highlighted path, and is connected to the left side of R16, not the inverting terminal of U2A. The interaction of the gray highlighted path and the purple highlighted path at the inverting input to U2A is not obvious and is analyzed below.\nThe purple highlighted path, named, clean tone path 2, see Section 37.11.2, consists of several reactive branches who’s function and operation is not obvious and is analyzed below. The gain control potentiometer P1A acts like a voltage divider, taking the signal from one end of C6 and attenuating the signal depending on the rotational position of the gain knob. Fully CCW, the signal at C6 is not attenuated and at the same time, the inverting input to U1B is grounded. The gain knob blends various amounts of either clean tone or distortion to the summing amplifier.\n\nThe schematic in Figure 37.14 will be used for MNA analysis. The circuit paths leading from the output of U1A are separated, with one path starting at C3. This path is connected to V1. The other path starts with R5||C4 and this path is connected to V2. A third path starts at the output of U1B and is connected to V3. The branch from the output of U1B to C9 was removed and the path terminates at node 8.\nBy using the superposition theorem, we can consider each voltage source independently and the composite result is the sum of the various results. The output of U1A is modeled as a voltage source, so the voltage at this node is determined by the voltage out U1A output. The current in each branch is determined by the impedance of each path. This allows examination of each path to see how the circuit works otherwise we would just see the composite results at node 2.\n\n\n\n\n\n\nFigure 37.14: LTSpice schematic of Klon Centaur with the sum paths driven by voltage sources.\n\n\n\nThe circuit in Figure 37.14 has two diodes, D2 and D3. These are omitted for MNA. There is no diode model supported by the MNA code so we have no choice but to ignore the diodes, which can be done when doing frequency domain analysis in the audio band. Diodes are not very frequency dependent since the junction capacitance is small, and at audio frequencies, plays a small role.\nThe diode capacitance can be ignored without too much loss in accuracy. D2 and D3 are used in the circuit to limit the amplitude of the signal from U1B. For signal amplitudes above the forward threshold voltage, the current through the diode exponentially increases with voltage. R13 limits current that U1B would need to source or sink for signal amplitudes above the diode’s threshold voltage, which limits the voltage at node 10 for large signals.\nSince we are primarily interested in examining the frequency response of the circuit paths and the V3 term cancels out in \\(H(s) = \\frac {v_2(s)}{v_{20}(s)}\\), we can treat the results of MNA as accurate for small signals without including the diodes in the circuit. See Section 38.6 and Figure 38.10 for a comparison of the LTSpice and MNA results that supports the idea of ignoring the diodes when doing frequency domain analysis.\nIn linear circuits, the principle of superposition applies, meaning that the response (voltage or current) to multiple inputs is the sum of the responses to each input applied individually. The Op Amp outputs control the voltages at the nodes they are connected to. This allows us to consider each path that originates at an Op Amp output independently and later using superposition, combine the results.\nIn the following analysis, the branches that are common to the node connected to the output of U1A are separated and replaced by voltage sources. This is shown in Figure 37.14, where \\(V_1\\), \\(V_2\\) and \\(V_3\\) drive the circuit branches. We can analyze the response from each of these sources one at a time, by setting either \\(V_1\\), \\(V_2\\) and \\(V_3\\) to one and the others to zero. The terms for the sources, \\(V_1\\), \\(V_2\\) or \\(V_3\\), cancel in the voltage transfer function, making the frequency response independent of the amplitude of the input source, with the condition that the diodes are not conducting. The analysis presented below is valid as long as the circuit remains in the linear domain.\nThe step response for each path, presented below, is calculated using a 0.1 volt square wave, which should keep the diodes in the non-conducting region. In Part 2, LTSpice will be used to examine the circuit when the diodes and possibly the Op Amp’s output are driven into the nonlinear range.\n\nDefine the frequency range for x axis to be used on all plots in this section and storage arrays for the magnitude of the frequency response. The frequency range for the x axis is 10 to 100kHz. The frequency response plots are generated for gains of 1, 10, 25, 50, 75 and 99 percent of the full scale value of the gain control potentiometer, P1, which is 100k\\(\\Omega\\). The plot colors for each gain setting are defined in the color list shown below. Arrays are declared to store the magnitude and radian frequency data for each path and each gain setting.\n\nx_axis = np.logspace(1, 5, 2000, endpoint=True)*2*np.pi\ncolor_list = ['tab:blue','tab:purple','tab:brown','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,2.5,9.75,25,50,75,99])/100\np1_value = 100e3\n\n# save the magnitude and radian frequency\nclean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\nclean_path1_w = np.zeros((len(gain_setting),len(x_axis)))\nclean_path2_mag = np.zeros((len(gain_setting),len(x_axis)))\nclean_path2_w = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathA_mag = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathA_w = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathB_mag = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathB_w = np.zeros((len(gain_setting),len(x_axis)))\n\n\n37.11.1 Clean tone path 1\n\n\n\n\n\n\nFigure 37.15: Klon Centaur schematic with clean tone path 1 highlighted.\n\n\n\nThe clean tone path in Figure 37.15 is highlighted. This signal path starts at the output of the input buffer Amp, U1A and runs to the output of the summing Op Amp, U2A. As described above this path can be analyzed in isolation of the other parts of the circuit based on the principle of superposition. This path starts with C3, which blocks the DC bias and forms a high pass filter blocking frequencies below the audio range. The signal in this path then continues to R7 and C16 which are a low pass filter. The branch consisting of C5 and R16 is terminated to ground when P1 is fully counterclockwise since the wiper of P1 is connected to the virtual ground. The low frequency gain of the summing amp, U2A, is determined by R7, R20 and R24.\nThe net list generated from Figure 37.14 is used for this analysis. V2 and V3 are set to zero and the transfer function from node 1 to node 2 is calculated. C5||R6 and the network surrounding U1B is included in the analysis since the impedance of these components appears along the path of interest.\nThe branch consisting of R5||C4 is the start of clean path 2. This circuit branch presents an impedance that is isolated since it is driven by V2, an ideal voltage source. C12 and R17, the other end of the clean path 2 are connected to the summing junction of U2A inverting input.\nBranch with C2 is not analyzed as part of clean path 1 since U1A output is an ideal voltage source and the current that flows from U1A into the branch containing C2 can be partitioned due to superposition.\nC13||R20 are in the feedback path of U2A. U2A is configured as an inverting summing amplifier. Pin 2 of U2A is a virtual ground since the Op Amp will keep the voltage difference between pins 2 and 3 to zero volts and pin 3 is connected to ground (as described above this is an AC ground). C13 limits the high frequency gain of U2A. This path is an AC coupled low pass filter.\n\nThe net list below has all the components of the direct and distortion paths, Figure 37.14. In the net list, the voltage sources V1, V2 and V3 are set to a value of 1. Later when we analyze various paths, some of these sources will be set to zero and by relying on the principle of superposition, we can isolate the various paths. In the net list, the diodes have been commented out.\n\n# change variable name to clean_path1_net_list\nclean_path_v3_net_list = '''\n* Klon-Centaur_clean_path_v3.asc\nV1 1 0 1\nR5 19 14 5.1e3\nR8 14 0 1.5e3\nC3 3 1 100e-9\nC4 19 14 68e-9\nC6 14 15 390e-9\nR9 15 0 1e3\nR6 4 3 10e3\nC5 4 3 68e-9\nRp1b2 14 16 50e3\nRp1a2 16 0 50e3\nRp1b1 0 4 50e3\nRp1a1 5 0 50e3\nR10 6 5 2e3\nR11 7 6 15e3\nC7 7 6 82e-9\nC8 8 7 390e-12\nR12 8 7 422e3\nR13 10 9 1e3\nC11 11 17 2.2e-9\nR15 17 16 22e3\nR17 12 16 27e3\nR18 18 16 12e3\nC12 12 18 27e-9\nR16 12 11 47e3\nR7 3 13 1.5e3\nR24 12 13 15e3\nR20 2 12 392e3\nC13 2 12 820e-12\nO1b 7 4 8\nO2a 12 0 2\n*D2 0 10 1N34A\n*D3 10 0 1N34A\nC16 13 0 1e-6\nC9 20 9 1e-6\nC10 11 10 1e-6\nV2 19 0 1\nV3 20 0 1\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(clean_path_v3_net_list)\n\nBuild and display the network equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{3} s v_{1} - C_{3} s v_{3} + I_{V1}\\)\\(0 = I_{O2a} + v_{12} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) + v_{2} \\left(C_{13} s + \\frac{1}{R_{20}}\\right)\\)\\(0 = - C_{3} s v_{1} + v_{3} \\left(C_{3} s + C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) + v_{4} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) - \\frac{v_{13}}{R_{7}}\\)\\(0 = v_{3} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) + v_{4} \\left(C_{5} s + \\frac{1}{Rp1b1} + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{5} \\cdot \\left(\\frac{1}{Rp1a1} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{10}}\\)\\(0 = v_{6} \\left(C_{7} s + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) + v_{7} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{10}}\\)\\(0 = v_{6} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) + v_{7} \\left(C_{7} s + C_{8} s + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{8} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right) + v_{8} \\left(C_{8} s + \\frac{1}{R_{12}}\\right)\\)\\(0 = - C_{9} s v_{20} + v_{9} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{10}}{R_{13}}\\)\\(0 = - C_{10} s v_{11} + v_{10} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{9}}{R_{13}}\\)\\(0 = - C_{10} s v_{10} - C_{11} s v_{17} + v_{11} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{12}}{R_{16}}\\)\\(0 = - C_{12} s v_{18} + v_{12} \\left(C_{12} s + C_{13} s + \\frac{1}{R_{24}} + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) + v_{2} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) - \\frac{v_{13}}{R_{24}} - \\frac{v_{16}}{R_{17}} - \\frac{v_{11}}{R_{16}}\\)\\(0 = v_{13} \\left(C_{16} s + \\frac{1}{R_{7}} + \\frac{1}{R_{24}}\\right) - \\frac{v_{3}}{R_{7}} - \\frac{v_{12}}{R_{24}}\\)\\(0 = - C_{6} s v_{15} + v_{14} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) + v_{19} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) - \\frac{v_{16}}{Rp1b2}\\)\\(0 = - C_{6} s v_{14} + v_{15} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{16} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{14}}{Rp1b2} - \\frac{v_{18}}{R_{18}} - \\frac{v_{12}}{R_{17}} - \\frac{v_{17}}{R_{15}}\\)\\(0 = - C_{11} s v_{11} + v_{17} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{16}}{R_{15}}\\)\\(0 = - C_{12} s v_{12} + v_{18} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{16}}{R_{18}}\\)\\(0 = I_{V2} + v_{14} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{19} \\left(C_{4} s + \\frac{1}{R_{5}}\\right)\\)\\(0 = C_{9} s v_{20} - C_{9} s v_{9} + I_{V3}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{19}\\)\\(V_{3} = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{9}, \\  I_{V3}, \\  v_{5}, \\  R_{7}, \\  v_{13}, \\  V_{1}, \\  v_{12}, \\  R_{11}, \\  v_{14}, \\  v_{7}, \\  C_{5}, \\  C_{8}, \\  C_{10}, \\  C_{12}, \\  V_{2}, \\  v_{6}, \\  v_{10}, \\  R_{10}, \\  I_{V1}, \\  I_{O2a}, \\  R_{12}, \\  v_{1}, \\  R_{6}, \\  C_{3}, \\  C_{13}, \\  R_{5}, \\  v_{20}, \\  C_{7}, \\  R_{18}, \\  R_{8}, \\  I_{O1b}, \\  I_{V2}, \\  R_{16}, \\  s, \\  V_{3}, \\  Rp1b2, \\  C_{6}, \\  R_{17}, \\  R_{15}, \\  v_{2}, \\  v_{3}, \\  R_{9}, \\  C_{4}, \\  Rp1a1, \\  v_{16}, \\  v_{4}, \\  Rp1b1, \\  v_{15}, \\  R_{20}, \\  v_{18}, \\  R_{13}, \\  v_{19}, \\  v_{11}, \\  v_{17}, \\  Rp1a2, \\  C_{16}, \\  v_{9}, \\  C_{11}, \\  v_{8}, \\  R_{24}\\right)\\)\n\n\nConstruct a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n\n37.11.1.1 Clean tone path 1 frequency response\nThe transfer function \\(H(s)=\\frac{v2}{v1}\\) is analyzed for various settings of the Gain control, P1. The gain setting is in steps of percentage of full scale, from 1 to 99 percent. The voltage sources V2 and V3 are set to zero so that the transfer function of clean tone path 1 can be examined.\n\nelement_values[V1] = 1\nelement_values[V2] = 0\nelement_values[V3] = 0\n\nThe plot below shows the frequency response of the path for various settings of P1 ranging from 1% to 99%.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    clean_path1_mag[i] = mag\n    clean_path1_w[i] = w    \n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-60,10))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.16: Clean tone path 1 magnitude and phase response\n\n\n\n\n\nThe Klon Centaur clean path 1 has a low pass profile in the guitar audio band. The path is AC coupled so there is some roll off in gain below 80 Hz. The position of P1 does not affect the gain of this path to any significant amount. There is only about 1.5 dB difference in gain between P1 being fully CW to fully CCW. The filter characteristics of peak gain, -3dB attenuation frequency and attenuation roll off for P1 setting of 50% are measured from the frequency response data using the code below.\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = clean_path1_mag[i].max()\nmax_gain_arg = clean_path1_mag[i].argmax()\nmax_gain_freq = clean_path1_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:.1f} Hz'.format(max_gain, max_gain_freq))\n\ngain_3dB_arg_offset = np.where(clean_path1_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nfreq_3dB = clean_path1_w[i][max_gain_arg+gain_3dB_arg_offset]/(2*np.pi)\nprint('-3dB frequency: {:.1f} Hz'.format(freq_3dB))\n\nprint('clean path 1 attenuation: {:.1f} dB per decade'.format(clean_path1_mag[i][1500] - clean_path1_mag[i][-1]))\n\ngain setting: 50%\nmax gain: 7.1 dB at 73.9 Hz\n-3dB frequency: 451.7 Hz\nclean path 1 attenuation: 39.9 dB per decade\n\n\nThe maximum gain of this path is 7.1 dB at 74 Hz with the gain control at 50%. As shown in the plot, the gain control does not affect the gain in this path too much. Within the guitar audio band, this path has a low pass characteristic with a -3dB frequency of 452 Hz and a roll off of about 40 dB per decade. As shown below there are two poles not canceled by zeros and this results in the 40 dB per decade roll off.\n\n\n37.11.1.2 Numerical solution for P1 at 50%\nThe analysis can be run for any setting of P1, for illustration a setting of 50% is used to generate numerical values.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(1 = v_{1}\\)\\(0 = v_{19}\\)\\(0 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{- 1.666 \\cdot 10^{36} s^{2} - 2.94 \\cdot 10^{39} s}{3.07377 \\cdot 10^{28} s^{4} + 3.8347452 \\cdot 10^{32} s^{3} + 1.324108096 \\cdot 10^{36} s^{2} + 1.3641377 \\cdot 10^{39} s + 9.5625 \\cdot 10^{40}}\\)\\(v_{3} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.822 \\cdot 10^{28} s^{2} + 1.98 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{4} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{5} = \\frac{1.56825 \\cdot 10^{37} s^{4} + 4.7313 \\cdot 10^{40} s^{3} + 4.50125 \\cdot 10^{43} s^{2} + 1.375 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{6} = \\frac{1.63098 \\cdot 10^{37} s^{4} + 4.920552 \\cdot 10^{40} s^{3} + 4.6813 \\cdot 10^{43} s^{2} + 1.43 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{7} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{8} = \\frac{1.2721644 \\cdot 10^{46} s^{5} + 7.45961435931766 \\cdot 10^{50} s^{4} + 2.18693901867302 \\cdot 10^{54} s^{3} + 2.07668666587681 \\cdot 10^{57} s^{2} + 6.37322274881527 \\cdot 10^{59} s}{1.2721644 \\cdot 10^{46} s^{5} + 2.09758384731754 \\cdot 10^{50} s^{4} + 1.10702928656076 \\cdot 10^{54} s^{3} + 2.03466134856873 \\cdot 10^{57} s^{2} + 1.21969565229069 \\cdot 10^{60} s + 8.09715639810431 \\cdot 10^{61}}\\)\\(v_{9} = 0.0\\)\\(v_{10} = 0.0\\)\\(v_{11} = 0.0\\)\\(v_{12} = 0.0\\)\\(v_{13} = \\frac{1.02 \\cdot 10^{28} s^{2} + 1.8 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{14} = 0.0\\)\\(v_{15} = 0.0\\)\\(v_{16} = 0.0\\)\\(v_{17} = 0.0\\)\\(v_{18} = 0.0\\)\\(v_{19} = 0.0\\)\\(v_{20} = 0.0\\)\\(I_{V1} = \\frac{- 1.0506 \\cdot 10^{29} s^{3} - 1.93544 \\cdot 10^{32} s^{2} - 1.53 \\cdot 10^{34} s}{1.53 \\cdot 10^{32} s^{3} + 1.4328 \\cdot 10^{36} s^{2} + 2.13344 \\cdot 10^{39} s + 1.53 \\cdot 10^{41}}\\)\\(I_{V2} = 0.0\\)\\(I_{V3} = 0.0\\)\\(I_{O1b} = \\frac{- 3.13650000000006 \\cdot 10^{40} s^{4} - 9.46260000000018 \\cdot 10^{43} s^{3} - 9.00250000000017 \\cdot 10^{46} s^{2} - 2.75000000000005 \\cdot 10^{49} s}{1.63098 \\cdot 10^{45} s^{4} + 1.6982148 \\cdot 10^{49} s^{3} + 3.87420704000001 \\cdot 10^{52} s^{2} + 2.54543933333334 \\cdot 10^{55} s + 1.70850000000001 \\cdot 10^{57}}\\)\\(I_{O2a} = \\frac{6.8 \\cdot 10^{23} s^{2} + 1.2 \\cdot 10^{27} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\nThe transfer function for the clean tone path 1 is calculated from the ratio of \\(v_{2}\\) and \\(v_{1}\\).\nThe voltage transfer function is \\(H(s)=\\frac {v_2} {v_{1}}\\):\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(- 1.666 \\cdot 10^{36} s^{2} - 2.94 \\cdot 10^{39} s\\right)}{3.07377 \\cdot 10^{28} s^{4} + 3.8347452 \\cdot 10^{32} s^{3} + 1.324108096 \\cdot 10^{36} s^{2} + 1.3641377 \\cdot 10^{39} s + 9.5625 \\cdot 10^{40}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nPole zero plot The poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above and printed below, there are two zeros and four poles in the transfer function. The zero at 0 Hz means that the direct current is blocked through this path, since the pole and zero near 0 Hz don’t quite cancel. Since the number of poles is greater than the number of zero, the transfer function is a low pass function.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 2\nz0: -280.86 Hz\nz1: 0.00 Hz\nnumber of poles: 4\np0: -1,198.55 Hz\np1: -495.13 Hz\np2: -279.87 Hz\np3: -12.02 Hz\n\n\n\n\n37.11.1.3 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 5 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*5*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero. There is a relatively large spike in the output at each square wave edge.\n\n\n37.11.1.4 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((-1,4))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.\n\n\n\n37.11.2 Clean tone path 2\n\n\n\n\n\n\nFigure 37.17: Klon Centaur schematic with clean tone path 2 highlighted.\n\n\n\nThe second clean tone path is highlighted in Figure 37.17. This circuit path, which runs from the output of the buffer amp to the output of the summing amp, U2A, is the least intuitive path in the pedal. The operation and interaction of the reactive branches with C4, C6, C11 and C12 is not very obvious. One thing to notice is that there is a DC path from the output of U1A to the inverting terminal of U2A. This will bias U2A to the DC level of the virtual ground. The DC path continues to the treble tone control circuit. V1 and V3 are set to zero and the transfer function from node 19 to node 2 is calculated.\nThe operation and purpose of this path has been discussed online in forums and web pages, see Section 37.4. None of these presented a detailed analysis to the level provided below. In this section, the path is analyzed while the input to the other paths are zero, so we can get the contribution of this path.\nThe C3 path has been partitioned since the output of U1A is an ideal voltage source and by applying superposition allows us to consider parts of the circuit independently. Since the circuit is considered a linear circuit,, the individual responses can be combined later to obtain the total response.\nThe C2 path is ignored since the circuit can be partitioned at each of the Op Amp’s outputs.\nThe C10 path is connected to the diodes and for now we can ignore the diodes since we are interested in the voltage transfer function and we assume the signal levels do not cause the diodes to conduct.\nThe components, C13||R20 and U2A, as described above, are part of an inverting low pass filter which sums the signals from the various paths.\nClean path 2 has reactive branches formed by the capacitors in the signal path or branching from the signal path. The presence of these capacitors (C4, C6, C10, C11 and C12) in the branches will produce poles and zeros in the voltage transfer function. It’s not obvious, at least to me, what is happening in this path and what the various branches are doing. We can analyze this path, setting V1 and V3 to zero in Figure 37.14 and using nodal analysis to obtain the voltage transfer function.\nLater in Section 39.3, I’ll look at the reactive branches isolated from the circuit to attempt to get some insight into the role they play in the overall operation of the circuit since the transfer function of Clean tone path 2 doesn’t provide much insight into what’s actually happening in this path; see Section 39.3.1, Section 39.3.2, Section 39.3.3 and Section 39.3.7.\n\n\n37.11.2.1 Frequency response versus P1\nThe frequency response for the clean tone path 2 for various settings of P1 is calculated and displayed below. The source \\(V_2\\) is set to one and the other sources are set to zero.\n\nelement_values[V1] = 0\nelement_values[V2] = 1\nelement_values[V3] = 0\n\nThe plot below shows the frequency response of the path for various settings of P1 ranging from 1% to 99%.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v19]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    clean_path2_mag[i] = mag\n    clean_path2_w[i] = w\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-60,20))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.18: Clean tone path 2 magnitude and phase response\n\n\n\n\n\nFrom the curves above, the clean path 2 has a low pass response with a cut off frequency about 2kHz and the gain varies from 10 dB to -30 dB controlled by the position of P1.\ndescribe filter characteristics, 3dB point, roll off, gain at 1kHz\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = clean_path2_mag[i].max()\nmax_gain_arg = clean_path2_mag[i].argmax()\nmax_gain_freq = clean_path2_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:.1f} Hz'.format(max_gain, max_gain_freq))\n\ngain_3dB_arg_offset = np.where(clean_path2_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nfreq_3dB = clean_path2_w[i][max_gain_arg+gain_3dB_arg_offset]/(2*np.pi)\nprint('-3dB frequency: {:.1f} Hz'.format(freq_3dB))\n\nprint('clean path 2 attenuation: {:.1f} dB per decade'.format(clean_path2_mag[i][1500] - clean_path2_mag[i][-1]))\n\ngain setting: 50%\nmax gain: -1.5 dB at 39.3 Hz\n-3dB frequency: 1109.2 Hz\nclean path 2 attenuation: 19.3 dB per decade\n\n\n\n\n37.11.2.2 Numerical solution for P1 at 50%\nThe transfer function for this path is solved for the case where P1 is set at a 50% rotational position.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numerical values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(0 = v_{1}\\)\\(1 = v_{19}\\)\\(0 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 0.0\\)\\(v_{2} = \\frac{- 1.26384690189495 \\cdot 10^{63} s^{5} - 3.30941715880806 \\cdot 10^{67} s^{4} - 1.76927318717644 \\cdot 10^{71} s^{3} - 3.29892164039092 \\cdot 10^{74} s^{2} - 1.88749342217544 \\cdot 10^{77} s - 7.25931088102553 \\cdot 10^{78}}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(v_{6} = 0.0\\)\\(v_{7} = 0.0\\)\\(v_{8} = 0.0\\)\\(v_{9} = \\frac{2.0138625 \\cdot 10^{55} s^{4} + 1.71863602941176 \\cdot 10^{59} s^{3} + 4.87499999999999 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{10} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 1.92002227941176 \\cdot 10^{56} s^{4} + 6.59363602941176 \\cdot 10^{59} s^{3} + 9.47058823529411 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{11} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 2.12140852941176 \\cdot 10^{56} s^{4} + 8.31227205882352 \\cdot 10^{59} s^{3} + 1.43455882352941 \\cdot 10^{63} s^{2} + 9.19117647058822 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{12} = 0.0\\)\\(v_{13} = 0.0\\)\\(v_{14} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.76830244412326 \\cdot 10^{60} s^{4} + 9.75686883763291 \\cdot 10^{63} s^{3} + 2.00756023341467 \\cdot 10^{67} s^{2} + 1.40196836955285 \\cdot 10^{70} s + 5.47822825670137 \\cdot 10^{71}}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\\(v_{15} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.57063979093177 \\cdot 10^{60} s^{4} + 5.72958732242324 \\cdot 10^{63} s^{3} + 5.3843527894717 \\cdot 10^{66} s^{2} + 2.13650902011353 \\cdot 10^{68} s}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\\(v_{16} = \\frac{4.72614965425532 \\cdot 10^{53} s^{5} + 1.34411248109 \\cdot 10^{58} s^{4} + 9.21167841492205 \\cdot 10^{61} s^{3} + 2.41846205484128 \\cdot 10^{65} s^{2} + 2.24113593696666 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{17} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 9.56082557247695 \\cdot 10^{57} s^{4} + 8.10026990741267 \\cdot 10^{61} s^{3} + 2.31064415746956 \\cdot 10^{65} s^{2} + 2.23683368415064 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{18} = \\frac{1.45868816489362 \\cdot 10^{57} s^{4} + 3.69828291543406 \\cdot 10^{61} s^{3} + 1.70166527761975 \\cdot 10^{65} s^{2} + 2.2123357321652 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{19} = 1.0\\)\\(v_{20} = 0.0\\)\\(I_{V1} = 0.0\\)\\(I_{V2} = \\frac{- 1.29871256480426 \\cdot 10^{71} s^{5} - 2.78057297595692 \\cdot 10^{75} s^{4} - 1.23998265533368 \\cdot 10^{79} s^{3} - 1.90922089398308 \\cdot 10^{82} s^{2} - 9.76878402295801 \\cdot 10^{84} s - 3.73327208955079 \\cdot 10^{86}}{7.70884347446809 \\cdot 10^{73} s^{5} + 3.67817386295305 \\cdot 10^{78} s^{4} + 4.51405215439493 \\cdot 10^{82} s^{3} + 1.00397005781958 \\cdot 10^{86} s^{2} + 6.31801858446797 \\cdot 10^{88} s + 2.45179159134104 \\cdot 10^{90}}\\)\\(I_{V3} = \\frac{2.0138625 \\cdot 10^{49} s^{5} + 1.71863602941176 \\cdot 10^{53} s^{4} + 4.87499999999999 \\cdot 10^{56} s^{3} + 4.59558823529411 \\cdot 10^{59} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(I_{O1b} = 0.0\\)\\(I_{O2a} = \\frac{5.15855878324468 \\cdot 10^{50} s^{5} + 1.35078251379921 \\cdot 10^{55} s^{4} + 7.22152321296506 \\cdot 10^{58} s^{3} + 1.34649862873099 \\cdot 10^{62} s^{2} + 7.70405478438957 \\cdot 10^{64} s + 2.96298403307165 \\cdot 10^{66}}{4.3362244543883 \\cdot 10^{55} s^{5} + 2.06897279791109 \\cdot 10^{60} s^{4} + 2.53915433684715 \\cdot 10^{64} s^{3} + 5.64733157523515 \\cdot 10^{67} s^{2} + 3.55388545376323 \\cdot 10^{70} s + 1.37913277012933 \\cdot 10^{72}}\\)\n\n\nThe transfer function for the Clean tone path 2 is calculated from the ratio of \\(v_{2}\\) and \\(v_{19}\\). There are six capacitors in the network that comprises this path, so the order of the denominator polynomial is six. The voltage transfer function is \\(H(s)=\\frac {v_2} {v_{19}}\\):\n\nH = U[v2]/U[v19]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(- 1.26384690189495 \\cdot 10^{63} s^{5} - 3.30941715880806 \\cdot 10^{67} s^{4} - 1.76927318717644 \\cdot 10^{71} s^{3} - 3.29892164039092 \\cdot 10^{74} s^{2} - 1.88749342217544 \\cdot 10^{77} s - 7.25931088102553 \\cdot 10^{78}\\right)}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n\n\n37.11.2.3 Poles and zeros\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the clean path 2 transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the poles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency. There are five zeros and six poles. There is no zero at 0 Hz. Since there are more poles than zeros, and the value of the last pole is greater than the value of the last zero, the transfer function is a low pass filter.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 5\nz0: -3,142.62 Hz\nz1: -458.92 Hz\nz2: -408.09 Hz\nz3: -151.29 Hz\nz4: -6.59 Hz\nnumber of poles: 6\np0: -4,629.79 Hz\np1: -2,545.69 Hz\np2: -495.13 Hz\np3: -231.62 Hz\np4: -180.17 Hz\np5: -6.60 Hz\n\n\n\n\n37.11.2.4 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 100 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. Since the diodes have been removed from the circuit for analysis, we can say that at these low signal amplitudes, the diodes are not active and can be ignored. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.025, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*100*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal*1e3, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step*1e3,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts, mV')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC offset is preserved and the DC gain of the path is less than -1. The DC gain can be calculated by setting the Laplace variable equal to 0.\n\nprint('DC gain: {:.2f}'.format(H.subs({s:0})))\n\nDC gain: -0.84\n\n\nThere is almost no overshoot in the response and the rise time is relatively fast, on the order of a couple milliseconds.\n\n\n37.11.2.5 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,0.2))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.\n\n\n\n37.11.3 Distortion path part A\n\n\n\n\n\n\nFigure 37.19: Klon Centaur distortion path part A schematic with the path highlighted.\n\n\n\nDistortion path part A is highlighted in Figure 37.19. There are four capacitors in this path which determine the frequency response. The signal level is also determined by the potentiometer P1B. The voltage transfer function from node 1 to node 8 is calculated below. The frequency response at node 8 shows some emphasis at 1 kHz as a function of the gain setting as seen in fig-distortion-path-part-A-freq-plot. The signal at the output of U1B, node 8, is what get clipped by the diodes. The guitar signal, already rich in harmonics, is heavily modified harmonically and amplitude limited by the diodes. In the net list the signal path at node 8 to C9 is removed and V3 is used to drive the rest of the path, because the MNA code is not modeling the diodes. So we can only look at the circuit up to that point.\nThe path starts at the output of U1A and ends at the output of U1B. The op amps isolate the path from the rest of the circuit.\nThe path starts with C3 and continues to R5||C4. The R7 & C16 branch (part of clean path 1) also connects to the C3, R5||C4 node. There are a lot of components in the circuit that connect to the path, some only tangentially, but still need to be included in the analysis.\nThe gain potentiometer, P1 is connected to the non-inverting input of U1B and the wiper of P1 is connected to the AC ground. The CCW end of P1 forms (modeled as Rp1b in Figure 37.14) a voltage divider with R6 and when P1 is fully CCW, the non-inverting input of U1B is grounded. This effectively stops the signal from traveling to U1B and the diodes.\nThe most interesting part of this path are the components in the feedback of U1B which are, R10, R11||C7, R12||C8 and P1B. These components are the main contributors to the gain and frequency response of signals in this path. It’s not obvious by inspection how these components play together, but some guesses can be made. Capacitor C3 AC couples the signal into the path, so the signals should be attenuated at very low frequencies. At high frequencies, the capacitor, C8, decreases in impedance and limits the gain of U1B. However one would need to examine the resonant frequencies of R11||C7 and R12||C8 to get an idea of what might be happening over the guitar audio band. The position of P1 complicates an intuitive inspection of the circuit’s operation and rather than guessing. To obtain some insight into the operation of the circuit, we could perform a nodal analysis of the circuit and then try to relate the dominant poles and zeros to the behavior of the circuit and to the individual components. In Section 39.3 an attempt is made to do this.\n\n37.11.3.1 Distortion path part A frequency response\nThe frequency response of the path for various settings of P1 is calculated and displayed below. The source \\(V_1\\) is set to one and the other sources are set to zero.\n\nelement_values[V1] = 1\nelement_values[V2] = 0\nelement_values[V3] = 0\n\nThe plot below shows the frequency response of the path for various settings of P1 ranging from 1% to 99%.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v8]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    diode_pathA_mag[i] = mag\n    diode_pathA_w[i] = w\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-40,40))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.20: Distortion path part A magnitude and phase response\n\n\n\n\n\nThe Klon Centaur distortion path part A has a band pass characteristic centered at 1kHz. The gain of this path at 1 kHz ranges from about -3 dB to 35 dB depending on the position of P1. Distortion path A shapes the tonal characteristics of the signal prior to the clipping diodes.\nThe frequency response for this path exhibits emphasis near 1,000 Hz for gains above 10% and starts to look like a band pass filter. The bandwidth for the filter is measured at the half-power points (gain −3 dB) and the quality factor, also called Q, is the reciprocal of the fractional bandwidth. These parameters are calculated below.\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = diode_pathA_mag[i].max()\nmax_gain_arg = diode_pathA_mag[i].argmax()\nmax_gain_freq = diode_pathA_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:,.0f} Hz'.format(max_gain, max_gain_freq))\n\nupper_3dB_arg_offset = np.where(diode_pathA_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nupper_3dB_freq = diode_pathA_w[i][max_gain_arg+upper_3dB_arg_offset]/(2*np.pi)\nprint('upper -3dB frequency: {:,.0f} Hz'.format(upper_3dB_freq))\n\nlower_3dB_arg = np.where(diode_pathA_mag[i][:max_gain_arg] &lt; max_gain - 3)[0][-1]\nlower_3dB_freq = diode_pathA_w[i][lower_3dB_arg]/(2*np.pi)\nprint('lower -3dB frequency: {:,.0f} Hz'.format(lower_3dB_freq))\n\ndiode_pathA_bw = upper_3dB_freq - lower_3dB_freq\nprint('bandwidth: {:,.0f} Hz'.format(diode_pathA_bw))\n\ndiode_pathA_q = max_gain_freq/diode_pathA_bw\nprint('Q factor: {:.1f}'.format(diode_pathA_q))\n\ngain setting: 50%\nmax gain: 12.2 dB at 1,109 Hz\nupper -3dB frequency: 2,788 Hz\nlower -3dB frequency: 464 Hz\nbandwidth: 2,323 Hz\nQ factor: 0.5\n\n\n\n\n37.11.3.2 Numerical solution for P1 at 50%\nThe transfer function for this path is solved for the case where P1 is set at a 50% rotational position.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numerical component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(1 = v_{1}\\)\\(0 = v_{19}\\)\\(0 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{- 1.666 \\cdot 10^{36} s^{2} - 2.94 \\cdot 10^{39} s}{3.07377 \\cdot 10^{28} s^{4} + 3.8347452 \\cdot 10^{32} s^{3} + 1.324108096 \\cdot 10^{36} s^{2} + 1.3641377 \\cdot 10^{39} s + 9.5625 \\cdot 10^{40}}\\)\\(v_{3} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.822 \\cdot 10^{28} s^{2} + 1.98 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{4} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{5} = \\frac{1.56825 \\cdot 10^{37} s^{4} + 4.7313 \\cdot 10^{40} s^{3} + 4.50125 \\cdot 10^{43} s^{2} + 1.375 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{6} = \\frac{1.63098 \\cdot 10^{37} s^{4} + 4.920552 \\cdot 10^{40} s^{3} + 4.6813 \\cdot 10^{43} s^{2} + 1.43 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{7} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{8} = \\frac{1.2721644 \\cdot 10^{46} s^{5} + 7.45961435931766 \\cdot 10^{50} s^{4} + 2.18693901867302 \\cdot 10^{54} s^{3} + 2.07668666587681 \\cdot 10^{57} s^{2} + 6.37322274881527 \\cdot 10^{59} s}{1.2721644 \\cdot 10^{46} s^{5} + 2.09758384731754 \\cdot 10^{50} s^{4} + 1.10702928656076 \\cdot 10^{54} s^{3} + 2.03466134856873 \\cdot 10^{57} s^{2} + 1.21969565229069 \\cdot 10^{60} s + 8.09715639810431 \\cdot 10^{61}}\\)\\(v_{9} = 0.0\\)\\(v_{10} = 0.0\\)\\(v_{11} = 0.0\\)\\(v_{12} = 0.0\\)\\(v_{13} = \\frac{1.02 \\cdot 10^{28} s^{2} + 1.8 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{14} = 0.0\\)\\(v_{15} = 0.0\\)\\(v_{16} = 0.0\\)\\(v_{17} = 0.0\\)\\(v_{18} = 0.0\\)\\(v_{19} = 0.0\\)\\(v_{20} = 0.0\\)\\(I_{V1} = \\frac{- 1.0506 \\cdot 10^{29} s^{3} - 1.93544 \\cdot 10^{32} s^{2} - 1.53 \\cdot 10^{34} s}{1.53 \\cdot 10^{32} s^{3} + 1.4328 \\cdot 10^{36} s^{2} + 2.13344 \\cdot 10^{39} s + 1.53 \\cdot 10^{41}}\\)\\(I_{V2} = 0.0\\)\\(I_{V3} = 0.0\\)\\(I_{O1b} = \\frac{- 3.13650000000006 \\cdot 10^{40} s^{4} - 9.46260000000018 \\cdot 10^{43} s^{3} - 9.00250000000017 \\cdot 10^{46} s^{2} - 2.75000000000005 \\cdot 10^{49} s}{1.63098 \\cdot 10^{45} s^{4} + 1.6982148 \\cdot 10^{49} s^{3} + 3.87420704000001 \\cdot 10^{52} s^{2} + 2.54543933333334 \\cdot 10^{55} s + 1.70850000000001 \\cdot 10^{57}}\\)\\(I_{O2a} = \\frac{6.8 \\cdot 10^{23} s^{2} + 1.2 \\cdot 10^{27} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\nThe transfer function for the distortion path part A is calculated from the ratio of \\(v_{8}\\) and \\(v_{1}\\).\nThe voltage transfer function is \\(H(s)=\\frac {v_8} {v_{1}}\\):\n\nH = U[v8]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\cdot \\left(1.2721644 \\cdot 10^{46} s^{5} + 7.45961435931766 \\cdot 10^{50} s^{4} + 2.18693901867302 \\cdot 10^{54} s^{3} + 2.07668666587681 \\cdot 10^{57} s^{2} + 6.37322274881527 \\cdot 10^{59} s\\right)}{1.2721644 \\cdot 10^{46} s^{5} + 2.09758384731754 \\cdot 10^{50} s^{4} + 1.10702928656076 \\cdot 10^{54} s^{3} + 2.03466134856873 \\cdot 10^{57} s^{2} + 1.21969565229069 \\cdot 10^{60} s + 8.09715639810431 \\cdot 10^{61}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nPole zero plot The poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the location of poles and zeros of the transfer function plotted on the complex plane and the units are in radian frequency. The number of poles and zeros are equal. There is a zero at 0 Hz not canceled by a pole and the value of the last zero is greater than the value of the last pole. This suggests that the transfer function is a band pass filter.\nPrinting the values of the poles and zeros in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 5\nz0: -8,848.65 Hz\nz1: -234.05 Hz\nz2: -132.98 Hz\nz3: -116.71 Hz\nz4: 0.00 Hz\nnumber of poles: 5\np0: -1,198.55 Hz\np1: -967.04 Hz\np2: -279.87 Hz\np3: -166.72 Hz\np4: -12.02 Hz\n\n\n\n\n37.11.3.3 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 10 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.2, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*10*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero. There is relatively a large spike in the output at each square wave edge. Might indicate that fast transients on the input get propagated to the diodes. This could be explored in more detail during prototype testing.\n\n\n37.11.3.4 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((-1,1))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.\n\n\n\n37.11.4 Distortion path part B\n\n\n\n\n\n\nFigure 37.21: Klon Centaur schematic with the distortion path part B highlighted.\n\n\n\nDistortion path part B is highlighted in Figure 37.21. This path contains the limiting diodes, D2 and D3, which are commented out of the net list since there is no diode model supported by the MNA code. C9 and C10 block the DC bias voltage from the output of U1B and the DC coming ultimately from U1A down the R5, P1A, R17 and R16 path. R13 limits the current to D2 and D3 when the signal is greater than the forward conduction voltage of the diodes and operates in the exponential part of the conduction curve. The clipping diodes when driven into conduction mode, generate additional harmonics that combine with the guitar signal, which is already rich in harmonics.\nAs described above the limiting diodes don’t affect the frequency response in a significant way, but they do control the maximum amplitude of the signal. This can be accounted for by setting V3 to 0.35 volts and looking at the response at node 2 with V1 and V2 set to zero.\nThe capacitor, C9, blocks DC at the output of U1A since this Op Amp is biased to +Vb (4.5Vdc). This keeps the D3 from being constantly forward biased, as well as allowing D2 to conduct during negative signal swings.\nR13 serves to limit the current from U1B when either D2 or D3 is forward biased by the signal.\nD2 and D3 are the Germanium diodes responsible for making the distortion desired by the guitar player. When the signal is nearly at or above the diode’s threshold, the diodes start to conduct current and this effectively limits the amplitude of the signal to about \\(\\pm 0.4\\) volts. The shape of the voltage to current curve, see Figure 38.3, determines the amplitude of each harmonic component generated.\nC10 blocks the bias voltage that is on pin 2 of U2A. Pin 3 of U2A is connected to +Vb and because the Op Amp is operating with feed back provided by R20 || C13 the voltage difference between pins 2 and 3 on U2A is zero, therefore R16 is biased at +Vb. Without C10, D3 would be continually forward biased.\nThe reactive branch formed by C11 and R15 is connected to the distortion path part B and needs to be included in the circuit analysis. The components R16, R17, R18, C11 and C12 form a PI network in this branch that is connected to the inverting terminal of U2A. It’s not obvious how these components are shaping the signal. The nodal analysis presented for this path includes these reactive paths. See Section 39.3.7 for an analysis of these branches.\nThe components, C13||R20 and U2A, as described above, are part of an inverting low pass filter which sums the signals from the various paths.\n\n37.11.4.1 Frequency response vs P1\nThe magnitude and phase response of the distortion path part B are plotted below for various setting on P1, the gain control potentiometer. The gain settings is shown as a percent of full scale rotation of the knob. The voltage sources, V1 and V2 shown in Figure 37.14 are set to zero and V3 is set to one and the transfer function \\(H(s)=\\frac{v_2}{v_{20}}\\) is plotted for various gain settings of 1% to 99%.\nAs described above, the term V3 in the transfer function gets canceled since it appears in both the numerator and denominator. So for values of V3 less than about \\(\\pm 0.3\\) volts, the diodes are not conducting and they can be ignored.\nThe Python code below sets the values of V1 = V2 = 0 and V3 = 1 in the component dictionary.\n\nelement_values[V1] = 0\nelement_values[V2] = 0\nelement_values[V3] = 1\n\nThe following Python code calculates and plots the transfer function for each value of gain setting.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v20]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    # use the bode function to calculate the magnitude and phase response\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    diode_pathB_mag[i] = mag\n    diode_pathB_w[i] = w\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-40,20))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 37.22: Distortion path part B magnitude and phase response.\n\n\n\n\n\nDistortion path part B has a low pass filter characteristic. The some filter parameters at a gain setting of 50% are calculated below with the following code.\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = diode_pathB_mag[i].max()\nmax_gain_arg = diode_pathB_mag[i].argmax()\nmax_gain_freq = diode_pathB_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:.1f} Hz'.format(max_gain, max_gain_freq))\n\ngain_3dB_arg_offset = np.where(diode_pathB_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nfreq_3dB = diode_pathB_w[i][max_gain_arg+gain_3dB_arg_offset]/(2*np.pi)\nprint('-3dB frequency: {:.1f} Hz'.format(freq_3dB))\n\nprint('distortion path part B mag attenuation: {:.1f} dB per decade'.format(diode_pathB_mag[i][1500] - diode_pathB_mag[i][-1]))\n\ngain setting: 50%\nmax gain: 18.1 dB at 54.2 Hz\n-3dB frequency: 555.7 Hz\ndistortion path part B mag attenuation: 19.7 dB per decade\n\n\nThe distortion path part B has an attenuation slope of about -20 dB and a -3 dB frequency point of 555 Hz.\n\n\n37.11.4.2 Numerical solution for P1 at 50%\nThe transfer function for this path is solved for the case where P1 is set at a 50% rotational position.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the network equations with component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(0 = v_{1}\\)\\(0 = v_{19}\\)\\(1 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nUse the SymPy’s solve function to find the node voltages and unknown currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 0.0\\)\\(v_{2} = \\frac{- 4.8116638262633 \\cdot 10^{63} s^{5} - 1.86402165198492 \\cdot 10^{68} s^{4} - 1.44698956852654 \\cdot 10^{72} s^{3} - 2.89838697892964 \\cdot 10^{75} s^{2} - 1.68943764340843 \\cdot 10^{78} s}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(v_{6} = 0.0\\)\\(v_{7} = 0.0\\)\\(v_{8} = 0.0\\)\\(v_{9} = \\frac{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29627373138023 \\cdot 10^{59} s^{4} + 2.81149214573178 \\cdot 10^{63} s^{3} + 6.20412190793865 \\cdot 10^{66} s^{2} + 3.81322450115202 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{10} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19836922372969 \\cdot 10^{59} s^{4} + 2.74080119229803 \\cdot 10^{63} s^{3} + 6.06858479379818 \\cdot 10^{66} s^{2} + 3.73660601392261 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{11} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19578429076426 \\cdot 10^{59} s^{4} + 2.73101074153298 \\cdot 10^{63} s^{3} + 5.99789384036444 \\cdot 10^{66} s^{2} + 3.60106889978214 \\cdot 10^{69} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{12} = 0.0\\)\\(v_{13} = 0.0\\)\\(v_{14} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 1.6734375 \\cdot 10^{60} s^{3} + 2.34375 \\cdot 10^{63} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{15} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 9.14062499999999 \\cdot 10^{59} s^{3}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{16} = \\frac{1.00693125 \\cdot 10^{54} s^{5} + 3.35690238970588 \\cdot 10^{58} s^{4} + 1.275328125 \\cdot 10^{62} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{17} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 1.46177548394608 \\cdot 10^{59} s^{4} + 4.04388334558824 \\cdot 10^{62} s^{3} + 2.77738425925926 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{18} = \\frac{3.1078125 \\cdot 10^{57} s^{4} + 9.40160845588234 \\cdot 10^{61} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{19} = 0.0\\)\\(v_{20} = 1.0\\)\\(I_{V1} = 0.0\\)\\(I_{V2} = \\frac{2.0138625 \\cdot 10^{49} s^{5} + 1.71863602941176 \\cdot 10^{53} s^{4} + 4.87499999999999 \\cdot 10^{56} s^{3} + 4.59558823529411 \\cdot 10^{59} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(I_{V3} = \\frac{- 2.58493296542554 \\cdot 10^{53} s^{5} - 9.79045076505435 \\cdot 10^{57} s^{4} - 7.06909534337431 \\cdot 10^{61} s^{3} - 1.35537114140466 \\cdot 10^{65} s^{2} - 7.66184872294075 \\cdot 10^{67} s}{4.81802717154256 \\cdot 10^{57} s^{5} + 2.29885866434566 \\cdot 10^{62} s^{4} + 2.82128259649683 \\cdot 10^{66} s^{3} + 6.27481286137239 \\cdot 10^{69} s^{2} + 3.94876161529248 \\cdot 10^{72} s + 1.53236974458815 \\cdot 10^{74}}\\)\\(I_{O1b} = 0.0\\)\\(I_{O2a} = \\frac{1.96394441888298 \\cdot 10^{54} s^{5} + 7.60825164075479 \\cdot 10^{58} s^{4} + 5.90607987153688 \\cdot 10^{62} s^{3} + 1.18301509344067 \\cdot 10^{66} s^{2} + 6.89566385064667 \\cdot 10^{68} s}{4.3362244543883 \\cdot 10^{58} s^{5} + 2.06897279791109 \\cdot 10^{63} s^{4} + 2.53915433684715 \\cdot 10^{67} s^{3} + 5.64733157523515 \\cdot 10^{70} s^{2} + 3.55388545376323 \\cdot 10^{73} s + 1.37913277012933 \\cdot 10^{75}}\\)\n\n\nThe transfer function for the distortion path part B is calculated from the ratio of \\(v_{2}\\) and \\(v_{20}\\).\nThe voltage transfer function is \\(H(s)=\\frac {v_2} {v_{20}}\\):\n\nH = U[v2]/U[v20]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(- 4.8116638262633 \\cdot 10^{63} s^{5} - 1.86402165198492 \\cdot 10^{68} s^{4} - 1.44698956852654 \\cdot 10^{72} s^{3} - 2.89838697892964 \\cdot 10^{75} s^{2} - 1.68943764340843 \\cdot 10^{78} s\\right)}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\n\n\nThe coefficients for the numerator and denominator polynomials extracted using the following code.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\n\n\n37.11.4.3 Pole zero plot\nThe poles and zeros of the voltage transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above and the calculations below show that there are five zeros and six poles in the transfer function. Many of the poles and zeros are nearly at the same frequency, so they cancel. There is a zero at 0 Hz, because the path has no direct DC path from input to output. The poles near 500 Hz and 2,500 Hz along with the zero near 1,000 Hz determine the low pass shape of the path’s frequency response.\nPrinting the pole and zero values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 5\nz0: -4,631.99 Hz\nz1: -1,110.36 Hz\nz2: -243.00 Hz\nz3: -180.26 Hz\nz4: 0.00 Hz\nnumber of poles: 6\np0: -4,629.79 Hz\np1: -2,545.69 Hz\np2: -495.13 Hz\np3: -231.62 Hz\np4: -180.17 Hz\np5: -6.60 Hz\n\n\n\n\n37.11.4.4 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 5 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input nearly of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*5*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero since after each step transition in the input signal, the output signal decays to zero. The time constant of the decay looks to be about 0.1 seconds.\nThere is a relatively large spike in the output at each square wave edge because there is a large amount of AC gain in the circuit provided by U2A. This could be explored in more detail during prototype testing. Signals in the pedal are getting filtered, so in part B of the path, edges from fast transients may have been removed.\n\n\n37.11.4.5 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,1))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 37.8.6.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#overlay-amplitude-response-for-the-paths",
    "href": "Klon Centaur part 1.html#overlay-amplitude-response-for-the-paths",
    "title": "37  Klon Centaur, part 1",
    "section": "37.12 Overlay amplitude response for the paths",
    "text": "37.12 Overlay amplitude response for the paths\nFrequency response plots for the paths are overlaid to examine their relative gains through the summing amplifier. The solid lines are for the clean paths 1, 2 and the cascade of distortion path parts A and B. Distortion path parta A and part B are plotted as a dash/dot line since the signal in this path is modified by the diodes before traveling to part B of the path.\nThe frequency response data is plotted from 10 to 100 kHz and the amplitude starting at a level of -40 dB. The frequency band of 80 to 8kHz is the typical audio band of an electric guitar and is plotted to highlight the band of interest. It is possible that sub harmonics of the guitar signal might be present below 80 Hz, and it is also possible that harmonics of the signal could extend to frequencies above 8kHz. The highlighted frequency band is not an absolute limit, but drawn only as a reference to indicate the general area to focus on for the analysis.\nThe black line in the plots below is the sum of the dashed green and red lines. Since distortion paths part A and part B are in series, the total amplitude response is obtained from the product of the two parts. These are plotted as logarithmic values, so the product is the sum of the logarithmic values. The distortion path and clean paths 1 and 2 are summed at Op Amp U2A.\nWhen looking at the amplitude plots overlaid, you will need to imagine that signals on paths with greater gain will dominate over signals on paths that have less gain. If the gain levels on a path are greater than the other paths by about 2 dB, then signals on the lower gain paths will be less discernible in the output. In other words, when the guitar signal on each of the paths are summed together, the lower amplitude signals will be masked. Auditory masking is dependent on relative amplitudes and frequency content. As discussed below, the signal on clean path 1 appears to be masked, but this would need to be verified by listening tests.\nThe required input level needed to drive the diodes in the distortion path into non-linear range varies with the gain setting. At lower gain settings, say from 0 to 10%, input levels above 0.05 volts peak are needed to drive the diodes in the distortion path into non-linear range and achieve a blend of clean and distortion. At a gain setting of 50%, an input level of 0.015 volts peak is needed to drive the diodes into non-linear range, while clean path 1 is more than 10 dB down from the distortion path and clean path 2 is attenuating the signal. Both clean paths are probably not discernible in the output.\nWhat is heard at the output will depend on the signal level at the input. At a gain setting of 1%, that is with the gain control mostly counter clockwise, with input levels of less than 0.25 volts peak, the diodes will not be conducting to a degree where clipping of the signal will take place. This is explained below.\n\n\n37.12.1 Gain setting of 1%\nThe frequency response plots are plotted for a gain setting of 1%, which is 1% rotational travel on the knob in the clockwise direction. As shown below, clean path 2 has the most gain across the guitar audio band.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 0 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path part A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path part B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,20))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nClean path 2 is the path with the most gain across the guitar audio spectrum. Overall effect is about 10 dB of clean gain from 80 to 1kHz and above 1kHz, the gain rolls off. Clean path 1 is not contributing much to the output. The gain for distortion path part A is negative for the band 80 to 1kHz and about 0 dB for higher frequencies. Signals on clean path 1 are probably not perceptible in the output since the gain in this path is more than 3 dB lower than clean path 2.\n\nThe 1N34A diodes in the distortion path will start to conduct sufficient current to produce harmonics at a voltage near the knee of the diode’s voltage current curve, see Figure 38.3. For the purposes of the calculations below, this point on the curve or knee is 0.25 volts. Typically, the forward voltage at a current of 5 mA is used to define the forward conduction voltage, but here we are interested in using the voltage where the diode starts to conduct current and generate harmonics.\n\nDiode_knee_1N34A = 0.25\n\nThe calculation below finds the maximum gain points on the curves above. BY using the maximum points we can get an idea of the relative signal levels in the output from each path.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 5.8 dB at 1.00%\nclean path 2 maximum gain 12.0 dB at 1.00%\ncascade of A and B maximum gain 7.5 dB at 1.00%\npath A maximum gain 0.2 dB at 1%\npeak signal for diode conduction threshold: 0.241 Vp\n\n\nWith a gain setting of 1%, an input signal of greater than about 0.25 volts peak is needed to drive the diodes into conduction and to start producing harmonics. The gain of clean path 2 is substantially higher than that of clean path 1 and the signal on clean path 1 probably will not be discernible in the output. This assumption could be easily verified by conducting blind listening tests. A drive signal to the pedal of greater than 0.25 volts peak is needed to produce harmonics in output. Since the gain of the distortion path with P1 set to 1% is 4 dB lower than clean path 2, any harmonics would be difficult to discern.\n\n\n37.12.2 gain setting 2.5%\nThe frequency response plots are plotted for a gain setting of 2.5%, which is 2.5% rotational travel on the knob in the clockwise direction. At this gain setting, it appears that the clean path 2 and the distortion path are able to provide contributions to the output since the gains at some frequencies are comparable.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 1 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.1f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.1f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.1f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.1f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.1f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,20))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plots above, the gain for clean path 1 is substantially less than clean path 2. The calculations below show that the difference in gain is about 4 dB. At any drive level, the amplitude of the signal on clean path 2 will be more than twice that of clean path 1. The signal on clean path 1 probably will not be discernable in the output.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.2f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 6.0 dB at 2.50%\nclean path 2 maximum gain 10.8 dB at 2.50%\ncascade of A and B maximum gain 13.5 dB at 2.50%\npath A maximum gain 3.8 dB at 2.50%\npeak signal for diode conduction threshold: 0.105 Vp\n\n\nAn input signal of greater than about 0.1 volts peak is needed to drive the diodes into conduction and produce harmonics. Distortion path part A is starting to provide some boost to the signals as shown by the red dot/dash curve. Signals following the diodes are then filtered by the profile shown by the green dot/dash curve, which is the distortion path part B. Near 1 kHz, you can see that the cascade of the distortion path parts A and B are providing a bit of a boost over that of clean path 2. Diode path B has the most gain up to about 1kHz then clean path 2 has more. Diode path A is boosting the signal in the band 600 Hz and higher into the diodes so this signal should dominate from 300 Hz to about 3 kHz.\nSignals on clean path 1 will be overshadowed compared to the signals on other paths over most of the guitar audio band. The signal through Clean path 1 is probably below the perception threshold.\nThe gain profiles through paths 2 and the distortion path at a gain setting of 2.5% illustrate the need for a preamp pedal prior to the Klon to control the signal level to the Klon. Normal guitar playing might be too soft to achieve the desired mix of clean and distortion through the Klon.\n\n\n37.12.3 gain setting 9.75%\nThe frequency response plots are plotted for a gain setting of 9.75%, which is almost 10% rotational travel on the knob in the clockwise direction. At this gain setting, it appears that the clean paths and distortion path are able to provide contributions to the output since the gains at around 80 Hz are about the same.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 2 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.2f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.2f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.2f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.2f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.2f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,20))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAt the low end of the guitar audio range, about 80 Hz, the gains on the clean paths and the distortion path are the same. Over the remainder of the guitar audio band, the distortion path dominates. The plot above suggests that at a gain setting of 9% or more, signals through the distorting path will dominate in the output. If the guitar signal has sufficient amplitude to drive the diodes into clipping, then you will hear distortion in the output. If the guitar signal is very low, you will hear the guitar signal filtered by essentially a band pass filter with a center frequency of 1 kHz. The plot above suggests that at a gain setting of 9% or more, signals through the distorting path will dominate in the output.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.2f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 6.5 dB at 9.75%\nclean path 2 maximum gain 7.2 dB at 9.75%\ncascade of A and B maximum gain 19.2 dB at 9.75%\npath A maximum gain 7.2 dB at 9.75%\npeak signal for diode conduction threshold: 0.048 Vp\n\n\nAn input signal of greater than about 0.05 volts peak is needed to drive the diodes into conduction.\n\n\n\n37.12.4 gain setting 25%\nThe frequency response plots are plotted for a gain setting of 25%, which is 25% rotational travel on the knob in the clockwise direction. At this gain setting, it appears that the distortion path will dominate the output.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 3 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,30))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 25%.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 6.9 dB at 25.00%\nclean path 2 maximum gain 3.1 dB at 25.00%\ncascade of A and B maximum gain 22.1 dB at 25.00%\npath A maximum gain 9.1 dB at 25%\npeak signal for diode conduction threshold: 0.031 Vp\n\n\nAn input signal of greater than about 0.03 volts peak is needed to drive the diodes into conduction.\n\n\n37.12.5 gain setting 50%\nThe frequency response plots are plotted for a gain setting of 50%. At this gain setting, it appears that the distortion path will dominate the output.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 4 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2,P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,30))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 50%.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 7.1 dB at 50.00%\nclean path 2 maximum gain -1.5 dB at 50.00%\ncascade of A and B maximum gain 25.5 dB at 50.00%\npath A maximum gain 12.2 dB at 50%\npeak signal for diode conduction threshold: 0.015 Vp\n\n\nAn input signal of greater than about 0.015 volts peak is needed to drive the diodes into conduction.\nBased on my research of how guitar players set up their Klons, a 40% to 60% gain position seems to be common to achieve the tone they desire. At this point clean path 2 is more than 3 dB less than Diode path B and probably not very audible. In the lower half of the guitar band, clean path 1 is about 2 to 3 dB less than diode path B and becoming less audible.\n\n\n37.12.6 gain setting 75%\nThe frequency response plots are plotted for a gain setting of 75%.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 5 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,40))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 75%.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.2f} mVp'.format(1000*Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 7.2 dB at 75.00%\nclean path 2 maximum gain -6.3 dB at 75.00%\ncascade of A and B maximum gain 30.6 dB at 75.00%\npath A maximum gain 17.4 dB at 75%\npeak signal for diode conduction threshold: 4.52 mVp\n\n\nAn input signal of greater than about 0.005 volts peak is needed to drive the diodes into conduction.\n\n\n37.12.7 gain setting 99%\nSetting the gain control to 99% of full scale and plotting the frequency response of the paths to compare the relative gains.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 6 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,50))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe signal on the distortion path will be the most prominent signal in the output when the gain is at 99%. As calculated below, the distortion path has sufficient gain that a peak signal of about 85 \\(\\mu V\\) will drive the diodes into conduction and generate harmonics. Signals on clean paths 1 and 2 probably are not discernible in the output.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.2f} uVp'.format(1e6*Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 7.2 dB at 99.00%\nclean path 2 maximum gain -27.4 dB at 99.00%\ncascade of A and B maximum gain 45.6 dB at 99.00%\npath A maximum gain 34.7 dB at 99%\npeak signal for diode conduction threshold: 84.67 uVp\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 99%.\nAt this point in the analysis, I wonder why clean path 1 is part of the design. At low gain, clean path 2 has a gain greater than clean path 1. At a gain setting of about 10%, clean path 1 and 2 have gains along parts of the frequency response curve that are about the same, however both clean paths are overshadowed by the distortion path. It seems like clean path 1 never contributes to the output in a meaningful way. Perhaps clean path 1 was in the initial attempt to blend clean and distortion together, then clean path 2 added later.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#summary-for-part-1",
    "href": "Klon Centaur part 1.html#summary-for-part-1",
    "title": "37  Klon Centaur, part 1",
    "section": "37.13 Summary for part 1",
    "text": "37.13 Summary for part 1\nPart 1 of the analysis used SMNA and the principle of superposition to perform a linear analysis of the Klon. In part 2, a comparison of results from LTSpice with diodes included are made with the linear analysis and the results are nearly identical. Here are a few comments:\n\nClean path 1 is not contributing to the output at a discernible level.\nThe mix and placement of the reactive branches in clean path 2 is a bit unusual when viewed as a filter.\nThe use of the dual gang pot, P1, could have been replaced by a signal pot by changing the topology of the circuits and paths. This is something that would have been discussed during a preliminary design review.\nThe use of a preamp before the Klon is recommended to better control the gain through the guitar signal chain. A variable gain preamp can set the drive level to the Klon and then the Klon’s gain pot can be used to set the desired level of distortion.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Klon Centaur, part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html",
    "href": "Klon Centaur part 2v0.html",
    "title": "38  Klon Centaur, part 2",
    "section": "",
    "text": "38.1 Non-linear analysis with LTSpice\nThe schematic shown below was drawn in LTSpice. The voltage converter, U3, in Figure 37.2, has been replaced by the voltage sources, \\(V2\\), \\(V3\\), \\(V4\\) and \\(V5\\). Voltage source, \\(V1\\), is the guitar input signal. The effects bypass switch modeled by setting \\(R_{26}\\) to 68k \\(\\Omega\\) and \\(R_{27}\\) to 0.01 \\(\\Omega\\), which models switch S1A shorting \\(R_{27}\\) to the wiper terminal of P3. All of the resistors and capacitors are assumed to be ideal. The schematic includes power supply connections for the Op Amps. In the analysis that follows, I’ll be looking at conditions where the Op Amps might be driven into saturation.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#sec-nonlinear_analysis",
    "href": "Klon Centaur part 2v0.html#sec-nonlinear_analysis",
    "title": "38  Klon Centaur, part 2",
    "section": "",
    "text": "Figure 38.1: Schematic of the Klon Centaur used for the LTSpice nonlinear analysis.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#semiconductor-components",
    "href": "Klon Centaur part 2v0.html#semiconductor-components",
    "title": "38  Klon Centaur, part 2",
    "section": "38.2 Semiconductor components",
    "text": "38.2 Semiconductor components\nWithin the Klon Centaur’s circuits there are several semiconductor devices used. These are the diodes, Op Amps and voltage converter. This section will describe these components and their use in the circuit.\n\n38.2.1 Dual High Slew Rate JFET Input Op Amp - TL072\nThe operational amplifier (Op Amp) used in the pedal is the TL072, available from Texas Instruments. The TL072 is a dual, high slew rate, JFET-input Op Amp and is part of a family of industry-standard devices (TL071, TL072, and TL074). There are next-generation versions available (TL071H, TL072H, and TL074H). The TL072 product continues to be available for existing customers, but new designs should consider an alternate product.\nThe TL072 provides outstanding value for cost-sensitive applications, and features include: low offset (1 mV, typical), high slew rate (20 V/µs), and common-mode input to the positive supply. High ESD (1.5 kV, HBM), integrated EMI and RF filters, and operation across the full –40°C to 125°C enable the TL07xH devices to be used in the most rugged and demanding applications.\nThe TL072 is available from Digikey from two manufacturers, Texas Instruments and STMicroelectronics.\nThe in LTSpice circuit simulations that follow, the following PSpice Model model from Texas Instruments was used:\n* TL072 OPERATIONAL AMPLIFIER \"MACROMODEL\" SUBCIRCUIT\n* CREATED USING PARTS RELEASE 4.01 ON 06/16/89 AT 13:08\n* (REV N/A)      SUPPLY VOLTAGE: +/-15V\n* CONNECTIONS:   NON-INVERTING INPUT\n*                | INVERTING INPUT\n*                | | POSITIVE POWER SUPPLY\n*                | | | NEGATIVE POWER SUPPLY\n*                | | | | OUTPUT\n*                | | | | |\n.SUBCKT TL072    1 2 3 4 5\n*\n  C1   11 12 3.498E-12\n  C2    6  7 15.00E-12\n  DC    5 53 DX\n  DE   54  5 DX\n  DLP  90 91 DX\n  DLN  92 90 DX\n  DP    4  3 DX\n  EGND 99  0 POLY(2) (3,0) (4,0) 0 .5 .5\n  FB    7 99 POLY(5) VB VC VE VLP VLN 0 4.715E6 -5E6 5E6 5E6 -5E6\n  GA    6  0 11 12 282.8E-6\n  GCM   0  6 10 99 8.942E-9\n  ISS   3 10 DC 195.0E-6\n  HLIM 90  0 VLIM 1K\n  J1   11  2 10 JX\n  J2   12  1 10 JX\n  R2    6  9 100.0E3\n  RD1   4 11 3.536E3\n  RD2   4 12 3.536E3\n  RO1   8  5 150\n  RO2   7 99 150\n  RP    3  4 2.143E3\n  RSS  10 99 1.026E6\n  VB    9  0 DC 0\n  VC    3 53 DC 2.200\n  VE   54  4 DC 2.200\n  VLIM  7  8 DC 0\n  VLP  91  0 DC 25\n  VLN   0 92 DC 25\n.MODEL DX D(IS=800.0E-18)\n.MODEL JX PJF(IS=15.00E-12 BETA=270.1E-6 VTO=-1)\n.ENDS\nThe following informative references are recommended:\n\nOp amps in small-signal audio design – Part 1: Op amp history, properties\nOp amps in small-signal audio design – Part 2: Distortion in bipolar and JFET input op-amps\nOp amps in small-signal audio design – Part 3: Selecting the right op amp\n\n\n\n38.2.2 General Purpose Germanium Diode - 1N34A\nThe clipping diodes, \\(D_2\\) and \\(D_3\\), are type 1N34A, a general purpose point contact Germanium diode. As recounted in interviews with Bill Finnegan, many versions of the 1N34A from various vendors were evaluated and 1N34A diodes from one particular source were selected based on listening tests. Bill has not disclosed the exact source of the 1N34A diodes he used, so this aspect of the Klon Centaur has remained a trade secret. It has been reported that Bill’s initial stock of Germanium diodes have been depleted and new production uses diodes from a new source.\nWhile the electrical characteristics of Germanium semiconductor devices is well understood, the sonic properties of audio circuits using Germanium semiconductor devices have been described as being warm and more musical. Accordingly, some mystic and urban lour have come to be associated with the use of Germanium diodes and transistors. Most online commentators seem to focus on the forward voltage drop of Germanium diodes along with some sonic qualities. Here are two excerpts:\nForward voltage of various diodes:\n\nMe and Dylan and David from the DIY guitar pedal/effects community decided to see for ourselves what the fuzz is about regarding diodes and their “softness”. Why do people like Germaniums over Silicons? What is the effect of multiple diodes in series? How exactly does the PN junction of a MOSFET look like? All these questions and more will be answered.\n\nEmulating germanium diodes\n\nWhen you get into vintage effect pedals etc. you might get to know the amazing germanium diode. These diodes are truly worse in every way compared to silicon diodes, and thus aren’t being produced anymore. This makes them a treasure for those who are chasing the vintage tone. Luckily here and there germanium diode surpluses are still being sold with nice profit margins.\n\n\nBut what is so special about germanium? Well, people claim that they clip “softer” than silicon diodes. This makes your tone sound “smoother” and whatever. In my post about testing diodes it is clear that the knee (slope) of germanium diodes is indeed smoother than those of silicon diodes so that’s one way to prove that it has “some” impact on your tone. But can’t we emulate this soft knee in some way?\n\n\nThe blogpost also showed how you can simply put diodes in series to double the forward voltage, but also make the knee softer. Putting 4 or more silicons in series gets you close to the softness of a germanium, but with a forward voltage of 2.8V.\n\nMy analysis of the circuits used in the Klon Centaur cannot evaluate the sonic aspects of Germanium diodes, something that could be properly investigated by building prototype circuits and doing blind listen tests, but instead will focus on the general electrical characteristics of the 1N34A. The 1N34A diode model used in the LTSpice simulations is:\n.model 1N34A D(bv=75 cjo=0.5e-12 eg=0.67 ibv=18e-3 is=2e-7 rs=7 n=1.3 vj=0.1 m=0.27)\nThe circuit shown below is used to evaluate the 1N34A model.\n\n\n\n\n\n\nFigure 38.2: Schematic of LTSpice diode test jig.\n\n\n\nThe following code loads the voltage versus current data for the 1N34A Germanium diode and the 1N914 Silicon diode models.\n\nfn = 'Diode-vi-curve.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\nCopy the data from the csv file into NumPy arrays.\n\n# initialize some empty arrays\nD_1N34A_voltage = np.zeros(len(LTSpice_data))\nD_1N34A_diode_current = np.zeros(len(LTSpice_data))\nD_1N914_voltage = np.zeros(len(LTSpice_data))\nD_1N914_diode_current = np.zeros(len(LTSpice_data))\n\n# load csv data into the array\nfor i in range(len(LTSpice_data)):\n    D_1N34A_voltage[i] = LTSpice_data[i][0]\n    D_1N34A_diode_current[i] = LTSpice_data[i][1]*1000\n    D_1N914_voltage[i] = LTSpice_data[i][2]\n    D_1N914_diode_current[i] = LTSpice_data[i][3]*1000\n\nPlot the LTSpice simulated forward voltage versus current relationship for 1N34A and 1N914 diode models.\n\nfig1, ax1 = plt.subplots()\nax1.plot([10, 100, 1000], [1,2,3])\n\nax1.text(D_1N34A_voltage[1375], D_1N34A_diode_current[1375], '{:.2f} volts, {:.2f} mA   '.format(D_1N34A_voltage[1375], D_1N34A_diode_current[1375]), fontsize=8, horizontalalignment='right', verticalalignment='center')\n\nax1.plot(D_1N34A_voltage, D_1N34A_diode_current,'-b',label='1N34A')\nax1.plot(D_1N34A_voltage[1375], D_1N34A_diode_current[1375],'xb')\n\nax1.plot(D_1N914_voltage, D_1N914_diode_current,'-r',label='1N914')\n\nax1.set_xlim(0.1,1)\nax1.set_ylim(0,10)\n\nax1.set_xlabel('volts')\nax1.set_ylabel('current. mA')\n\nax1.set_xscale('log')\nax1.set_xticks([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 1.0])\nax1.get_xaxis().set_major_formatter(matplotlib.ticker.ScalarFormatter())\n\nax1.get_xaxis().set_tick_params(which='minor', size=0)\nax1.get_xaxis().set_tick_params(which='minor', width=0)\n\nax1.grid()\nax1.legend()\nplt.title('Forward voltage versus current for 1N34A and 1N914 diode models')\nplt.show()\n\n\n\n\n\n\n\nFigure 38.3: Voltage vs current plot for 1N34A and 1N914 diodes.\n\n\n\n\n\nAs shown in the plot above, the VI curves for the 1N34A and 1N914 diode models are different. The 1N34A has a forward voltage of 0.38 volts at 5mA, whereas the 1N914 had a forward voltage of about 0.62 volts at 5mA. The shape of the two curves is also different with the 1N34A curve being a bit more rounded. The harmonics generated in audio circuits using the 1N34A will have a different set of amplitude coefficients and a different sound.\n\n\n38.2.3 CMOS Switched Capacitor Voltage Converter - ICL7660\nThe electrical power to operate the Klon Centaur comes from the DC jack or the internal 9 volt battery. Nominally both the DC jack or the battery are 9 volt sources, however as the battery drains, the voltage will be less than 9 volts and the power source connected to the DC jack might be slightly different than 9 volts. The 9 volt power source is filtered by \\(C_{17}\\) and \\(D_4\\) provides reverse voltage protection. Internal to the Klon Centaur there are four power supply rails derived from the 9 volt battery or the DC jack. The 9 volts is divided by two using resistors R29 and R30 to produce +4.5V and C18 stabilizes this voltage.\n\\(U_3\\) is a CMOS switched capacitor voltage converter, part number ICL7660, which converts positive 9 volts into -9 and +18 volts. The ICL7660, with a few external components, can double, divide, or multiply a positive input voltage. The ICL7660 will operate from 1.5V to 10V input voltage and can deliver upto 10mA with a 0.5V output drop. The ICL7660 is currently produced by Renesas Electronics Corporation and Analog Devices Inc./Maxim Integrated, and distributed by Digikey under the part numbers, ICL7660CPAZ and ICL7660CPA+.\nThe Op Amps \\(U_1\\) and \\(U_2\\) are connected to different supply rails. \\(U_{1A}\\) and \\(U_{1B}\\) power supply voltages are 9 volts and ground. The signal ground is a virtual ground with a voltage of 4.5 volts. This allows audio signals processed by \\(U_1\\) to swing between about 2 volts and 7 volts peak to peak without clipping. The power supply levels for \\(U_{2A}\\) and \\(U_{2B}\\) are 18 volts and -9 volts. This allows signals processed by \\(U_2\\) to swing between about -7 to +16 volts peak to peak without clipping.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#input-voltage-and-gain-sweep",
    "href": "Klon Centaur part 2v0.html#input-voltage-and-gain-sweep",
    "title": "38  Klon Centaur, part 2",
    "section": "38.3 Input Voltage and Gain Sweep",
    "text": "38.3 Input Voltage and Gain Sweep\nLTSpice was set up to run a series of simulations which stepped though a list of \\(V1\\) amplitudes and values for \\(R_{gain}\\). The frequency of \\(V1\\) was set to 1 kHz since this is the frequency where some resonant paths peak. The voltage range used for \\(V1\\) is 0.1 volts to 1.5 volts. The following SPICE commands were used:\n.tran 0 5m 0\n.param Rtone=5k\n.param Routput=99.999k\n.step param Rgain list 1 250 500 750 1k 2.5k 5k 7.5k 10k 15k 20k 25k 30k 35k 40k 45k 50k 55k 60k 65k 70k 75k 80k 85k 90k 92.5k 95k 97.5k 99.9k\n.step param V1_amp list 0.1 0.25 0.5 0.75 1.0 1.25 1.5\nThe following Python reads in the data file generated by LTSpice.\n\nLTSpice_data_fn = 'Sweep_Vin_&_Rgain.csv'\nLTSpice_sweep_df = pd.read_csv(LTSpice_data_fn)\n\nThere are about 354,000 records in the Pandas dataframe. Voltage data was collected from the nodes listed in Table 38.1 and a short description of the node’s location in the circuit is provided.\n\n\n\nTable 38.1: Nodes and connections\n\n\n\n\n\nNode\nDescription\n\n\n\n\n7\nU1A output\n\n\n14\nU1B output\n\n\n17\nright side of C10\n\n\n19\nU2A output\n\n\n21\nU2B output\n\n\n\n\n\n\nA sample of the first 5 records in the dataframe are displayed below. Each simulation run for the various \\(V1\\) gains and \\(R_{gain}\\) setting is delimited by Step Information: ….\n\nLTSpice_sweep_df.head(5)\n\n\n\n\n\n\n\n\n\ntime\nV(7)\nV(14)\nV(17)\nV(19)\nV(21)\n\n\n\n\n0\nStep Information: V1_amp=100m Rgain=1 (Step: ...\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n0\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n2\n1.25000001460762E-08\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n3\n2.50000002921524E-08\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n4\n5.00000005843049E-08\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n\n\n\n\n\n\nIn the csv file, there are lines of text for each new step in the simulation. For example:\nStep Information: V1_amp=100m Rgain=1K (Step: 29/203)\nThese lines of text are used to locate the index of the start of the data from each simulation sweep by looking at each record for the word ‘Step’ and a list of index values is created.\n\nlst = LTSpice_sweep_df['time'].tolist()\n\nstep_index = []\nrow_cnt = 0\nfor i in lst:\n    if 'Step' in i:\n        step_index.append(row_cnt)\n    row_cnt += 1\n\nA new dataframe called sweep_df is created. The following code finds the peak to peak voltage at each node for each sweep and loads the values into the dataframe.\n\nsweep_df = pd.DataFrame(columns=['V1amp','Rgain','V7pp','V14pp','V17pp','V19pp','V21pp'])\n\nfor i in range(0,len(step_index)):\n    #\n    row_elements = LTSpice_sweep_df['time'][step_index[i]].split()\n\n    #\n    Rgain_str = row_elements[3][6:]\n    Rgain_value = float(Rgain_str.replace('K', 'e3'))\n    Rgain_percent = Rgain_value/100e3*100\n    V1_amp_str = row_elements[2][7:]\n    V1_amp_value = float(V1_amp_str.replace('m', 'e-3'))\n\n    #\n    if i == 0:\n        v7_pp_value = LTSpice_sweep_df['V(7)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(7)'][0:step_index[i+1]].min()\n        v14_pp_value = LTSpice_sweep_df['V(14)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(14)'][0:step_index[i+1]].min()\n        v17_pp_value = LTSpice_sweep_df['V(17)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(17)'][0:step_index[i+1]].min()\n        v19_pp_value = LTSpice_sweep_df['V(19)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(19)'][0:step_index[i+1]].min()\n        v21_pp_value = LTSpice_sweep_df['V(21)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(21)'][0:step_index[i+1]].min()\n    elif i &lt; len(step_index)-1:\n        v7_pp_value = LTSpice_sweep_df['V(7)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(7)'][step_index[i]:step_index[i+1]].min()\n        v14_pp_value = LTSpice_sweep_df['V(14)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(14)'][step_index[i]:step_index[i+1]].min()\n        v17_pp_value = LTSpice_sweep_df['V(17)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(17)'][step_index[i]:step_index[i+1]].min()\n        v19_pp_value = LTSpice_sweep_df['V(19)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(19)'][step_index[i]:step_index[i+1]].min()        \n        v21_pp_value = LTSpice_sweep_df['V(21)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(21)'][step_index[i]:step_index[i+1]].min()        \n    else:\n        v7_pp_value = LTSpice_sweep_df['V(7)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(7)'][step_index[i]:-1].min()        \n        v14_pp_value = LTSpice_sweep_df['V(14)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(14)'][step_index[i]:-1].min()  \n        v17_pp_value = LTSpice_sweep_df['V(17)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(17)'][step_index[i]:-1].min()  \n        v19_pp_value = LTSpice_sweep_df['V(19)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(19)'][step_index[i]:-1].min()   \n        v21_pp_value = LTSpice_sweep_df['V(21)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(21)'][step_index[i]:-1].min()          \n\n    # load values into new dataframe\n    sweep_df.loc[i] = [V1_amp_value, Rgain_percent, v7_pp_value,v14_pp_value,v17_pp_value,v19_pp_value,v21_pp_value]\n\nThe first five lines of the dataframe are displayed below.\n\nsweep_df.head(5)\n\n\n\n\n\n\n\n\n\nV1amp\nRgain\nV7pp\nV14pp\nV17pp\nV19pp\nV21pp\n\n\n\n\n0\n0.10\n0.001\n0.197555\n0.000146\n0.000140\n0.138082\n0.161292\n\n\n1\n0.25\n0.001\n0.493868\n0.000367\n0.000352\n0.345193\n0.403173\n\n\n2\n0.50\n0.001\n0.987762\n0.000732\n0.000703\n0.690350\n0.806184\n\n\n3\n0.75\n0.001\n1.481557\n0.001101\n0.001054\n1.035477\n1.209899\n\n\n4\n1.00\n0.001\n1.975554\n0.001466\n0.001405\n1.380598\n1.612327\n\n\n\n\n\n\n\n\nA list of the amplitudes of \\(V1\\) used for each sweep is created from the dataframe as well as a list of the \\(R_{gain}\\) sweep values.\n\nV1_amp_list = sweep_df['V1amp'].unique()\nRgain_list = sweep_df['Rgain'].unique()\n\n\n38.3.1 Op Amp saturation at Node 14 - \\(U_{1B}\\) output\nNode V14 is the output of \\(U_{1B}\\). This is the distortion path part A. As can be seen, an input of 1.5 volts is needed to saturate the Op Amp at the lowest gain setting. At a gain setting of 50%, an input of 0.75 volts peak will drive the Op Amp into saturation. Supply rail voltages for \\(U_1\\) are 9 volts and ground, with a virtual ground reference of 4.5 volts. This means that at some gain settings, it is likely that guitar signals with even small peak to peak amplitudes will drive \\(U_{1B}\\) into saturation.\nThe peak to peak values for \\(v_{14}\\) are plotted versus \\(R_{gain}\\) and \\(V1\\).\n\nfor i in V1_amp_list:\n    plt.plot(sweep_df[sweep_df['V1amp'] == i]['Rgain'].to_numpy(),sweep_df[sweep_df['V1amp'] == i]['V14pp'].to_numpy(),'-',label = 'V1={:.2f}'.format(i))\n\n# position legend outside the graph\nplt.legend(bbox_to_anchor=(1.3,1)) # V1 legend position: relative (horizontal position, vertical position) \n\nplt.ylabel('U1 output, Vpp')\nplt.xlabel('Rgain value, k\\u03A9')\n\nax1.set_ylim((-0.5,6))\nplt.grid()\nplt.title('Node 14 Vpp levels versus $R_{gain}$ and $V1$')\n\nplt.show()\n\n\n\n\n\n\n\nFigure 38.4: Node 14 peak to peak voltage versus \\(R_{gain}\\) and \\(V1\\) input.\n\n\n\n\n\nAs shown above, \\(U_{1B}\\), maximum output swing is about 6Vpp. This is because the power rails for \\(U_1\\) are 0 and 9V and \\(U_1\\) is not rail-to-rail capable. The SPICE model used for the TLO72 Op Amp reproduces the maximum output signal swing. If the gain pot, \\(P_1\\) is set midpoint, signal inputs greater than 0.75V will drive U1B’s output into saturation as shown on the red curve above. This likely means that for mid range gain settings and loud guitar inputs, the guitar signal is first clipped by \\(U_{1B}\\) and then again by the diodes. Any large harmonics generated by \\(U_{1B}\\) will be mostly altered by \\(D_2\\) and \\(D_3\\).\n\n\n38.3.2 Guitar Output Signal Levels\nSince I don’t own a guitar and I’m not a guitar player, I searched online to find typical guitar signal levels. Various references such as Electric Guitar Output and Electric Guitar Output Voltage Levels placed the guitar output level in the range of 15\\(\\mu\\)V to 740mV depending on playing style, string gauge and pickup type.\nThe reference, Guitar & Bass Pickup Output Voltages, provided the following table with comments:\n\n\n\nTable 38.2: Pickup Output Voltage - Averaged RMS (Peak)\n\n\n\n\n\nModified Maton\nNeck (2.0kΩ)\nMiddle (N/A)\nBridge (2.0kΩ)\n\n\n\n\nE1\n40 mV (150mV)\n\n32 mV (200mV)\n\n\nE2\n12 mV (120mV)\n\n20 mV (300mV)\n\n\nChord\n36 mV (200mV)\n\n\n\n\nAverage\n29 mV (156 mV)\n\n29 mV (267 mV)\n\n\n\n\n\n\n\n\n\nTable 38.3: More Pickup Output Voltages\n\n\n\n\n\n\n\n\n\n\n\nSamick ‘TV Twenty’\nNeck (11.5kΩ)\nMiddle (11.3kΩ)\nBridge (15.3kΩ)\n\n\n\n\nE1\n44 mV (250mV)\n76 mV (300 mV)\n120 mV (800 mV)\n\n\nE2\n12 mV (50 mV)\n12 mV (159 mV)\n16 mV (200 mV)\n\n\nChord\n76 mV (450 mV)\n72 mV (400 mV)\n128 mV (850 mV)\n\n\nAverage\n44 mV (250 mV)\n53 mV (283 mV)\n88 mV (617 mV)\n\n\n\n\n\n\n\nTabulated results aren’t especially useful, for the simple reason that there will be huge variations due to playing style, and what’s being played. However, I did summarize the results. All numbers are millivolts (RMS) taken from the scope captures shown below. I didn’t include the bass, only the two guitars. Note that I use light gauge strings, and you will get more level with thicker ones. I don’t have a set for comparison, but I’d expect that you could get at least 6dB (×2) more when played hard. The pickup resistance is also shown in the table, not because it’s especially useful on its own, but you can make comparisons. It includes the parallel resistance of the volume control, as I didn’t feel like dismantling my guitars for a more accurate measurement.\n\nSo it would seem possible that when playing chords, some relatively high signal levels are produced by the guitar and that saturation of \\(U_{1B}\\)’s output is likely. It seems likely to me that over driving \\(U_{1B}\\) was a design oversight since the tone of the pedal is claimed to emanate from the hand selected Germanium diodes.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#sinusoidal-input",
    "href": "Klon Centaur part 2v0.html#sinusoidal-input",
    "title": "38  Klon Centaur, part 2",
    "section": "38.4 Sinusoidal Input",
    "text": "38.4 Sinusoidal Input\nIn this section the transient analysis simulation results from LTSpice for the voltages at the diodes, \\(v_{17}\\), is examined by using NumPy and SciPy functions. The input stimulus to the Klon Centaur circuit is a 1kHz sine wave. The LTSpice simulation was run with various gain settings and input amplitude values.\nA new Pandas data frame is declared with the column names shown below. In this dataframe the node voltage versus time is tabulated for each input level and gain setting.\n\ntd_node_voltage_df = pd.DataFrame(columns=['V1amp','Rgain','time','V7','V14','V17','V19','V21'])\n\nData is loaded into the new dataframe with the following code.\n\nfor i in range(0,len(step_index)):\n    #\n    row_elements = LTSpice_sweep_df['time'][step_index[i]].split()\n\n    # convert the units of 'K' and 'm' to float\n    Rgain_str = row_elements[3][6:]\n    Rgain_value = float(Rgain_str.replace('K', 'e3'))\n    Rgain_percent = Rgain_value/100e3*100\n    V1_amp_str = row_elements[2][7:]\n    V1_amp_value = float(V1_amp_str.replace('m', 'e-3'))\n\n    #\n    if i == 0:\n        time_values = LTSpice_sweep_df['time'][1:step_index[i+1]].to_numpy()\n        v7_values = LTSpice_sweep_df['V(7)'][1:step_index[i+1]].to_numpy()\n        v14_values = LTSpice_sweep_df['V(14)'][1:step_index[i+1]].to_numpy()\n        v17_values = LTSpice_sweep_df['V(17)'][1:step_index[i+1]].to_numpy()\n        v19_values = LTSpice_sweep_df['V(19)'][1:step_index[i+1]].to_numpy()\n        v21_values = LTSpice_sweep_df['V(21)'][1:step_index[i+1]].to_numpy()\n    elif (i != 0) and (i &lt; len(step_index)-1):\n        time_values = LTSpice_sweep_df['time'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v7_values = LTSpice_sweep_df['V(7)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v14_values = LTSpice_sweep_df['V(14)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v17_values = LTSpice_sweep_df['V(17)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v19_values = LTSpice_sweep_df['V(19)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v21_values = LTSpice_sweep_df['V(21)'][step_index[i]+1:step_index[i+1]].to_numpy()\n    else:\n        time_values = LTSpice_sweep_df['time'][step_index[i]+1:-1].to_numpy()\n        v7_values = LTSpice_sweep_df['V(7)'][step_index[i]+1:-1].to_numpy()\n        v14_values = LTSpice_sweep_df['V(14)'][step_index[i]+1:-1].to_numpy()\n        v17_values = LTSpice_sweep_df['V(17)'][step_index[i]+1:-1].to_numpy()\n        v19_values = LTSpice_sweep_df['V(19)'][step_index[i]+1:-1].to_numpy()\n        v21_values = LTSpice_sweep_df['V(21)'][step_index[i]+1:-1].to_numpy()\n\n    # load values into new dataframe\n    td_node_voltage_df.loc[i] = [V1_amp_value, Rgain_percent,time_values,v7_values,v14_values,v17_values,v19_values,v21_values]\n\nThe first five records in the dataframe are displayed below.\n\ntd_node_voltage_df.head(5)\n\n\n\n\n\n\n\n\n\nV1amp\nRgain\ntime\nV7\nV14\nV17\nV19\nV21\n\n\n\n\n0\n0.10\n0.001\n[0, 1.25000001460762E-08, 2.50000002921524E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n1\n0.25\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n2\n0.50\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n3\n0.75\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n4\n1.00\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n\n\n\n\n\n\nAt an offset of 127 in the dataframe, the gain setting is 60% and the input amplitude is 0.25 volts. This will produce a signal at the diodes a bit larger than the conduction threshold and the signal will be slightly voltage limited as shown in the plot below.\n\ni=127\nprint('Node 17, voltage vs input level V1amp={:.3f}, Rgain={:.0f}'.format(td_node_voltage_df.loc[i]['V1amp'],td_node_voltage_df.loc[i]['Rgain']))\nnum_samples = len(td_node_voltage_df.loc[i]['time'])\nprint(f'Number of samples in the simulation: {num_samples:,d}')\n\nNode 17, voltage vs input level V1amp=0.250, Rgain=60\nNumber of samples in the simulation: 1,280\n\n\nThe bias voltage of 4.5 has been subtracted from the values in the plot.\n\nplt.plot(np.asarray(td_node_voltage_df.loc[i]['time'], dtype=float),\n         np.asarray(td_node_voltage_df.loc[i]['V17'], dtype=float) - 4.5,\n         '-')\n\nplt.ylabel('Node voltage, volts')\nplt.xlabel('time')\n#plt.grid()\nplt.title('Node 17 voltage, offset removed')\nplt.show()\n\n\n\n\n\n\n\nFigure 38.5: Node 17, voltage at input level V1=0.25 and Rgain=60\n\n\n\n\n\nThe plot above shows the voltage at node 17. Somewhat evident is the rounding of the peaks of the waveform.\nLTSpice returns the node voltages versus time where the sample interval is not uniform. LTSpice varies the time step to aid in the solution convergence. By plotting time data versus sample number we can see in the plot below, the function is not a straight line, but somewhat stair cased.\n\nt_data = np.asarray(td_node_voltage_df.loc[i]['time'], dtype=float)\ny_data = np.asarray(td_node_voltage_df.loc[i]['V17'], dtype=float) - 4.5\n\n# plot the data\nplt.plot(t_data[0:300])\nplt.xlabel('time samples')\nplt.ylabel('time, sec')\nplt.title('Title')\nplt.show()\n\n\n\n\n\n\n\nFigure 38.6: Node 17, sample time plotted\n\n\n\n\n\nWe can use NumPy’s function interp to resample the data so that the sample intervals are uniform.\n\nstop_time = 20e-3\nxnew = np.linspace(0, stop_time, int(len(t_data))) #np.linspace(0, 10, num=1001)\nynew = np.interp(xnew, t_data, y_data)\n\nThe harmonic content of the signal plotted in Figure 38.5 can be examined by the use of Fast Fourier transform (FFT). Since the simulation data ends abruptly, there is typically a non-zero value for the last data point in the simulation. A window function is typically used to minimize the “spectral leakage” associated with any discontinuities at the ends of the data set and helps to produce a more accurate representation of the signal’s true frequency content.\nThere are many window functions described in the signal processing literature. The window function used in this analysis is the Hann function and implemented by the NumPy function hanning. The Hann function is a taper formed by using a weighted cosine. The window is named after Julius von Hann, often referred to as Hanning. It is also known as the raised cosine, because of its similarity to a raised-cosine distribution.\nThe data, window and windowed data is plotted below.\n\nfft_window = np.hanning(len(xnew))\nyw = ynew*fft_window\n\n# plot the data\nplt.plot(xnew,ynew)\nplt.plot(xnew ,yw)\nplt.plot(xnew,fft_window)\nplt.xlabel('Time, sec')\nplt.ylabel('Voltage, volts')\nplt.legend(['Node 17 voltage', 'windowed data', 'window function'], loc='best')\nplt.title('Title')\nplt.show()\n\n\n\n\n\n\n\nFigure 38.7: Node 17 voltage, window and windowed data\n\n\n\n\n\nThe plot above overlays the voltage at node 17, the window function and the windowed data.\nThe following code displays various parameters about the signal sample being analyzed.\n\nnum_samples = len(ynew)\nprint(f'The number of samples is: {num_samples:,.0f}')\n\nsps = num_samples/stop_time\nprint(f'The sample rate is: {sps:,.0f} samples per second')\n\nnyquist_freq = sps/2\nprint(f'The Nyquist frequency: {nyquist_freq:,.0f} Hz')\n\ndt = stop_time/len(xnew)\nprint(f'The sample interval: {dt*1e6} \\u03BCs')\n\nThe number of samples is: 1,280\nThe sample rate is: 64,000 samples per second\nThe Nyquist frequency: 32,000 Hz\nThe sample interval: 15.625 μs\n\n\nThe SciPy library includes functions to compute discrete Fourier transforms, which are used in the code below to find the frequency components of the voltage at node 17. The SciPy function fft computes the one dimensional discrete Fourier Transform (DFT) using the Fast Fourier Transform (FFT) algorithm.\n\nyw_fft = scipy.fft.fft(yw)\n\nThe following code displays the frequency components of node 17 voltage. To display the amplitude spectrum in volts rms, take the two-sided amplitude amplitude spectrum and multiply the non-DC components by the square root of two and discard the second half of the array. The following equations show the calculations from a two-sided FFT to a single-sided amplitude spectrum.\n\nyw_fft_ss = yw_fft[0:int(num_samples/2)] # use lower half of the array\nfreq = np.arange(int(num_samples/2))*sps/num_samples\n\nk = np.ones(len(freq)) # Scaling factor is sqrt(2) except for at DC when it is 1\nk[1:] = k[1:]*sqrt(2)\nywf_ss_Vrms_dB = 20*np.log10(abs(2*k*yw_fft_ss/num_samples)) # 2 is the Hann window correction factor\n\nplt.plot(freq,ywf_ss_Vrms_dB)\nplt.xlim(0,10000)\nplt.ylim(-100,-10)\nplt.ylabel('amplitude, dBVrms')\nplt.xlabel('frequency, Hz')\nplt.title('FFT of the voltage at node 17')\n#plt.legend(loc='best')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\nFigure 38.8: Node 17, frequency spectrum.\n\n\n\n\n\nThe frequency plot shows that odd harmonics are generated by the clipping action of the diodes.\nAlthough LTSpice can calculate the FFT of voltages or currents, Python can also be used to display the simulation results and perform additional analysis. As shown above, node voltages and branch currents can be extracted from LTSpice and brought into JupyterLab.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#actual-signals",
    "href": "Klon Centaur part 2v0.html#actual-signals",
    "title": "38  Klon Centaur, part 2",
    "section": "38.5 Actual Signals",
    "text": "38.5 Actual Signals\nA useful feature of LTSpice is capability to use wav files as input signals to a circuit simulation. Actual guitar signals in the form of wav files were obtained from Sample Focus. The wav files are availabe under their Standard License and are free to use. I chose the file clean-electric-guitar-harmonic-reality.wav since I thought it represented someting close to the type of signals that a player would run through their Klon Centaur.\nA transient analysis was performed using the file Klon-Centaur_v2_wavefile.asc and the input source, V1, wavefile = clean-electric-guitar-harmonic-reality.wav was declared as the value of V1. The simulation output was written to a wav file with the directive, .wave “klon_out.wav” 16 44.1k V(2). Using this file, the output of the circuit can be listened to on a computers audio player. The node voltages a several places were written to a csv file to be processed and plotted by Python in this notebook. The schematic includes a pre-amp labeled as U1. The gain as been set to unity, but other gains can be obtained by adjusting the values of resistors \\(R_{19}\\) and \\(R_{14}\\).\nThe following Python modules are loaded into the JupyterLab environment in order to read wav files.\n\nfrom scipy.io import wavfile\nimport scipy.io\n\nThe simulation input file, clean-electric-guitar-harmonic-reality.wav, is loaded to the variable wav_input. The input file has two channels since it’s a stereo recording and these are the left and right channels. The length of the audio sample and the sample rate is displayed below.\n\nsamplerate_input, wav_input = wavfile.read('clean-electric-guitar-harmonic-reality.wav')\nlength_in = wav_input.shape[0] / samplerate_input\nprint(f\"length = {length_in} seconds\")\nprint(f\"sample rate = {samplerate_input:,.0f} sps\")\n\nlength = 6.4 seconds\nsample rate = 44,100 sps\n\n\nSince the wave file contains stereo data, each channel is extracted, but only channel 0 is displayed.\n\n# split the data in channels\nchan0 = np.zeros(len(wav_input))\nchan1 = np.zeros(len(wav_input))\n\nfor i in range(len(wav_input)):\n    chan0[i] =  wav_input[i][0]\n    chan1[i] =  wav_input[i][1]    \n\ntime = np.linspace(0, length_in, len(wav_input))\nplt.plot(time, chan0, label=\"channel 0\")\nplt.legend()\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude\")\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see in the plot above, the input signal consists of five strums on the guitar. The amplitude of the signal in the plot above is the value of the 16 bit binary data. LTSpice converts the binary data to volts.\nThe following code reads the csv file saved after the simulation and places the data into a Python dataframe. Notice that the node voltage at \\(v_{14}\\) has had the 4.5V offset removed.\n\nLTSpice_wavefile_df = pd.read_csv('wavefile_Vin.csv',delimiter='\\t')\n\nThe first ten lines in the dataframe are:\n\nLTSpice_wavefile_df.head(10)\n\n\n\n\n\n\n\n\n\ntime\nV(1)\nV(2)\nV(14)-4.5\nV(16)\n\n\n\n\n0\n0.000000\n4.499921e-24\n6.839725e-13\n0.000218\n7.566022e-13\n\n\n1\n0.000386\n-3.242693e-07\n-5.593652e-08\n0.000217\n-2.294244e-07\n\n\n2\n0.000392\n-8.991888e-06\n-2.135811e-06\n0.000205\n-1.153911e-05\n\n\n3\n0.000399\n-1.766024e-05\n-6.099190e-06\n0.000190\n-2.611201e-05\n\n\n4\n0.000405\n-2.632934e-05\n-1.194607e-05\n0.000171\n-4.394813e-05\n\n\n5\n0.000412\n-3.499917e-05\n-1.967646e-05\n0.000149\n-6.504747e-05\n\n\n6\n0.000418\n-4.366974e-05\n-2.929036e-05\n0.000123\n-8.941003e-05\n\n\n7\n0.000424\n-5.234105e-05\n-4.078776e-05\n0.000094\n-1.170358e-04\n\n\n8\n0.000431\n-6.101310e-05\n-5.416866e-05\n0.000061\n-1.479248e-04\n\n\n9\n0.000437\n-7.730443e-05\n-7.190395e-05\n0.000018\n-1.888111e-04\n\n\n\n\n\n\n\n\nThe data is saved to several NumPy arrays to be processed and displayed using Python. Of interest are the input and output nodes, \\(v_1\\) and \\(v_2\\), as well as the nodes \\(v_{14}\\) and \\(v_{16}\\).\n\nt_data = np.asarray(LTSpice_wavefile_df['time'], dtype=float)\nv1_data = np.asarray(LTSpice_wavefile_df['V(1)'], dtype=float)\nv2_data = np.asarray(LTSpice_wavefile_df['V(2)'], dtype=float)\nv14_data = np.asarray(LTSpice_wavefile_df['V(14)-4.5'], dtype=float)\nv16_data = np.asarray(LTSpice_wavefile_df['V(16)'], dtype=float)\n\nThe following code plots the voltage at nodes \\(v_1\\) and \\(v_2\\), which are the input and output nodes of the Klon Centaur. Only the first 54 ms or so is plotted.\n\nstart_index = 3500\nstop_index = 10000\nplt.plot(t_data[start_index:stop_index]*1000,v1_data[start_index:stop_index],'-r',label='V1')\n#plt.plot(t_data[start_index:stop_index]*1000,v16_data[start_index:stop_index],'-',label='V16')\n#plt.plot(t_data[start_index:stop_index]*1000,v14_data[start_index:stop_index],'-',label='V14')\nplt.plot(t_data[start_index:stop_index]*1000,v2_data[start_index:stop_index],'-b',label='V2')\n\nplt.ylabel('Node voltage, volts')\nplt.xlabel('time,ms')\nplt.grid()\nplt.title('title')\n\n#plt.legend(loc=\"lower right\")\nplt.legend(bbox_to_anchor=(1.2,1))\nplt.show()\n\n\n\n\n\n\n\nFigure 38.9: Actual signals caption\n\n\n\n\n\nThe plot above shows the pedal has some gain applied to the signal. The fundamental frequency appears the same, but the overall waveform is much different, as would be expected since the pedal is modifying the input signal with filtering and amplitude clipping by the diodes.\nThe plot below shows the voltage plots for node \\(v_{14}\\), the output terminal of \\(U_{1B}\\) and \\(v_{16}\\), the voltage on \\(D_2\\).\n\nstart_index = 3500\nstop_index = 10000\n#plt.plot(t_data[start_index:stop_index]*1000,v1_data[start_index:stop_index],'-',label='V1')\nplt.plot(t_data[start_index:stop_index]*1000,v16_data[start_index:stop_index],'-k', linewidth=1, label='V14')\nplt.plot(t_data[start_index:stop_index]*1000,v14_data[start_index:stop_index],'-r', linewidth=0.5, label='V16')\n#plt.plot(t_data[start_index:stop_index]*1000,v2_data[start_index:stop_index],'-',label='V2')\n\nplt.ylabel('Node voltage, volts')\nplt.xlabel('time,ms')\nplt.grid()\nplt.title('title')\n\n#plt.legend(loc=\"lower right\")\nplt.legend(bbox_to_anchor=(1.2,1))\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the amplitude limiting caused by the diodes on the signal.\nFrom here additional numerical analysis of the node voltages can be performed within the JupyterLab notebook using the signal processing code of NumPy and SciPy. Python’s numerical analysis capability can be combined with circuit simulation results from LTSpice and actual physical measurements of prototype circuits to aid the designer in the analysis and development of electronic circuits.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#sec-Comparison_of_MNA_and_LTSpice_results",
    "href": "Klon Centaur part 2v0.html#sec-Comparison_of_MNA_and_LTSpice_results",
    "title": "38  Klon Centaur, part 2",
    "section": "38.6 Comparison of MNA and LTSpice results",
    "text": "38.6 Comparison of MNA and LTSpice results\nIn this section the solutions obtained from MNA and LTSpice will be compared to each other. As shown below the two solutions are very comparable which allows us to have a high degree of confidence in the accuracy of the MNA solution.\nThe netlist for the MNA solution was obtained from Figure 37.3 and the schematic of Figure 38.1 was used for the LTSpice simulation. For the MNA solution, the diodes, \\(D_2\\) and \\(D_3\\) were removed from the netlist by inserting an asterisk at the start of those lines which turn the lines into comments, shown below. Additionally, the MNA netlist treats the Op Amps as ideal Op Amps. In the LTSpice simulation, device modules are used for the diodes and Op Amps. This will add some accuracy to the simulation. The amplitude of the input signal, \\(V1\\), in the LTSpice simulation was chosen to be \\(\\pm25 mV\\) in the transient simulations, so that the diodes would not be conducting. This keeps both the MNA and the LTSpice solutions in the linear domain.\nThe MNA solution is presented first, followed by loading and reading the exported LTSpice simulation results which were exported as a csv file. The two solutions are plotted on the same graph so that the results can be compared.\nThe netlist for the circuit in Figure 37.3, was exported and shown below.\n\nnet_list = '''\n* Klon-Centaur_v1.asc\nV1 1 0 1\nR1 3 1 10e3\nR2 0 4 1000e3\nC1 4 3 100e-9\nR5 7 25 5.1e3\nR8 25 0 1.5e3\nC3 8 7 100e-9\nC4 7 25 68e-9\nC6 25 26 390e-9\nR9 26 0 1e3\nR6 9 8 10e3\nC5 9 8 68e-9\nRp1b2 25 27 50e3\nRp1a2 27 0 50e3\nRp1b1 11 0 50e3\nRp1a1 0 9 50e3\nR10 12 11 2e3\nR11 13 12 15e3\nC7 13 12 82e-9\nC8 14 13 390e-12\nR12 14 13 422e3\nR13 16 15 1e3\nC11 17 28 2.2e-9\nR15 28 27 22e3\nR17 18 27 27e3\nR18 29 27 12e3\nC12 18 29 27e-9\nR16 18 17 47e3\nR7 8 10 1.5e3\nR24 18 10 15e3\nR20 19 18 392e3\nC13 19 18 820e-12\nR21 19 32 1.8e3\nR22 20 19 100e3\nRp2a 32 30 5e3\nRp2b 30 31 5e3\nC14 20 30 3.9e-9\nR241 21 20 100e3\nR25 23 22 560\nR23 21 31 4.7e3\nO1a 7 4 7\nO1b 13 9 14\nO2a 18 0 19\nO2b 20 0 21\nR3 5 0 100e3\nR4 6 5 560\n*D2 0 16 1N34A\n*D3 16 0 1N34A\nC2 7 5 4.7e-6\nC16 10 0 1e-6\nC9 14 15 1e-6\nC10 17 16 1e-6\nC15 21 22 4.7e-6\nR26 2 6 68e3\nR28 2 0 100e3\nRp3a 23 24 50e3\nRp3b 24 0 50e3\nR27 2 24 0.01\n'''\n\nThe symbolic modified nodal analysis function is called with the netlist and the MNA results are returned.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe netlist report provides some statistics about the circuit, which are printed below.\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 56\nnumber of branches: 52\nnumber of nodes: 32\nnumber of unknown currents: 5\nnumber of RLC (passive components): 51\nnumber of resistors: 35\nnumber of capacitors: 16\nnumber of inductors: 0\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of Op Amps: 4\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\nThere are 32 nodes and 5 unknown currents in the circuit. This means that the MNA technique will generate a system of 37 equations for SymPy to solve.\nThe network equations are assembled with the following lines of Python code.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nThe system of equations is displayed with the following code using the markdown function.\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = v_{2} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{24}}{R_{27}} - \\frac{v_{6}}{R_{26}}\\)\\(0 = - C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}}\\)\\(0 = - C_{1} s v_{3} + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}}\\right)\\)\\(0 = - C_{2} s v_{7} + v_{5} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{4}}\\)\\(0 = v_{6} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{2}}{R_{26}}\\)\\(0 = - C_{2} s v_{5} - C_{3} s v_{8} + I_{O1a} + v_{25} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{7} \\left(C_{2} s + C_{3} s + C_{4} s + \\frac{1}{R_{5}}\\right)\\)\\(0 = - C_{3} s v_{7} + v_{8} \\left(C_{3} s + C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) + v_{9} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) - \\frac{v_{10}}{R_{7}}\\)\\(0 = v_{8} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) + v_{9} \\left(C_{5} s + \\frac{1}{Rp1a1} + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{10} \\left(C_{16} s + \\frac{1}{R_{7}} + \\frac{1}{R_{24}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{18}}{R_{24}}\\)\\(0 = v_{11} \\cdot \\left(\\frac{1}{Rp1b1} + \\frac{1}{R_{10}}\\right) - \\frac{v_{12}}{R_{10}}\\)\\(0 = v_{12} \\left(C_{7} s + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) + v_{13} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) - \\frac{v_{11}}{R_{10}}\\)\\(0 = v_{12} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) + v_{13} \\left(C_{7} s + C_{8} s + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{14} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right)\\)\\(0 = - C_{9} s v_{15} + I_{O1b} + v_{13} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right) + v_{14} \\left(C_{8} s + C_{9} s + \\frac{1}{R_{12}}\\right)\\)\\(0 = - C_{9} s v_{14} + v_{15} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{16}}{R_{13}}\\)\\(0 = - C_{10} s v_{17} + v_{16} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{15}}{R_{13}}\\)\\(0 = - C_{10} s v_{16} - C_{11} s v_{28} + v_{17} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{18}}{R_{16}}\\)\\(0 = - C_{12} s v_{29} + v_{18} \\left(C_{12} s + C_{13} s + \\frac{1}{R_{24}} + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) + v_{19} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) - \\frac{v_{10}}{R_{24}} - \\frac{v_{27}}{R_{17}} - \\frac{v_{17}}{R_{16}}\\)\\(0 = I_{O2a} + v_{18} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) + v_{19} \\left(C_{13} s + \\frac{1}{R_{22}} + \\frac{1}{R_{21}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{20}}{R_{22}} - \\frac{v_{32}}{R_{21}}\\)\\(0 = - C_{14} s v_{30} + v_{20} \\left(C_{14} s + \\frac{1}{R_{241}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{21}}{R_{241}} - \\frac{v_{19}}{R_{22}}\\)\\(0 = - C_{15} s v_{22} + I_{O2b} + v_{21} \\left(C_{15} s + \\frac{1}{R_{241}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{20}}{R_{241}} - \\frac{v_{31}}{R_{23}}\\)\\(0 = - C_{15} s v_{21} + v_{22} \\left(C_{15} s + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}}\\)\\(0 = v_{23} \\cdot \\left(\\frac{1}{Rp3a} + \\frac{1}{R_{25}}\\right) - \\frac{v_{24}}{Rp3a} - \\frac{v_{22}}{R_{25}}\\)\\(0 = v_{24} \\cdot \\left(\\frac{1}{Rp3b} + \\frac{1}{Rp3a} + \\frac{1}{R_{27}}\\right) - \\frac{v_{23}}{Rp3a} - \\frac{v_{2}}{R_{27}}\\)\\(0 = - C_{6} s v_{26} + v_{25} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) + v_{7} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) - \\frac{v_{27}}{Rp1b2}\\)\\(0 = - C_{6} s v_{25} + v_{26} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{27} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{25}}{Rp1b2} - \\frac{v_{29}}{R_{18}} - \\frac{v_{18}}{R_{17}} - \\frac{v_{28}}{R_{15}}\\)\\(0 = - C_{11} s v_{17} + v_{28} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{27}}{R_{15}}\\)\\(0 = - C_{12} s v_{18} + v_{29} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{27}}{R_{18}}\\)\\(0 = - C_{14} s v_{20} + v_{30} \\left(C_{14} s + \\frac{1}{Rp2b} + \\frac{1}{Rp2a}\\right) - \\frac{v_{31}}{Rp2b} - \\frac{v_{32}}{Rp2a}\\)\\(0 = v_{31} \\cdot \\left(\\frac{1}{Rp2b} + \\frac{1}{R_{23}}\\right) - \\frac{v_{30}}{Rp2b} - \\frac{v_{21}}{R_{23}}\\)\\(0 = v_{32} \\cdot \\left(\\frac{1}{Rp2a} + \\frac{1}{R_{21}}\\right) - \\frac{v_{30}}{Rp2a} - \\frac{v_{19}}{R_{21}}\\)\\(V_{1} = v_{1}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{13} - v_{9}\\)\\(0 = v_{18}\\)\\(0 = v_{20}\\)\n\n\nThere are too many equations and symbols for SymPy to obtain a symbolic solution and symbolic results would not be useful.\nThe following code is used to turn the free symbols into SymPy variables and the numeric values for the components are put into a Python dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n38.6.1 Numerical Solution\nAs shown below, the value of \\(V1\\) is set to one. The value of \\(V1\\) gets canceled in the voltage transfer function, so this value does not affect the solution. The bypass switch is put into the effects position by setting the values of \\(R_{26}\\) and \\(R_{27}\\). The controls on the Klon Centaur are set to mid position.\n\nelement_values[V1] = 1\n\n# bypass switch in effects position\nelement_values[R26] = 68e3\nelement_values[R27] = 0.01\n\n# gain pot, P1\nP1_value = 100e3\nP1_setting = 0.5 # a percent of full scale\nelement_values[Rp1b2] = P1_setting*P1_value\nelement_values[Rp1a2] = P1_value - P1_setting*P1_value\nelement_values[Rp1b1] = P1_setting*P1_value\nelement_values[Rp1a1] = P1_value - P1_setting*P1_value\n\n# treble pot, P2\nP2_value = 10e3\nP2_setting = 0.5\nelement_values[Rp2b] = P2_setting*P2_value\nelement_values[Rp2a] = P2_value - P2_setting*P2_value\n\n#output pot, P3\nP3_value = 100e3\nP3_setting = 0.5\nelement_values[Rp3b] = P3_setting*P3_value\nelement_values[Rp3a] = P3_value - P3_setting*P3_value\n\nThe following code replaces the symbols in the network equations with numerical values and displays the equations.\n\nNE = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.0001 v_{1} - 0.0001 v_{3}\\)\\(0 = 100.000024705882 v_{2} - 100.0 v_{24} - 1.47058823529412 \\cdot 10^{-5} v_{6}\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{4} - 0.0001 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.0001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 1.0 \\cdot 10^{-6}\\right)\\)\\(0 = - 4.7 \\cdot 10^{-6} s v_{7} + v_{5} \\cdot \\left(4.7 \\cdot 10^{-6} s + 0.00179571428571429\\right) - 0.00178571428571429 v_{6}\\)\\(0 = - 1.47058823529412 \\cdot 10^{-5} v_{2} - 0.00178571428571429 v_{5} + 0.00180042016806723 v_{6}\\)\\(0 = I_{O1a} - 4.7 \\cdot 10^{-6} s v_{5} - 1.0 \\cdot 10^{-7} s v_{8} + v_{25} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{7} \\cdot \\left(4.868 \\cdot 10^{-6} s + 0.000196078431372549\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{7} - 0.000666666666666667 v_{10} + v_{8} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{9} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{8} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{9} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 6.66666666666667 \\cdot 10^{-5} v_{18} - 0.000666666666666667 v_{8}\\)\\(0 = 0.00052 v_{11} - 0.0005 v_{12}\\)\\(0 = - 0.0005 v_{11} + v_{12} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{13} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{12} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{13} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{14} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} - 1.0 \\cdot 10^{-6} s v_{15} + v_{13} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{14} \\cdot \\left(1.00039 \\cdot 10^{-6} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{14} + v_{15} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{16}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{17} - 0.001 v_{15} + v_{16} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{16} - 2.2 \\cdot 10^{-9} s v_{28} + v_{17} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{29} - 6.66666666666667 \\cdot 10^{-5} v_{10} - 2.12765957446809 \\cdot 10^{-5} v_{17} + v_{18} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) + v_{19} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) - 3.7037037037037 \\cdot 10^{-5} v_{27}\\)\\(0 = I_{O2a} + v_{18} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{19} \\cdot \\left(8.2 \\cdot 10^{-10} s + 0.000568106575963719\\right) - 1.0 \\cdot 10^{-5} v_{20} - 0.000555555555555556 v_{32}\\)\\(0 = - 3.9 \\cdot 10^{-9} s v_{30} - 1.0 \\cdot 10^{-5} v_{19} + v_{20} \\cdot \\left(3.9 \\cdot 10^{-9} s + 2.0 \\cdot 10^{-5}\\right) - 1.0 \\cdot 10^{-5} v_{21}\\)\\(0 = I_{O2b} - 4.7 \\cdot 10^{-6} s v_{22} - 1.0 \\cdot 10^{-5} v_{20} + v_{21} \\cdot \\left(4.7 \\cdot 10^{-6} s + 0.000222765957446809\\right) - 0.000212765957446809 v_{31}\\)\\(0 = - 4.7 \\cdot 10^{-6} s v_{21} + v_{22} \\cdot \\left(4.7 \\cdot 10^{-6} s + 0.00178571428571429\\right) - 0.00178571428571429 v_{23}\\)\\(0 = - 0.00178571428571429 v_{22} + 0.00180571428571429 v_{23} - 2.0 \\cdot 10^{-5} v_{24}\\)\\(0 = - 100.0 v_{2} - 2.0 \\cdot 10^{-5} v_{23} + 100.00004 v_{24}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{26} + v_{25} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{27} + v_{7} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{25} + v_{26} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{18} - 2.0 \\cdot 10^{-5} v_{25} + 0.000205824915824916 v_{27} - 4.54545454545455 \\cdot 10^{-5} v_{28} - 8.33333333333333 \\cdot 10^{-5} v_{29}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{17} - 4.54545454545455 \\cdot 10^{-5} v_{27} + v_{28} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 8.33333333333333 \\cdot 10^{-5} v_{27} + v_{29} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = - 3.9 \\cdot 10^{-9} s v_{20} + v_{30} \\cdot \\left(3.9 \\cdot 10^{-9} s + 0.0004\\right) - 0.0002 v_{31} - 0.0002 v_{32}\\)\\(0 = - 0.000212765957446809 v_{21} - 0.0002 v_{30} + 0.000412765957446809 v_{31}\\)\\(0 = - 0.000555555555555556 v_{19} - 0.0002 v_{30} + 0.000755555555555556 v_{32}\\)\\(1 = v_{1}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{13} - v_{9}\\)\\(0 = v_{18}\\)\\(0 = v_{20}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{1.60460486959839 \\cdot 10^{204} s^{15} + 3.27859737275232 \\cdot 10^{209} s^{14} + 2.24239224921523 \\cdot 10^{214} s^{13} + 6.17846960611372 \\cdot 10^{218} s^{12} + 6.98631389088568 \\cdot 10^{222} s^{11} + 3.84144613823827 \\cdot 10^{226} s^{10} + 1.14176089090876 \\cdot 10^{230} s^{9} + 1.9487479169721 \\cdot 10^{233} s^{8} + 1.9264469914375 \\cdot 10^{236} s^{7} + 1.04007382786928 \\cdot 10^{239} s^{6} + 2.4949612511751 \\cdot 10^{241} s^{5} + 8.71156576910649 \\cdot 10^{242} s^{4} + 1.59377116458413 \\cdot 10^{244} s^{3} + 5.83569842526406 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{3} = \\frac{100.0 s + 1000.0}{101.0 s + 1000.0}\\)\\(v_{4} = \\frac{100.0 s}{101.0 s + 1000.0}\\)\\(v_{5} = \\frac{7.08081890044526 \\cdot 10^{204} s^{15} + 5.16811216386491 \\cdot 10^{209} s^{14} + 1.44527574255849 \\cdot 10^{214} s^{13} + 2.06993156176013 \\cdot 10^{218} s^{12} + 1.70763881138264 \\cdot 10^{222} s^{11} + 8.56283170735283 \\cdot 10^{225} s^{10} + 2.66372688771691 \\cdot 10^{229} s^{9} + 5.13265459135094 \\cdot 10^{232} s^{8} + 5.97388273658386 \\cdot 10^{235} s^{7} + 3.92904920853072 \\cdot 10^{238} s^{6} + 1.24088217015922 \\cdot 10^{241} s^{5} + 1.14762193670536 \\cdot 10^{243} s^{4} + 2.99189745426633 \\cdot 10^{244} s^{3} + 9.40378060745908 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{6} = \\frac{7.03608903088174 \\cdot 10^{204} s^{15} + 5.15267855413586 \\cdot 10^{209} s^{14} + 1.45178661250784 \\cdot 10^{214} s^{13} + 2.10349021556464 \\cdot 10^{218} s^{12} + 1.75075517725956 \\cdot 10^{222} s^{11} + 8.80666065452342 \\cdot 10^{225} s^{10} + 2.73522884121702 \\cdot 10^{229} s^{9} + 5.24990520050914 \\cdot 10^{232} s^{8} + 6.08244062485052 \\cdot 10^{235} s^{7} + 3.9819101460933 \\cdot 10^{238} s^{6} + 1.25112552321302 \\cdot 10^{241} s^{5} + 1.14536375990424 \\cdot 10^{243} s^{4} + 2.98047751957814 \\cdot 10^{244} s^{3} + 9.37463641227194 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{7} = \\frac{100.0 s}{101.0 s + 1000.0}\\)\\(v_{8} = \\frac{1.53 \\cdot 10^{27} s^{4} + 3.822 \\cdot 10^{30} s^{3} + 1.98 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{9} = \\frac{1.53 \\cdot 10^{27} s^{4} + 3.372 \\cdot 10^{30} s^{3} + 1.65 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{10} = \\frac{1.02 \\cdot 10^{30} s^{3} + 1.8 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{11} = \\frac{1.56825 \\cdot 10^{39} s^{5} + 4.7313 \\cdot 10^{42} s^{4} + 4.50125 \\cdot 10^{45} s^{3} + 1.375 \\cdot 10^{48} s^{2}}{1.6472898 \\cdot 10^{39} s^{5} + 1.716827928 \\cdot 10^{43} s^{4} + 3.92993125840001 \\cdot 10^{46} s^{3} + 2.60963579706668 \\cdot 10^{49} s^{2} + 1.98012893333334 \\cdot 10^{51} s + 1.70850000000001 \\cdot 10^{52}}\\)\\(v_{12} = \\frac{1.63098 \\cdot 10^{39} s^{5} + 4.920552 \\cdot 10^{42} s^{4} + 4.6813 \\cdot 10^{45} s^{3} + 1.43 \\cdot 10^{48} s^{2}}{1.6472898 \\cdot 10^{39} s^{5} + 1.716827928 \\cdot 10^{43} s^{4} + 3.92993125840001 \\cdot 10^{46} s^{3} + 2.60963579706668 \\cdot 10^{49} s^{2} + 1.98012893333334 \\cdot 10^{51} s + 1.70850000000001 \\cdot 10^{52}}\\)\\(v_{13} = \\frac{1.53 \\cdot 10^{27} s^{4} + 3.372 \\cdot 10^{30} s^{3} + 1.65 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{14} = \\frac{1.2721644 \\cdot 10^{48} s^{6} + 7.45961435931766 \\cdot 10^{52} s^{5} + 2.18693901867302 \\cdot 10^{56} s^{4} + 2.07668666587681 \\cdot 10^{59} s^{3} + 6.37322274881527 \\cdot 10^{61} s^{2}}{1.284886044 \\cdot 10^{48} s^{6} + 2.11983185019071 \\cdot 10^{52} s^{5} + 1.12019716327369 \\cdot 10^{56} s^{4} + 2.06607825492002 \\cdot 10^{59} s^{3} + 1.25223922229928 \\cdot 10^{62} s^{2} + 9.39782361437604 \\cdot 10^{63} s + 8.09715639810431 \\cdot 10^{64}}\\)\\(v_{15} = \\frac{6.12932264586913 \\cdot 10^{102} s^{11} + 6.51555635737714 \\cdot 10^{107} s^{10} + 2.17603109429572 \\cdot 10^{112} s^{9} + 2.68844248892112 \\cdot 10^{116} s^{8} + 1.13053821227643 \\cdot 10^{120} s^{7} + 2.23994746250022 \\cdot 10^{123} s^{6} + 2.30739995895308 \\cdot 10^{126} s^{5} + 1.20420010870915 \\cdot 10^{129} s^{4} + 2.58996550003362 \\cdot 10^{131} s^{3} + 4.88678797757097 \\cdot 10^{132} s^{2}}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{16} = \\frac{5.82609631815901 \\cdot 10^{102} s^{11} + 6.20459033050087 \\cdot 10^{107} s^{10} + 2.08899742179437 \\cdot 10^{112} s^{9} + 2.61237691738473 \\cdot 10^{116} s^{8} + 1.1029219023253 \\cdot 10^{120} s^{7} + 2.18945780465391 \\cdot 10^{123} s^{6} + 2.25814621576051 \\cdot 10^{126} s^{5} + 1.17971076699241 \\cdot 10^{129} s^{4} + 2.54117204265127 \\cdot 10^{131} s^{3} + 4.88678797757097 \\cdot 10^{132} s^{2}}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{17} = \\frac{5.82609631815901 \\cdot 10^{102} s^{11} + 6.20155806722377 \\cdot 10^{107} s^{10} + 2.08588776152561 \\cdot 10^{112} s^{9} + 2.6036735501346 \\cdot 10^{116} s^{8} + 1.09531534517166 \\cdot 10^{120} s^{7} + 2.16184149470277 \\cdot 10^{123} s^{6} + 2.2076565579142 \\cdot 10^{126} s^{5} + 1.13045702379984 \\cdot 10^{129} s^{4} + 2.2962786254839 \\cdot 10^{131} s^{3} + 7.44223933649292 \\cdot 10^{129} s^{2}}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{18} = 0.0\\)\\(v_{19} = \\frac{- 7.729048460181 \\cdot 10^{111} s^{11} - 6.70683975958242 \\cdot 10^{116} s^{10} - 1.81971363059071 \\cdot 10^{121} s^{9} - 1.67621479136811 \\cdot 10^{125} s^{8} - 6.52036854696871 \\cdot 10^{128} s^{7} - 1.29707240532995 \\cdot 10^{132} s^{6} - 1.40520092072882 \\cdot 10^{135} s^{5} - 7.99228974825901 \\cdot 10^{137} s^{4} - 1.93754865846681 \\cdot 10^{140} s^{3} - 4.5595739475291 \\cdot 10^{141} s^{2} - 5.87797755461241 \\cdot 10^{142} s}{1.11932525587559 \\cdot 10^{107} s^{12} + 7.53562243981751 \\cdot 10^{111} s^{11} + 1.85774899364618 \\cdot 10^{116} s^{10} + 2.21913676324559 \\cdot 10^{120} s^{9} + 1.44029380607801 \\cdot 10^{124} s^{8} + 5.35372971100406 \\cdot 10^{127} s^{7} + 1.16592059808606 \\cdot 10^{131} s^{6} + 1.47731120257604 \\cdot 10^{134} s^{5} + 1.03131600544421 \\cdot 10^{137} s^{4} + 3.39523523720125 \\cdot 10^{139} s^{3} + 3.22720097422481 \\cdot 10^{141} s^{2} + 9.92148657875569 \\cdot 10^{142} s + 6.97940858343004 \\cdot 10^{143}}\\)\\(v_{20} = 0.0\\)\\(v_{21} = \\frac{3.95481784029325 \\cdot 10^{142} s^{12} + 3.59328293991187 \\cdot 10^{147} s^{11} + 1.07126591160631 \\cdot 10^{152} s^{10} + 1.2379488657562 \\cdot 10^{156} s^{9} + 6.83908611414043 \\cdot 10^{159} s^{8} + 2.02622810355854 \\cdot 10^{163} s^{7} + 3.42946419411261 \\cdot 10^{166} s^{6} + 3.34535147697467 \\cdot 10^{169} s^{5} + 1.76926228708653 \\cdot 10^{172} s^{4} + 4.0721594196483 \\cdot 10^{174} s^{3} + 9.55806164763192 \\cdot 10^{175} s^{2} + 1.22830078078907 \\cdot 10^{177} s}{4.12410117110505 \\cdot 10^{137} s^{13} + 3.0103661400075 \\cdot 10^{142} s^{12} + 8.41948178298009 \\cdot 10^{146} s^{11} + 1.20583791200201 \\cdot 10^{151} s^{10} + 9.94394854727057 \\cdot 10^{154} s^{9} + 4.98228898678412 \\cdot 10^{158} s^{8} + 1.54832846094415 \\cdot 10^{162} s^{7} + 2.98069258113566 \\cdot 10^{165} s^{6} + 3.4670700029695 \\cdot 10^{168} s^{5} + 2.28020147721265 \\cdot 10^{171} s^{4} + 7.21381116019837 \\cdot 10^{173} s^{3} + 6.78032628263838 \\cdot 10^{175} s^{2} + 2.07583050373503 \\cdot 10^{177} s + 1.4584630398505 \\cdot 10^{178}}\\)\\(v_{22} = \\frac{6.85813943594846 \\cdot 10^{209} s^{14} + 6.23149200163213 \\cdot 10^{214} s^{13} + 1.85798416714712 \\cdot 10^{219} s^{12} + 2.14759495200953 \\cdot 10^{223} s^{11} + 1.18695802863377 \\cdot 10^{227} s^{10} + 3.51914477074802 \\cdot 10^{230} s^{9} + 5.96321503551836 \\cdot 10^{233} s^{8} + 5.82860517934846 \\cdot 10^{236} s^{7} + 3.09491694101256 \\cdot 10^{239} s^{6} + 7.20414774924852 \\cdot 10^{241} s^{5} + 1.98864584585651 \\cdot 10^{243} s^{4} + 2.98014618856633 \\cdot 10^{244} s^{3} + 1.20559813397992 \\cdot 10^{245} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{23} = \\frac{1.7772515220219 \\cdot 10^{202} s^{15} + 6.81849260987794 \\cdot 10^{209} s^{14} + 6.18730893852549 \\cdot 10^{214} s^{13} + 1.84424847158735 \\cdot 10^{219} s^{12} + 2.13154630657843 \\cdot 10^{223} s^{11} + 1.17806610880784 \\cdot 10^{227} s^{10} + 3.49281298994759 \\cdot 10^{230} s^{9} + 5.91875100545495 \\cdot 10^{233} s^{8} + 5.78538507711761 \\cdot 10^{236} s^{7} + 3.07215760493155 \\cdot 10^{239} s^{6} + 7.15198904282505 \\cdot 10^{241} s^{5} + 1.97626859181365 \\cdot 10^{243} s^{4} + 2.96479076850346 \\cdot 10^{244} s^{3} + 1.19870858018881 \\cdot 10^{245} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{24} = \\frac{1.6046042313112 \\cdot 10^{204} s^{15} + 3.27859742501188 \\cdot 10^{209} s^{14} + 2.24239258971998 \\cdot 10^{214} s^{13} + 6.17847082322234 \\cdot 10^{218} s^{12} + 6.98631535945215 \\cdot 10^{222} s^{11} + 3.8414469577917 \\cdot 10^{226} s^{10} + 1.1417611327669 \\cdot 10^{230} s^{9} + 1.94874832122297 \\cdot 10^{233} s^{8} + 1.92644737793556 \\cdot 10^{236} s^{7} + 1.04007402627119 \\cdot 10^{239} s^{6} + 2.49496168358823 \\cdot 10^{241} s^{5} + 8.71156623701718 \\cdot 10^{242} s^{4} + 1.59377112003383 \\cdot 10^{244} s^{3} + 5.83569848840183 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{25} = \\frac{2.45172905834765 \\cdot 10^{103} s^{11} + 9.68148531052587 \\cdot 10^{107} s^{10} + 1.4606354787583 \\cdot 10^{112} s^{9} + 1.1118010386943 \\cdot 10^{116} s^{8} + 4.74470229541557 \\cdot 10^{119} s^{7} + 1.18318963185146 \\cdot 10^{123} s^{6} + 1.71551739396071 \\cdot 10^{126} s^{5} + 1.36079544612597 \\cdot 10^{129} s^{4} + 4.9599835245097 \\cdot 10^{131} s^{3} + 4.50843208510485 \\cdot 10^{133} s^{2} + 1.10895177447563 \\cdot 10^{135} s}{2.47624634893113 \\cdot 10^{103} s^{11} + 1.59004486411129 \\cdot 10^{108} s^{10} + 3.61517379487977 \\cdot 10^{112} s^{9} + 3.78464232805846 \\cdot 10^{116} s^{8} + 2.00891207055978 \\cdot 10^{120} s^{7} + 5.59415322555028 \\cdot 10^{123} s^{6} + 8.38986340894985 \\cdot 10^{126} s^{5} + 6.58119928527113 \\cdot 10^{129} s^{4} + 2.34134961457795 \\cdot 10^{132} s^{3} + 2.27227126156765 \\cdot 10^{134} s^{2} + 7.03932584377252 \\cdot 10^{135} s + 4.96313499266136 \\cdot 10^{136}}\\)\\(v_{26} = \\frac{1.8859454294982 \\cdot 10^{102} s^{11} + 6.96372064155883 \\cdot 10^{106} s^{10} + 9.4500881336385 \\cdot 10^{110} s^{9} + 6.12921616081805 \\cdot 10^{114} s^{8} + 2.07817710908427 \\cdot 10^{118} s^{7} + 3.77279945248749 \\cdot 10^{121} s^{6} + 3.52244289588368 \\cdot 10^{124} s^{5} + 1.43575241665188 \\cdot 10^{127} s^{4} + 1.33955488977009 \\cdot 10^{129} s^{3} + 3.3268553234269 \\cdot 10^{130} s^{2}}{1.90480488379318 \\cdot 10^{102} s^{11} + 1.22311143393176 \\cdot 10^{107} s^{10} + 2.78090291913828 \\cdot 10^{111} s^{9} + 2.91126332927574 \\cdot 10^{115} s^{8} + 1.54531697735368 \\cdot 10^{119} s^{7} + 4.30319478888483 \\cdot 10^{122} s^{6} + 6.45374108380758 \\cdot 10^{125} s^{5} + 5.0624609886701 \\cdot 10^{128} s^{4} + 1.80103816505996 \\cdot 10^{131} s^{3} + 1.74790097043665 \\cdot 10^{133} s^{2} + 5.41486603367117 \\cdot 10^{134} s + 3.81779614820105 \\cdot 10^{135}}\\)\\(v_{27} = \\frac{1.88222602341909 \\cdot 10^{102} s^{11} + 1.44831320913199 \\cdot 10^{107} s^{10} + 3.33801857194441 \\cdot 10^{111} s^{9} + 2.10195340190251 \\cdot 10^{115} s^{8} + 6.09908734298142 \\cdot 10^{118} s^{7} + 1.03118401308102 \\cdot 10^{122} s^{6} + 1.15158862697664 \\cdot 10^{125} s^{5} + 8.34202083067121 \\cdot 10^{127} s^{4} + 3.11019048617547 \\cdot 10^{130} s^{3} + 2.89886444198637 \\cdot 10^{132} s^{2} + 7.19752353626009 \\cdot 10^{133} s}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{28} = \\frac{5.82609631815901 \\cdot 10^{102} s^{11} + 5.38670883277337 \\cdot 10^{107} s^{10} + 1.27216965746747 \\cdot 10^{112} s^{9} + 6.64897103289498 \\cdot 10^{115} s^{8} + 1.55848892487266 \\cdot 10^{119} s^{7} + 2.0196506789592 \\cdot 10^{122} s^{6} + 1.65370058165892 \\cdot 10^{125} s^{5} + 9.3035629828195 \\cdot 10^{127} s^{4} + 3.09621286334538 \\cdot 10^{130} s^{3} + 2.89538084059482 \\cdot 10^{132} s^{2} + 7.19752353626009 \\cdot 10^{133} s}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{29} = \\frac{5.80933957845398 \\cdot 10^{105} s^{10} + 4.29080189304769 \\cdot 10^{110} s^{9} + 8.97820488469026 \\cdot 10^{114} s^{8} + 3.71645960936262 \\cdot 10^{118} s^{7} + 7.3537893012926 \\cdot 10^{121} s^{6} + 9.12978651085666 \\cdot 10^{124} s^{5} + 7.36450542873379 \\cdot 10^{127} s^{4} + 3.01702284548585 \\cdot 10^{130} s^{3} + 2.87554446572889 \\cdot 10^{132} s^{2} + 7.19752353626009 \\cdot 10^{133} s}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{30} = \\frac{- 8.51604883530572 \\cdot 10^{145} s^{11} - 7.38975505425107 \\cdot 10^{150} s^{10} - 2.00500362033169 \\cdot 10^{155} s^{9} - 1.84689319717609 \\cdot 10^{159} s^{8} - 7.18429665129523 \\cdot 10^{162} s^{7} - 1.42914512745319 \\cdot 10^{166} s^{6} - 1.54828368925286 \\cdot 10^{169} s^{5} - 8.80609432748894 \\cdot 10^{171} s^{4} - 2.13483704770277 \\cdot 10^{174} s^{3} - 5.02384667470906 \\cdot 10^{175} s^{2} - 6.47649502597865 \\cdot 10^{176} s}{1.23723035133151 \\cdot 10^{138} s^{13} + 9.03109842002251 \\cdot 10^{142} s^{12} + 2.52584453489403 \\cdot 10^{147} s^{11} + 3.61751373600603 \\cdot 10^{151} s^{10} + 2.98318456418117 \\cdot 10^{155} s^{9} + 1.49468669603524 \\cdot 10^{159} s^{8} + 4.64498538283244 \\cdot 10^{162} s^{7} + 8.94207774340698 \\cdot 10^{165} s^{6} + 1.04012100089085 \\cdot 10^{169} s^{5} + 6.84060443163796 \\cdot 10^{171} s^{4} + 2.16414334805951 \\cdot 10^{174} s^{3} + 2.03409788479151 \\cdot 10^{176} s^{2} + 6.22749151120508 \\cdot 10^{177} s + 4.3753891195515 \\cdot 10^{178}}\\)\\(v_{31} = \\frac{6.11569769117515 \\cdot 10^{142} s^{12} + 5.51535977354834 \\cdot 10^{147} s^{11} + 1.62079074088092 \\cdot 10^{152} s^{10} + 1.81720425616362 \\cdot 10^{156} s^{9} + 9.68101996756486 \\cdot 10^{159} s^{8} + 2.78523733270819 \\cdot 10^{163} s^{7} + 4.61082276419168 \\cdot 10^{166} s^{6} + 4.42302462011667 \\cdot 10^{169} s^{5} + 2.3092855641627 \\cdot 10^{172} s^{4} + 5.26274816190945 \\cdot 10^{174} s^{3} + 1.23462727158089 \\cdot 10^{176} s^{2} + 1.58562464429135 \\cdot 10^{177} s}{1.23723035133151 \\cdot 10^{138} s^{13} + 9.03109842002251 \\cdot 10^{142} s^{12} + 2.52584453489403 \\cdot 10^{147} s^{11} + 3.61751373600603 \\cdot 10^{151} s^{10} + 2.98318456418117 \\cdot 10^{155} s^{9} + 1.49468669603524 \\cdot 10^{159} s^{8} + 4.64498538283244 \\cdot 10^{162} s^{7} + 8.94207774340698 \\cdot 10^{165} s^{6} + 1.04012100089085 \\cdot 10^{169} s^{5} + 6.84060443163796 \\cdot 10^{171} s^{4} + 2.16414334805951 \\cdot 10^{174} s^{3} + 2.03409788479151 \\cdot 10^{176} s^{2} + 6.22749151120508 \\cdot 10^{177} s + 4.3753891195515 \\cdot 10^{178}}\\)\\(v_{32} = \\frac{- 2.09392021448787 \\cdot 10^{142} s^{12} - 1.94326032460412 \\cdot 10^{147} s^{11} - 6.02561137520802 \\cdot 10^{151} s^{10} - 7.51406465858297 \\cdot 10^{155} s^{9} - 4.5049667155391 \\cdot 10^{159} s^{8} - 1.41665499765086 \\cdot 10^{163} s^{7} - 2.4997681836795 \\cdot 10^{166} s^{6} - 2.51225462752033 \\cdot 10^{169} s^{5} - 1.35822245396784 \\cdot 10^{172} s^{4} - 3.17780063580552 \\cdot 10^{174} s^{3} - 7.46507632725237 \\cdot 10^{175} s^{2} - 9.6030788316236 \\cdot 10^{176} s}{4.12410117110505 \\cdot 10^{137} s^{13} + 3.0103661400075 \\cdot 10^{142} s^{12} + 8.41948178298009 \\cdot 10^{146} s^{11} + 1.20583791200201 \\cdot 10^{151} s^{10} + 9.94394854727057 \\cdot 10^{154} s^{9} + 4.98228898678412 \\cdot 10^{158} s^{8} + 1.54832846094415 \\cdot 10^{162} s^{7} + 2.98069258113566 \\cdot 10^{165} s^{6} + 3.4670700029695 \\cdot 10^{168} s^{5} + 2.28020147721265 \\cdot 10^{171} s^{4} + 7.21381116019837 \\cdot 10^{173} s^{3} + 6.78032628263838 \\cdot 10^{175} s^{2} + 2.07583050373503 \\cdot 10^{177} s + 1.4584630398505 \\cdot 10^{178}}\\)\\(I_{V1} = - \\frac{s}{1010000.0 s + 10000000.0}\\)\\(I_{O1a} = \\frac{- 2.70597410328679 \\cdot 10^{219} s^{15} - 1.40952219736433 \\cdot 10^{224} s^{14} - 2.89506196813579 \\cdot 10^{228} s^{13} - 3.04164245258279 \\cdot 10^{232} s^{12} - 1.83147809274918 \\cdot 10^{236} s^{11} - 6.73574545204554 \\cdot 10^{239} s^{10} - 1.5665738047603 \\cdot 10^{243} s^{9} - 2.32141567625824 \\cdot 10^{246} s^{8} - 2.14477529599212 \\cdot 10^{249} s^{7} - 1.16030830949982 \\cdot 10^{252} s^{6} - 3.18519845024456 \\cdot 10^{254} s^{5} - 3.09847396565709 \\cdot 10^{256} s^{4} - 8.94956428372171 \\cdot 10^{257} s^{3} - 5.14067180787152 \\cdot 10^{258} s^{2} - 7.57219841131285 \\cdot 10^{258} s}{1.14426033431195 \\cdot 10^{222} s^{15} + 8.35332028071706 \\cdot 10^{226} s^{14} + 2.33666500385672 \\cdot 10^{231} s^{13} + 3.34741928805962 \\cdot 10^{235} s^{12} + 2.76150756989043 \\cdot 10^{239} s^{11} + 1.38442436148026 \\cdot 10^{243} s^{10} + 4.30623628788468 \\cdot 10^{246} s^{9} + 8.30212816663644 \\cdot 10^{249} s^{8} + 9.68123085316084 \\cdot 10^{252} s^{7} + 6.3982750284636 \\cdot 10^{255} s^{6} + 2.04872740406202 \\cdot 10^{258} s^{5} + 2.03099522034642 \\cdot 10^{260} s^{4} + 7.18430910233388 \\cdot 10^{261} s^{3} + 8.56450849506381 \\cdot 10^{262} s^{2} + 3.71961416513097 \\cdot 10^{263} s + 4.97297061330902 \\cdot 10^{263}}\\)\\(I_{O1b} = \\frac{- 4.21097917053769 \\cdot 10^{104} s^{11} - 3.77924980566261 \\cdot 10^{109} s^{10} - 9.92997441757908 \\cdot 10^{113} s^{9} - 8.50908134662235 \\cdot 10^{117} s^{8} - 3.06757906646461 \\cdot 10^{121} s^{7} - 5.59206863004313 \\cdot 10^{124} s^{6} - 5.45154925766715 \\cdot 10^{127} s^{5} - 2.71561053418032 \\cdot 10^{130} s^{4} - 5.46266159572619 \\cdot 10^{132} s^{3} - 1.99716435906042 \\cdot 10^{133} s^{2}}{6.19061587232783 \\cdot 10^{108} s^{11} + 3.97511216027823 \\cdot 10^{113} s^{10} + 9.03793448719942 \\cdot 10^{117} s^{9} + 9.46160582014616 \\cdot 10^{121} s^{8} + 5.02228017639945 \\cdot 10^{125} s^{7} + 1.39853830638757 \\cdot 10^{129} s^{6} + 2.09746585223746 \\cdot 10^{132} s^{5} + 1.64529982131778 \\cdot 10^{135} s^{4} + 5.85337403644487 \\cdot 10^{137} s^{3} + 5.68067815391911 \\cdot 10^{139} s^{2} + 1.75983146094313 \\cdot 10^{141} s + 1.24078374816534 \\cdot 10^{142}}\\)\\(I_{O2a} = \\frac{3.3626013454035 \\cdot 10^{136} s^{13} + 9.65376563272377 \\cdot 10^{141} s^{12} + 6.94781520560786 \\cdot 10^{146} s^{11} + 1.92876721384856 \\cdot 10^{151} s^{10} + 2.22164463155264 \\cdot 10^{155} s^{9} + 1.24858671565291 \\cdot 10^{159} s^{8} + 3.76102357261743 \\cdot 10^{162} s^{7} + 6.4489486322457 \\cdot 10^{165} s^{6} + 6.35343543582645 \\cdot 10^{168} s^{5} + 3.38584747530741 \\cdot 10^{171} s^{4} + 7.83854999479935 \\cdot 10^{173} s^{3} + 1.8403929052726 \\cdot 10^{175} s^{2} + 2.36593974661912 \\cdot 10^{176} s}{5.93870568639127 \\cdot 10^{140} s^{13} + 4.3349272416108 \\cdot 10^{145} s^{12} + 1.21240537674913 \\cdot 10^{150} s^{11} + 1.73640659328289 \\cdot 10^{154} s^{10} + 1.43192859080696 \\cdot 10^{158} s^{9} + 7.17449614096913 \\cdot 10^{161} s^{8} + 2.22959298375957 \\cdot 10^{165} s^{7} + 4.29219731683535 \\cdot 10^{168} s^{6} + 4.99258080427609 \\cdot 10^{171} s^{5} + 3.28349012718622 \\cdot 10^{174} s^{4} + 1.03878880706857 \\cdot 10^{177} s^{3} + 9.76366984699927 \\cdot 10^{178} s^{2} + 2.98919592537844 \\cdot 10^{180} s + 2.10018677738472 \\cdot 10^{181}}\\)\\(I_{O2b} = \\frac{2.03114459659645 \\cdot 10^{202} s^{15} - 5.41693661192227 \\cdot 10^{208} s^{14} - 5.04785253855921 \\cdot 10^{213} s^{13} - 1.53008409272363 \\cdot 10^{218} s^{12} - 1.81469537957374 \\cdot 10^{222} s^{11} - 1.03167063298355 \\cdot 10^{226} s^{10} - 3.12503707997176 \\cdot 10^{229} s^{9} - 5.37863302316374 \\cdot 10^{232} s^{8} - 5.31943071374497 \\cdot 10^{235} s^{7} - 2.85232586842996 \\cdot 10^{238} s^{6} - 6.71226680183562 \\cdot 10^{240} s^{5} - 1.97687215290958 \\cdot 10^{242} s^{4} - 3.0724877848804 \\cdot 10^{243} s^{3} - 1.58099876055239 \\cdot 10^{244} s^{2} - 2.1981591906048 \\cdot 10^{244} s}{4.57704133724782 \\cdot 10^{207} s^{15} + 3.34132811228682 \\cdot 10^{212} s^{14} + 9.34666001542689 \\cdot 10^{216} s^{13} + 1.33896771522385 \\cdot 10^{221} s^{12} + 1.10460302795617 \\cdot 10^{225} s^{11} + 5.53769744592102 \\cdot 10^{228} s^{10} + 1.72249451515387 \\cdot 10^{232} s^{9} + 3.32085126665458 \\cdot 10^{235} s^{8} + 3.87249234126433 \\cdot 10^{238} s^{7} + 2.55931001138544 \\cdot 10^{241} s^{6} + 8.19490961624807 \\cdot 10^{243} s^{5} + 8.12398088138566 \\cdot 10^{245} s^{4} + 2.87372364093355 \\cdot 10^{247} s^{3} + 3.42580339802553 \\cdot 10^{248} s^{2} + 1.48784566605239 \\cdot 10^{249} s + 1.98918824532361 \\cdot 10^{249}}\\)\n\n\n\n\n38.6.2 Magnitude and Phase Response\nThe voltage transfer function, \\(\\frac{v2(s)}{v1(s)}\\), is calculated below.\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\cdot \\left(1.60460486959839 \\cdot 10^{204} s^{15} + 3.27859737275232 \\cdot 10^{209} s^{14} + 2.24239224921523 \\cdot 10^{214} s^{13} + 6.17846960611372 \\cdot 10^{218} s^{12} + 6.98631389088568 \\cdot 10^{222} s^{11} + 3.84144613823827 \\cdot 10^{226} s^{10} + 1.14176089090876 \\cdot 10^{230} s^{9} + 1.9487479169721 \\cdot 10^{233} s^{8} + 1.9264469914375 \\cdot 10^{236} s^{7} + 1.04007382786928 \\cdot 10^{239} s^{6} + 2.4949612511751 \\cdot 10^{241} s^{5} + 8.71156576910649 \\cdot 10^{242} s^{4} + 1.59377116458413 \\cdot 10^{244} s^{3} + 5.83569842526406 \\cdot 10^{244} s^{2}\\right)}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\n\n\nThe SciPy function bode is used to calculate the magnitude and phase of the transfer function.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nRead the frequency response data from LTSpice so the LTSpice and Python results plots can be overlaid for comparison.\n\nfn = 'Klon-Centaur_v2_freq_resp.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nH_v2 = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    H_v2[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results using np.unwrap(2 * phase) / 2) to keep the phase plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(H_v2)[0:-1]),'-k',label='LTSpice sch v2 mag')    # LTSpice magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-r',label='MNA mag, dB')    # MNA magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\nplt.legend(loc='upper right')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(H_v2)[0:-1]/2) *180/np.pi,':',color='k',label='LTSpice phase')  # LTSpice phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='r',label='MNA phase')  # MNA phase plot\nplt.legend(loc='lower right')\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 38.10: LTSpice and MNA data magnitude and phase response plotted for comparison\n\n\n\n\n\nAs shown above, there is a slight difference between the MNA results and the LTSpice simulation, but generally there is good agreement. The LTSpice simulation is using device models for the diodes and Op Amps which accounts for the slight differences.\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the voltage transfer function are plotted on the complex frequency plane.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Complex plane Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane and the units are in radian frequency. These values are printed in the following table.\n\ntable_header = ['Zeros, rad/s', 'Poles, rad/s']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:,.2f}'.format(sys_zeros[i])\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:,.2f}'.format(sys_poles[i])\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, rad/s       Poles, rad/s\n-----------------  --------------\n-95,456.35+0.00j   -29,089.84\n-60,141.16+0.00j   -15,995.02\n-31,576.17+0.00j   -7,530.71\n-7,000.27+0.00j    -6,076.07\n-4,086.01+0.00j    -5,671.58\n-1,544.35+0.00j    -3,111.00\n-1,226.10+53.30j   -1,758.48\n-1,226.10-53.30j   -1,455.33\n-1,015.01+250.67j  -1,132.02\n-1,015.01-250.67j  -1,047.53\n-16.52+17.66j      -75.51\n-16.52-17.66j      -41.49\n-4.72+0.00j        -9.90\n0.00+0.00j         -4.97\n0.00+0.00j         -2.47\n\n\n\n38.6.2.1 Square Wave Response\nThe SciPy function lsim was used to calculate the time domain response to a 10 Hz square wave. The input amplitude is scaled and level shifted to produce a 0 to 50 mV signal which keeps the levels at node 16 below the diode conduction level.\n\nt = np.linspace(0, 0.2, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*10*t, duty=0.5)/40+1/40\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.ylim((-.4,.4))\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the input square wave in red and the out signal in blue. The signal path is AC coupled as indicated by the lack of DC response in the plot. The decay time is a bit over 25 ms.\nAt the leading edge of the square wave input, there is about a 250 mV spike, which suggests a large AC gain in the circuit because the abrupt change in the input signal at the leading edge of steps of the square wave produces substantial harmonic components within the pass band of the pedal’s frequency response.\nThe square wave simulation data from LTSpice was loaded in the JupyterLab notebook so that the data could be overlaid along with the NMA solution.\n\nfn = 'Klon-Centaur_v2_square_wave.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# initialize some empty arrays\ntime = np.zeros(len(LTSpice_data))\nvoltage1 = np.zeros(len(LTSpice_data))\nvoltage2 = np.zeros(len(LTSpice_data))\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    time[i] = LTSpice_data[i][0]\n    voltage1[i] = LTSpice_data[i][1]\n    voltage2[i] = LTSpice_data[i][2]\n\nThe code below generates the plots for the LTSpice and Python MNA data.\n\nplt.title('LTSpice and Python MNA results')\n\n#plt.plot(time, voltage1, 'g', alpha = 1.0, linewidth=1, label='LTSpice v1(t)')\nplt.plot(time, voltage2, '-.r', alpha = 1.0, linewidth=2, label='LTSpice v2(t)')\n\n#plt.plot(t_step, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', alpha = 1.0, linewidth = 1.0, label='Python MNA result')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, there is close agreement between the two solutions in both the frequency and time domain for input signal levels and gain settings that do not produce node voltages at node 16 with levels that would drive the diodes into conduction.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#summary-for-part-2",
    "href": "Klon Centaur part 2v0.html#summary-for-part-2",
    "title": "38  Klon Centaur, part 2",
    "section": "38.7 Summary for part 2",
    "text": "38.7 Summary for part 2\nThe semiconductor parts used in the pedal were described as well as the SPICE device models used in the LTSpice simulations. The MNA method can not easily handle the non-linear operation resulting from saturated Op Amp outputs or forwarded biased diodes. LTSpice was used to examine the operating point where the Op Amps would be driven into saturation.\nFrom the analysis it appears that output of \\(U_{1A}\\) could be clipping the signal at some combinations of input level and gain. Python was used to display the results of LTSpice transient analysis and the harmonic content of the distorted signal was plotted. The operation of the pedal with actual music signals as inputs was simulated. This illustrates how MNA can be used in conjunction with LTSpice to do circuit analysis and generate reports.\nFinally analysis results obtained from LTSpice were compared to the Python MNA results. The magnitude, phase and time domain plots superimpose giving us confidence that the Python analysis results are correct.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Klon Centaur, part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html",
    "href": "Klon Centaur part 3v1.html",
    "title": "39  Klon Centaur, part 3",
    "section": "",
    "text": "39.1 Design Review\nThis section is not a formal design review, but will only present some comments and concerns that might have come up at design review. I don’t know if Finnegan ever conducted any design reviews as is typically done in industry. In hindsight he should have taken steps to legally protect his design beyond trademarking the CENTAUR ™ name. I suppose at the time he didn’t know how popular his pedal would become and lack of funds limited his ability to patent Klon Centaur design. There are many examples of electric circuits that have been patented and Finnegan could have sought out help from friends to help with this aspect. He was naive to think that covering the components with black goop (epoxy) would keep his circuit a secret. Additionally, starting a business based on a product that had a critical component, the Germanium diodes, in extremely limited supply was shortsighted.\nIt has been reported that Finnegan worked with MIT graduate Fred Fenning and other electrical engineer friends on this project. The description of the development is a little vague but sounded like the design flow was mainly building prototype circuits, fiddling with the design and Finnegan doing evaluation and playing tests to get the tone he wanted. The design and development of the pedal took four and half years.\nSometimes it’s hard to describe exactly what makes something popular, but it’s evident that Finnegan’s goal to build a pedal that would provide guitar players with an open, transparent tone, similar to that of a turned-up tube amplifier, was unique and successful. The scarcity of original pedals contributes to them being coveted, valuable and copied. The ability to blend clean and distortion at low to high volume levels is what made this pedal unique at the time.\nHere are a few comments that I would provide during a design review:",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Klon Centaur, part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#sec-design_review",
    "href": "Klon Centaur part 3v1.html#sec-design_review",
    "title": "39  Klon Centaur, part 3",
    "section": "",
    "text": "The circuit analysis present in Part 1, Figure 37.15, shows that Clean Path 1 seems to contribute minimally to the output of the pedal, since the signal on this path gets covered over by signals on the other paths. I think the design could be simplified by removing this path. Blind listing tests would validate this assertion.\nThe analysis presented in Section 39.3.3 seems to show that the function of this path is somewhat superfluous since the zero created by \\(C_{13}\\) and \\(R_{20}\\) negates the frequency emphasis created by this path.\nThe use of the dual gang pot, \\(P_1\\), to blend Clean Path 2 and the diode path should be evaluated. Perhaps there is a way the blending could be accomplished with a single pot. This would simplify the bill of materials and wiring the connections of the printed circuit board (PCB) to \\(P_1\\).\nIt seems that loud playing at gains of more than 50% will saturate U1b, those harmonics will color the tone. This aspect of the signal flow through the pedal needs to be examined more closely to determine if this is a desirable effect. Although, \\(D_2\\) and \\(D_3\\) will re-shape the harmonics.\nThe internal wiring of the PCB to \\(S_1\\), \\(D_1\\) and the pots could be simplified to make assembly and production simplified.\nThe use of hand selected Germanium diodes is a problem since this limits future production with a parts obsolescence problem down the road.\nA tolerance, reliability and temperature analysis of the design should be done. The mix of carbon and metal film resistors is unusual and contributes to a longer Bill of Materials (BOM).\nOther reviews such as: requirements review, production readiness review, documentation review, testing review",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Klon Centaur, part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#klon-centaur-clones",
    "href": "Klon Centaur part 3v1.html#klon-centaur-clones",
    "title": "39  Klon Centaur, part 3",
    "section": "39.2 Klon Centaur Clones",
    "text": "39.2 Klon Centaur Clones\nThe Klon Centaur is one of the most legendary and sought-after overdrive pedals in guitar history and clones stem from a few key factors. Bill Finnegan famously “gooped” (covered in epoxy resin) the circuit board of the original Centaurs to prevent replication. However, the circuit was eventually reverse-engineered and schematics became available online around 2008. The limited production of the original Klons (around 8,000 units) and their legendary status led to extremely high prices on the secondary market. This created a huge demand for more affordable alternatives.\nOnce the circuit was reverse engineered, several manufacturers began producing clones. These variations emerged for several reasons. Primarily to offer the Klon sound at a much lower price point and sourcing the exact original components (especially certain germanium diodes) became difficult and expensive, leading manufacturers to use readily available alternatives that aim to replicate the sound.\nIn 2014, Finnegan released the Klon KTR, a redesigned version intended for mass production. It uses surface-mount device (SMD) components, is smaller, and includes a buffered/true bypass selector. While the circuit is fundamentally the same as the original, the change in manufacturing methods and component types (even if the same type components, like germanium diodes) can lead to subtle differences that some purists notice.\nMany clones (Klones) introduce “improvements” or additional features that weren’t on the original, such as:\n\nBass boost switches (to address the Klon’s subtle low-end roll-off).\nDifferent clipping diode options (silicon, LED, other germanium types) offer different overdrive textures.\nSeparate clean blend and gain controls (the original Klon uses a dual-ganged gain pot that blends clean and over driven signals).\nSmaller enclosures.\nTrue bypass versus a buffered bypass option.\n\nIn essence, the Klon Centaur variations exist due to a combination of intentional minor adjustments by the original creator, the need to adapt the design for wider production (KTR), and the extensive efforts of other manufacturers to replicate, modify, and improve upon a highly sought-after and influential circuit.\nThere are many pedals inspired by the Klon Centaur, here are a few:\n\nWampler Tumnus Overdrive Pedal: This is a very popular Klon clone that captures the essence of the Klon Centaur in a compact and affordable package. It has a wide range of gain on tap, from a subtle boost to a more overdriven sound. It also has a toggle switch that allows you to select between two different clipping voicings.\nEarthQuaker Devices Westwood Translucent Overdrive: This pedal is a bit more of a modern take on the Klon Centaur sound. It has a more aggressive clipping section that can add a bit more bite to your overdrive sound. It also has a three-band EQ that allows you to dial in your tone precisely.\nJ Rockett Rockaway Archer: This pedal is another well-regarded Klon clone that is known for its versatility. It has a wide range of gain on tap, as well as a toggle switch that allows you to select between two different clipping voicings. It also has a built-in clean boost that can be used to push your amp into overdrive.\nTone City Bad Horse Overdrive: This is a very affordable Klon clone that is surprisingly good. It captures the essence of the Klon Centaur sound in a compact and affordable package. However, it is not quite as transparent as some of the other pedals on this list.\nBest Klon clones 2024: Our pick of the best Klon Centaur Klones for every budget: From straight-up clones to full reimaginings, here are some of the best Klon Centaur-inspired pedals on the market today.\nWay Huge Smalls Deep State Conspiracy Theory Diodes Overdrive: The following bit of snake oil can be found in their product description:\n\nThe Way Huge Deep State Overdrive is a limited-edition guitar pedal designed to emulate the sound of the Klon Centaur, a highly sought-after overdrive pedal from the mid-1990s. The Deep State utilizes a unique diode that Way Huge’s “resident mad scientist” Jeorge Tripps discovered. Tripps’ discovery of the diode was accidental and occurred during an experiment where he inserted the diodes into a Conspiracy Theory overdrive. Way Huge describes this diode as having a “truly magical-sounding voltage drop,” resulting in “smooth, velvety clipping” that is very responsive to playing dynamics.\n\n\nA recent development in the world of Klon clones is that a legal complaint was filed in United States District Court, District of Massachusetts by Klon LLC against Empower Tribe, dated May 30, 2025. It seems the essence of the complaint centers around the use of Klon’s registered “CENTAUR” Trade Mark on Behringer’s CENTARA OVERDRIVE pedal, which has now been branded as “CENTARA”, but originally called “CENTAUR”.\nKlon obtained two U.S. trademark registrations for the CENTAUR:\n\nU.S. Reg. No. 5661741, registered on January 22, 2019, for electronic effects pedals, foot pedals, guitar pedals, sound effect pedals (Class 15), and repair/maintenance services (Class 37).\nU.S. Reg. No. 6147899, registered on September 8, 2020, for electronic effects pedals, sound effect pedals (Class 9), foot pedals, and guitar pedals (Class 15).\n\nAside from the trademarked “Centaur” name, the pedal’s circuits, function and operation do not seem to be protected intellectual property.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Klon Centaur, part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#sec-analysis_of_reactive_branches",
    "href": "Klon Centaur part 3v1.html#sec-analysis_of_reactive_branches",
    "title": "39  Klon Centaur, part 3",
    "section": "39.3 Analysis of Reactive Branches",
    "text": "39.3 Analysis of Reactive Branches\nThe following analysis will examine some of the reactive branches in the pedal’s circuits. A branch is essentially a portion of a circuit that contains one or more circuit elements (like resistors, capacitors, inductors etc.), connects two nodes and provides a topological framework for describing and analyzing the interconnections of components within an electrical circuit. In electrical circuits, reactive branches are branches that contain components that store and release energy rather than simply dissipating it as heat. These components are primarily inductors and capacitors. We want to answer the question - what are the components in this branch of the circuit doing? We have to be careful about loading effects provided by the other components attached to the branch we are analyzing that have been excluded. With this in mind, we can attempt to provide an intuitive explanation of the circuit’s operation.\n\nThe following Python modules are used in this JupyterLab notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\nfrom tabulate import tabulate\ninit_printing()\n\nThe function below is used to display less digits when printing equations. It was copied from stackoverflow from the link provided in the comment.\n\ndef round_expr(expr, num_digits):\n    '''\n    from stackoverflow, used to display fewer digits\n    https://stackoverflow.com/questions/48491577/printing-the-output-rounded-to-3-decimals-in-sympy\n    '''\n    return expr.xreplace({n : round(n, num_digits) for n in expr.atoms(Number)})\n\n\n39.3.1 Reactive Branch 1\nThe circuit shown below is reactive branch 1. This circuit is a modified version of the circuit path analyzed in Section 37.11.1 and is a slightly modified version of the highlighted portion of circuit shown in Figure 37.15.\nThis circuit branch starts at the output of Op Amp \\(U_{1A}\\) and follows the components \\(C_3\\), \\(R_7\\) and \\(R_{24}\\) to the Op Amp \\(U_{2A}\\). Components \\(R_6\\), \\(C_5\\), \\(P_1\\) and \\(C_{16}\\) connect to circuit nodes along the branch of interest. The output of \\(U_{1A}\\) is replaced by the independent voltage source \\(V_1\\). The inverting input of \\(U_{2A}\\) is connected to \\(R_{24}\\) and this is the summing junction for other signal paths in the Klon Centaur. \\(C_3\\) acts as a DC block. The components, \\(C_5\\), \\(R_6\\) and \\(P_1\\) on node 3, and components \\(R_7\\) and \\(C_16\\) complete a low pass filter section ending at node 5.\nThe components,\\(R_{24}\\), \\(R_{20}\\) and \\(U_{2A}\\) are configured as an inverting amplifier with a gain of \\(\\frac{R_{20}}{R_{24}}\\).\nThe circuit shown below is effectively a low pass filter with a DC block. \\(C_3\\) will block low frequencies down to DC. \\(C_4\\), \\(R_6\\) and \\(R_{p1b}\\) will put a zero in the transfer function along with \\(C_3\\). Given that there are three capacitors in the circuit, there are likely three poles in the voltage transfer function. \\(C_{13}\\) in the feedback of \\(U_{2A}\\) was omitted from the analysis so that the operation of the circuit could be analyzed without the pole created by \\(R_{20}\\) and \\(C_{13}\\) from dominating the frequency response of the transfer function.\nThe component \\(R_{p1b1}\\) in Figure 39.1 is one of the dual ganged pots in \\(P_1\\). The wiper of \\(P_1\\) is connected to ground. Node 4 in the schematic below is connected to the non-inverting input of \\(U_{1B}\\), but this connection is being ignored for this analysis since \\(U_{1B}\\) is not on the signal path we are interested in. We can still get an idea of what the components shown in the schematic are doing, but the exact location of the poles and zeros will be a little off.\n\n\n\n\n\n\nFigure 39.1: Schematic of reactive branch 1.\n\n\n\nThe netlist below was exported from LTSpice.\n\nreactive_branch_1_net_list = '''\n* Klon-Centaur_sum_path1_v1.asc\nV1 1 0 1\nC3 3 1 100e-9\nR6 4 3 10e3\nC5 4 3 68e-9\nR7 3 5 1.5e3\nR24 6 5 15e3\nC16 5 0 1e-6\nRp1b 0 4 50e3\nO2a 6 0 2\nR20 2 6 392e3\n*C13 2 6 820e-12\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_1_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{3} s v_{1} - C_{3} s v_{3} + I_{V1}\\)\\(0 = I_{O2a} + \\frac{v_{2}}{R_{20}} - \\frac{v_{6}}{R_{20}}\\)\\(0 = - C_{3} s v_{1} + v_{3} \\left(C_{3} s + C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) + v_{4} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) - \\frac{v_{5}}{R_{7}}\\)\\(0 = v_{3} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) + v_{4} \\left(C_{5} s + \\frac{1}{Rp1b} + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{5} \\left(C_{16} s + \\frac{1}{R_{7}} + \\frac{1}{R_{24}}\\right) - \\frac{v_{3}}{R_{7}} - \\frac{v_{6}}{R_{24}}\\)\\(0 = v_{6} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{5}}{R_{24}} - \\frac{v_{2}}{R_{20}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{6}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n39.3.1.1 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the node voltages and dependent currents using symbolic notation.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{3} C_{5} R_{20} R_{6} Rp1b V_{1} s^{2} - C_{3} R_{20} R_{6} V_{1} s - C_{3} R_{20} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{3} = \\frac{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b V_{1} s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} V_{1} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b V_{1} s^{2} + C_{3} R_{24} R_{6} V_{1} s + C_{3} R_{24} Rp1b V_{1} s + C_{3} R_{6} R_{7} V_{1} s + C_{3} R_{7} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{4} = \\frac{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b V_{1} s^{3} + C_{16} C_{3} R_{24} R_{7} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b V_{1} s^{2} + C_{3} R_{24} Rp1b V_{1} s + C_{3} R_{7} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{5} = \\frac{C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{2} + C_{3} R_{24} R_{6} V_{1} s + C_{3} R_{24} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{6} = 0\\)\\(I_{V1} = \\frac{- C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} V_{1} s^{3} - C_{16} C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{3} - C_{16} C_{3} R_{24} R_{6} V_{1} s^{2} - C_{16} C_{3} R_{24} R_{7} V_{1} s^{2} - C_{16} C_{3} R_{24} Rp1b V_{1} s^{2} - C_{3} C_{5} R_{24} R_{6} V_{1} s^{2} - C_{3} C_{5} R_{6} R_{7} V_{1} s^{2} - C_{3} C_{5} R_{6} Rp1b V_{1} s^{2} - C_{3} R_{24} V_{1} s - C_{3} R_{6} V_{1} s - C_{3} R_{7} V_{1} s - C_{3} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(I_{O2a} = \\frac{C_{3} C_{5} R_{6} Rp1b V_{1} s^{2} + C_{3} R_{6} V_{1} s + C_{3} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{- C_{3} C_{5} R_{20} R_{6} Rp1b s^{2} - C_{3} R_{20} R_{6} s - C_{3} R_{20} Rp1b s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\n\n\nThe numerator is a second order polynomial and the denominator is a third order polynomial. Generally, the order of the dominator is equal to the number of reactive elements in the circuit; sometimes roots of the numerator will exactly cancel with a root of the denominator polynomial. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n39.3.1.2 Numerator Polynomial of \\(H_{sym}(s)\\)\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=- C_{3} C_{5} R_{20} R_{6} Rp1b s^{2} - C_{3} R_{20} R_{6} s - C_{3} R_{20} Rp1b s\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$&lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=- C_{3} C_{5} R_{20} R_{6} Rp1b\\)\n\n\n\\(b_1=- C_{3} R_{20} R_{6} - C_{3} R_{20} Rp1b\\)\n\n\n\\(b_0=0\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nMarkdown('There are {:d} zeros, which are:\\\n    &lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;'.format(len(num_root_sym),latex(num_root_sym[0]),latex(num_root_sym[1])))\n\nThere are 2 zeros, which are:\n\n\\(z_0=0\\)\n\n\n\\(z_1=\\frac{- R_{6} - Rp1b}{C_{5} R_{6} Rp1b}\\)\n\n\n\n\\(C_3\\) is responsible for the zero at \\(\\omega=0\\) since this capacitor provids an open circuit at DC.\n\n\n39.3.1.3 Denominator Polynomial of \\(H_{sym}(s)\\)\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_3s^3+a_2s^2+a_1s+a_0\\)\nwhere \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\na3 = H_sym_denom.coeff(s**3)\na2 = H_sym_denom.coeff(s**2)\na1 = H_sym_denom.coeff(s**1)\na0 = (H_sym_denom - a1*s*1 - a2*s**2 - a3*s**3).expand()\nMarkdown('&lt;p&gt;$a_3={:s}$&lt;/p&gt;&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;\\\n    $a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a3),\n    latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_3=C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b\\)\n\n\n\\(a_2=C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\)\n\n\n\\(a_1=C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\)\n\n\n\\(a_0=R_{24} + R_{6} + R_{7} + Rp1b\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transfer function, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are:\\\n    &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;&lt;p&gt;$p_2={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1]),latex(denom_root_sym[2])))\n\nThere are 3 poles, which are:\n\n\\(p_0=- \\frac{- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}}{3} - \\frac{C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b}{3 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b}\\)\n\n\n\\(p_1=- \\frac{- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}}{3} - \\frac{C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b}{3 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b}\\)\n\n\n\\(p_2=- \\frac{- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}}{3} - \\frac{C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b}{3 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b}\\)\n\n\n\nThe expressions for the poles of \\(H(s)\\) are rather long and not very intuitive.\n\n\n39.3.1.4 Numerical Solution for P1 at 50%\nThe network equations can be numerically solved when the element values are included in the calculations. The solution below is for when \\(R_{p1b1}\\) is set to 50%.\n\nequ_N = NE_sym.subs(element_values)\n\nWe get the following numerical network equations:\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],8)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\n\n\n\\(0 = I_{O2a} + 2.55 \\cdot 10^{-6} v_{2} - 2.55 \\cdot 10^{-6} v_{6}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} + v_{3} \\cdot \\left(1.7 \\cdot 10^{-7} s + 0.00076667\\right) + v_{4} \\left(- 7.0 \\cdot 10^{-8} s - 0.0001\\right) - 0.00066667 v_{5}\\)\n\n\n\\(0 = v_{3} \\left(- 7.0 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(7.0 \\cdot 10^{-8} s + 0.00012\\right)\\)\n\n\n\\(0 = - 0.00066667 v_{3} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.00073333\\right) - 6.667 \\cdot 10^{-5} v_{6}\\)\n\n\n\\(0 = - 2.55 \\cdot 10^{-6} v_{2} - 6.667 \\cdot 10^{-5} v_{5} + 6.922 \\cdot 10^{-5} v_{6}\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = v_{6}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{- 2.6656 \\cdot 10^{29} s^{2} - 4.704 \\cdot 10^{32} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{3} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.822 \\cdot 10^{28} s^{2} + 1.98 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{4} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{5} = \\frac{1.02 \\cdot 10^{28} s^{2} + 1.8 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{6} = 0.0\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 2.6656 \\cdot 10^{29} s^{2} - 4.704 \\cdot 10^{32} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n\n\n39.3.1.5 Pole Zero Plot\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob',\n    markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-280.86      -1198.55\n0.00         -279.87\n             -12.02\n\n\n\n\n39.3.1.6 Reactive Branch 1 Frequency Response\nThe transfer function \\(H(s)=\\frac{v2}{v1}\\) is analyzed for various settings of the Gain control, P1. The gain setting is in steps of percentage of full scale, from 1 to 99% and is plotted below.\n\n# setup\nx_axis = np.logspace(0, 5, 2000, endpoint=True)*2*np.pi\ncolor_list = ['tab:blue','tab:purple','tab:brown','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,2.5,9.75,25,50,75,99])/100\np1_value = 100e3\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1b] = p1_value - gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1] #U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((1,100e3))\nax1.set_ylim((-60,10))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the band pass characteristic of the circuit in Figure 39.1. The highlighted frequencies are the guitar audio band. Rotation of \\(P_{1B}\\) has a limited effect in this path. Keep in mind that a pole at 500 Hz from \\(C_{13}\\) is not included which would move the low pass corner frequency considerably lower if it was included.\n\n\n\n39.3.2 Reactive Branch 2\nThe circuit shown below is reactive branch 2. This circuit is part of the circuit path analyzed in Section 37.11.3 and is a slightly modified version of the highlighted portion of circuit shown in Figure 37.19.\n\n\n\n\n\n\nFigure 39.2: Schematic of reactive branch 2.\n\n\n\nThe schematic above includes the components that are in the feed back loop around U1B. \\(P_1\\) is modeled by two resistors, Rp1a1 and Rp1b1. The wiper of P1 is connected to ground. When \\(P_1\\) fully clockwise, \\(V_1\\) is shunted by the full value of \\(P_1\\), which is 100 k\\(\\Omega\\), and node 3 is effectively connected to ground. When \\(P_1\\) is fully counter clockwise, the wiper, which is connected to ground is effectively grounding \\(V_1\\) and the non-inverting terminal of \\(U_{1B}\\), which prevents the signal from propagating to \\(U_{1B}\\).\nThe parallel combination of \\(C_8\\) and \\(R_{12}\\) along with \\(C_7\\) and \\(R_{11}\\) determine the frequency response. The netlist below was exported from LTSpice.\n\nreactive_branch_2_net_list = '''\n*reactive_branch_2.asc\nV1 1 0 1\nRp1b1 0 1 50e3\nRp1a1 3 0 50e3\nR10 4 3 2e3\nR11 5 4 15e3\nC7 5 4 82e-9\nC8 2 5 390e-12\nR12 2 5 422e3\nO1B 5 1 2\n'''\n\nUsing the function SymMNA.smna generate the network equations from the MNA matrices and display the equations.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_2_net_list)\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{Rp1b1}\\)\\(0 = I_{O1b} + v_{2} \\left(C_{8} s + \\frac{1}{R_{12}}\\right) + v_{5} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right)\\)\\(0 = v_{3} \\cdot \\left(\\frac{1}{Rp1a1} + \\frac{1}{R_{10}}\\right) - \\frac{v_{4}}{R_{10}}\\)\\(0 = v_{4} \\left(C_{7} s + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) + v_{5} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{10}}\\)\\(0 = v_{2} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right) + v_{4} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) + v_{5} \\left(C_{7} s + C_{8} s + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right)\\)\\(V_{1} = v_{1}\\)\\(0 = - v_{1} + v_{5}\\)\n\n\nTurn the free symbols into SymPy variables and load the element values.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n39.3.2.1 Symbolic solution\nThe network equations for the circuit in Figure 39.2 can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{7} C_{8} R_{10} R_{11} R_{12} V_{1} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 V_{1} s^{2} + C_{7} R_{10} R_{11} V_{1} s + C_{7} R_{11} R_{12} V_{1} s + C_{7} R_{11} Rp1a1 V_{1} s + C_{8} R_{10} R_{12} V_{1} s + C_{8} R_{11} R_{12} V_{1} s + C_{8} R_{12} Rp1a1 V_{1} s + R_{10} V_{1} + R_{11} V_{1} + R_{12} V_{1} + Rp1a1 V_{1}}{C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\\(v_{3} = \\frac{C_{7} R_{11} Rp1a1 V_{1} s + Rp1a1 V_{1}}{C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\\(v_{4} = \\frac{C_{7} R_{10} R_{11} V_{1} s + C_{7} R_{11} Rp1a1 V_{1} s + R_{10} V_{1} + Rp1a1 V_{1}}{C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{V_{1}}{Rp1b1}\\)\\(I_{O1b} = \\frac{- C_{7} R_{11} V_{1} s - V_{1}}{C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} R_{12} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + R_{12} + Rp1a1}{C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\n\n\nBoth the numerator and denominator are second order polynomials.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n39.3.2.2 Numerator Polynomial\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} R_{12} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + R_{12} + Rp1a1\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$\\\n    &lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=C_{7} C_{8} R_{10} R_{11} R_{12} + C_{7} C_{8} R_{11} R_{12} Rp1a1\\)\n\n\n\\(b_1=C_{7} R_{10} R_{11} + C_{7} R_{11} R_{12} + C_{7} R_{11} Rp1a1 + C_{8} R_{10} R_{12} + C_{8} R_{11} R_{12} + C_{8} R_{12} Rp1a1\\)\n\n\n\\(b_0=R_{10} + R_{11} + R_{12} + Rp1a1\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nMarkdown('There are {:d} zeros, which are:\\\n    &lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;'.format(len(num_root_sym),latex(num_root_sym[0]),latex(num_root_sym[1])))\n\nThere are 2 zeros, which are:\n\n\\(z_0=\\frac{- C_{7} R_{10} R_{11} - C_{7} R_{11} R_{12} - C_{7} R_{11} Rp1a1 - C_{8} R_{10} R_{12} - C_{8} R_{11} R_{12} - C_{8} R_{12} Rp1a1 - \\sqrt{C_{7}^{2} R_{10}^{2} R_{11}^{2} + 2 C_{7}^{2} R_{10} R_{11}^{2} R_{12} + 2 C_{7}^{2} R_{10} R_{11}^{2} Rp1a1 + C_{7}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{7}^{2} R_{11}^{2} R_{12} Rp1a1 + C_{7}^{2} R_{11}^{2} Rp1a1^{2} - 2 C_{7} C_{8} R_{10}^{2} R_{11} R_{12} - 2 C_{7} C_{8} R_{10} R_{11}^{2} R_{12} - 2 C_{7} C_{8} R_{10} R_{11} R_{12}^{2} - 4 C_{7} C_{8} R_{10} R_{11} R_{12} Rp1a1 + 2 C_{7} C_{8} R_{11}^{2} R_{12}^{2} - 2 C_{7} C_{8} R_{11}^{2} R_{12} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12}^{2} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12} Rp1a1^{2} + C_{8}^{2} R_{10}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{11} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{11} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{12}^{2} Rp1a1^{2}}}{2 C_{7} C_{8} R_{11} R_{12} \\left(R_{10} + Rp1a1\\right)}\\)\n\n\n\\(z_1=\\frac{- C_{7} R_{10} R_{11} - C_{7} R_{11} R_{12} - C_{7} R_{11} Rp1a1 - C_{8} R_{10} R_{12} - C_{8} R_{11} R_{12} - C_{8} R_{12} Rp1a1 + \\sqrt{C_{7}^{2} R_{10}^{2} R_{11}^{2} + 2 C_{7}^{2} R_{10} R_{11}^{2} R_{12} + 2 C_{7}^{2} R_{10} R_{11}^{2} Rp1a1 + C_{7}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{7}^{2} R_{11}^{2} R_{12} Rp1a1 + C_{7}^{2} R_{11}^{2} Rp1a1^{2} - 2 C_{7} C_{8} R_{10}^{2} R_{11} R_{12} - 2 C_{7} C_{8} R_{10} R_{11}^{2} R_{12} - 2 C_{7} C_{8} R_{10} R_{11} R_{12}^{2} - 4 C_{7} C_{8} R_{10} R_{11} R_{12} Rp1a1 + 2 C_{7} C_{8} R_{11}^{2} R_{12}^{2} - 2 C_{7} C_{8} R_{11}^{2} R_{12} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12}^{2} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12} Rp1a1^{2} + C_{8}^{2} R_{10}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{11} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{11} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{12}^{2} Rp1a1^{2}}}{2 C_{7} C_{8} R_{11} R_{12} \\left(R_{10} + Rp1a1\\right)}\\)\n\n\n\n\n\n39.3.2.3 Denominator Polynomial\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + Rp1a1\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_3s^3+a_2s^2+a_1s+a_0\\)\nwhere \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\n\n\n\n\\(a_2=C_{7} C_{8} R_{10} R_{11} R_{12} + C_{7} C_{8} R_{11} R_{12} Rp1a1\\)\n\n\n\\(a_1=C_{7} R_{10} R_{11} + C_{7} R_{11} Rp1a1 + C_{8} R_{10} R_{12} + C_{8} R_{11} R_{12} + C_{8} R_{12} Rp1a1\\)\n\n\n\\(a_0=R_{10} + R_{11} + Rp1a1\\)\n\n\n\nThe roots of the denominator polynomial can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are:\\\n    &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1])))\n\nThere are 2 poles, which are:\n\n\\(p_0=- \\frac{1}{C_{8} R_{12}}\\)\n\n\n\\(p_1=\\frac{- R_{10} - R_{11} - Rp1a1}{C_{7} R_{11} \\left(R_{10} + Rp1a1\\right)}\\)\n\n\n\n\n\n39.3.2.4 Numerical Solution for P1 at 50%\nA numerical solution for the network equations is obtained for P1 at 50% rotation. The element values are substituted into the equations and displayed.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],6)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 2.0 \\cdot 10^{-5} v_{1}\\)\n\n\n\\(0 = I_{O1b} + 2.0 \\cdot 10^{-6} v_{2} - 2.0 \\cdot 10^{-6} v_{5}\\)\n\n\n\\(0 = 0.00052 v_{3} - 0.0005 v_{4}\\)\n\n\n\\(0 = - 0.0005 v_{3} + 0.000567 v_{4} - 6.7 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-6} v_{2} - 6.7 \\cdot 10^{-5} v_{4} + 6.9 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = - v_{1} + v_{5}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{3.74166 \\cdot 10^{22} s^{2} + 2.11154097156402 \\cdot 10^{27} s + 1.7381516587678 \\cdot 10^{30}}{3.74166 \\cdot 10^{22} s^{2} + 2.66540971563981 \\cdot 10^{26} s + 2.38151658767774 \\cdot 10^{29}}\\)\n\n\n\\(v_{3} = \\frac{3075000000000.0 s + 2.5 \\cdot 10^{15}}{3198000000000.0 s + 3.35000000000001 \\cdot 10^{15}}\\)\n\n\n\\(v_{4} = \\frac{3198000000000.0 s + 2.6 \\cdot 10^{15}}{3198000000000.0 s + 3.35000000000001 \\cdot 10^{15}}\\)\n\n\n\\(v_{5} = 1.0\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{3.74166 \\cdot 10^{22} s^{2} + 2.11154097156402 \\cdot 10^{27} s + 1.7381516587678 \\cdot 10^{30}}{3.74166 \\cdot 10^{22} s^{2} + 2.66540971563981 \\cdot 10^{26} s + 2.38151658767774 \\cdot 10^{29}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n\n\n39.3.2.5 Pole Zero Plot\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob',\n    markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-8848.65     -967.04\n-132.98      -166.72\n\n\n\n\n39.3.2.6 Pole/Zero Locus Plot versus \\(P_1\\) value\nFor each position of \\(P_1\\), there are two zeros and two poles. The plot below shows the frequency locations for the pole and zero locations as a function of \\(P_1\\) rotation. Since the poles and zeros don’t have imaginary parts, the complex frequency is plotted on the vertical axis versus the gain control rotational position, from 1 to 99 percent. The plot provides a visual indication of how the poles and zeros change as a function \\(P_1\\).\n\nsym_num, sym_denom = fraction(H_sym) #returns numerator and denominator\n\np1_value = 100e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp1a1] = p1_value - i*p1_value\n    element_values[Rp1b1] = i*p1_value\n    num_roots.append(solve(sym_num.subs(element_values),s))\n    denom_roots.append(solve(sym_denom.subs(element_values),s))\n\n# put the zeros into an array\nz0_locus = np.zeros(len(np.array(num_roots)))\nz1_locus = np.zeros(len(np.array(num_roots)))\nfor i in range(len(np.array(num_roots))):\n    z0_locus[i] = -np.array(num_roots)[i][0]    \n    z1_locus[i] = -np.array(num_roots)[i][1]        \n\n# put the poles into an array\np0_locus = np.zeros(len(np.array(denom_roots)))\np1_locus = np.zeros(len(np.array(denom_roots)))\nfor i in range(len(np.array(denom_roots))):\n    p0_locus[i] = -np.array(denom_roots)[i][0]    \n    p1_locus[i] = -np.array(denom_roots)[i][1]        \n\nAfter solving for the numerator and dominator roots of the transfer function at various positions of \\(P_1\\), we can examine the range of frequencies that the zeros take on as \\(P_1\\) is rotated.\n\nprint(f'z0 range as a function of P1: {z0_locus.min()/(2*np.pi)/1e3:.3f} to {z0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z1 range as a function of P1: {z1_locus.min()/(2*np.pi)/1e3:.3f} to {z1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\nz0 range as a function of P1: 5.023 to 137.640 kHz\nz1 range as a function of P1: 0.133 to 0.133 kHz\n\n\nAs shown above, \\(z_0\\) will move from about 5kHz to 137 kHz as \\(P_1\\) is rotated. \\(z_1\\)’s position in the complex frequency plane remains constant. The position of \\(z_0\\) is plotted below.\n\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z0_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_0')\n#plt.plot(np.linspace(1,99,len(np.array(num_roots))),z1_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_1')\n\n#plt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-r', markerfacecolor='none',label='p_0')\n#plt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-r', markerfacecolor='none',label='p_1')\n\nplt.ylim((0,140))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the position of \\(z_0\\) moves more dramatically when \\(P_1\\) is rotated from 80 to 100%.\nThe range of the poles on the complex plane is printed below.\n\nprint(f'p0 range as a function of P1: {p0_locus.min()/(2*np.pi)/1e3:.3f} to {p0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p1 range as a function of P1: {p1_locus.min()/(2*np.pi)/1e3:.3f} to {p1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\np0 range as a function of P1: 0.967 to 0.967 kHz\np1 range as a function of P1: 0.149 to 0.776 kHz\n\n\nThe position of \\(p_0\\) is constant and \\(p_1\\) moves from 150 Hz to 776 Hz as \\(P_1\\) is rotated.\n\n#plt.plot(np.linspace(1,99,len(np.array(num_roots))),z0_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_0')\n#plt.plot(np.linspace(1,99,len(np.array(num_roots))),z1_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_1')\n\n#plt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-k', markerfacecolor='none',label='p_0')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-r', markerfacecolor='none',label='p_1')\n\nplt.ylim((0,1))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, \\(p_1\\) moves more dramatically as \\(P_1\\) is rotated from 80% to 100%.\n\n\n39.3.2.7 Reactive Branch 2 Frequency Response\nThe voltage transfer function for the reactive branch shown in Figure 39.2 is plotted below.\n\n# set up\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,25,50,75,99])/100\np1_value = 100e3\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    #element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    #element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    #tf_num_coef_list.append(a)\n    #tf_denom_coef_list.append(b)\n    \n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    #clean_path1_mag[i] = mag\n    \n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='mag: {:.0f}%'.format(gain_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase: {:.0f}%'.format(gain_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\n#ax1.legend(loc='lower left')\n#ax2.legend(loc='lower right')\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, when the gain is increased, a resonance develops near 1 kHz.\n\n\n\n39.3.3 Reactive Branch 3\nThe schematic shown below represents the highlighted parts of the Klon Centuar circuit shown in Figure 37.17 and Figure 37.21. The voltage source \\(V_1\\) is the output Op Amp of \\(U_{1A}\\) and the voltage source \\(V_2\\) is the output of \\(U_{1B}\\). The Diodes \\(D_1\\) and \\(D_2\\) have been commented out in the netlist. Node 10 is the summing junction for clean path 2 and the diode path.\nOne of the ganged pots in \\(P_1\\), which is the gain control, is represented in the schematic by the resistors \\(R_{p1b2}\\) and \\(R_{p1a2}\\). The variable \\(R_{gain}\\) is used to control the position of the wiper. The gain pot, \\(P_1\\)’s terminals, are across \\(R_9\\) and \\(C_6\\) and \\(P_1\\)’s wiper contact at node 5 and forms a voltage divider that controls the signal amplitude at node 5.\nIn this section of the analysis we will look at the reactive path from node 1 to node 2 with \\(V_2\\) set to zero. This will include most of the components that are attached to these nodes. The components that are not included are those components along clean path 1 shown in Figure 37.15. Node 10 below is a virtual ground and by superposition we can separate out the contribution from clan path 1 and add it back later if we want to consider the combined contribution of the signals from the inputs to the summing junction. For now we are only interested in reactive branch 3.\nThe capacitor \\(C_{13}\\) shown in Figure 37.17 has been removed from this analysis. \\(C_{13}\\) in parallel with \\(R_{20}\\) in the feedback path around \\(U_{2B}\\) adds a zero to the voltage transfer function at about 500 Hz. The effect of this low pass filter is excluded from this analysis since we are interested only in the reactive path prior to \\(U_{1B}\\)\nWe will examine the solution to the network equations with \\(P_1\\) set to 50%. A symbolic solution was taking too long on my laptop, so this step was skipped. The poles and zeros for \\(P_1\\) are plotted and tabulated. The locus of poles and zeros for the transfer function are plotted to see how they move in the frequency domain as a function of \\(P_1\\). Finally, a frequency response plot of the voltage transfer function versus gain settings is generated.\nIn Section 39.3.4 and Section 39.3.6, reactive branch 3 is divided into two smaller subcircuits at \\(P_1\\). This is done to gain some insight into the operation of components along this path.\n\n\n\n\n\n\nFigure 39.3: Schematic of reactive branches 3 and 4. Reactive branch 3 is the path from V1 to V2 and reactive branch 4 is the path from V3 to V2.\n\n\n\nThe netlist below was exported from LTSpice when the schematic was generated.\n\nReactive_branch_3_4_net_list = '''\n* Reactive_branch_3&4.asc\nV1 1 0 1\nV2 6 0 0\nR5 1 3 5.1e3\nR8 3 0 1.5e3\nC4 1 3 68e-9\nC6 3 4 390e-9\nR9 4 0 1e3\nRp1b2 3 5 50e3\nRp1a2 5 0 50e3\nR13 8 7 1e3\nC11 9 11 2.2e-9\nR15 11 5 22e3\nR17 10 5 27e3\nR18 12 5 12e3\nC12 10 12 27e-9\nR16 10 9 47e3\n*R20 2 10 100e3\nR20 2 10 392e3\n*C13 2 10 820e-12\nO2a 10 0 2\n*D2 0 8 1N34A\n*D3 8 0 1N34A\nC9 6 7 1e-6\nC10 9 8 1e-6\n'''\n\nThe function SymMNA.smna generates the MNA matrices from the netlist.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Reactive_branch_3_4_net_list)\n\nThe following code builds and displays the symbolic circuit equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) + v_{3} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right)\\)\\(0 = I_{O2a} - \\frac{v_{10}}{R_{20}} + \\frac{v_{2}}{R_{20}}\\)\\(0 = - C_{6} s v_{4} + v_{1} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{3} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{Rp1b2}\\)\\(0 = - C_{6} s v_{3} + v_{4} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{5} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{3}}{Rp1b2} - \\frac{v_{12}}{R_{18}} - \\frac{v_{10}}{R_{17}} - \\frac{v_{11}}{R_{15}}\\)\\(0 = C_{9} s v_{6} - C_{9} s v_{7} + I_{V2}\\)\\(0 = - C_{9} s v_{6} + v_{7} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{8}}{R_{13}}\\)\\(0 = - C_{10} s v_{9} + v_{8} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{7}}{R_{13}}\\)\\(0 = - C_{10} s v_{8} - C_{11} s v_{11} + v_{9} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{10}}{R_{16}}\\)\\(0 = - C_{12} s v_{12} + v_{10} \\left(C_{12} s + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{2}}{R_{20}} - \\frac{v_{5}}{R_{17}} - \\frac{v_{9}}{R_{16}}\\)\\(0 = - C_{11} s v_{9} + v_{11} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{5}}{R_{15}}\\)\\(0 = - C_{12} s v_{10} + v_{12} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{5}}{R_{18}}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{6}\\)\\(0 = v_{10}\\)\n\n\nThe free symbols in the equations above are turned into SymPy variables and the element values are loaded into a Python dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n39.3.3.1 Numerical Solution for P1 at 50%\nThe network equations were too complex to generate symbolic solutions on my laptop. A numerical solution for the equations can easily be generated and this was done for \\(P_1\\) = 50%. The element values are substituted into the equations and displayed.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],9)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078\\right) + v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078\\right)\\)\n\n\n\\(0 = I_{O2a} - 2.551 \\cdot 10^{-6} v_{10} + 2.551 \\cdot 10^{-6} v_{2}\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{4} + v_{1} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078\\right) + v_{3} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745\\right) - 2.0 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{3} + v_{4} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(0 = - 3.7037 \\cdot 10^{-5} v_{10} - 4.5455 \\cdot 10^{-5} v_{11} - 8.3333 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{3} + 0.000205825 v_{5}\\)\n\n\n\\(0 = I_{V2} + 1.0 \\cdot 10^{-6} s v_{6} - 1.0 \\cdot 10^{-6} s v_{7}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{8}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{9} - 0.001 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-9} s v_{11} - 1.0 \\cdot 10^{-6} s v_{8} - 2.1277 \\cdot 10^{-5} v_{10} + v_{9} \\cdot \\left(1.002 \\cdot 10^{-6} s + 2.1277 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} + v_{10} \\cdot \\left(2.7 \\cdot 10^{-8} s + 6.0865 \\cdot 10^{-5}\\right) - 2.551 \\cdot 10^{-6} v_{2} - 3.7037 \\cdot 10^{-5} v_{5} - 2.1277 \\cdot 10^{-5} v_{9}\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-9} s v_{9} + v_{11} \\cdot \\left(2.0 \\cdot 10^{-9} s + 4.5455 \\cdot 10^{-5}\\right) - 4.5455 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{10} + v_{12} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.3333 \\cdot 10^{-5}\\right) - 8.3333 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = v_{6}\\)\n\n\n\\(0 = v_{10}\\)\n\n\n\nUse SymPy to solve for the unknown voltages and currents in the network equations. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{- 2.02215504303191 \\cdot 10^{56} s^{5} - 5.2950674540929 \\cdot 10^{60} s^{4} - 2.8308370994823 \\cdot 10^{64} s^{3} - 5.27827462462547 \\cdot 10^{67} s^{2} - 3.01998947548071 \\cdot 10^{70} s - 1.16148974096409 \\cdot 10^{72}}{4.3362244543883 \\cdot 10^{55} s^{5} + 2.06897279791109 \\cdot 10^{60} s^{4} + 2.53915433684715 \\cdot 10^{64} s^{3} + 5.64733157523515 \\cdot 10^{67} s^{2} + 3.55388545376323 \\cdot 10^{70} s + 1.37913277012933 \\cdot 10^{72}}\\)\n\n\n\\(v_{3} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.76830244412326 \\cdot 10^{60} s^{4} + 9.75686883763291 \\cdot 10^{63} s^{3} + 2.00756023341467 \\cdot 10^{67} s^{2} + 1.40196836955285 \\cdot 10^{70} s + 5.47822825670137 \\cdot 10^{71}}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\n\n\n\\(v_{4} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.57063979093177 \\cdot 10^{60} s^{4} + 5.72958732242324 \\cdot 10^{63} s^{3} + 5.3843527894717 \\cdot 10^{66} s^{2} + 2.13650902011353 \\cdot 10^{68} s}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\n\n\n\\(v_{5} = \\frac{4.72614965425532 \\cdot 10^{53} s^{5} + 1.34411248109 \\cdot 10^{58} s^{4} + 9.21167841492205 \\cdot 10^{61} s^{3} + 2.41846205484128 \\cdot 10^{65} s^{2} + 2.24113593696666 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{6} = 0.0\\)\n\n\n\\(v_{7} = \\frac{2.0138625 \\cdot 10^{55} s^{4} + 1.71863602941176 \\cdot 10^{59} s^{3} + 4.87499999999999 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{8} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 1.92002227941176 \\cdot 10^{56} s^{4} + 6.59363602941176 \\cdot 10^{59} s^{3} + 9.47058823529411 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{9} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 2.12140852941176 \\cdot 10^{56} s^{4} + 8.31227205882352 \\cdot 10^{59} s^{3} + 1.43455882352941 \\cdot 10^{63} s^{2} + 9.19117647058822 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{10} = 0.0\\)\n\n\n\\(v_{11} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 9.56082557247695 \\cdot 10^{57} s^{4} + 8.10026990741267 \\cdot 10^{61} s^{3} + 2.31064415746956 \\cdot 10^{65} s^{2} + 2.23683368415064 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{12} = \\frac{1.45868816489362 \\cdot 10^{57} s^{4} + 3.69828291543406 \\cdot 10^{61} s^{3} + 1.70166527761975 \\cdot 10^{65} s^{2} + 2.2123357321652 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 2.02215504303191 \\cdot 10^{56} s^{5} - 5.2950674540929 \\cdot 10^{60} s^{4} - 2.8308370994823 \\cdot 10^{64} s^{3} - 5.27827462462547 \\cdot 10^{67} s^{2} - 3.01998947548071 \\cdot 10^{70} s - 1.16148974096409 \\cdot 10^{72}}{4.3362244543883 \\cdot 10^{55} s^{5} + 2.06897279791109 \\cdot 10^{60} s^{4} + 2.53915433684715 \\cdot 10^{64} s^{3} + 5.64733157523515 \\cdot 10^{67} s^{2} + 3.55388545376323 \\cdot 10^{70} s + 1.37913277012933 \\cdot 10^{72}}\\)\n\n\nThe code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot for P1=50%')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-3142.62     -4629.79\n-458.92      -2545.69\n-408.09      -231.62\n-151.29      -180.17\n-6.59        -6.6\n\n\n\n\n39.3.3.2 Pole/Zero Locus Plot versus P1 value\nThere are 5 zeros and poles in the voltage transfer function. Solutions for the values of the poles and zeros as a function of \\(P_1\\)’s rotational position are saved to an array.\n\np1_value = 100e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp1a2] = p1_value - i*p1_value\n    element_values[Rp1b2] = i*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)    \n    sys_tf = signal.TransferFunction(a,b)\n    \n    num_roots.append(np.roots(sys_tf.num))\n    denom_roots.append(np.roots(sys_tf.den))\n\n# put the zeros into an array\nz0_locus = np.zeros(len(np.array(num_roots)))\nz1_locus = np.zeros(len(np.array(num_roots)))\nz2_locus = np.zeros(len(np.array(num_roots)))\nz3_locus = np.zeros(len(np.array(num_roots)))\nz4_locus = np.zeros(len(np.array(num_roots)))\n\nfor i in range(len(np.array(num_roots))):\n    z0_locus[i] = -np.array(num_roots)[i][0]    \n    z1_locus[i] = -np.array(num_roots)[i][1]        \n    z2_locus[i] = -np.array(num_roots)[i][2]    \n    z3_locus[i] = -np.array(num_roots)[i][3]  \n    z4_locus[i] = -np.array(num_roots)[i][4]    \n    \n# put the poles into an array\np0_locus = np.zeros(len(np.array(denom_roots)))\np1_locus = np.zeros(len(np.array(denom_roots)))\np2_locus = np.zeros(len(np.array(denom_roots)))\np3_locus = np.zeros(len(np.array(denom_roots)))\np4_locus = np.zeros(len(np.array(denom_roots)))\n\nfor i in range(len(np.array(denom_roots))):\n    p0_locus[i] = -np.array(denom_roots)[i][0]    \n    p1_locus[i] = -np.array(denom_roots)[i][1]       \n    p2_locus[i] = -np.array(denom_roots)[i][2]      \n    p3_locus[i] = -np.array(denom_roots)[i][3]      \n    p4_locus[i] = -np.array(denom_roots)[i][4]      \n\nThe range of values the zeros take on as a function of \\(P_1\\) is printed below.\n\nprint(f'z0 range as a function of P1: {z0_locus.min()/(2*np.pi)/1e3:.3f} to {z0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z1 range as a function of P1: {z1_locus.min()/(2*np.pi)/1e3:.3f} to {z1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z2 range as a function of P1: {z2_locus.min()/(2*np.pi)/1e3:.3f} to {z2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z3 range as a function of P1: {z3_locus.min()/(2*np.pi)/1e3:.3f} to {z3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z4 range as a function of P1: {z4_locus.min()/(2*np.pi)/1e3:.3f} to {z4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\nz0 range as a function of P1: 3.143 to 3.143 kHz\nz1 range as a function of P1: 0.459 to 0.459 kHz\nz2 range as a function of P1: 0.408 to 0.408 kHz\nz3 range as a function of P1: 0.151 to 0.151 kHz\nz4 range as a function of P1: 0.007 to 0.007 kHz\n\n\nAs shown above, the zeros of the transfer function don’t change with \\(P_1\\).\nThe range of values the poles take on as a function of \\(P_1\\) is printed below.\n\nprint(f'p0 range as a function of P1: {p0_locus.min()/(2*np.pi)/1e3:.3f} to {p0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p1 range as a function of P1: {p1_locus.min()/(2*np.pi)/1e3:.3f} to {p1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p2 range as a function of P1: {p2_locus.min()/(2*np.pi)/1e3:.3f} to {p2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p3 range as a function of P1: {p3_locus.min()/(2*np.pi)/1e3:.3f} to {p3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p4 range as a function of P1: {p4_locus.min()/(2*np.pi)/1e3:.3f} to {p4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\np0 range as a function of P1: 4.611 to 5.043 kHz\np1 range as a function of P1: 2.546 to 3.046 kHz\np2 range as a function of P1: 0.232 to 0.455 kHz\np3 range as a function of P1: 0.179 to 0.181 kHz\np4 range as a function of P1: 0.007 to 0.007 kHz\n\n\nAs shown above the poles of the transfer function vary with \\(P_1\\), and these are plotted below.\n\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_0')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_1')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p2_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_2')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p3_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_3')\n\nplt.ylim((0,6))\nplt.legend(loc='upper left')\nplt.title('Gain control pole frequency plot vs gain pot rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plots above, the pole locations don’t change all that much as a function of \\(P_1\\) rotation.\n\n\n39.3.3.3 Reactive Branch 3 Frequency Response\nThe plot below shows the magnitude and phase of voltage transfer function versus frequency at various positions of \\(P_1\\).\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,25,50,75,99])/100\np1_value = 100e3\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    #element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    #element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    #tf_num_coef_list.append(a)\n    #tf_denom_coef_list.append(b)\n    \n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    #clean_path1_mag[i] = mag\n    \n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='mag: {:.0f}%'.format(gain_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase: {:.0f}%'.format(gain_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\n#ax1.legend(loc='lower left')\n#ax2.legend(loc='lower right')\nax1.grid()\nplt.title('Magnitude and phase response')\n#plt.savefig('plt_rb_3.png')\nplt.show()\n\n\n\n\n\n\n\n\nThe magnitude and phase of voltage transfer function for reactive branch 3 shows about a 20 dB increase in gain over the guitar frequency band.\nKeep in mind that \\(C_{13}\\) and \\(R_{20}\\) put a pole into the voltage transfer function at about 500 Hz, which reduces the frequency emphasis plotted above. This can be easily seen if \\(C_{13}\\) is included in the netlist and the analysis above is re-run. Poles and zeros with C13 as shown below, notice the addition of a pole at 495 Hz.\nZeros, Hz    Poles, Hz\n-----------  -----------\n-3142.62     -4629.79\n-458.92      -2545.69\n-408.09      -495.13\n-151.29      -231.62\n-6.59        -180.17\n             -6.6\nThe plot of transfer function with \\(C_{13}\\) included in the analysis is:\n\n\n\nFrequency response of reactive branch 3 with C13 included in the analysis.\n\n\nNotice that zero at 500 Hz now dominates the shape of the transfer function, which is now somewhat flat over the guitar band and a low pass filter with a cutoff starting around 3 kHz.\n\n\n\n39.3.4 Reactive Branch 3a\nThe schematic shown below is a sub-circuit of reactive branch 3 from \\(V_1\\) to \\(P_1\\) (in the schematic below, the reference designator for \\(P_1\\) is \\(R_{p1ab2}\\) since \\(P_1\\) is modeled as two resistors.). In Figure 39.4, the nodes have been renumbered and \\(P_1\\) has been replaced by a fixed value resistor of 100 k\\(\\Omega\\).\nThe branch from node 1 to node 3 is composed of components \\(R_5\\) and \\(C_4\\), and these have a resonant frequency of about 450 Hz. \\(R_5\\) and \\(C_4\\) are in parallel with each other and in series with the signal path and this arrangement forms a zero in the voltage transfer function. The components \\(R_9\\) and \\(C_6\\) are in series with each other and have a resonant frequency of about 400 Hz and present a shunt to the signal path, which produces a second zero in the voltage transfer function. By inspection we can see the gain is \\((R_8||P_1)/(R_5+R_8||P_1)\\) at \\(\\omega=0\\) since the capacitors are open circuits at DC. At high frequency the gain is 1 since \\(C_4\\) looks like a short at high frequency.\n\n\n\n\n\n\nFigure 39.4: Schematic of reactive branch 3a.\n\n\n\nThe netlist below was obtained from the LTSpice schematic.\n\nreactive_branch_3_4_a_net_list = '''\n* Reactive_branch_3&4_a.asc\nR5 1 2 5.1e3\nR8 2 0 1.5e3\nC4 1 2 68e-9\nC6 2 3 390e-9\nR9 3 0 1e3\nRp1ab2 2 0 100e3\nV1 1 0 1\n'''\n\nThe MNA matrices are generated by calling SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_3_4_a_net_list)\n\nThe network equations are built from the MNA matrices.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) + v_{2} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right)\\)\\(0 = - C_{6} s v_{3} + v_{1} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{2} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right)\\)\\(0 = - C_{6} s v_{2} + v_{3} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are turned into SymPy symbols and the element values are loaded into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n39.3.4.1 Symbolic solution\nThe network equations can be solved symbolically and are displayed below.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{4} R_{5} R_{8} Rp1ab2 V_{1} s + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s + R_{8} Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(v_{3} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(I_{V1} = \\frac{- C_{4} C_{6} R_{5} R_{8} R_{9} V_{1} s^{2} - C_{4} C_{6} R_{5} R_{8} Rp1ab2 V_{1} s^{2} - C_{4} C_{6} R_{5} R_{9} Rp1ab2 V_{1} s^{2} - C_{4} R_{5} R_{8} V_{1} s - C_{4} R_{5} Rp1ab2 V_{1} s - C_{6} R_{8} R_{9} V_{1} s - C_{6} R_{8} Rp1ab2 V_{1} s - C_{6} R_{9} Rp1ab2 V_{1} s - R_{8} V_{1} - Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\n\n\nSymPy can solve and display the node voltage equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{4} R_{5} R_{8} Rp1ab2 V_{1} s + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s + R_{8} Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(v_{3} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(I_{V1} = \\frac{- C_{4} C_{6} R_{5} R_{8} R_{9} V_{1} s^{2} - C_{4} C_{6} R_{5} R_{8} Rp1ab2 V_{1} s^{2} - C_{4} C_{6} R_{5} R_{9} Rp1ab2 V_{1} s^{2} - C_{4} R_{5} R_{8} V_{1} s - C_{4} R_{5} Rp1ab2 V_{1} s - C_{6} R_{8} R_{9} V_{1} s - C_{6} R_{8} Rp1ab2 V_{1} s - C_{6} R_{9} Rp1ab2 V_{1} s - R_{8} V_{1} - Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{8} Rp1ab2}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\n\n\nWe can look at the numerator and denominator polynomials of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n39.3.4.2 Numerator Polynomial\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{8} Rp1ab2\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$\\\n    &lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(b_1=C_{4} R_{5} R_{8} Rp1ab2 + C_{6} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(b_0=R_{8} Rp1ab2\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nMarkdown('There are {:d} zeros, which are:\\\n    &lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;'.format(len(num_root_sym),latex(num_root_sym[0]),latex(num_root_sym[1])))\n\nThere are 2 zeros, which are:\n\n\\(z_0=- \\frac{1}{C_{4} R_{5}}\\)\n\n\n\\(z_1=- \\frac{1}{C_{6} R_{9}}\\)\n\n\n\n\n\n39.3.4.3 Denominator Polynomial\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_2s^2+a_1s+a_0\\)\nwhere \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\n\n\n\\(a_2=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(a_1=C_{4} R_{5} R_{8} Rp1ab2 + C_{6} R_{5} R_{8} R_{9} + C_{6} R_{5} R_{8} Rp1ab2 + C_{6} R_{5} R_{9} Rp1ab2 + C_{6} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(a_0=R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transder fuction, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are:\\\n    &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1])))\n\nThere are 2 poles, which are:\n\n\\(p_0=\\frac{- C_{4} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{8} R_{9} - C_{6} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{9} Rp1ab2 - C_{6} R_{8} R_{9} Rp1ab2 - \\sqrt{C_{4}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9}^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + C_{6}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{9}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8} R_{9}^{2} Rp1ab2^{2} + C_{6}^{2} R_{8}^{2} R_{9}^{2} Rp1ab2^{2}}}{2 C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2}\\)\n\n\n\\(p_1=\\frac{- C_{4} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{8} R_{9} - C_{6} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{9} Rp1ab2 - C_{6} R_{8} R_{9} Rp1ab2 + \\sqrt{C_{4}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9}^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + C_{6}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{9}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8} R_{9}^{2} Rp1ab2^{2} + C_{6}^{2} R_{8}^{2} R_{9}^{2} Rp1ab2^{2}}}{2 C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2}\\)\n\n\n\n\n\n\n39.3.5 Analysis Using the Extra Element Theorem\nThe coefficients of the numerator and denominator polynomials for the transfer function of the circuit shown in Figure 39.4 can be determined by using the N Extra Element Theorem of Middlebrook, Vorperian, and Lindal (1998). Since there are only two reactive components in the circuit, this can be performed by inspection. See the example starting on slide 85 of Basso (2016). The following code cells walk through the steps.\nThe denominator polynomial coefficients \\(c_2\\) and \\(c_1\\) in the expression:\n\\(c_2s^2+c_1s+1\\)\ncan be found by the following steps. First find the time constants \\(\\tau_1\\) and \\(\\tau_2\\) while \\(V_1=0\\). To find \\(\\tau_1\\), look at Figure 39.4 with \\(V_1=0\\) and \\(C_6\\) replaced by its impedance at \\(\\omega=0\\), which is an open circuit. The resistance seen by \\(C_4\\) is the parallel combination of \\(R_5\\), \\(R_8\\) and \\(R_{p1ab2}\\) which is equal to \\(\\frac {1} {\\frac {1}{R_5}+\\frac {1}{R_8}+\\frac {1}{R_{p1ab2}} }\\). We can create a new symbol \\(Rp\\) to represent the parallel combination of \\(R_5\\), \\(R_8\\) and \\(R_{p1ab2}\\).\n\nRp = symbols('Rp')\n\ntau_1 = C4*Rp\nMarkdown('The time constant $\\\\tau_1 = {:s}$.'.format(latex(tau_1)))\n\nThe time constant \\(\\tau_1 = C_{4} Rp\\).\n\n\nTo find \\(\\tau_2\\), replace \\(C_4\\) its impedance at \\(\\omega=0\\), which is an open circuit. The resistance seen by \\(C_6\\) is \\(R_9\\) plus the parallel combination of \\(R_5\\), \\(R_8\\) and \\(R_{p1ab2}\\) which is equal to \\(R_9 + \\frac {1} {\\frac {1}{R_5}+\\frac {1}{R_8}+\\frac {1}{R_{p1ab2}} }\\).\n\ntau_2 = C6*(Rp+R9)\nMarkdown('The time constant $\\\\tau_2 = {:s}$.'.format(latex(tau_2)))\n\nThe time constant \\(\\tau_2 = C_{6} \\left(R_{9} + Rp\\right)\\).\n\n\n\nc_1 = tau_1+tau_2\nMarkdown('The denominator polynomial coefficient, $c_1 = \\\\tau_1+\\\\tau_2 = {:s}$.'.format(latex(c_1)))\n\nThe denominator polynomial coefficient, \\(c_1 = \\tau_1+\\tau_2 = C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\).\n\n\nTo find \\(c_2\\), place C1 in its high-frequency and look into C2, \\(V_1\\) is still zero, this is \\(\\tau_1^2\\) and \\(a_2 = \\tau_1 \\tau_1^2\\).\n\n# tau_1^2\ntau_1_2 = (C6*R9)\nMarkdown('$\\\\tau_1^2 = {:s}$'.format(latex(tau_1_2)))\n\n\\(\\tau_1^2 = C_{6} R_{9}\\)\n\n\nThe second coeeficient is equal to \\(\\tau_1 \\tau_1^2\\).\n\nc_2 = tau_1*tau_1_2\nMarkdown('$c_2 = {:s}$'.format(latex(c_2)))\n\n\\(c_2 = C_{4} C_{6} R_{9} Rp\\)\n\n\n\nMarkdown('The denominator polynomial = ${:s}$'.format(latex(c_2*s**2+c_1*s+1)))\n\nThe denominator polynomial = \\(C_{4} C_{6} R_{9} Rp s^{2} + s \\left(C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\right) + 1\\)\n\n\nTo find if \\(C_4\\) and \\(C_6\\) cause zeros in the transfer function, the following procedure is used:\n\nPlace \\(C_4\\) in its high-frequency state while \\(C_6\\) is in its low frequency state, check if the stimulus can propagate through the circuit to form a response on the output.\nThe place \\(C_6\\) in its high-frequency state while \\(C_4\\) is in its low frequency state, check if the stimulus can propagate through the circuit to form a response on the output.\n\nIn both cases the stimulus can propagate through the circuit to form a response on the output.\nTo find the locations of the zeros, you have to find the impedance condition in the circuit where, for a certain stimulus frequency, you null the response. Either a series impedance becomes an infinite value or a shunt branch is zero. This happens for:\n\nt1 = C6*R9\nt2 = C4*R5\nMarkdown('$t_1 = C_6R_9$ and $t_2 = C_4R_5$')\n\n\\(t_1 = C_6R_9\\) and \\(t_2 = C_4R_5\\)\n\n\n\nMarkdown('We can write the numerator polynomial in factored form: ${:s}$'.format(latex((s+1/t1)*(s+1/t2))))\n\nWe can write the numerator polynomial in factored form: \\(\\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)\\)\n\n\nThe DC gain of the transfer function, \\(H_0\\) can be found by letting \\(\\omega=0\\) and is:\n\\(H_0=\\frac{R_8||P_1}{R_5+R_8||P_1}\\)\nNow we can write the transfer function:\n\nH_0 = symbols('H_0')\nMarkdown('$H(s)={:s}$'.format(latex(H_0*(s+1/t1)*(s+1/t2)/(c_2*s**2+c_1*s+1))))\n\n\\(H(s)=\\frac{H_{0} \\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)}{C_{4} C_{6} R_{9} Rp s^{2} + s \\left(C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\right) + 1}\\)\n\n\nThe expression obtained for \\(H(s)\\) above can be checked by substituting element values and comparing to the MNA results above.\nSubstituting \\(R_{p1ab2}\\) for \\(P_1\\), the expression for \\(H_0\\) is:\n\nH_0 = (1/(1/R8+1/Rp1ab2))/(R5+1/(1/R8+1/Rp1ab2))\nMarkdown('$H_0(s)={:s}$'.format(latex(H_0)))\n\n\\(H_0(s)=\\frac{1}{\\left(R_{5} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}}\\right) \\left(\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}\\right)}\\)\n\n\nPutting all the sysmbols together, we get:\n\nMarkdown('$H(s)={:s}$'.format(latex(H_0*(s+1/t1)*(s+1/t2)/(c_2*s**2+c_1*s+1))))\n\n\\(H(s)=\\frac{\\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)}{\\left(R_{5} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}}\\right) \\left(\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}\\right) \\left(C_{4} C_{6} R_{9} Rp s^{2} + s \\left(C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\right) + 1\\right)}\\)\n\n\nMaking the substitution for \\(R_P\\) we get:\n\nH = (H_0*(s+1/t1)*(s+1/t2)/(c_2*s**2+c_1*s+1)).subs({Rp:1/(1/R5+1/R8+1/Rp1ab2)})\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{\\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)}{\\left(R_{5} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}}\\right) \\left(\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}\\right) \\left(\\frac{C_{4} C_{6} R_{9} s^{2}}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}} + s \\left(\\frac{C_{4}}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}} + C_{6} \\left(R_{9} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}}\\right)\\right) + 1\\right)}\\)\n\n\nPutting in the element values we get:\n\nH = H.subs(element_values)\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{0.224668613794653 \\left(s + 2564.10256410256\\right) \\left(s + 2883.50634371396\\right)}{3.03868793529544 \\cdot 10^{-8} s^{2} + 0.00091478094810155 s + 1}\\)\n\n\nNow we can extract the numerator and demoninator and compare to the MNA results.\n\nH1_num, H1_denom = fraction(H)\n\nThe numerator obtained with the EET is:\n\nH1_num.expand()/H1_num.expand().coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 5447.60890781652 s + 7393606.00952296\\)\n\n\nWhich exactly matches the numberator obtained from MNA.\n\nH_sym_num.subs(element_values)/H_sym_num.subs(element_values).coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 5447.60890781652 s + 7393606.00952297\\)\n\n\nLooking at the demominators, the demininator obtanained from the EET is :\n\nH1_denom/H1_denom.coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 30104.4716529146 s + 32908940.3483867\\)\n\n\nWhich exactly matches the demoninator obtained from MNA.\n\nH_sym_denom.subs(element_values)/H_sym_denom.subs(element_values).coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 30104.4716529146 s + 32908940.3483867\\)\n\n\nThis varifies that the EET solution is valid. If the circuit is a 2nd order circuit, this analysis approach can be useful.\n\n39.3.5.1 Numerical Solution\nIf numerical values are substituted for the reference designators in the symbolic equations, the following numerical equations can be obtained.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],8)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(7.0 \\cdot 10^{-8} s + 0.00019608\\right) + v_{2} \\left(- 7.0 \\cdot 10^{-8} s - 0.00019608\\right)\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{3} + v_{1} \\left(- 7.0 \\cdot 10^{-8} s - 0.00019608\\right) + v_{2} \\cdot \\left(4.6 \\cdot 10^{-7} s + 0.00087275\\right)\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{2} + v_{3} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{2652000000000.0 s^{2} + 1.44470588235294 \\cdot 10^{16} s + 1.96078431372549 \\cdot 10^{19}}{2652000000000.0 s^{2} + 7.98370588235294 \\cdot 10^{16} s + 8.72745098039216 \\cdot 10^{19}}\\)\n\n\n\\(v_{3} = \\frac{2652000000000.0 s^{2} + 7.64705882352941 \\cdot 10^{15} s}{2652000000000.0 s^{2} + 7.98370588235294 \\cdot 10^{16} s + 8.72745098039216 \\cdot 10^{19}}\\)\n\n\n\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('The transfer function is: $H(s)={:s}$'.format(latex(H)))\n\nThe transfer function is: \\(H(s)=\\frac{2652000000000.0 s^{2} + 1.44470588235294 \\cdot 10^{16} s + 1.96078431372549 \\cdot 10^{19}}{2652000000000.0 s^{2} + 7.98370588235294 \\cdot 10^{16} s + 8.72745098039216 \\cdot 10^{19}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-458.92      -4610.47\n-408.09      -180.8\n\n\n\n\n39.3.5.2 Reactive Branch 3a Frequency Response\nThe frequency response for the circuit in Figure 39.4 is shown below.\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n#gain_setting = np.array([1,25,50,75,99])/100\n#p1_value = 100e3\n\n#tf_num_coef_list = []\n#tf_denom_coef_list = []\n\n#clean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\n\n#color_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n#x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n#clean_path1_mag[i] = mag\n\n# plot the results\ni=0\nax1.semilogx(w/(2*np.pi), mag,'-k',label='mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':k',label='phase')  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\nax1.set_ylim((-20,5))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nBy examining the circuit in Figure 39.4, we can see that there is a DC path from node 1 to node 2. At \\(\\omega=0\\), the capacitors act as open circuits and the circuit reduces to a voltage divider equal to \\(\\frac {R_8||P_1} {R_5+R_8||P_1}\\) between nodes 1 and 2. At high frequencies, the capacitors act as short circuits and at high frequencies node 2 is shorted to node 1 by \\(C_4\\)\n\n\n\n39.3.6 Reactive Branch 3b\nThe branch composed of components \\(R_{15}\\), \\(C_{11}\\) and \\(R_{16}\\) and the branch composed of components \\(R_{17}\\), \\(R_{18}\\) and \\(C_{12}\\), form an unusual summing network attached to node 10 in Figure 39.3. The signal from the diode path combines with the signal from clean path 2 through \\(C_{11}\\) at node 9.\nThe resistor \\(R_{16}\\) conducts this blended signal into the summing junction at node 10. The signal from clean path 2 travels through the branch composed of components \\(R_{17}\\), \\(R_{18}\\) and \\(C_{12}\\) to the summing junction at node 10. The branch from node 5 to node 10, consisting of components \\(R_{17}\\), \\(R_{18}\\) and \\(C_{12}\\), attaches to the summing junction at node 10 and combines the signal from clean path 2. These components have resonances that contribute to the poles and zeros of the transfer function.\nThe components \\(R_{18}\\) and \\(C_{12}\\) have a resonant frequency of about 500 Hz and since these are in series contribute to a pole to the transfer function at their resonant frequency. The components \\(R_{18}+R_{17}\\) and \\(C_{12}\\) have a resonant frequency of about 150 Hz and these contribute to a zero to the transfer function at their resonant frequency.\nIt’s not clear how the arrangement of these components attached to the summing junction were determined, perhaps this topology came to look like this by experimentation in the circuit prototyping and testing phase of the design.\nWhen \\(P_{1A}\\) in Figure 37.17, is rotated fully clockwise the wiper is connected to the ground end and no signal propagates along the path. When \\(P_{1A}\\) is rotated fully counter clockwise, the wiper is connected to \\(C_6\\) and the clean signal can propagate along the path. Otherwise, \\(P_{1A}\\) acts as a voltage divider and the amplitude of the signal can be adjusted by the user.\nThe schematic in Figure 39.3 has been redrawn below, notice that the node numbers have changed. The capacitor values for \\(C_{10}\\) and \\(C_9\\) have been combined and 0.5 \\(\\mu\\)F has been used for the value of \\(C_{10}\\) below.\n\n\n\n\n\n\nFigure 39.5: Schematic of reactive branch 3b.\n\n\n\nThe capacitor, \\(C_9\\), has been absorbed into \\(C_{10}\\) in the schematic above in order to reduce the component and node count for the MNA. Since \\(C_9\\) and \\(C_{10}\\) are in series, the value of \\(C_{10}\\) has been adjusted. The capacitor \\(C_{13}\\) has not been included in the netlist so we can observe the operation of this reactive branch without the zero created at 500 Hz by \\(C_{13}\\).\n\nreactive_branch_3_4_a_net_list = '''\n* Reactive_branch_3b.asc\nR13 3 0 1e3\nC11 4 6 2.2e-9\nR15 6 1 22e3\nR17 5 1 27e3\nR18 7 1 12e3\nC12 5 7 27e-9\nR16 5 4 47e3\nV1 1 0 1\nC10 4 3 0.5e-6\nR20 2 5 392e3\n*C13 2 5 820e-12\nO2A 5 0 2\n'''\n\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_3_4_a_net_list)\n\nBuild the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{7}}{R_{18}} - \\frac{v_{5}}{R_{17}} - \\frac{v_{6}}{R_{15}}\\)\\(0 = I_{O2a} + \\frac{v_{2}}{R_{20}} - \\frac{v_{5}}{R_{20}}\\)\\(0 = - C_{10} s v_{4} + v_{3} \\left(C_{10} s + \\frac{1}{R_{13}}\\right)\\)\\(0 = - C_{10} s v_{3} - C_{11} s v_{6} + v_{4} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{5}}{R_{16}}\\)\\(0 = - C_{12} s v_{7} + v_{5} \\left(C_{12} s + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{2}}{R_{20}} - \\frac{v_{1}}{R_{17}} - \\frac{v_{4}}{R_{16}}\\)\\(0 = - C_{11} s v_{4} + v_{6} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{1}}{R_{15}}\\)\\(0 = - C_{12} s v_{5} + v_{7} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{1}}{R_{18}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{5}\\)\n\n\nTurn the free symbols into SymPy variables and load the element values.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n39.3.6.1 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the node voltages and dependent currents using symbolic notation.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} R_{13} R_{15} R_{20} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{16} R_{20} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{17} R_{20} V_{1} s^{2} - C_{10} C_{11} R_{15} R_{16} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{17} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{18} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{17} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{18} R_{20} V_{1} s^{2} - C_{10} R_{13} R_{20} V_{1} s - C_{10} R_{16} R_{20} V_{1} s - C_{11} C_{12} R_{15} R_{17} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{15} R_{18} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{17} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{18} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{17} R_{18} R_{20} V_{1} s^{2} - C_{11} R_{15} R_{20} V_{1} s - C_{11} R_{16} R_{20} V_{1} s - C_{11} R_{17} R_{20} V_{1} s - C_{12} R_{17} R_{20} V_{1} s - C_{12} R_{18} R_{20} V_{1} s - R_{20} V_{1}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\\(v_{3} = \\frac{C_{10} C_{11} R_{13} R_{16} V_{1} s^{2}}{C_{10} C_{11} R_{13} R_{15} s^{2} + C_{10} C_{11} R_{13} R_{16} s^{2} + C_{10} C_{11} R_{15} R_{16} s^{2} + C_{10} R_{13} s + C_{10} R_{16} s + C_{11} R_{15} s + C_{11} R_{16} s + 1}\\)\\(v_{4} = \\frac{C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} + C_{11} R_{16} V_{1} s}{C_{10} C_{11} R_{13} R_{15} s^{2} + C_{10} C_{11} R_{13} R_{16} s^{2} + C_{10} C_{11} R_{15} R_{16} s^{2} + C_{10} R_{13} s + C_{10} R_{16} s + C_{11} R_{15} s + C_{11} R_{16} s + 1}\\)\\(v_{5} = 0\\)\\(v_{6} = \\frac{C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} + C_{10} R_{13} V_{1} s + C_{10} R_{16} V_{1} s + C_{11} R_{16} V_{1} s + V_{1}}{C_{10} C_{11} R_{13} R_{15} s^{2} + C_{10} C_{11} R_{13} R_{16} s^{2} + C_{10} C_{11} R_{15} R_{16} s^{2} + C_{10} R_{13} s + C_{10} R_{16} s + C_{11} R_{15} s + C_{11} R_{16} s + 1}\\)\\(v_{7} = \\frac{V_{1}}{C_{12} R_{18} s + 1}\\)\\(I_{V1} = \\frac{- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{16} R_{17} R_{18} V_{1} s^{3} - C_{10} C_{11} R_{13} R_{15} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{17} V_{1} s^{2} - C_{10} C_{11} R_{15} R_{16} V_{1} s^{2} - C_{10} C_{11} R_{16} R_{17} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{17} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{18} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{17} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{18} V_{1} s^{2} - C_{10} R_{13} V_{1} s - C_{10} R_{16} V_{1} s - C_{11} C_{12} R_{15} R_{17} V_{1} s^{2} - C_{11} C_{12} R_{15} R_{18} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{17} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{18} V_{1} s^{2} - C_{11} C_{12} R_{17} R_{18} V_{1} s^{2} - C_{11} R_{15} V_{1} s - C_{11} R_{16} V_{1} s - C_{11} R_{17} V_{1} s - C_{12} R_{17} V_{1} s - C_{12} R_{18} V_{1} s - V_{1}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\\(I_{O2a} = \\frac{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} V_{1} s^{3} + C_{10} C_{11} R_{13} R_{15} V_{1} s^{2} + C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} + C_{10} C_{11} R_{13} R_{17} V_{1} s^{2} + C_{10} C_{11} R_{15} R_{16} V_{1} s^{2} + C_{10} C_{12} R_{13} R_{17} V_{1} s^{2} + C_{10} C_{12} R_{13} R_{18} V_{1} s^{2} + C_{10} C_{12} R_{16} R_{17} V_{1} s^{2} + C_{10} C_{12} R_{16} R_{18} V_{1} s^{2} + C_{10} R_{13} V_{1} s + C_{10} R_{16} V_{1} s + C_{11} C_{12} R_{15} R_{17} V_{1} s^{2} + C_{11} C_{12} R_{15} R_{18} V_{1} s^{2} + C_{11} C_{12} R_{16} R_{17} V_{1} s^{2} + C_{11} C_{12} R_{16} R_{18} V_{1} s^{2} + C_{11} C_{12} R_{17} R_{18} V_{1} s^{2} + C_{11} R_{15} V_{1} s + C_{11} R_{16} V_{1} s + C_{11} R_{17} V_{1} s + C_{12} R_{17} V_{1} s + C_{12} R_{18} V_{1} s + V_{1}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} R_{13} R_{15} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{16} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{11} R_{15} R_{16} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{18} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{10} R_{13} R_{20} s - C_{10} R_{16} R_{20} s - C_{11} C_{12} R_{15} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{15} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{17} R_{18} R_{20} s^{2} - C_{11} R_{15} R_{20} s - C_{11} R_{16} R_{20} s - C_{11} R_{17} R_{20} s - C_{12} R_{17} R_{20} s - C_{12} R_{18} R_{20} s - R_{20}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\n\n\nThe numerator and the denominator are third order polynomials in terms of \\(s\\). Generally, the order of the dominator is equal to the number of reactive elements in the circuit. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n39.3.6.2 Numerator Polynomial of \\(H_{sym}(s)\\)\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} R_{13} R_{15} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{16} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{11} R_{15} R_{16} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{18} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{10} R_{13} R_{20} s - C_{10} R_{16} R_{20} s - C_{11} C_{12} R_{15} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{15} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{17} R_{18} R_{20} s^{2} - C_{11} R_{15} R_{20} s - C_{11} R_{16} R_{20} s - C_{11} R_{17} R_{20} s - C_{12} R_{17} R_{20} s - C_{12} R_{18} R_{20} s - R_{20}\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_3s^{3}+b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_3\\), \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb3 = H_sym_num.coeff(s**3)\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2 - b3*s**3).expand()\n\nMarkdown('&lt;p&gt;$b_3={:s}$&lt;/p&gt;&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$\\\n    &lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b3),latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_3=- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20}\\)\n\n\n\\(b_2=- C_{10} C_{11} R_{13} R_{15} R_{20} - C_{10} C_{11} R_{13} R_{16} R_{20} - C_{10} C_{11} R_{13} R_{17} R_{20} - C_{10} C_{11} R_{15} R_{16} R_{20} - C_{10} C_{12} R_{13} R_{17} R_{20} - C_{10} C_{12} R_{13} R_{18} R_{20} - C_{10} C_{12} R_{16} R_{17} R_{20} - C_{10} C_{12} R_{16} R_{18} R_{20} - C_{11} C_{12} R_{15} R_{17} R_{20} - C_{11} C_{12} R_{15} R_{18} R_{20} - C_{11} C_{12} R_{16} R_{17} R_{20} - C_{11} C_{12} R_{16} R_{18} R_{20} - C_{11} C_{12} R_{17} R_{18} R_{20}\\)\n\n\n\\(b_1=- C_{10} R_{13} R_{20} - C_{10} R_{16} R_{20} - C_{11} R_{15} R_{20} - C_{11} R_{16} R_{20} - C_{11} R_{17} R_{20} - C_{12} R_{17} R_{20} - C_{12} R_{18} R_{20}\\)\n\n\n\\(b_0=- R_{20}\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nThere are three solutions:\n\nMarkdown('&lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;&lt;p&gt;$z_2={:s}$&lt;/p&gt;'.format(latex(num_root_sym[0]),latex(num_root_sym[1]),latex(num_root_sym[2])))\n\n\n\\(z_0=- \\frac{- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}}{3} - \\frac{C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}}{3 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)}\\)\n\n\n\\(z_1=- \\frac{- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}}{3} - \\frac{C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}}{3 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)}\\)\n\n\n\\(z_2=- \\frac{- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}}{3} - \\frac{C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}}{3 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)}\\)\n\n\n\n\n\n39.3.6.3 Denominator Polynomial of \\(H_{sym}(s)\\)\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_3s^3+a_2s^2+a_1s+a_0\\)\nwhere \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\na3 = H_sym_denom.coeff(s**3)\na2 = H_sym_denom.coeff(s**2)\na1 = H_sym_denom.coeff(s**1)\na0 = (H_sym_denom - a1*s*1 - a2*s**2 - a3*s**3).expand()\nMarkdown('&lt;p&gt;$a_3={:s}$&lt;/p&gt;&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;\\\n    $a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a3),\n    latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_3=C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18}\\)\n\n\n\\(a_2=C_{10} C_{11} R_{13} R_{15} R_{17} + C_{10} C_{11} R_{13} R_{16} R_{17} + C_{10} C_{11} R_{15} R_{16} R_{17} + C_{10} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{12} R_{16} R_{17} R_{18} + C_{11} C_{12} R_{15} R_{17} R_{18} + C_{11} C_{12} R_{16} R_{17} R_{18}\\)\n\n\n\\(a_1=C_{10} R_{13} R_{17} + C_{10} R_{16} R_{17} + C_{11} R_{15} R_{17} + C_{11} R_{16} R_{17} + C_{12} R_{17} R_{18}\\)\n\n\n\\(a_0=R_{17}\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transfer function, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nThe poles of the transfer function are:\n\nMarkdown('&lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;&lt;p&gt;$p_2={:s}$&lt;/p&gt;'.format(latex(denom_root_sym[0]),latex(denom_root_sym[1]),latex(denom_root_sym[2])))\n\n\n\\(p_0=- \\frac{1}{C_{12} R_{18}}\\)\n\n\n\\(p_1=\\frac{- C_{10} R_{13} - C_{10} R_{16} - C_{11} R_{15} - C_{11} R_{16} - \\sqrt{C_{10}^{2} R_{13}^{2} + 2 C_{10}^{2} R_{13} R_{16} + C_{10}^{2} R_{16}^{2} - 2 C_{10} C_{11} R_{13} R_{15} - 2 C_{10} C_{11} R_{13} R_{16} - 2 C_{10} C_{11} R_{15} R_{16} + 2 C_{10} C_{11} R_{16}^{2} + C_{11}^{2} R_{15}^{2} + 2 C_{11}^{2} R_{15} R_{16} + C_{11}^{2} R_{16}^{2}}}{2 C_{10} C_{11} R_{13} R_{15} + 2 C_{10} C_{11} R_{13} R_{16} + 2 C_{10} C_{11} R_{15} R_{16}}\\)\n\n\n\\(p_2=\\frac{- C_{10} R_{13} - C_{10} R_{16} - C_{11} R_{15} - C_{11} R_{16} + \\sqrt{C_{10}^{2} R_{13}^{2} + 2 C_{10}^{2} R_{13} R_{16} + C_{10}^{2} R_{16}^{2} - 2 C_{10} C_{11} R_{13} R_{15} - 2 C_{10} C_{11} R_{13} R_{16} - 2 C_{10} C_{11} R_{15} R_{16} + 2 C_{10} C_{11} R_{16}^{2} + C_{11}^{2} R_{15}^{2} + 2 C_{11}^{2} R_{15} R_{16} + C_{11}^{2} R_{16}^{2}}}{2 C_{10} C_{11} R_{13} R_{15} + 2 C_{10} C_{11} R_{13} R_{16} + 2 C_{10} C_{11} R_{15} R_{16}}\\)\n\n\n\nThe expressions for the zeros and poles of \\(H(s)\\) are rather long and not very intuitive.\n\n\n39.3.6.4 Numerical Solution\nAfter substituting the element values into the network equations, we get the following numerical equations:\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],9)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 0.000165825 v_{1} - 3.7037 \\cdot 10^{-5} v_{5} - 4.5455 \\cdot 10^{-5} v_{6} - 8.3333 \\cdot 10^{-5} v_{7}\\)\n\n\n\\(0 = I_{O2a} + 2.551 \\cdot 10^{-6} v_{2} - 2.551 \\cdot 10^{-6} v_{5}\\)\n\n\n\\(0 = - 5.0 \\cdot 10^{-7} s v_{4} + v_{3} \\cdot \\left(5.0 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(0 = - 5.0 \\cdot 10^{-7} s v_{3} - 2.0 \\cdot 10^{-9} s v_{6} + v_{4} \\cdot \\left(5.02 \\cdot 10^{-7} s + 2.1277 \\cdot 10^{-5}\\right) - 2.1277 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{7} - 3.7037 \\cdot 10^{-5} v_{1} - 2.551 \\cdot 10^{-6} v_{2} - 2.1277 \\cdot 10^{-5} v_{4} + v_{5} \\cdot \\left(2.7 \\cdot 10^{-8} s + 6.0865 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-9} s v_{4} - 4.5455 \\cdot 10^{-5} v_{1} + v_{6} \\cdot \\left(2.0 \\cdot 10^{-9} s + 4.5455 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{5} - 8.3333 \\cdot 10^{-5} v_{1} + v_{7} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.3333 \\cdot 10^{-5}\\right)\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = v_{5}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{- 7.62501901595745 \\cdot 10^{36} s^{3} - 1.58125055488394 \\cdot 10^{41} s^{2} - 1.4965495647969 \\cdot 10^{44} s - 5.92359767891683 \\cdot 10^{45}}{1.60389694148936 \\cdot 10^{35} s^{3} + 3.68772736943907 \\cdot 10^{39} s^{2} + 9.98619741295937 \\cdot 10^{42} s + 4.08002901353966 \\cdot 10^{44}}\\)\n\n\n\\(v_{3} = \\frac{4.99999999999999 \\cdot 10^{24} s^{2}}{1.17340425531915 \\cdot 10^{26} s^{2} + 2.33576402321083 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}\\)\n\n\n\\(v_{4} = \\frac{4.99999999999999 \\cdot 10^{24} s^{2} + 9.99999999999999 \\cdot 10^{27} s}{1.17340425531915 \\cdot 10^{26} s^{2} + 2.33576402321083 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}\\)\n\n\n\\(v_{5} = 0.0\\)\n\n\n\\(v_{6} = \\frac{4.99999999999999 \\cdot 10^{24} s^{2} + 2.331083172147 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}{1.17340425531915 \\cdot 10^{26} s^{2} + 2.33576402321083 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}\\)\n\n\n\\(v_{7} = \\frac{250000.0}{81.0 s + 250000.0}\\)\n\n\n\nThe voltage transfer function is displayed below.\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 7.62501901595745 \\cdot 10^{36} s^{3} - 1.58125055488394 \\cdot 10^{41} s^{2} - 1.4965495647969 \\cdot 10^{44} s - 5.92359767891683 \\cdot 10^{45}}{1.60389694148936 \\cdot 10^{35} s^{3} + 3.68772736943907 \\cdot 10^{39} s^{2} + 9.98619741295937 \\cdot 10^{42} s + 4.08002901353966 \\cdot 10^{44}}\\)\n\n\nThe code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-3142.62     -3161.52\n-151.29      -491.22\n-6.59        -6.6\n\n\n\n\n39.3.6.5 Reactive Branch 3b Frequency Response\nThe amplitude and phase of the reactive branch is plotted below.\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n#gain_setting = np.array([1,25,50,75,99])/100\n#p1_value = 100e3\n\n#tf_num_coef_list = []\n#tf_denom_coef_list = []\n\n#clean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\n\n#color_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n#x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n#clean_path1_mag[i] = mag\n\n# plot the results\ni=0\nax1.semilogx(w/(2*np.pi), mag,'-k',label='mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':k',label='phase')  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\nax1.set_ylim((0,40))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the amplitude response, there is a lot of gain in this path since \\(R_{20}\\) is relatively large compared to the impedance of the other components connected to the non-inverting input of \\(U_{2A}\\). One thing to keep in mind is that the effect of \\(C_{13}\\) is not included in the plot above. The zero created at 500 Hz by \\(C_{13}\\) creates a dominating low pass response, which makes me wonder how much do the components \\(C_{11}\\) and \\(C_{12}\\) contribute to the overall tone created by the pedal.\n\n\n\n39.3.7 Reactive Branch 4\nReactive branch 4 is the circuit path following the diodes, \\(D_2\\) and \\(D_3\\) and shown in Figure 37.21. The diodes have been commented out in this analysis and \\(V_1\\) has been turned off and \\(V_2\\) is set to a value of 1. The source \\(V_2\\) represents the signal after the diode shaping. In Figure 39.3 the components from reactive paths 3 and 4 are connected at the non-inverting terminals of \\(U_{2A}\\). This makes the netlist rather long and the number of equations makes a symbolic solution impracticable. Notice that \\(C_{13}\\) is not included in the netlist, which is noted below.\n\nReactive_branch_3_4_net_list = '''\n* Reactive_branch_3&4.asc\nV1 1 0 0\nV2 6 0 1\nR5 1 3 5.1e3\nR8 3 0 1.5e3\nC4 1 3 68e-9\nC6 3 4 390e-9\nR9 4 0 1e3\nRp1b2 3 5 50e3\nRp1a2 5 0 50e3\nR13 8 7 1e3\nC11 9 11 2.2e-9\nR15 11 5 22e3\nR17 10 5 27e3\nR18 12 5 12e3\nC12 10 12 27e-9\nR16 10 9 47e3\n*R20 2 10 100e3\nR20 2 10 393e3\n*C13 2 10 820e-12\nO2a 10 0 2\n*D2 0 8 1N34A\n*D3 8 0 1N34A\nC9 6 7 1e-6\nC10 9 8 1e-6\n'''\n\nThe following code takes the netlist and builds and displays the MNA equations.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Reactive_branch_3_4_net_list)\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) + v_{3} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right)\\)\\(0 = I_{O2a} - \\frac{v_{10}}{R_{20}} + \\frac{v_{2}}{R_{20}}\\)\\(0 = - C_{6} s v_{4} + v_{1} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{3} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{Rp1b2}\\)\\(0 = - C_{6} s v_{3} + v_{4} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{5} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{3}}{Rp1b2} - \\frac{v_{12}}{R_{18}} - \\frac{v_{10}}{R_{17}} - \\frac{v_{11}}{R_{15}}\\)\\(0 = C_{9} s v_{6} - C_{9} s v_{7} + I_{V2}\\)\\(0 = - C_{9} s v_{6} + v_{7} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{8}}{R_{13}}\\)\\(0 = - C_{10} s v_{9} + v_{8} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{7}}{R_{13}}\\)\\(0 = - C_{10} s v_{8} - C_{11} s v_{11} + v_{9} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{10}}{R_{16}}\\)\\(0 = - C_{12} s v_{12} + v_{10} \\left(C_{12} s + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{2}}{R_{20}} - \\frac{v_{5}}{R_{17}} - \\frac{v_{9}}{R_{16}}\\)\\(0 = - C_{11} s v_{9} + v_{11} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{5}}{R_{15}}\\)\\(0 = - C_{12} s v_{10} + v_{12} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{5}}{R_{18}}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{6}\\)\\(0 = v_{10}\\)\n\n\nTurn the free symbols into SymPy variables and load the element values.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n39.3.7.1 Numerical Solution for P1 at 50%\nSubstitute the component values into the network equations and display the numerical equations.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],7)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.0001961\\right) + v_{3} \\left(- 1.0 \\cdot 10^{-7} s - 0.0001961\\right)\\)\n\n\n\\(0 = I_{O2a} - 2.5 \\cdot 10^{-6} v_{10} + 2.5 \\cdot 10^{-6} v_{2}\\)\n\n\n\\(0 = - 4.0 \\cdot 10^{-7} s v_{4} + v_{1} \\left(- 1.0 \\cdot 10^{-7} s - 0.0001961\\right) + v_{3} \\cdot \\left(5.0 \\cdot 10^{-7} s + 0.0008827\\right) - 2.0 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 4.0 \\cdot 10^{-7} s v_{3} + v_{4} \\cdot \\left(4.0 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(0 = - 3.7 \\cdot 10^{-5} v_{10} - 4.55 \\cdot 10^{-5} v_{11} - 8.33 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{3} + 0.0002058 v_{5}\\)\n\n\n\\(0 = I_{V2} + 1.0 \\cdot 10^{-6} s v_{6} - 1.0 \\cdot 10^{-6} s v_{7}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{8}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{9} - 0.001 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{8} - 2.13 \\cdot 10^{-5} v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 2.13 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = 6.09 \\cdot 10^{-5} v_{10} - 2.5 \\cdot 10^{-6} v_{2} - 3.7 \\cdot 10^{-5} v_{5} - 2.13 \\cdot 10^{-5} v_{9}\\)\n\n\n\\(0 = 4.55 \\cdot 10^{-5} v_{11} - 4.55 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = 8.33 \\cdot 10^{-5} v_{12} - 8.33 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = v_{1}\\)\n\n\n\\(1.0 = v_{6}\\)\n\n\n\\(0 = v_{10}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_2\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 0.0\\)\n\n\n\\(v_{2} = \\frac{- 1.96394441888298 \\cdot 10^{71} s^{5} - 7.60825164075479 \\cdot 10^{75} s^{4} - 5.90607987153688 \\cdot 10^{79} s^{3} - 1.18301509344067 \\cdot 10^{83} s^{2} - 6.89566385064667 \\cdot 10^{85} s}{1.10336500111661 \\cdot 10^{70} s^{5} + 5.26456182674577 \\cdot 10^{74} s^{4} + 6.46095251106143 \\cdot 10^{78} s^{3} + 1.43698004458909 \\cdot 10^{82} s^{2} + 9.04296553120415 \\cdot 10^{84} s + 3.50924368989652 \\cdot 10^{86}}\\)\n\n\n\\(v_{3} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 1.6734375 \\cdot 10^{60} s^{3} + 2.34375 \\cdot 10^{63} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{4} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 9.14062499999999 \\cdot 10^{59} s^{3}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{5} = \\frac{1.00693125 \\cdot 10^{54} s^{5} + 3.35690238970588 \\cdot 10^{58} s^{4} + 1.275328125 \\cdot 10^{62} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{6} = 1.0\\)\n\n\n\\(v_{7} = \\frac{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29627373138023 \\cdot 10^{59} s^{4} + 2.81149214573178 \\cdot 10^{63} s^{3} + 6.20412190793865 \\cdot 10^{66} s^{2} + 3.81322450115202 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{8} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19836922372969 \\cdot 10^{59} s^{4} + 2.74080119229803 \\cdot 10^{63} s^{3} + 6.06858479379818 \\cdot 10^{66} s^{2} + 3.73660601392261 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{9} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19578429076426 \\cdot 10^{59} s^{4} + 2.73101074153298 \\cdot 10^{63} s^{3} + 5.99789384036444 \\cdot 10^{66} s^{2} + 3.60106889978214 \\cdot 10^{69} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{10} = 0.0\\)\n\n\n\\(v_{11} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 1.46177548394608 \\cdot 10^{59} s^{4} + 4.04388334558824 \\cdot 10^{62} s^{3} + 2.77738425925926 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{12} = \\frac{3.1078125 \\cdot 10^{57} s^{4} + 9.40160845588234 \\cdot 10^{61} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v6]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 1.96394441888298 \\cdot 10^{71} s^{5} - 7.60825164075479 \\cdot 10^{75} s^{4} - 5.90607987153688 \\cdot 10^{79} s^{3} - 1.18301509344067 \\cdot 10^{83} s^{2} - 6.89566385064667 \\cdot 10^{85} s}{1.10336500111661 \\cdot 10^{70} s^{5} + 5.26456182674577 \\cdot 10^{74} s^{4} + 6.46095251106143 \\cdot 10^{78} s^{3} + 1.43698004458909 \\cdot 10^{82} s^{2} + 9.04296553120415 \\cdot 10^{84} s + 3.50924368989652 \\cdot 10^{86}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n\n\n39.3.7.2 Pole Zero Plot\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-4631.99     -4629.79\n-1110.36     -2545.69\n-243         -231.62\n-180.26      -180.17\n0            -6.6\n\n\n\n\n39.3.7.3 Pole/Zero Locus Plot versus P1 value\nThere are six zeros and six poles. The code below solves the network equations and finds the numerator and denominator roots of the transfer function for various rotation positions of \\(P_1\\).\n\np1_value = 100e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp1a2] = p1_value - i*p1_value\n    element_values[Rp1b2] = i*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v6]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)    \n    sys_tf = signal.TransferFunction(a,b)\n    \n    num_roots.append(np.roots(sys_tf.num))\n    denom_roots.append(np.roots(sys_tf.den))\n\nThe range of values taken on by the zeros as \\(P_1\\) is rotated are printed below.\n\n# put the zeros into an array\nz0_locus = np.zeros(len(np.array(num_roots)))\nz1_locus = np.zeros(len(np.array(num_roots)))\nz2_locus = np.zeros(len(np.array(num_roots)))\nz3_locus = np.zeros(len(np.array(num_roots)))\nz4_locus = np.zeros(len(np.array(num_roots)))\n\nfor i in range(len(np.array(num_roots))):\n    z0_locus[i] = -np.array(num_roots)[i][0]    \n    z1_locus[i] = -np.array(num_roots)[i][1]        \n    z2_locus[i] = -np.array(num_roots)[i][2]    \n    z3_locus[i] = -np.array(num_roots)[i][3]  \n    z4_locus[i] = -np.array(num_roots)[i][4]    \n\nprint(f'z0 range as a function of P1: {z0_locus.min()/(2*np.pi)/1e3:.3f} to {z0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z1 range as a function of P1: {z1_locus.min()/(2*np.pi)/1e3:.3f} to {z1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z2 range as a function of P1: {z2_locus.min()/(2*np.pi)/1e3:.3f} to {z2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z3 range as a function of P1: {z3_locus.min()/(2*np.pi)/1e3:.3f} to {z3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z4 range as a function of P1: {z4_locus.min()/(2*np.pi)/1e3:.3f} to {z4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\nz0 range as a function of P1: 4.611 to 5.652 kHz\nz1 range as a function of P1: 1.111 to 2.529 kHz\nz2 range as a function of P1: 0.243 to 0.467 kHz\nz3 range as a function of P1: 0.179 to 0.181 kHz\nz4 range as a function of P1: -0.000 to -0.000 kHz\n\n\nThe plot provides a visual indication of how the zeros change in frequency as a function of the rotational position of \\(P_1\\).\n\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z0_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_0')\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z1_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_1')\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z2_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_2')\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z3_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_3')\n\nplt.ylim((0,6))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the zeros are relatively constant versus \\(P_1\\) for most of the rotational range.\nThe range of values for each of the poles as function of \\(P_1\\) are printed below.\n\n# put the poles into an array\np0_locus = np.zeros(len(np.array(denom_roots)))\np1_locus = np.zeros(len(np.array(denom_roots)))\np2_locus = np.zeros(len(np.array(denom_roots)))\np3_locus = np.zeros(len(np.array(denom_roots)))\np4_locus = np.zeros(len(np.array(denom_roots)))\n\nfor i in range(len(np.array(denom_roots))):\n    p0_locus[i] = -np.array(denom_roots)[i][0]    \n    p1_locus[i] = -np.array(denom_roots)[i][1]       \n    p2_locus[i] = -np.array(denom_roots)[i][2]      \n    p3_locus[i] = -np.array(denom_roots)[i][3]      \n    p4_locus[i] = -np.array(denom_roots)[i][4]      \n\nprint(f'p0 range as a function of P1: {p0_locus.min()/(2*np.pi)/1e3:.3f} to {p0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p1 range as a function of P1: {p1_locus.min()/(2*np.pi)/1e3:.3f} to {p1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p2 range as a function of P1: {p2_locus.min()/(2*np.pi)/1e3:.3f} to {p2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p3 range as a function of P1: {p3_locus.min()/(2*np.pi)/1e3:.3f} to {p3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p4 range as a function of P1: {p4_locus.min()/(2*np.pi)/1e3:.3f} to {p4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\np0 range as a function of P1: 4.611 to 5.043 kHz\np1 range as a function of P1: 2.546 to 3.046 kHz\np2 range as a function of P1: 0.232 to 0.455 kHz\np3 range as a function of P1: 0.179 to 0.181 kHz\np4 range as a function of P1: 0.007 to 0.007 kHz\n\n\nThe plot provides a visual indication of how the poles change in frequency as a function of the rotational position of \\(P_1\\).\n\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_0')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_1')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p2_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_2')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p3_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_3')\n\nplt.ylim((0,6))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the poles are relatively constant versus \\(P_1\\) for most of the rotational range.\n\n\n39.3.7.4 Reactive Branch 4 Frequency Response\nThe frequency response of reactive branch 4 is plotted below. The gain setting is a percent of full scale.\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,25,50,75,99])/100\np1_value = 100e3\n\n#tf_num_coef_list = []\n#tf_denom_coef_list = []\n\n#clean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\n\n#color_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    #element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    #element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v6]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    #tf_num_coef_list.append(a)\n    #tf_denom_coef_list.append(b)\n    \n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    #clean_path1_mag[i] = mag\n    \n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='mag: {:.0f}%'.format(gain_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase: {:.0f}%'.format(gain_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n#ax1.set_ylim((0,15))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\n#ax1.legend(loc='lower left')\n#ax2.legend(loc='lower right')\nax1.grid()\nplt.title('Magnitude and phase response')\n#plt.savefig('reactive_path_4_bode.png')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that influence of the rotation of \\(P_1\\) has a large effect on the amplitude response at \\(P_1\\) rotational positions of 50 and 75%. However when \\(C_{13}\\) is included in the analysis, the zero created at about 500 Hz greatly influences the response along this path as shown in the plot below.\n\n\n\nReactive path 4 with \\(C_{13}\\) included in the netlist.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Klon Centaur, part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#summary",
    "href": "Klon Centaur part 3v1.html#summary",
    "title": "39  Klon Centaur, part 3",
    "section": "39.4 Summary",
    "text": "39.4 Summary\nThe Klon Centaur is a famous, highly sought-after and legendary guitar pedal. The pedal was adopted by some notable players (Jeff Beck, Mark Tremonti, John Mayer, Andy Summers, Peter Frampton, Jason Isbell, James Hetfield, Joe Perry, Britt Daniel, David Grissom, Adam Hann, Joe Bonamassa). The limited initial production and long wait times led to its rarity and high demand.\nWorking on this series of JupyterLab pages has given me the opportunity to to learn a few things about electric guitars and pedals. If I were to continue farther down this path, the next step would be to build some breadboard circuits and verify my analysis by comparing calculated with measured results.\nHere are a few of my observations:\n\nClean path 1 not contributing much and signals on this path appear to be covered by the clean path 2 and the diode path.\nReactive branches 3 and 4 are unusual filters\n\nBranch 3 provides 20 dB of emphasis across the guitar audio band\nBranch 4 provides 3 to 4 dB of emphasis across the guitar audio band\n\nBoth seem superfluous and appear to be dominated by \\(R_{20}\\) and \\(C_{13}\\)\n\n\n\n\n\n\nBasso, Christophe. 2016. “Introduction to Fast Analytical Techniques: Application to Small-Signal Modeling.” 2016. https://www.powersimtof.com/Downloads/PPTs/Chris%20Basso%20APEC%20seminar%202016.pdf.\n\n\nMiddlebrook, R. D., V. Vorperian, and J. Lindal. 1998. “The n Extra Element Theorem.” IEEE Transactions on Circuits and Systems I: Fundamental Theory and Applications 45 (9): 919–35. https://doi.org/10.1109/81.721258.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Klon Centaur, part 3</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html",
    "href": "Wien bridge oscillator.html",
    "title": "40  Wien Bridge Oscillator",
    "section": "",
    "text": "40.1 Introduction\nThis chapter is about a type of electronic oscillator called a Wien Bridge Oscillator. An electronic oscillator is a circuit that converts a direct current power source into an alternating current signal. Essentially, it generates a periodic, repetitive electrical signal. A Wien Bridge oscillator uses a frequency selective bridge circuit as the topology for the oscillator. The bridge circuit was originally developed by Max Wien in 1891 for impedance measurements. The bridge circuit consists of four resistors and two capacitors.\nStudying electronic oscillators is fundamental for anyone wanting to learn about electronics. Oscillators are examples of circuits that utilize positive feedback. Many oscillators rely on resonant circuits (LC tanks or crystal resonators) to determine their frequency. Studying oscillators introduces concepts like frequency stability, phase noise and harmonic distortion, which are crucial for designing high-performance electronic systems. Understanding different oscillator types (RC, LC, crystal, VCOs, etc.) helps in selecting the right component for a specific application based on requirements for frequency range, stability, cost and power consumption.\nThe use of MNA and Python can enable easy symbolic and numerical analysis of Wien Bridge oscillators.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#introduction",
    "href": "Wien bridge oscillator.html#introduction",
    "title": "40  Wien Bridge Oscillator",
    "section": "",
    "text": "Figure 40.1: Schematic of a Wien Bridge Oscillator drawn in a bridge configuration.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#circuit-description",
    "href": "Wien bridge oscillator.html#circuit-description",
    "title": "40  Wien Bridge Oscillator",
    "section": "40.2 Circuit Description",
    "text": "40.2 Circuit Description\nThe circuit in Figure 40.1 is a Wien Bridge oscillator drawn to emphasize the bridge topology. A bridge circuit is a type of electrical circuit topology where two circuit branches are “bridged” by a third branch connected between them at an intermediate point. It’s often visualized as an “H” or diamond shape. A bridge circuit essentially consists of two parallel voltage dividers sharing a common power source. A third branch, often containing a galvanometer (a sensitive current meter) or a voltmeter, connects the midpoints of these two voltage dividers. The key to many bridge circuits is the “balance” or “null” condition. When the bridge is balanced, the voltage potential at the midpoints of the two parallel branches is equal, meaning no current flows through the bridging branch (or the voltage difference across it is zero).\nThe element values in the schematic have all been set to 1; in Section 40.5, the element values will be determined. The components \\(R_1\\), \\(R_2\\) and \\(C_1\\) and \\(C_2\\) do not need to be of equal value, but if they are, some of the analysis is simplified. The circuit above is missing the amplitude stabilizing elements that are usually included in real world implementations of the Wien Bridge oscillator. See Section 40.6 for a version of an actual implementation.\nThe following Python modules are used in this JupyterLab notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\nfrom tabulate import tabulate\ninit_printing()",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#network-equations",
    "href": "Wien bridge oscillator.html#network-equations",
    "title": "40  Wien Bridge Oscillator",
    "section": "40.3 Network Equations",
    "text": "40.3 Network Equations\nThe netlist for the schematic above was generated by LTSpice and copied into the cell below.\n\nWien_bridge_v0_net_list = '''\n* Wien bridge oscillator v0.asc\nO1 4 2 1\nR4 4 1 1\nR1 0 2 1\nR3 0 4 1\nR2 2 3 1\nC2 3 1 1\nC1 0 2 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Wien_bridge_v0_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = - C_{2} s v_{3} + I_{O1} + v_{1} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}}\\)\\(0 = v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\)\\(0 = - C_{2} s v_{1} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\)\\(0 = v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{1}}{R_{4}}\\)\\(0 = - v_{2} + v_{4}\\)\n\n\nThere is no independent voltage or current source in the circuit, so all the node voltages are zero.\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#open-loop-analysis",
    "href": "Wien bridge oscillator.html#open-loop-analysis",
    "title": "40  Wien Bridge Oscillator",
    "section": "40.4 Open Loop Analysis",
    "text": "40.4 Open Loop Analysis\nThe analysis presented here follows the same steps that can be found in Budak (1974). While most sophisticated control systems are closed-loop (meaning they use feedback), open-loop analysis is incredibly important for several reasons. The open-loop transfer function (\\(G(s)H(s)\\) or just \\(G(s)\\) if \\(H(s)=1\\)) represents the inherent dynamics of the system you are trying to control. By analyzing the open-loop circuit you can understand how the circuit responds to inputs without any corrective action from a feedback loop. This tells you about its natural gain, phase shift, time delays and stability characteristics in isolation. It helps in identifying poles and zeros that are inherent to the system.\nThe circuit shown below is the open loop Wien Bridge circuit. \\(V_1\\) is the output of the Op Amp that drives the frequency selective parts of the oscillator and the value of \\(V_1\\) is K. The element values have been set to 1 because we are doing a symbolic solution to start with.\n\n\n\n\n\n\nFigure 40.2: Schematic used for loop calculations\n\n\n\nThe netlist below was exported from LTSpice.\n\nWien_bridge_loop_gain_net_list = '''\n* Wien bridge loop gain.asc\nR2 3 2 1\nR1 2 0 1\nC1 2 0 1\nC2 1 3 1\nV1 1 0 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Wien_bridge_loop_gain_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{2} s v_{1} - C_{2} s v_{3} + I_{V1}\\)\\(0 = v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\)\\(0 = - C_{2} s v_{1} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n40.4.0.1 Symbolic solution\nThe network equations for the circuit in Figure 40.2 can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the node voltages and dependent currents using symbolic notation.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} R_{1} V_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\\(v_{3} = \\frac{C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{2} R_{1} V_{1} s + C_{2} R_{2} V_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} R_{1} V_{1} s^{2} - C_{2} V_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C_{2} R_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\n\n\nThe numerator is a first order polynomial and the denominator is a second order polynomial. Generally, the order of the dominator is equal to the number of reactive elements in the circuit; sometimes roots of the numerator will exactly cancel with a root of the denominator polynomial. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n40.4.0.2 Numerator Polynomial of \\(H_{sym}(s)\\)\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=C_{2} R_{1} s\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$&lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=0\\)\n\n\n\\(b_1=C_{2} R_{1}\\)\n\n\n\\(b_0=0\\)\n\n\n\nThe roots of the numerator polynomial can easily be found by inspection. There is only one root and the value is zero.\n\n\n40.4.0.3 Denominator Polynomial of \\(H_{sym}(s)\\)\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_2s^2+a_1s+a_0\\)\nwhere \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\na2 = H_sym_denom.coeff(s**2)\na1 = H_sym_denom.coeff(s**1)\na0 = (H_sym_denom - a1*s*1 - a2*s**2).expand()\nMarkdown('&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;$a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_2=C_{1} C_{2} R_{1} R_{2}\\)\n\n\n\\(a_1=C_{1} R_{1} + C_{2} R_{1} + C_{2} R_{2}\\)\n\n\n\\(a_0=1\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transfer function, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are: &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1])))\n\nThere are 2 poles, which are:\n\n\\(p_0=\\frac{- C_{1} R_{1} - C_{2} R_{1} - C_{2} R_{2} - \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\\(p_1=\\frac{- C_{1} R_{1} - C_{2} R_{1} - C_{2} R_{2} + \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\n\\(H(s)\\) is a band pass function. We can find \\(\\omega_n\\) and Q.\n\nomega_n = sqrt(a0/a2)\nMarkdown('The natural frequency is: ${:s}$'.format(latex(omega_n)))\n\nThe natural frequency is: \\(\\sqrt{\\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\n\nBW = (a1/a2)\nMarkdown('The bandwidth is: ${:s}$'.format(latex(BW)))\n\nThe bandwidth is: \\(\\frac{C_{1} R_{1} + C_{2} R_{1} + C_{2} R_{2}}{C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\nquality_factor = omega_n/BW\nMarkdown('The Q is: ${:s}$'.format(latex(quality_factor)))\n\nThe Q is: \\(\\frac{C_{1} C_{2} R_{1} R_{2} \\sqrt{\\frac{1}{C_{1} C_{2} R_{1} R_{2}}}}{C_{1} R_{1} + C_{2} R_{1} + C_{2} R_{2}}\\)\n\n\nAccording to Budak (1974), the 3 dB bandwidth of the loop gain is more than \\(2\\omega_n\\). Most often R’s and C’s are made the same so \\(BW=3\\omega_n\\). Accordingly, the frequency selectivity is somewhat poor.\n\n\n40.4.1 Characteristic Equation\nThe Wien bridge oscillator has positive feedback provided by the RC components \\(R_1\\), \\(R_2\\), \\(C_1\\) and \\(C_2\\). Including K as the gain term, the characteristic equation becomes \\(1 - KH(s) = 0\\). The roots of the characteristic equation dictate the circuit’s stability. For stable positive feedback, oscillation requires the roots of \\(1 - G(s)H(s) = 0\\) to have zero real parts.\nWe can define a new symbol, K, to be the gain of the Op Amp determined by \\(R_3\\) and \\(R_4\\) in Figure 40.1.\n\nK = symbols('K')\n\n\nMarkdown('The characteristic equation is: ${:s}$'.format(latex(1-K*H_sym)))\n\nThe characteristic equation is: \\(- \\frac{C_{2} K R_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1} + 1\\)\n\n\nWe can solve for the roots of the characteristic equation.\n\nroots_char_equ = solve(1-K*H_sym,s)\nMarkdown('There are {:d} roots, which are: &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(roots_char_equ),latex(roots_char_equ[0]),latex(roots_char_equ[1])))\n\nThere are 2 roots, which are:\n\n\\(p_0=\\frac{- C_{1} R_{1} + C_{2} K R_{1} - C_{2} R_{1} - C_{2} R_{2} - \\sqrt{C_{1}^{2} R_{1}^{2} - 2 C_{1} C_{2} K R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} K^{2} R_{1}^{2} - 2 C_{2}^{2} K R_{1}^{2} - 2 C_{2}^{2} K R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\\(p_1=\\frac{- C_{1} R_{1} + C_{2} K R_{1} - C_{2} R_{1} - C_{2} R_{2} + \\sqrt{C_{1}^{2} R_{1}^{2} - 2 C_{1} C_{2} K R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} K^{2} R_{1}^{2} - 2 C_{2}^{2} K R_{1}^{2} - 2 C_{2}^{2} K R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\nFor the oscillator to run and be stable, the roots need to be imaginary with a real part equal to zero. From the expressions for the roots, we can see that the real part of the roots will be zero if \\(-C_1R_1 + C_2KR_1 - C_2R_1 - C_2R_2=0\\). This is called the critical value, \\(K_c\\). If \\(K \\lt K_c\\), the roots are in the left hand complex frequency plane and oscillations will not be sustained. If \\(K \\gt K_c\\), the oscillations will grow and the amplitude will exceed the dynamic range of the Op Amp. Maintaining the exact value of \\(K_c\\) is not possible in the real world and the circuit in Figure 40.3 is one example of a realistic circuit.\nWe can solve this expression to determine the component values to make the real part zero.\n\nMarkdown('Solving for K, we get: K = ${:s}$'.format(latex(solve(-C1*R1 + C2*K*R1 - C2*R1 - C2*R2,K))))\n\nSolving for K, we get: K = \\(\\left[ \\frac{C_{1}}{C_{2}} + 1 + \\frac{R_{2}}{R_{1}}\\right]\\)\n\n\nIf we substitute the expression for K back into the characteristic equation we get a set of imaginary poles.\n\nroots_char_equ = solve((1-K*H_sym).subs({K:1+R2/R1+C1/C2}),s)\nMarkdown('There are {:d} roots, which are: &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(roots_char_equ),latex(roots_char_equ[0]),latex(roots_char_equ[1])))\n\nThere are 2 roots, which are:\n\n\\(p_0=- \\sqrt{- \\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\n\\(p_1=\\sqrt{- \\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\n\nThus, with the gain, \\(K=1+R_2/R_1+C_1/C_2\\), we get two imaginary roots.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#sec-design-example",
    "href": "Wien bridge oscillator.html#sec-design-example",
    "title": "40  Wien Bridge Oscillator",
    "section": "40.5 Design Example",
    "text": "40.5 Design Example\nFor the example design, we want the Wien Bridge oscillator to have a frequency of 1kHz. If we let \\(R=R_1=R_2\\) and \\(C_1 = C_2 = 0.1\\mu F\\), we can solve for \\(R\\).\nFirst we declare a new symbol, \\(R\\).\n\nR = symbols('R')\n\nThe expression for the natural frequency was obtained from the characteristic polynomial.\n\nMarkdown('The expression for the natural frequency is: $\\omega_n={:s}$'.format(latex(omega_n)))\n\nThe expression for the natural frequency is: \\(\\omega_n=\\sqrt{\\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\nAfter making some substitutions, we can solve for \\(R\\); we get the numerical value for R.\n\nR = solve(omega_n.subs({C1:0.1e-6,C2:0.1e-6,R1:R,R2:R})-2*np.pi*1e3,R)[1]\nMarkdown('R = ${:s}$'.format(latex(R)))\n\nR = \\(1591.54943091895\\)\n\n\nWe can update the element values as follows:\n\nelement_values[R1] = R\nelement_values[R2] = R\nelement_values[C1] = 0.1e-6\nelement_values[C2] = 0.1e-6\n\nIf we substitute these values into the expression for K, we get:\n\nMarkdown('K = ${:s}$'.format(latex((1+C1/C2+R2/R1).subs(element_values))))\n\nK = \\(3.0\\)\n\n\nK, which is the gain of the Op Amp is \\(K=1+R_4/R_3\\). If we choose \\(R_3=1k\\Omega\\) and solve for \\(R_4\\), we get:\n\nK = 1+R4/R3\nsolve(K.subs({R3:1e3})-3,R4)[0]\nMarkdown('R4 = ${:s}$'.format(latex(solve(K.subs({R3:1e3})-3,R4)[0])))\n\nR4 = \\(2000.0\\)\n\n\nWe can update the element values for \\(R_3\\) and \\(R_4\\).\n\nelement_values[R3] = 1e3\nelement_values[R4] = 2e3\n\n\n40.5.1 Numerical Solution\nThe network equations can be numerically solved when the element values are included in the calculations.\n\nequ_N = NE_sym.subs(element_values)\n\nWe get the following numerical network equations:\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(equ_N.lhs[i]))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\n\n\n\\(0 = v_{2} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.00125663706143592\\right) - 0.000628318530717959 v_{3}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000628318530717959 v_{2} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\). The node voltages and unknown current is:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{6.28318530717959 \\cdot 10^{25} s}{1.0 \\cdot 10^{22} s^{2} + 1.88495559215388 \\cdot 10^{26} s + 3.94784176043576 \\cdot 10^{29}}\\)\n\n\n\\(v_{3} = \\frac{1.0 \\cdot 10^{22} s^{2} + 1.25663706143592 \\cdot 10^{26} s}{1.0 \\cdot 10^{22} s^{2} + 1.88495559215388 \\cdot 10^{26} s + 3.94784176043576 \\cdot 10^{29}}\\)\n\n\n\\(I_{V1} = \\frac{- 6.28318530717959 \\cdot 10^{25} s^{2} - 3.94784176043576 \\cdot 10^{29} s}{1.0 \\cdot 10^{29} s^{2} + 1.88495559215388 \\cdot 10^{33} s + 3.94784176043576 \\cdot 10^{36}}\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{6.28318530717959 \\cdot 10^{25} s}{1.0 \\cdot 10^{22} s^{2} + 1.88495559215388 \\cdot 10^{26} s + 3.94784176043576 \\cdot 10^{29}}\\)\n\n\n\n\n40.5.2 Characteristic Equation\nIn control systems engineering, the characteristic equation is a fundamental algebraic equation that plays a crucial role in understanding and analyzing the behavior, and most importantly, the stability of a dynamic system. The value \\(k=3\\) was determined above. The roots of the characteristic equation directly reveal critical information about the system’s dynamic response and stability. The roots of the characteristic equation are the poles of the closed-loop system. If a pair of roots lies exactly on the imaginary axis (with zero real part), the system is marginally stable. This usually means the system will oscillate continuously without decaying or growing.\nThe solve function can determine the roots of the characteristic equation.\n\nchar_equ_roots = solve(1-3*H,s)\nMarkdown('There are {:d} imaginary roots at, {:,.0f}$j\\omega$ Hz and {:,.0f}$j\\omega$ Hz.'.format(len(char_equ_roots),complex(char_equ_roots[0]/(2*np.pi)).imag,complex(char_equ_roots[1]/(2*np.pi)).imag))\n\nThere are 2 imaginary roots at, -1,000\\(j\\omega\\) Hz and 1,000\\(j\\omega\\) Hz.\n\n\n\n\n40.5.3 Feedback Transfer Function\nThe feedback transfer function of Figure 40.2 is \\(H_{sym}(s)=\\frac {v_2(s)}{v_1(s)}\\). The magnitude and phase response is plotted below.\n\nH_num, H_denom = fraction(3*H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n# plot the magnitude and phase\nax1.semilogx(w/(2*np.pi), mag,'-k',label='mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':k',label='phase')  # phase plot\n\nax1.set_ylim((-40,5))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe band pass nature of the feedback transfer function limits the oscillation frequency to \\(\\omega_n\\).",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#sec-ltspice-simulation",
    "href": "Wien bridge oscillator.html#sec-ltspice-simulation",
    "title": "40  Wien Bridge Oscillator",
    "section": "40.6 LTSpice Simulation",
    "text": "40.6 LTSpice Simulation\nThe circuit shown below is an example of a Wien Bridge oscillator with standard component values and amplitude stabilizing components consisting of \\(R_5\\), \\(D_1\\) and \\(D_2\\). There are many other examples of Wien Bridge oscillators online.\n\n\n\n\n\n\nFigure 40.3: Schematic used for LTSpice.\n\n\n\nThe circuit above is from Franco (2002), Figure 10.3 (a). The component values were chosen from the design example above. The value for \\(R_4\\) was chosen a bit higher to keep the poles in the right hand plane over tolerance and temperature variations. This circuit can be simulated in LTSpice with the following file.\n* Wien bridge oscillator v1.asc\nXU1 4 2 1 opamp Aol=100K GBW=10Meg\nR4 1 4 2.1k\nR2 3 2 1.58k\nR1 2 0 1.58k\nR3 4 0 1k\nC1 2 0 0.1µ\nC2 1 3 0.1µ\nD1 4 5 1N914\nD2 5 4 1N914\nR5 5 1 100\n.model D D\n.lib standard.dio\n.lib opamp.sub\n.tran 0.1s\n.ic V(2)=0.01\n.backanno\n.end",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#summary",
    "href": "Wien bridge oscillator.html#summary",
    "title": "40  Wien Bridge Oscillator",
    "section": "40.7 Summary",
    "text": "40.7 Summary\nThis notebook has presented some of the analysis and calculations for the design of a Wien Bridge oscillator using Python and MNA. Oscillators are networks that produce a pair of imaginary axis poles. When a circuit has poles exactly on the imaginary axis (e.g., at \\(j\\omega_0\\) and \\(-j\\omega_0\\)), it means that the system will exhibit a sustained, undamped oscillation at the frequency \\(\\omega_0\\). There is no exponential decay or growth; the oscillations continue indefinitely. Oscillators are designed with positive feedback loops. This positive feedback, along with specific gain and phase conditions, put the system’s poles onto the imaginary axis. Without this positive feedback, the poles would typically be in the left half of the s-plane (leading to stable, decaying responses).\n\n\n\n\nBudak, A. 1974. Passive and Active Network Analysis and Synthesis. Houghton Mifflin.\n\n\nFranco, Sergio. 2002. Design with Operational Amplifiers and Analog Integrated Circuits, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Flyback circuit.html",
    "href": "Flyback circuit.html",
    "title": "41  Flyback Circuit",
    "section": "",
    "text": "Analysis of a flyback switch mode power supply.\nThis page is a placeholder.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Flyback Circuit</span>"
    ]
  },
  {
    "objectID": "Diode circuit.html",
    "href": "Diode circuit.html",
    "title": "42  Diode Circuit",
    "section": "",
    "text": "Circuit analysis with one or more diodes in the circuit.\nThis page is a placeholder.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Transistor circuit.html",
    "href": "Transistor circuit.html",
    "title": "43  Transistor Circuit",
    "section": "",
    "text": "Circuit analysis with one or more transistors in the circuit.\nThis page is a placeholder.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Transistor Circuit</span>"
    ]
  },
  {
    "objectID": "Bridged T-coil temp.html",
    "href": "Bridged T-coil temp.html",
    "title": "44  Bridged T-Coil",
    "section": "",
    "text": "A circuit with a coupled inductor and a bridging capacitor.\nAbstract from The Bridged T-Coil [A Circuit for All Seasons]\n\nThe bridged T-coil, often simply called the T-coil, is a circuit topology that extends the bandwidth by a greater factor than does inductive peaking. Many high-speed amplifiers, line drivers, and input/output (I/O) interfaces in today?s wireline systems incorporate on-chip T-coils to deal with parasitic capacitances. …\n\nOther references:\n\nThe Bridged T-Coil\nTopics in IC Design\n\nThis page is a placeholder.",
    "crumbs": [
      "Example problems",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Bridged T-Coil</span>"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "References",
    "section": "",
    "text": "Akbaba, Mehmet, Omar Dakkak, Byung-Seo Kim, Adnan Cora, and Shahrudin\nAwang Nor. 2022. “Electric Circuit-Based Modeling and Analysis of\nthe Translational, Rotational Mechanical and Electromechanical Systems\nDynamics.” IEEE Access. https://doi.org/10.1109/ACCESS.2022.3185422.\n\n\nAntoniou, Andreas. 1969. “Realization of Gyrators Using\nOperational Amplifiers and Their Use in RC-Active-Network\nSynthesis.” In. https://api.semanticscholar.org/CorpusID:64381922.\n\n\nBasso, Christophe. 2016. “Introduction to Fast Analytical\nTechniques: Application to Small-Signal Modeling.” 2016. https://www.powersimtof.com/Downloads/PPTs/Chris%20Basso%20APEC%20seminar%202016.pdf.\n\n\nBruton, L. 1978. “Multiple-Amplifier RC-Active Filter Design with\nEmphasis on GIC Realizations (Invited Paper).” IEEE\nTransactions on Circuits and Systems.\n\n\nBudak, A. 1974. Passive and Active Network Analysis and\nSynthesis. Houghton Mifflin.\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The\nCircuits and Filters Handbook, 3rd Edition. CRC Press. https://www.gbv.de/dms/ilmenau/toc/585302871.PDF.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of\nAnalog Circuits Through Symbolic Analysis. https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis.\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nFranco, Sergio. 2002. Design with Operational Amplifiers and Analog\nIntegrated Circuits, 3rd Edition. McGraw-Hill.\n\n\nHayes, M. 2022. “Lcapy: Symbolic Linear Circuit Analysis with\nPython.” https://doi.org/10.7717/peerj-cs.875.\n\n\nHaykin, S. 1970. Active Network Theory. Addison Wesley.\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd\nEdition. McGraw-Hill.\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal\nApproach to Network Analysis.” IEEE Transactions on Circuits\nand Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric\nCircuit Analysis. Prentice-Hall, Inc.\n\n\nLees, Andrew. 2023. “Solution of Electrical Network Where\nArbitrary Initial Conditions Cannot Be Assigned.” 2023. https://electronics.stackexchange.com/questions/682634/solution-of-electrical-network-where-arbitrary-initial-conditions-cannot-be-assi.\n\n\nMalek, Ihdene. 2020. “Eliminating Ideal Voltage Source for Node\nAnalysis.” Electrical Engineering Stack Exchange. https://electronics.stackexchange.com/q/479528.\n\n\nMiddlebrook, R. D. 1991. “Low-Entropy Expressions: The Key to\nDesign-Oriented Analysis.” In Proceedings Frontiers in\nEducation Twenty-First Annual Conference. Engineering Education in a New\nWorld Order, 399–403. https://doi.org/10.1109/FIE.1991.187513.\n\n\n———. 1992. “Methods of Design-Oriented Analysis: The Quadratic\nEquation Revisited.” In Proceedings. Twenty-Second Annual\nConference Frontiers in Education, 95–102. https://doi.org/10.1109/FIE.1992.683365.\n\n\nMiddlebrook, R. D., V. Vorperian, and J. Lindal. 1998. “The n\nExtra Element Theorem.” IEEE Transactions on Circuits and\nSystems I: Fundamental Theory and Applications 45 (9): 919–35. https://doi.org/10.1109/81.721258.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit\nEquations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific\nComputing. Numerical Recipes in c Book Set. Cambridge University\nPress.\n\n\nSedra, A., and J. Espinoza. 1975. “Sensitivity and Frequency\nLimitations of Biquadratic Active Filters.” IEEE Transactions\non Circuits and Systems.\n\n\nStout, D. 1976. Handbook of Operational Amplifier Circuit\nDesign. McGraw-Hill.\n\n\nTow, J. 1968. “Active RC Filters a State-Space\nRealization.” Proceedings of the IEEE 56 (6): 1137–39.\nhttps://doi.org/10.1109/PROC.1968.6502.\n\n\nuser15174. 2023. “How to Find Transfer Function for This Pi-Filter\nUsing FACTS Method with 6 Reactive Elements?” https://electronics.stackexchange.com/questions/681002/how-to-find-transfer-function-for-this-pi-filter-using-facts-method-with-6-react/681087#681087.\n\n\nuser349644. 2023. “Transfer Function of the Below Circuit.”\nhttps://electronics.stackexchange.com/questions/682389/transfer-function-of-the-below-circuit.\n\n\nuser69860. 2016. “Nodal Analysis - Deriving Equations at Each\nNode.” https://electronics.stackexchange.com/q/192420.\n\n\nVorpérian, Vatché. 2002. Fast Analytical Techniques for Electrical\nand Electronic Circuits. Cambridge University Press. https://www.cambridge.org/core/books/fast-analytical-techniques-for-electrical-and-electronic-circuits/17845BA88A05A1645A8409D6739A475A#fndtn-information.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design\nHandbook, Third Edition. McGraw-Hill Education.\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley &\nSons.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "SymMNA_py.html",
    "href": "SymMNA_py.html",
    "title": "Appendix A — SymMNA.py",
    "section": "",
    "text": "The code listing below is for the Python functions that implement the MNA algorithm.\n\"\"\"Symbolic modified nodal analysis\nLast update: 29 Jun 2024\n\nDescription:\nThe modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear \ncircuit analysis.\n\nMy code started initially by following Erik Cheever's Analysis of Resistive Circuits [1], which used Matlab code \nto generate modified nodal equations. I somewhat followed his MATLAB file for resistors, capacitors, Op Amps and independent sources. \nThe naming of the matrices follows his convention. The preprocessor and parser code was converted from my old C code. \nThe use of pandas for a data frame is new and SymPy is used to do the math and the use of element \nstamps are from [2].\n\nInductors are being addressed in the D matrix. Erik's code puts inductors into the G matrix as 1/s/L.  \nMy code puts the inductor contribution into the D matrix and the unknown current from the inductor into \nthe B and C matrices.  Coupled inductors also affect the D matrix, so it makes sense to allow the inductors \nto be in the D matrix rather than the G matrix.\n\nReferences:\n1. [Analysis of  Resistive Circuits](http://www.swarthmore.edu/NatSci/echeeve1/Ref/mna/MNA1.html), retrieved October 6, 2017  \n2. [ECE 570 Session 3](http://www2.engr.arizona.edu/~ece570/session3.pdf), Computer Aided Engineering for Integrated Circuits, retrieved November 13, 2023  \n\nReferences use in the debugging of the Op Amp stamp:   \n3. [Design of Analog Circuits Through Symbolic Analysis](https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis) edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fernandez, retrieved June29, 2024 \n4. [Computer Aided Design and Design Automation](https://www.gbv.de/dms/ilmenau/toc/585302871.PDF), edited by Wai-Kai Chen, retrieved June 29, 2024\n\nExample usage:  See SMNA_func_test.py\n\"\"\"\n\nfrom sympy import *\nimport numpy as np\nimport pandas as pd\n\ndef get_part_values(net_df):\n    \"\"\" construct a dictionary of element values from the netlist dataframe: value_dict, get_part_values\n    Parameters\n    ----------\n    net_df: pandas dataframe\n        the network dataframe returned by the smna function below\n    Returns\n    -------\n    element values: Python dictionary\n        the element values from the netlist\n    \"\"\"\n\n    # initialize variables\n    element_value_keys = []\n    element_value_values = []\n\n    for i in range(len(net_df)):\n        if net_df.iloc[i]['element'][0] == 'F' or net_df.iloc[i]['element'][0] == 'E' or net_df.iloc[i]['element'][0] == 'G' or net_df.iloc[i]['element'][0] == 'H':\n            element_value_keys.append(var(net_df.iloc[i]['element'].lower()))\n            element_value_values.append(net_df.iloc[i]['value'])\n        else:\n            element_value_keys.append(var(net_df.iloc[i]['element']))\n            element_value_values.append(net_df.iloc[i]['value'])\n\n    return dict(zip(element_value_keys, element_value_values))\n\ndef smna(net_list):\n    \"\"\"Symbolic modified nodal analysis\n    Parameters\n    ----------\n    net_list: str\n        The circuit net list, needs a \\n at the end of each line\n    Returns\n    -------\n    report: text string\n            The net list report.\n    df: pandas dataframe\n            circuit net list info loaded into a dataframe\n    df2: pandas dataframe\n            branches with unknown currents\n    A: SymPy matrix\n            The A matrix is (m+n) by (m+n) and is the combination of 4 smaller matrices, G, B, C, and D.\n            The G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections\n            between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, \n            where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage \n            sources, current controlling elements, etc. In Python row and columns are: G[row, column]\n            The B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes\n            and m is the number of current unknowns, i_unk. There is one column for each unknown current.\n            The code loop through all the branches and process elements that have stamps for the B matrix: \n            The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).\n            The code is similar to the B matrix code, except the indices are swapped. The code loops through \n            all the branches and process elements that have stamps for the C matrix: \n            The D matrix is an m by m matrix, where m is the number of unknown currents. \n    X: list\n            The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages \n            and the currents through the independent voltage sources). The top n elements are the n node \n            voltages. The bottom m elements represent the currents through the m independent voltage \n            sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix \n            is m by 1 and holds the unknown currents through the voltage sources\n    Z: list\n            The Z matrix holds the independent voltage and current sources and is the combination\n            of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, \n            and m is the number of independent voltage sources. The I matrix is n by 1 and contains \n            the sum of the currents through the passive elements into the corresponding node (either \n            zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the \n            values of the independent voltage sources.\n    \"\"\"\n\n    # initialize variables\n    num_rlc = 0 # number of passive elements\n    num_res = 0 # number of resistors\n    num_cap = 0 # number of capacitors\n    num_ind = 0 # number of inductors\n    num_v = 0    # number of independent voltage sources\n    num_i = 0    # number of independent current sources\n    i_unk = 0  # number of current unknowns\n    num_opamps = 0   # number of Op Amps\n    num_vcvs = 0     # number of controlled sources of various types\n    num_vccs = 0\n    num_cccs = 0\n    num_ccvs = 0\n    num_cpld_ind = 0 # number of coupled inductors\n\n    content = net_list.splitlines()\n\n    content = [x.strip() for x in content]  #remove leading and trailing white space\n    # remove empty lines\n    while '' in content:\n        content.pop(content.index(''))\n\n    # remove comment lines, these start with a asterisk *\n    content = [n for n in content if not n.startswith('*')]\n    # remove other comment lines, these start with a semicolon ;\n    content = [n for n in content if not n.startswith(';')]\n    # remove spice directives, these start with a period, .\n    content = [n for n in content if not n.startswith('.')]\n    # converts 1st letter to upper case\n    #content = [x.upper() for x in content] &lt;- this converts all to upper case\n    content = [x.capitalize() for x in content]\n    # removes extra spaces between entries\n    content = [' '.join(x.split()) for x in content]\n\n    line_cnt = len(content) # number of lines in the netlist\n    branch_cnt = 0  # number of branches in the netlist\n    # check number of entries on each line, count each element type\n    for i in range(line_cnt):\n        x = content[i][0]\n        tk_cnt = len(content[i].split()) # split the line into a list of words\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_rlc += 1\n            branch_cnt += 1\n            if x == 'R':\n                num_res += 1            \n            if x == 'C':\n                num_cap += 1            \n            if x == 'L':\n                num_ind += 1\n        elif x == 'V':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_v += 1\n            branch_cnt += 1\n        elif x == 'I':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_i += 1\n            branch_cnt += 1\n        elif x == 'O':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_opamps += 1\n        elif x == 'E':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vcvs += 1\n            branch_cnt += 1\n        elif x == 'G':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vccs += 1\n            branch_cnt += 1\n        elif x == 'F':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_cccs += 1\n            branch_cnt += 1\n        elif x == 'H':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_ccvs += 1\n            branch_cnt += 1\n        elif x == 'K':\n            if (tk_cnt != 4):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_cpld_ind += 1\n        else:\n            raise Exception(\"unknown element type in branch {:d}: {:s}\".format(i,content[i]))\n\n\n    ''' The parser performs the following operations.\n     1. puts branch elements into data frame  \n     2. counts number of nodes  \n\n     data frame labels:\n     - element: type of element  \n     - p node: positive node  \n     - n node: negative node, for a current source, the arrow point terminal, LTSpice \n     puts the inductor phasing dot on this terminal  \n     - cp node: controlling positive node of branch  \n     - cn node: controlling negative node of branch  \n     - Vout: Op Amp output node  \n     - value: value of element or voltage  \n     - Vname: voltage source through which the controlling current flows. Need to \n     add a zero volt voltage source to the controlling branch.  \n     - Lname1: name of coupled inductor 1  \n     - Lname2: name of coupled inductor 2'''  \n\n    # build the pandas data frame\n    df = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n        'Vout','value','Vname','Lname1','Lname2'])\n\n    # this data frame is for branches with unknown currents\n    df2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n    # ### Functions to load branch elements into data frame and check for gaps in node numbering\n\n    # loads voltage or current sources into branch structure\n    def indep_source(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads passive elements into branch structure\n    def rlc_element(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads multi-terminal elements into branch structure\n    # O - Op Amps\n    def opamp_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vout'] = int(tk[3])\n\n    # G - VCCS\n    def vccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # E - VCVS\n    # in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\n    def vcvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # F - CCCS\n    def cccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # H - CCVS\n    def ccvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # K - Coupled inductors\n    def cpld_ind_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n        df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # function to scan df and get largest node number\n    def count_nodes():\n        # need to check that nodes are consecutive\n        # fill array with node numbers\n        p = np.zeros(line_cnt+1)\n        for i in range(line_cnt):\n            # need to skip coupled inductor 'K' statements\n            if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n                p[df['p node'][i]] = df['p node'][i]\n                p[df['n node'][i]] = df['n node'][i]\n\n        # find the largest node number\n        if df['n node'].max() &gt; df['p node'].max():\n            largest = df['n node'].max()\n        else:\n            largest =  df['p node'].max()\n\n        largest = int(largest)\n        # check for unfilled elements, skip node 0\n        for i in range(1,largest):\n            if p[i] == 0:\n                raise Exception('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n        return largest\n\n    # load branch info into data frame\n    for i in range(line_cnt):\n        x = content[i][0]\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            rlc_element(i)\n        elif (x == 'V') or (x == 'I'):\n            indep_source(i)\n        elif x == 'O':\n            opamp_sub_network(i)\n        elif x == 'E':\n            vcvs_sub_network(i)\n        elif x == 'G':\n            vccs_sub_network(i)\n        elif x == 'F':\n            cccs_sub_network(i)\n        elif x == 'H':\n            ccvs_sub_network(i)\n        elif x == 'K':\n            cpld_ind_sub_network(i)\n        else:\n            raise Exception(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n    '''29 Nov 2023:  When the D matrix is built, independent voltage sources are processed\n    in the data frame order when building the D matrix. If the voltage source followed element\n    L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different\n    row in relation to its position in the Ev matrix. This would cause the node attached to \n    the terminal of the voltage source to be zero volts.  \n    Solution - The following block of code was added to move voltage source types to the \n    beginning of the net list dataframe before any calculations are performed.''' \n\n    # Check for position of voltage sources in the dataframe.\n    source_index = [] # keep track of voltage source row number\n    other_index = [] # make a list of all other types\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V'):\n            source_index.append(i)\n        else:\n            other_index.append(i)\n\n    df = df.reindex(source_index+other_index,copy=True) # reorder the data frame\n    df.reset_index(drop=True, inplace=True) # renumber the index\n\n    # count number of nodes\n    num_nodes = count_nodes()\n\n    # Build df2: consists of branches with current unknowns, used for C & D matrices\n    # walk through data frame and find these parameters\n    count = 0\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n            df2.loc[count,'element'] = df.loc[i,'element']\n            df2.loc[count,'p node'] = df.loc[i,'p node']\n            df2.loc[count,'n node'] = df.loc[i,'n node']\n            count += 1\n\n    # print the netlist report\n    report = 'Net list report\\n'\n    report = report+('number of lines in netlist: {:d}\\n'.format(line_cnt))\n    report = report+'number of branches: {:d}\\n'.format(branch_cnt)\n    report = report+'number of nodes: {:d}\\n'.format(num_nodes)\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are current unknows\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\n    report = report+'number of unknown currents: {:d}\\n'.format(i_unk)\n    report = report+'number of RLC (passive components): {:d}\\n'.format(num_rlc)\n    report = report+'number of resistors: {:d}\\n'.format(num_res)    \n    report = report+'number of capacitors: {:d}\\n'.format(num_cap)    \n    report = report+'number of inductors: {:d}\\n'.format(num_ind)\n    report = report+'number of independent voltage sources: {:d}\\n'.format(num_v)\n    report = report+'number of independent current sources: {:d}\\n'.format(num_i)\n    report = report+'number of Op Amps: {:d}\\n'.format(num_opamps)\n    report = report+'number of E - VCVS: {:d}\\n'.format(num_vcvs)\n    report = report+'number of G - VCCS: {:d}\\n'.format(num_vccs)\n    report = report+'number of F - CCCS: {:d}\\n'.format(num_cccs)\n    report = report+'number of H - CCVS: {:d}\\n'.format(num_ccvs)\n    report = report+'number of K - Coupled inductors: {:d}\\n'.format(num_cpld_ind)\n\n    # initialize some symbolic matrix with zeros\n    # A is formed by [[G, C] [B, D]]\n    # Z = [I,E]\n    # X = [V, J]\n    V = zeros(num_nodes,1)\n    I = zeros(num_nodes,1)\n    G = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\n    s = Symbol('s')  # the Laplace variable\n\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are element types that have unknown currents\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    # if i_unk == 0, just generate empty arrays\n    B = zeros(num_nodes,i_unk)\n    C = zeros(i_unk,num_nodes)\n    D = zeros(i_unk,i_unk)\n    Ev = zeros(i_unk,1)\n    J = zeros(i_unk,1)\n\n    ''' The G matrix is n by n, where n is the number of nodes. \n    The matrix is formed by the interconnections between the resistors, \n    capacitors and VCCS type elements.  In the original paper G is called Yr, \n    where Yr is a reduced form of the nodal matrix excluding the contributions \n    due to voltage sources, current controlling elements, etc.  In Python row \n    and columns are: G[row, column]'''\n    for i in range(len(df)):  # process each row in the data frame\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node']\n        cn2 = df.loc[i,'cn node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'R':\n            g = 1/sympify(df.loc[i,'element'])\n        if x == 'C':\n            g = s*sympify(df.loc[i,'element'])\n        if x == 'G':   #vccs type element\n            g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n        if (x == 'R') or (x == 'C'):\n            # If neither side of the element is connected to ground\n            # then subtract it from the appropriate location in the matrix.\n            if (n1 != 0) and (n2 != 0):\n                G[n1-1,n2-1] += -g\n                G[n2-1,n1-1] += -g\n\n            # If node 1 is connected to ground, add element to diagonal of matrix\n            if n1 != 0:\n                G[n1-1,n1-1] += g\n\n            # same for for node 2\n            if n2 != 0:\n                G[n2-1,n2-1] += g\n\n        if x == 'G':    #vccs type element\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0 and cn1 != 0:\n                G[n1-1,cn1-1] += g\n\n            if n2 != 0 and cn2 != 0:\n                G[n2-1,cn2-1] += g\n\n            if n1 != 0 and cn2 != 0:\n                G[n1-1,cn2-1] -= g\n\n            if n2 != 0 and cn1 != 0:\n                G[n2-1,cn1-1] -= g\n\n    '''The B matrix is an n by m matrix with only 0, 1 and -1 elements, where \n    n = number of nodes and m is the number of current unknowns, i_unk. There is \n    one column for each unknown current. The code loop through all the branches \n    and process elements that have stamps for the B matrix:  \n     - Voltage sources (V)  \n     - Op Amps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)    \n\n    The order of the columns is as they appear in the netlist.  CCCS (F) does not get\n    its own column because the controlling current is through a zero volt voltage source,\n    called Vname and is already in the net list.'''\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'O':  # Op Amp type, output connection of the Op Amp goes in the B matrix\n            B[n_vout-1,sn] = 1\n            sn += 1   # increment source count\n        if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\n    ''' The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).  \n    The code is similar to the B matrix code, except the indices are swapped.   The code loops through \n    all the branches and process elements that have stamps for the C matrix:  \n     - Voltage sources (V)  \n     - Opamps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)  \n\n     Op Amp elements\n     The Op Amp element is assumed to be an ideal Op Amp and use of this component is valid only when \n     used in circuits with a DC path (a short or a resistor) from the output terminal to the negative \n     input terminal of the Op Amp. No error checking is provided and if the condition is violated, \n     the results likely will be erroneous. See [3][4].   \n\n     Find the the column position in the C and D matrix for controlled sources\n     needs to return the node numbers and branch number of controlling branch'''\n    def find_vname(name):\n        # need to walk through data frame and find these parameters\n        for i in range(len(df2)):\n            # process all the elements creating unknown currents\n            if name == df2.loc[i,'element']:\n                n1 = df2.loc[i,'p node']\n                n2 = df2.loc[i,'n node']\n                return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n        raise Exception('failed to find matching branch element in find_vname')\n\n    # generate the C Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        cn2 = df.loc[i,'cn node']\n        n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n        if x == 'O':  # Op Amp type, input connections of the opamp go into the C matrix\n            # C[sn,n_vout-1] = 1\n            if i_unk &gt; 1:  #is B greater than 1 by n?, O\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   # increment source count\n\n        if x == 'F':  # need to count F (cccs) types\n            sn += 1   #increment source count\n        if x == 'H':  # H: ccvs\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n                # add entry for cp and cn of the controlling voltage\n                if cn1 != 0:\n                    C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n                if cn2 != 0:\n                    C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n                vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n                if vn1 != 0:\n                    C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n                if vn2 != 0:\n                    C[vn2-1] = sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\n    ''' The D matrix is an m by m matrix, where m is the number of unknown currents.  \n    m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n    Stamps that affect the D matrix are: inductor, ccvs and cccs  \n    inductors: minus sign added to keep current flow convention consistent  \n\n    Coupled inductors notes:  \n    Can the K statement be anywhere in the net list, even before Lx and Ly?   \n    12/6/2017 doing some debugging on with coupled inductors  \n    LTSpice seems to put the phasing dot on the neg node when it generates the netlist   \n    This code uses M for mutual inductance, LTSpice uses k for the coupling coefficient.'''  \n\n    # generate the D Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        #cn2 = df.loc[i,'cn node']\n        #n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n        # process elements with input to D matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is D greater than 1 by 1?\n                D[sn,sn] += -s*sympify(df.loc[i,'element'])\n            else:\n                D[sn] += -s*sympify(df.loc[i,'element'])\n            sn += 1   #increment source count\n\n        if x == 'H':  # H: ccvs\n            # if there is a H type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'F':  # F: cccs\n            # if there is a F type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            D[sn,sn] = 1\n            sn += 1   #increment source count\n\n        if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n            # if there is a K type, D is m by m\n            vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n            vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n            # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n            D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n            D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n    ''' The V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.  \n    Maybe make small v's v_1 so as not to confuse v1 with V1.'''\n    # generate the V matrix\n    for i in range(num_nodes):\n        V[i] = sympify('v{:d}'.format(i+1))\n\n    ''' The J matrix is an m by 1 matrix, where m is the number of unknown currents.\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    The J matrix is an m by 1 matrix, with one entry for each i_unk from a source'''\n    for i in range(len(df2)):\n        # process all the unknown currents\n        J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\n    ''' The I matrix is an n by 1 matrix, where n is the number of nodes. The value\n    of each element of I is determined by the sum of current sources into the \n    corresponding node. If there are no current sources connected to the node, the value is zero.'''\n\n    # generate the I matrix, current sources have n2 = arrow end of the element\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'I':\n            g = sympify(df.loc[i,'element'])\n            # sum the current into each node\n            if n1 != 0:\n                I[n1-1] -= g\n            if n2 != 0:\n                I[n2-1] += g\n\n    # The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n    sn = 0   # count source number\n    for i in range(len(df)):\n        # process all the passive elements\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            Ev[sn] = sympify(df.loc[i,'element'])\n            sn += 1\n\n\n    ''' The Z matrix holds the independent voltage and current sources and is the combination of 2\n    smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the\n    number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents\n    through the passive elements into the corresponding node (either zero, or the sum of independent\n    current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.'''\n    Z = I[:] + Ev[:]  # the + operator in Python concatenates the lists\n\n\n    ''' The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through\n    the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the\n    currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages.\n    The J matrix is m by 1 and holds the unknown currents through the voltage sources '''\n    X = V[:] + J[:]  # the + operator in Python concatenates the lists\n\n    # The A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n    n = num_nodes\n    m = i_unk\n    A = zeros(m+n,m+n)\n    for i in range(n):\n        for j in range(n):\n            A[i,j] = G[i,j]\n\n    if i_unk &gt; 1:\n        for i in range(n):\n            for j in range(m):\n                A[i,n+j] = B[i,j]\n                A[n+j,i] = C[j,i]\n\n        for i in range(m):\n            for j in range(m):\n                A[n+i,n+j] = D[i,j]\n\n    if i_unk == 1:\n        for i in range(n):\n            A[i,n] = B[i]\n            A[n,i] = C[i]\n        A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\n    return report, df, df2, A, X, Z",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>SymMNA.py</span>"
    ]
  },
  {
    "objectID": "Change-log.html",
    "href": "Change-log.html",
    "title": "Appendix B — Change Log",
    "section": "",
    "text": "The following table is a history of the Python MNA code development.\n\n\n\nTable B.1: Code change log\n\n\n\n\n\n\n\n\n\nDate\nEvent\n\n\n\n\n7/1/2015\nPython coding started, derived from my network.c code\n\n\n8/18/2017\nchanged approach, now implementing a modified nodal analysis\n\n\n8/19/2017\nWrote some code to generate symbolic matrices, works OK, so heading down the SymPy path. Basic debugging finished, but I still need to verify some circuits using Ls and Cs.\n\n\n8/30/2017\nStarted to add code for Op Amps\n\n\n9/1/2017\nCode added to process Op Amps\n\n\n9/3/2017\nAdded code to remove SPICE directives. Fixed orientation of current sources in the I matrix. N2 is the arrow end of the current source.\n\n\n9/5/2017\nAfter doing some verification testing with inductors and capacitors, it seems that inductors are not being treated correctly. According to some research, inductor stamps affect the B,C and D arrays. Erik Cheever’s code puts inductors into the G matrix as 1/s/L. LTSpice results are different from the Python code. Capacitors seem to work OK. Plan is to add controlled sources, then get inductors working.\n\n\n9/6/2017\nOp Amp_test_circuit_426 is not working. Results not the same as LTSpice Chebyshev_LPF_1dB_4pole: cut off frequency not correct, other features look OK still need to debug Op Amps and inductors Adding: VCCS = G type branch element: G needs to be modified CCVS = H type branch element: B, C and D need to be modified\n\n\n9/10/2017\nresearching formulation of B matrix what about a network with only 1 current source? The B, C and D matrix would be 0 by 0. Think about changing the name of the G matrix to Yr, to keep same as used in Ho, Ruehli, and Brennan (1975).CCVS = H type branch element: B, C and D need to be modifiedCCCS = F type branch element: B, C and D need to be modifiedVCCS = G type branch element: G needs to be modifiedVCVS = E type branch element: B and C need to be modifiedFor CCCS = F type branch elements and CCVS = H type branch elements, need to add a zero volt voltage source to the net list through which the current flows. It is necessary to add to the net list one extra voltage source for every F and H type element.\n\n\n9/12/2017\nstill working on the B matrix\n\n\n9/18/2017\nstill debugging B matrix, looks like we don’t need find_vname() or df2. This is because a zero volt voltage source is added to the netlist in SPICE. need to add CCCS type to the list of i_unk. Filled out some B matrices by hand and got the same answer as the code.\n\n\n9/30/2017\ndebugging B, C & D matricesVCVS is a E type element and SymPy didn’t like it, but fixed the problem in parser by changing the label E to Ea. Also changed the E matrix name to Ev. Code seems to run, just need to verify it. Need to find a new name for func1.\n\n\n10/1/2017\nCleaning up comments and notes.\n\n\n10/4/2017\nFixed incrementing of sn in D matrix. The D matrix needs to count all i_unks. In find_vnam() fixed col_num to return just the row number in df2.\n\n\n10/5/2017\nFixed E type in matrix C. Added CCCS to i_unk count. Fixed E type in D. Fixed J matrix. I need to look at the equations next, they don’t look correct.\n\n\n10/7/2017\nUpdates to the comments. Verifying equations with hand generated KCL equations. Fixed H type in D.\n\n\n10/9/2017\nStill verifying code. Fixed F type in C. Still need to verify Op Amps, inductors and capacitors.\n\n\n11/19/2017\nFixing some documentation.\n\n\n11/30/2017\nFixing the C matrix for Op Amps, one test case ran OKChen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the Op Amp stamp.\n\n\n12/2/2017\nAdded code for coupled inductors, not tested yet.\n\n\n12/6/2017\nTesting code for coupled inductors. Changes made to D matrix code. test_circuit_9 seems to give the correct results.\n\n\n18 Feb 2022\nNoticed a bug when the independent voltage source is the last line in the netlist, moving to the 1st line in the netlist generates what seems like correct equations. Investigation continues. For now, ordering the net list with sources first seems to work. Problem is with generation of the Ev and J matrices. In this version, I corrected some grammar and spelling errors.\n\n\n11/14/2023\nNew version of SymPy does not support non-Expr objects in a Matrix. Code to generate the circuit equations towards the end of the notebook produced an error. This line generated the error: \\(equ[i] = Eq(eq\\_temp,Z[i])\\). See the note here for details. In SymPy 1.8 and earlier versions it was possible to put non-Expr elements in a Matrix and the matrix elements could be any arbitrary Python object. Corrections have been made in this notebook. At the time of debugging this issue, I’m running sympy.__version__ = ‘1.11.1’\n\n\n29 Nov 2023\nProblem - When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.Solution - added code to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n\n1/9/2024\nCode for building matrix A was not including matrix D if i_unk == 1. The following line of code is new: \\(A[n,n] = D[0]\\) also with a comment. Added verification tests test_14 and test_15 for the case of i_unk == 1 and 0.\n\n\n1/16/2024\ncreated a function to implement SMNA, replaced warning print statements with raise Exception()\n\n\n7/31/2024\nadded code to count number of resistors and capacitors in network and include count in report\n\n\n\n\n\n\nThe following table is a history of updates to the book project.\n\n\n\nTable B.2: Book project change log\n\n\n\n\n\n\n\n\n\nDate\nEvent\n\n\n\n\n9/1/2023\nAround this time, testing Quarto, started this book project\n\n\n12/1/2023\nAround this time, posting numerous test/draft versions to GitHub pages\n\n\n5/1/2024\nAdded chapter on mechanical system analog\n\n\n5/15/2024\nIncremental changes to many chapters\n\n\n6/03/2024\nIncremental updates\n\n\n6/30/2024\nSMNA_example - correcting spelling, grammar and updating comments.SymMNA - correcting spelling, grammar and updating comments.Introduction - added example circuit and schematic.references.bib - added url to two references.2nd_order_BRF - rewrite, now calling the smna function.Two Amplifier RIAA Pre-amp - correcting spelling, grammar and updating comments.Various chapters - displaying network equations using LaTex vs. printing a SymPy matrix.\n\n\n11/20/2024\nAdded: Future example problems, added reference to online tools for running Python and schematic capture (Google Colab and EasyEDA schematic editor).\n\n\n12/6/2024\nAdded Klon Centaur parts 2, 3 chapter place holders; see note at end of part 1. Added place holders for future chapters. The place holders will make pushing changes to github.io easier.Fixed broken link in Mechanical systems chapter.\n\n\n8/16/2025\nSciPy functions impulse2 and step2 changed to impulse and step because in SciPy 1.13.0 impulse2 and step2 were removed.Added appendix D and E.Updates to Klon Centaur Parts 1, 2 & 3.Updates to Chapter 2.Updates to About This Book and Gemini generated cover.Added Wien Bridge Oscillator.\n\n\n\n\n\n\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press. https://www.gbv.de/dms/ilmenau/toc/585302871.PDF.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis. https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis.\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  },
  {
    "objectID": "Google Colab.html",
    "href": "Google Colab.html",
    "title": "Appendix C — Google Colab",
    "section": "",
    "text": "Google’s Colab is a good choice for a web based tool that has a free tier and easy to use. Since it is web based, there is nothing to install. Colab can be used to run the Jupyter notebooks contained in this book. Colab can be useful to obtain symbolic solutions for large or complex networks that would take a long time to run on a typical home desktop or laptop. For example, in Chapter 26, obtaining a symbolic solution took a few seconds running in Colab, compared to several hours on my laptop.\nGoogle Colab (short for Google Colaboratory) is a free cloud service provided by Google that allows users to write and execute Python code in a browser-based environment. A gmail account is needed to run Colab. There is a free tier of service which is sutable for running the Jupyter notebooks in this book, however the computing enviroment is not saved between sessions. \nThe basic steps to open and run a Jupyter notebook are as follows:\n\nOpen colab at the url: https://colab.research.google.com/.\nUpload a Jupyter notebook from Google drive, github or local storage.\n\nOn the left hand side pane, select the file icon, then select upload to session storage, then upload SymMNA.py. This needs to be done at the beginning of each session.\n\nCells for qmd and some markdown commands are not supported, but they can be ignored. Links to images will not work and need to be inserted using the menu at the top of the text cell (these broken links for the images can also be ignored).\nColab creates a new folder in your Google drive called “Colab Notebooks”.\nThe Colab computing enviroment is not saved in the free tier.\n\nThere are alternatives to Colab such as Kaggle, Cocalc, GitHub Codespaces, Anaconda Cloud and Deepnote which can be used if the limitiations of Google’s free or paid tiers are not acceptable.\nGoogle Colab can be run on a mobile device such as a mobile phone. Appendix D is an example of a Jupyter notebook that can be uploaded to Colab and run to perform symbolic circuit analsys on a mobile device. Of course internet connectivity is required. The circuit shown in Figure E.1 is used in Appendix D.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Google Colab</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html",
    "href": "SMNA_mobile.html",
    "title": "Appendix D — SMNA mobile",
    "section": "",
    "text": "D.1 Load the net list\nThe netlist can be exported from a schematic capture program or generated by hand. The input node is labled as node 1 and the output node is labled as node 2, but any node ordering is acceptable with adjustments to the code below.\nnet_list = '''\nR1 1 3 1\nR2 0 2 1\nL1 3 4 1\nL2 4 2 1\nC1 0 4 2\nV1 1 0 1\n'''",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "SMNA_mobile.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "Appendix D — SMNA mobile",
    "section": "D.2 Call the symbolic modified nodal analysis function",
    "text": "D.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = smna(net_list)\n\nDisplay the MNA equations:\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L2} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(C_{1} s v_{4} - I_{L1} + I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{3} - v_{4} = 0\\)\\(- I_{L2} L_{2} s - v_{2} + v_{4} = 0\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#build-the-network-equation-matrix",
    "href": "SMNA_mobile.html#build-the-network-equation-matrix",
    "title": "Appendix D — SMNA mobile",
    "section": "D.3 Build the network equation matrix",
    "text": "D.3 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( V_{1}, \\  C_{1}, \\  L_{2}, \\  R_{1}, \\  v_{4}, \\  v_{2}, \\  L_{1}, \\  R_{2}, \\  v_{3}, \\  s, \\  I_{L1}, \\  I_{L2}, \\  I_{V1}, \\  v_{1}\\right)\\)\n\n\nBuild a dictionary of element values:\n\nelement_values = get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#symbolic-solution",
    "href": "SMNA_mobile.html#symbolic-solution",
    "title": "Appendix D — SMNA mobile",
    "section": "D.4 Symbolic solution",
    "text": "D.4 Symbolic solution\nThe network equations can be solved symbolically using the SymPy function, solve.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution:\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{2} V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C_{1} L_{1} L_{2} V_{1} s^{3} + C_{1} L_{1} R_{2} V_{1} s^{2} + L_{1} V_{1} s + L_{2} V_{1} s + R_{2} V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(v_{4} = \\frac{L_{2} V_{1} s + R_{2} V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C_{1} L_{2} V_{1} s^{2} - C_{1} R_{2} V_{1} s - V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{C_{1} L_{2} V_{1} s^{2} + C_{1} R_{2} V_{1} s + V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(I_{L2} = \\frac{V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#transfer-function",
    "href": "SMNA_mobile.html#transfer-function",
    "title": "Appendix D — SMNA mobile",
    "section": "D.5 Transfer function",
    "text": "D.5 Transfer function\nAssuming node 1 is the input source node and node 2 is the output node of the transfer function.\n\nH_sym = (U_sym[v2]/U_sym[v1]).nsimplify().simplify().expand().together()\nH_sym\n\n\\(\\displaystyle \\frac{R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\n\n\n\nH_sym_num, H_sym_denom = fraction(H_sym) #returns numerator and denominator\n\nSolve for the roon of the numerator.\n\nH_sym_num_roots = solve(H_sym_num,s)\n\nDisplay the first solution.\n\n#H_sym_num_roots[0]\n\nSolve for the roots of the denominator.\n\nH_sym_denom_roots = solve(H_sym_denom,s)\n\nDisplay the first solution.\n\nH_sym_denom_roots[0]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{2}}{L_{1}^{2} L_{2}^{2}} - \\frac{3 \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1} L_{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{2}}{L_{1}^{2} L_{2}^{2}} - \\frac{3 \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1} L_{2}}\\right)^{3} + \\left(\\frac{2 \\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1}^{2} L_{2}^{2}}\\right)^{2}}}{2} + \\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{2 C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{2 C_{1} L_{1}^{2} L_{2}^{2}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{2}}{L_{1}^{2} L_{2}^{2}} - \\frac{3 \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1} L_{2}}\\right)^{3} + \\left(\\frac{2 \\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1}^{2} L_{2}^{2}}\\right)^{2}}}{2} + \\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{2 C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{2 C_{1} L_{1}^{2} L_{2}^{2}}}}{3} - \\frac{L_{1} R_{2} + L_{2} R_{1}}{3 L_{1} L_{2}}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#numerical-solution",
    "href": "SMNA_mobile.html#numerical-solution",
    "title": "Appendix D — SMNA mobile",
    "section": "D.6 Numerical solution",
    "text": "D.6 Numerical solution\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{1}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(v_{3} = \\frac{2.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(v_{4} = \\frac{1}{2.0 s^{2} + 2.0 s + 2.0}\\)\\(I_{V1} = \\frac{- 2.0 s^{2} - 2.0 s - 1.0}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(I_{L1} = \\frac{2.0 s^{2} + 2.0 s + 1.0}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(I_{L2} = \\frac{1}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#dc-operating-point",
    "href": "SMNA_mobile.html#dc-operating-point",
    "title": "Appendix D — SMNA mobile",
    "section": "D.7 DC operating point",
    "text": "D.7 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\)\\(0 = - I_{L2} + 1.0 v_{2}\\)\\(0 = I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\)\\(0 = - I_{L1} + I_{L2}\\)\\(1.0 = v_{1}\\)\\(0 = v_{3} - v_{4}\\)\\(0 = - v_{2} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          1.000000\nv2          0.500000\nv3          0.500000\nv4          0.500000\nI_V1       -0.500000\nI_L1        0.500000\nI_L2        0.500000",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#ac-analysis",
    "href": "SMNA_mobile.html#ac-analysis",
    "title": "Appendix D — SMNA mobile",
    "section": "D.8 AC analysis",
    "text": "D.8 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\n# calculate Hz and radians\nomega = 1 # frequency in radians per second\nprint('omega of {:.1f} rad/sec = {:.3f} Hz'.format(omega,omega/(2*np.pi)))\n\nfreq = 1 # frequency in cycles per second, Hz\nprint('frequency of {:.1f} Hz = {:.3f} rad/sec'.format(freq,freq*2*np.pi))\n\nomega of 1.0 rad/sec = 0.159 Hz\nfrequency of 1.0 Hz = 6.283 rad/sec\n\n\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\)\\(0 = - I_{L2} + 1.0 v_{2}\\)\\(0 = I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\)\\(0 = - I_{L1} + I_{L2} + 2.0 i v_{4}\\)\\(1.0 = v_{1}\\)\\(0 = - 1.0 i I_{L1} + v_{3} - v_{4}\\)\\(0 = - 1.0 i I_{L2} - v_{2} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.353553   -135.000000\nv3         0.353553     45.000000\nv4         0.500000    -90.000000\nI_V1       0.790569    161.565051\nI_L1       0.790569    -18.434949\nI_L2       0.353553   -135.000000",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#transfer-function-1",
    "href": "SMNA_mobile.html#transfer-function-1",
    "title": "Appendix D — SMNA mobile",
    "section": "D.9 Transfer function",
    "text": "D.9 Transfer function\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{1}{2 \\left(s^{3} + 2 s^{2} + 2 s + 1\\right)}\\)\n\n\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#poles-and-zeros-of-the-transfer-function",
    "href": "SMNA_mobile.html#poles-and-zeros-of-the-transfer-function",
    "title": "Appendix D — SMNA mobile",
    "section": "D.10 Poles and zeros of the transfer function",
    "text": "D.10 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#pole-zero-plot",
    "href": "SMNA_mobile.html#pole-zero-plot",
    "title": "Appendix D — SMNA mobile",
    "section": "D.11 Pole zero plot",
    "text": "D.11 Pole zero plot\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 3\n-0.16+0.00j Hz\n-0.08+0.14j Hz\n-0.08-0.14j Hz",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#bode-plot",
    "href": "SMNA_mobile.html#bode-plot",
    "title": "Appendix D — SMNA mobile",
    "section": "D.12 Bode plot",
    "text": "D.12 Bode plot\n\nx = np.logspace(-2, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#impulse-and-step-response",
    "href": "SMNA_mobile.html#impulse-and-step-response",
    "title": "Appendix D — SMNA mobile",
    "section": "D.13 Impulse and step response",
    "text": "D.13 Impulse and step response\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA mobile</span>"
    ]
  },
  {
    "objectID": "EasyEDA_schematic_editor.html",
    "href": "EasyEDA_schematic_editor.html",
    "title": "Appendix E — EasyEDA",
    "section": "",
    "text": "Generating a netlist from a schematic can be facilitated by a schematic editor program. EasyEDA is an example of a web based schematic editor that is free and easy to use. Since it it web based, there is nothing to install.\nEasyEDA is an Electronic Design Automation (EDA) tool that enables hardware engineers to design, simulate, share - publicly and privately - and discuss schematics, simulations and printed circuit boards. EasyEDA allows the creation and editing of schematic diagrams, SPICE simulation of mixed analogue and digital circuits. A subscription-free membership is offered for public projects plus a limited number of private projects. The company is based in Shenzhen, China.\nA tutorial and User Guide is available that explains how to draw a schematic and export a netlist.\nThe schematic in Figure E.1 was drawn using using a web browser on EasyEDA.com. The nodes were labled with net ports and the ground node name was changed from “GND” to 0.\n\n\n\n\n\n\nFigure E.1: EasyEDA schematic\n\n\n\nThe LTSpice netlist for the schematic was exported with the command:\n/file/export Net List/LTSPice for This sheet\nto obtain the following netlist:\n** easyedaspiceNetlist **\nR1 1 3 1\nR2 0 2 1\nL1 3 4 1\nL2 4 2 1\nC1 0 4 2\nV1 1 0 1\n.tran 10m\nThe net list can be copied into a Jypyter Notebook to be analized as shown in Appendix D.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>EasyEDA</span>"
    ]
  }
]