[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "",
    "text": "Welcome\nWelcome to Symbolic Modified Nodal Analysis using Python. This book is personal project that is being made available online during the development of the book.\nThe Python code presented in this book will allow students and professionals to automatically generate symbolic network equations from a circuit’s netlist. Then using the power of SymPy, NumPy and SciPy those equations can be symbolically or numerically solved. The JupyterLab notebooks presented in this book can be used as templates to analyze almost any linear electrical circuit.\nThis book was written in R MarkDown using plain text files and JupyterLab notebooks. The source files were rendered into an HTML book using Quarto, an open-source scientific and technical publishing system. HTML books are actually just a special type of Quarto Website. Quarto does a good job of formatting the documents into web pages for a book. Some of the lines of code and mathematical expressions are wider than the page and Quarto inserts a slider bar in the code or equation windows. Chapter and paragraph numbering are automatically generated by Quarto as well as the numbering of figures and tables.\nI don’t have a proof reader or professional editors for this project. Instead, I’m relying on the LibreOffice spell checker and the grammar and spell checker of Google Docs to help me with the proof reading part of the writing process. Employing professional editors to work on this project may happen in the future.\nSome sections of this work were developed with the assistance of Gemini, an artificial intelligence developed by Google. While this technology was utilized to draft some of the initial content, second and subsequent draft versions have been meticulously reviewed by the author. Every Gemini assisted section has been reworded for style and fact-checked for accuracy.\nPython code contained in this book can run in a browser-based environment, see Appendix C — Google Colab. Additionally, online schematics editors are available, see Appendix E — EasyEDA. By using web based tools, the reader is not required to install any programs.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#sec-source_code",
    "href": "index.html#sec-source_code",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "Source Code",
    "text": "Source Code\nThe source code for this project can be found on GitHub. Here you will find markdown files, JupyterLab notebooks, LTSpice schematics and image files. I will do my best to keep these files current. All the source code is subject to the license stated in License.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "Overview",
    "text": "Overview\nThe first four chapters introduce the topic of circuit analysis with some light background theory and describe my implementation of symbolic modified nodal analysis with Python. In addition, basic circuit analysis topics of - Resistive Networks, RLC Networks, Transfer Function, Transient Analysis, Mutual Inductance and Initial Conditions using Python are presented.\nThe next part of the book, Example Problems, contains circuit analysis example problems. This is followed by Validation Tests, which are 15 test circuits used to validate the Python code. This is followed by the Appendices which contain: references, code listing, notes about Colab and EasyEDA, a change log and a short history of electric circuit analysis.\nThe right margin of each page contains index with links to all the chapters. The left margin contains links to sections within the current chapter.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "About the Author",
    "text": "About the Author\nThis book is published under the pseudonym Tiburonboy.\nWhen I was about ten years old, my parents gave me an electronics kit for Christmas. It was a collection of resistors, capacitors, transistors and other assorted electronic components. The kit included about ten plans to build various circuits like an AM radio and audio oscillator. Ever since then I have been interested in radios and electronics.\nAfter graduating from high school, my Dad asked me what I was going to study in college and I told him mathematics. He suggested that I study electrical engineering since engineers were more in demand than mathematicians and electrical engineering was very math oriented. This turned out to be the best advice he gave me, because for the next 37 years my interest in electronics evolved into a very rewarding career as an electrical engineer.\nMy first job after graduating from college was working as a civilian for the US Navy. For more than 40 years I have been designing electronic circuits for instrumentation and telemetry systems. I have five Patents and have published seven technical papers.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#feedback",
    "href": "index.html#feedback",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "Feedback",
    "text": "Feedback\nIf you have complaints, find any errors, or have suggestions, send me an email at:\njuan1543cabrillo@sudomail.com",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "Citation",
    "text": "Citation\nIf you find the book useful, please cite it as follows:\n@online{Tiburonboy2024, \n    author = {Tiburonboy}, \n    title = {Symbolic Modified Nodal Analysis using Python},\n    year = {2024},\n    url = {https://tiburonboy.github.io/Symbolic-Modified-Nodal-Analysis-using-Python/},\n    urldate = {2025-08-13}\n}",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#python-module-versions",
    "href": "index.html#python-module-versions",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "Python Module Versions",
    "text": "Python Module Versions\nThe following versions were used in this book.\n\n\n\nTable 1: Library versions\n\n\n\n\n\n\n\n\n\nPackage\nversion\n\n\n\n\nPython\n3.10.9\n\n\nJupyterLab\n3.5.3\n\n\nIPython\n8.10.0\n\n\nNumPy\n1.23.5\n\n\nSymPy\n1.11.1\n\n\nSciPy\n1.10.0\n\n\nPandas\n1.5.3\n\n\nTabulate\n0.8.10\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8\n\n\nQuarto\n1.4.553\n\n\n\n\n\n\nThe Jupyter notebooks are available from my GitHub repository. The results presented in this book should be reproducible if the libraries and modules have the same version numbers.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#revision-history",
    "href": "index.html#revision-history",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "Revision History",
    "text": "Revision History\nThis book will be updated occasionally to update content and fix spelling and grammar mistakes - see Table B.2. Additionally, new content will be added as new chapters in the Example Problems section.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#sec-license",
    "href": "index.html#sec-license",
    "title": "Symbolic Modified Nodal Analysisusing Python",
    "section": "License",
    "text": "License\nThis work (includes python code, documentation, test circuits, etc.) is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n\nShare — Copy and redistribute the material in any medium or format.\n\nAdapt — Remix, transform, and build upon the material for any purpose, even commercially.\n\nAttribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\n\nShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "Preface.html",
    "href": "Preface.html",
    "title": "Preface",
    "section": "",
    "text": "The origin of this book stems from a Python circuit analysis coding project that I started in 2015. Over the years I’ve put my code on GitHub along with some test circuits, documentation and JupyterLab notebooks. See Source Code for a link to the repository. I think I have enough content that I’m able to turn the effort into an online book.\nOne of the first topics taught to electrical engineering students is basic electrical circuit analysis. This can be thought of as EE 101, and deals with circuit models not physical circuits. The voltage to current relationship for resistors is described by Ohm’s law, \\(v=iR\\). The voltage to current relationships for capacitors and inductors can be described by the following differential equations: \\[v(t) = \\frac{1}{C} \\int_{t_0}^t i \\mathrm d t+v(t_0)\\] \\[v=L \\frac {\\mathrm d i}{\\mathrm d t}\\] Since differential equations are used to model capacitors and inductors, EE 101 is usually taught after courses in calculus and differential equations. If an electrical network has several branches or loops, then there is a family of equations that describe the circuit, and these are a system of differential equations. Most of the problems presented in textbooks are relatively simple since developing the differential equations and solving them in the time domain with pencil and paper is laborious. After subjecting their students to the rigors of time domain analysis, professors introduce phasors and frequency domain analysis using Laplace transformed circuit elements. Then the problem turns into an algebra problem and students wonder why so much classroom effort was placed on obtaining solutions by solving differential equations.\nThe circuit analysis technique presented in this book analyzes electrical circuits in the frequency domain. The inductors and capacitors in the circuit are replaced by their transformed values. Inductors are replaced by their steady state Laplace value, \\(sL\\), where L is the value of the inductor with units of henrys (named after Joseph Henery) and \\(s\\) is the Laplace variable equal to \\(j \\omega\\) where \\(j\\) is the imaginary number and \\(\\omega\\) is the radian frequency. Capacitors in the circuit are replaced by their steady state Laplace value, \\(\\frac {1}{sC}\\) where C is the value of the capacitor with units in farads (named after Micheal Faraday).\nThe nodal analysis code started as a translation from some C code to generate a nodal admittance matrix that I had written in 1988. I wrote the C code for two reasons. Free versions of SPICE for the PC didn’t exist at the time and I wanted to use some of the code from, Numerical Recipes in C, Press (1992). The original C code worked well and calculated numerical solutions. I then started writing some C code to generate the matrices with symbolic values and then intended to use LISP to symbolically solve the equations. I didn’t get too far with this effort. The LISP code would generate huge symbolic strings with no simplification. The output was a big pile of trash that was not in the least bit useful or decipherable. Currently, there are many free circuit simulators available.\nIn 2014, I started to use Python for my coding projects and engineering calculations. There are some nice Python libraries for numeric and symbolic calculations (such as NumPy and SymPy), so I decided to try writing a Python script to generate node equations based on my old C code I had written many years before. Part way into this project I discovered that there is a new nodal analysis technique being taught today in engineering school called modified nodal analysis (MNA). My motivation for reviving this coding project is my continued interest in circuit analysis and synthesis.\nThe MNA procedure provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Some of my younger colleagues at work were taught this method, but I never heard of it. These days, I never really analyze a circuit by hand, unless it’s so simple that you can almost do it by inspection. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. LTSpice is the version of SPICE that I use, since it’s free and does a good job converging when analyzing switching circuits.\nMy code started initially by following the code from Cheever (2022), which used MATLAB to generate modified nodal equations. I somewhat followed his MATLAB code for resistors, capacitors, op amps and independent sources. The naming of the matrices follows his convention. The preprocessor and parser code was converted from my old C code. The use of Pandas for a data frame is new and SymPy is used to do the math; the use of element stamps is from Palusinski (2005).\nThis book is the result of my continued interest in circuit analysis and synthesis.\n\n\n\n\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit Equations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific Computing. Numerical Recipes in c Book Set. Cambridge University Press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What Is Circuit Analysis and Who Is This Book For?\nThe purpose of this book is to describe a method implemented in the Python programming language that will automatically generate symbolic network equations from a circuit’s netlist. The Python programming language and the associated libraries such as SymPy and NumPy make analyzing electric circuits almost effortless and the JupyterLab Notebooks described in this book can be used as template for analyzing almost any linear electric circuit.\nThis book is not a college text book about circuit analysis, there are many good books available that cover this topic. This book is about using Modified Nodal Analysis and the Python programming language to analyze electric circuits. Python’s open-source nature makes it a powerful and cost-effective tool for complex computational problems.\nCircuit analysis is a foundational skill necessary for a broad range of professionals whose work involves the design and development of electronic systems. Electrical Engineers and Circuit Designers are the core audience, as they rely on techniques like Kirchhoff’s Laws to create efficient circuits, calculate voltage drops and current flows, and simulate how an electric circuit will behave before it’s ever built. Fields like Power Systems Engineering, Control Systems Engineering and even Physics require this knowledge to understand energy distribution, optimize system performance and analyze complex physical models where circuits are used as analogues.\nThe Modified Nodal Analysis (MNA) is an essential extension of standard Nodal Analysis, and its primary benefits revolve around its systematic and comprehensive nature, particularly for computer-aided analysis. The key advantage of MNA is its ability to accommodate many types of circuit elements in a single, unified matrix formulation. Unlike traditional Nodal Analysis, which struggles to directly model voltage sources and components whose current is not easily defined by node voltages (such as dependent voltage sources and inductors), MNA introduces the currents through these elements as additional unknown variables. This standardization makes the process of formulating the circuit equations highly algorithmic and straightforward to automate, forming the backbone of professional circuit simulators like SPICE. Consequently, MNA eliminates the need for manual, ad-hoc techniques like supernodes or source transformations, allowing for the rapid and reliable analysis of large, complex, and linear circuits.\nElectric circuit analysis is the process of figuring out the unknown currents and voltages in a network of connected electrical components, which is commonly call a circuit. It is a fundamental skill that is taught to engineering students and serves as the bedrock for understanding and designing virtually all modern electrical and electronic systems.\nCircuit analysis is used for calculating power flow, voltage drops and fault currents in power grids; designing amplifiers, filters, power supplies and logic circuits for devices like smartphones and computers. This process relies on using basic physical laws and systematic mathematical techniques to create and solve a system of independent equations.\nThis method presented in this book will be particularly useful when the circuit is of simple to moderate complexity and symbolic network equations are desired. In some cases, symbolic solutions for the equations can be obtained.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#who-is-this-book-not-for",
    "href": "Introduction.html#who-is-this-book-not-for",
    "title": "1  Introduction",
    "section": "1.2 Who Is This Book Not For?",
    "text": "1.2 Who Is This Book Not For?\nThere are a few cases where MNA and the Python code presented in this book may not be that useful for you.\n\nThis book or the JupyterLab notebooks may not be particularly useful for students doing circuit analysis homework assignments by hand with pencil and paper. If the student is asked to find the loop equations or traditional node equations, the automatically generated MNA equations will be different.\nThe input to the Python code is a netlist and generating the netlist either by hand or with a schematic capture program may be more work than just determining the network equations in the traditional way.\nIf the circuit is so simple that the unknown variables can be solve for almost by inspection, starting with a netlist is not necessary and requires unnecessary additional work.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#assumptions",
    "href": "Introduction.html#assumptions",
    "title": "1  Introduction",
    "section": "1.3 Assumptions",
    "text": "1.3 Assumptions\nA basic understanding of Python programming is helpful, meaning you should be familiar with core concepts such as variables, data types (e.g., lists, dictionaries and strings), control flow (using if else statements and for while loops) and defining and calling functions.\nAdditionally, familiarity with JupyterLab notebooks is required. This involves knowing how to navigate the interface, create new notebooks, write and run code within cells, and utilize Markdown cells for documentation and annotation. JupyterLab serves as the primary interactive environment for writing and testing Python code.\nThe analysis of electric circuits, whether done by hand or with the help of Python and MNA, fundamentally relies on the concept of ideal components. These are theoretical abstractions that possess perfect behavior (e.g., a resistor has only resistance, an inductor has only inductance) and ignore the inevitable imperfections of real-world devices, such as parasitic capacitance, lead resistance, or temperature dependence.\nFurthermore, almost all conventional circuit analysis methods, including Nodal and Mesh analysis, rely on the assumption of a lumped-element model, which assumes the circuit is small enough that electrical effects occur instantaneously throughout the circuit, neglecting the time delay associated with the propagation of electromagnetic fields. This allows us to treat the circuit’s current and voltage as functions of time alone, rather than of both position and time (as required for wave propagation or transmission line effects). Finally, the systematic matrix methods discussed (MNA) are designed specifically for linear time-invariant (LTI) circuits, where the relationship between voltage and current is linear (e.g., Ohm’s law holds true) and the component values or connections do not change over time.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#why-not-just-use-spice-or-some-other-program",
    "href": "Introduction.html#why-not-just-use-spice-or-some-other-program",
    "title": "1  Introduction",
    "section": "1.4 Why Not Just Use SPICE or Some Other Program?",
    "text": "1.4 Why Not Just Use SPICE or Some Other Program?\nThe core reason you need symbolic analysis even with powerful numerical tools like SPICE is the difference between a number and a formula. SPICE and similar programs are numerical simulators. They give you a specific number for a specific set of component values and inputs.\nSymbolic analysis, however, gives you the actual algebraic formulas for the circuit’s behavior. While powerful, exact symbolic analysis is typically limited to smaller circuits because the complexity and length of the resulting expressions grow dramatically with the number of components and branches in the network.\nThe Python code presented in this notebook is somewhat unique since Python is open source, free and runs on a variety of platforms, the code presented in the JupyterLab notebooks is portable. As described in the Welcome page, the Python code is made available under a public domain license and archived in a GitHub repository, see Section 1.\nThere are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, TINA and Maple.\nSLiCAP is a symbolic linear analysis tool. SLiCAP is now a Python program, but originally it was written in MATLAB.\nTINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some symbolic analysis capability.\nMaple is a mathematical package and there is an application note available describing its use in symbolic circuit analysis. The application note presents a method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.\nSymbolic Circuit Analysis is a web page devoted to symbolic circuit analysis.\nSAPWIN is a windows program package for symbolic and numerical simulation of analog circuits.\nLcapy is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics. Hayes (2022) provides an overview of Lcapy as well as a survey of symbolic circuit analysis packages.\nLTSpice has been used extensively to verify the MNA numerical results in addition to drawing the circuit schematics shown in this book’s examples.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#why-use-symbolic-circuit-analysis",
    "href": "Introduction.html#why-use-symbolic-circuit-analysis",
    "title": "1  Introduction",
    "section": "1.5 Why Use Symbolic Circuit Analysis?",
    "text": "1.5 Why Use Symbolic Circuit Analysis?\nSymbolic circuit analysis is a formal technique where the behavior or characteristic of a circuit (like voltage gain or impedance) is calculated with the circuit components and frequency (or time) represented by symbols instead of numerical values.\nFor small circuits, the analytical expression (e.g., a transfer function) explicitly shows how each component affects the circuit’s performance metrics (gain, poles, zeros, etc.). This allows a designer to immediately see which elements are dominant and how to modify component values to meet specifications. A symbolic expression remains valid across a range of component values and operating conditions (as long as the underlying model is valid). By using symbolic analysis the network equations in symbolic form can be useful to document a design or to include in a technical paper.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#getting-started",
    "href": "Introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.6 Getting Started",
    "text": "1.6 Getting Started\nThe best way to begin your journey into symbolic circuit analysis with Python is through hands-on practice. The most effective approach is to copy one of the provided JupyterLab Notebooks and use it as a template for analyzing your own circuits. By doing this, you’ll immediately begin applying the Modified Nodal Analysis (MNA) method and leverage the computational power of Python libraries like SymPy for symbolic computation, NumPy for numerical handling, and Matplotlib for generating plots.\nThis practical, project-oriented approach will quickly familiarize you with setting up a circuit’s netlist, deriving its symbolic network equations, solving for unknown voltages and currents, and gaining the deep, qualitative insights that only symbolic analysis can provide.\nSource code for this book is available here and related material is located here. Python code contained in this book can run in a browser-based environment, see Appendix C. Additionally, online schematics editors are available, see Appendix E. By using web based tools, the reader is not required to install any programs.\nRewrite this section and point to Section 1 to keep Github links all in one place.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#about-the-math",
    "href": "Introduction.html#about-the-math",
    "title": "1  Introduction",
    "section": "1.7 About the Math",
    "text": "1.7 About the Math\nThe type of math used in circuit analysis depends on the complexity and nature of the circuit. Solving calculus and differential equations are not used in the analysis presented in this book. Since the Python modules SymPy and NumPy are being extensively employed, actual proficiency with the math is not really required. However, there are some advance concepts that are used throughout the book and that are not really explained.\n\nComplex Numbers: Crucial for AC circuit analysis, where quantities like impedance are represented as complex numbers to simplify calculations involving magnitude and phase shifts in sinusoidal waveforms. The Laplace Transform is used to convert differential equations into algebraic equations.\nLinear Algebra: Essential for solving systems of simultaneous linear equations that result from MNA.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Introduction.html#summary",
    "href": "Introduction.html#summary",
    "title": "1  Introduction",
    "section": "1.8 Summary",
    "text": "1.8 Summary\nThis book serves as a practical guide for performing symbolic circuit analysis using the Python programming language and its associated scientific libraries, such as SymPy and NumPy. The primary goal is to provide a systematic and computationally efficient method for analyzing linear electric circuits, utilizing JupyterLab Notebooks as adaptable templates.\nThe book is not a traditional circuit analysis textbook but focuses specifically on implementing the Modified Nodal Analysis (MNA) method. MNA is an essential extension of standard nodal analysis that allows all types of circuit elements (including voltage sources, inductors, and dependent sources) to be incorporated into a single, unified matrix formulation. This approach forms the algorithmic backbone of professional circuit simulators like SPICE.\nImportant Points:\n\nSymbolic Analysis: This technique calculates a circuit’s behavior (e.g., gain, impedance) with components and frequency represented by symbols instead of numerical values. This provides qualitative insight into the circuit’s operation, aids in design optimization, and yields exact analytical solutions that numerical simulators (like SPICE) cannot.\nTarget Audience: Circuit analysis is a foundational skill for a broad range of professionals, including Electrical Engineers, Circuit Designers, Electronics Technicians and those in Power Systems and Control Systems Engineering.\nModified Nodal Analysis (MNA): The book leverages MNA to formulate the circuit problem as a system of simultaneous linear equations, \\(\\mathbf{G} \\cdot \\mathbf{V} = \\mathbf{I}\\), which are then solved using matrix inversion implemented in Python.\nAdvanced Concepts (The s-Domain): The text covers Laplace Transformed Circuit Models, which convert time-domain differential equations into simpler algebraic equations in the s-domain (complex frequency domain). This is crucial for analyzing circuits with energy storage elements (capacitors and inductors) and determining their transient and transfer functions.\nFoundations of Circuit Analysis: A review of fundamental concepts is provided, including Ohm’s Law, Kirchhoff’s Current Law (KCL), and Kirchhoff’s Voltage Law (KVL), along with an overview of the key mathematical tools required (Algebra, Linear Algebra, Calculus, and Complex Numbers).\n\n\n\n\n\nHayes, M. 2022. “Lcapy: Symbolic Linear Circuit Analysis with Python.” https://doi.org/10.7717/peerj-cs.875.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html",
    "href": "Basic_concepts.html",
    "title": "2  Basic Concepts",
    "section": "",
    "text": "2.1 What is an Electric Circuit?\nThis chapter will cover some fundamental concepts and definitions related to electric circuit analysis are presented.\nElectric circuit analysis relies on fundamental concepts starting with Ideal Components, which are theoretical models (like a perfect resistor or capacitor) that simplify analysis by ignoring real-world imperfections. These components are connected to form a circuit, which is represented visually by a Schematic and algebraically by a Netlist. The foundational physical quantities are Electric Charge (measured in Coulombs, C), whose movement constitutes Current (Amperes, A), and Voltage (Volts, V), which represents the energy per unit charge available to move current. The core relationship between these quantities in a resistive element is defined by Ohm’s Law (\\(V = IR\\)). Elements are classified as Passive (resistors, capacitors, inductors) if they only consume or store energy, or Active (sources, transistors) if they generate or control energy. Finally, Energy Storage Elements. the capacitor and inductor, introduce dynamic behavior, as they store energy in electric and magnetic fields, respectively, leading to time-varying currents and voltages.\nAn electric circuit is a complete, closed-loop path through which electric current (a flow of electric charge) can continuously travel.\nA simple circuit usually contain three fundamental parts: a power source (like a battery) to provide the energy and voltage difference needed to push the current, conductors (like wires) to carry the current, and a load (like a light bulb or motor) that uses the electrical energy and converts it into another form, such as light or motion. For the circuit to be functional, this path must remain unbroken, also known as a closed circuit; any break, like an open switch, creates an open circuit and stops the flow of current.\nElectromotive Force (EMF), symbolized as \\(E\\) and measured in volts \\(V\\), is the total electrical energy provided by a source, such as a battery, generator, or solar cell, per unit of electric charge to drive current through a circuit. Although it contains the word “force”, EMF is technically a measure of energy conversion.\nThe source converts non-electrical energy (like chemical or mechanical) into electrical energy, thereby creating the potential difference necessary to push charge carriers around the loop. In an ideal source with no internal resistance, the EMF is equal to the terminal voltage, but in real devices, the actual voltage delivered to the external circuit is slightly less than the EMF due to the internal resistance of the source.\nIn electromagnetism and electronics, electromotive force is an energy transfer to an electric circuit per unit of electric charge, measured in volts.\nDevices called electrical transducers provide an emf by converting other forms of energy into electrical energy. Other types of electrical equipment also produce an emf, such as batteries, which convert chemical energy, and generators, which convert mechanical energy. This energy conversion is achieved by physical forces applying physical work on electric charges.\nHowever, electromotive force itself is not a physical force, and ISO/IEC standards have deprecated the term in favor of source voltage or source tension instead.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#electric-charge-and-current",
    "href": "Basic_concepts.html#electric-charge-and-current",
    "title": "2  Basic Concepts",
    "section": "2.2 Electric Charge and Current",
    "text": "2.2 Electric Charge and Current\nThe differences between electric charge, electrical current (conventional current), and electron flow are a source of confusion for many beginners in electronics.\nHere is a breakdown of the three concepts and their relationships:\n1. Electric Charge (\\(Q\\))\n\nElectric charge is the most fundamental concept, a physical property of matter that causes it to experience a force when placed in an electromagnetic field.\nWhat it is: The property of subatomic particles—specifically, the protons (positive charge) and electrons (negative charge) that allows them to interact electrically.\nUnit: The Coulomb. The charge on a single electron is \\(1.602 \\times 10^{-19} \\text{ C}\\).\nRelationship to the others: Charge is the thing that moves to create a current. Both conventional current and electron flow describe the movement of this charge.\n\n2. Electrical Current (Conventional Current)\n\nElectrical current (or Conventional Current) is the standard definition used in almost all circuit analysis and engineering.\nWhat it is: The rate of flow of electric charge through a conductor. \\(I = \\frac{\\Delta Q}{\\Delta t}\\)\nUnit: The Ampere, which is equivalent to one Coulomb per second.\nDirection: Positive to Negative (from the positive terminal of a battery to the negative terminal).\nBasis: This direction is a historical convention established by Benjamin Franklin before the discovery of the electron. He incorrectly assumed that electricity flowed from positive to negative.\nUse in Circuits: This convention is almost universally used in circuit diagrams, textbooks, and Kirchhoff’s Laws, because it’s consistent whether the moving charge is positive (like ions in an electrolyte) or negative (like electrons in a wire).\n\n3. Electron Flow\n\nElectron flow describes the actual physical movement of the primary charge carriers in metallic conductors (like copper wire).\nWhat it is: The physical movement of negatively charged electrons through a circuit.\nDirection: Negative to Positive (from the negative terminal of a battery to the positive terminal).\nBasis: This direction is based on the physical reality that electrons are the mobile charge carriers in most metal conductors, and they are repelled by the negative terminal and attracted to the positive terminal.\nUse in Circuits: This model is typically used when studying the internal physics of materials, such as semiconductors, where understanding the movement of both electrons and ‘holes’ (the absence of an electron, treated as a positive charge) is crucial.\n\nThe fundamental difference lies in the direction of flow.\n\n\n\n\n\n\n\n\n\nFeature\nElectric Charge (\\(Q\\))\nElectrical Current (Conventional Current) (\\(I\\))\nElectron Flow\n\n\n\n\nConcept\nFundamental property of matter (the stuff that moves).\nRate of charge flow (the measurement of movement).\nActual movement of charge carriers in most metal wires (the reality of movement).\n\n\nDirection\nN/A (Property)\nPositive to Negative\nNegative to Positive\n\n\nBasis\nPhysical property of particles (protons/electrons).\nHistorical convention.\nPhysical reality of electron movement.\n\n\nPrimary Use\nCalculating total charge (Coulombs).\nCircuit analysis, schematics, engineering.\nSemiconductor physics, some technician training.\n\n\n\nIn summary, Charge is the entity, Conventional Current is the agreed-upon direction used for mathematics and design (positive to negative), and Electron Flow is the true physical direction of electrons in a wire (negative to positive). Both current models lead to the same functional results in circuit calculations.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#voltage-energy-and-power",
    "href": "Basic_concepts.html#voltage-energy-and-power",
    "title": "2  Basic Concepts",
    "section": "2.3 Voltage, Energy and Power",
    "text": "2.3 Voltage, Energy and Power\nVoltage, also known as (electrical) potential difference is the difference in electric potential between two points. In the context of circuit analysis, the fundamental quantities are current, voltage and resistance.\n\n\n\n\n\n\n\n\n\nQuantity\nUnit (SI)\nSymbol\nDefines/Measures\n\n\n\n\nElectric Current\nAmpere\nA (or \\(I\\))\nThe rate of flow of electric charge.\n\n\nElectric Potential Difference (Voltage)\nVolt\nV (or \\(E\\) or \\(U\\))\nThe electrical “pressure” that drives the current.\n\n\nElectrical Resistance\nOhm\n\\(\\Omega\\) (Omega)\nThe opposition a material offers to the flow of electric current.\n\n\n\nThese three units are intrinsically linked by Ohm’s Law: \\(V = I \\times R\\).\nBeyond the core three, several other quantities are crucial in circuit analysis:\n\n\n\n\n\n\n\n\n\n\nQuantity\nUnit (SI)\nSymbol\nRelationship/Formula\nMeasures\n\n\n\n\nElectric Power\nWatt\nW\n\\(P = V \\times I\\)\nThe rate at which electrical energy is transferred or converted.\n\n\nCapacitance\nFarad\nF\n\\(C = Q / V\\)\nA component’s ability to store an electric charge.\n\n\nInductance\nHenry\nH\n\\(V = L \\frac{di}{dt}\\)\nA conductor’s ability to oppose a change in current.\n\n\nFrequency\nHertz\nHz\n\\(Hz = s^{-1}\\)\nThe number of cycles (e.g., of an AC waveform) per second.\n\n\nElectrical Energy\nJoule (or kWH for practical use)\nJ (or kWh)\n\\(E = P \\times t\\)\nThe work done by electrical forces.\n\n\n\nThese three concepts - Voltage, Energy, and Power - are fundamental to understanding how electricity works and are closely related. Think of electricity in terms of a water analogy to help clarify their roles:\nVoltage is the electric pressure or “push” that causes electric charge (current) to flow. It is the measure of potential energy per unit charge between two points in a circuit.\n\nDefinition: The work or energy required to move a unit of electric charge from one point to another.\nSymbol: \\(V\\)\nUnit: Volt (\\(\\text{V}\\))\n\\(1 \\text{ Volt} = 1 \\text{ Joule per Coulomb}\\) (\\(1 \\text{ V} = 1 \\text{ J/C}\\))\nWater Analogy: The height or pressure of the water in a tank. The higher the tank, the more pressure there is to push the water out.\n\nEnergy is the total capacity to do work. In an electrical circuit, it’s the total work done by the movement of charge.\n\nDefinition: The total amount of electrical work performed or stored. It does not have a time component.\nSymbol: \\(E\\) or \\(W\\) (for Work)\nUnit: Joule (\\(\\text{J}\\)) or kilowatt-hour (\\(\\text{kWh}\\)) for utility billing.\nWater Analogy: The total volume of water in the tank. This is the total potential to do work (like filling buckets).\n\nKey Relationship: Electrical energy (\\(E\\)) is simply Power (\\(P\\)) multiplied by the time (\\(t\\)) over which the power is consumed: \\[E = P \\times t\\]\nPower is the rate at which electrical energy is transferred or consumed. It tells you how quickly the work is being done.\n\nDefinition: The rate at which energy is transferred or transformed. It is energy per unit of time.\nSymbol: \\(P\\)\nUnit: Watt (\\(\\text{W}\\))\n\n\\(1 \\text{ Watt} = 1 \\text{ Joule per Second}\\) (\\(1 \\text{ W} = 1 \\text{ J/s}\\))\n\nWater Analogy: The flow rate of the water coming out of the hose (e.g., gallons per second).\n\nKey Relationship: Electrical power is the product of Voltage (\\(V\\)) and Current (\\(I\\)): \\[P = V \\times I\\] Power is high if you have a high voltage and a large current, or a very high voltage and a small current (as long as their product is large).\nSummary of Differences\nThe table below summarizes the key distinctions between these three concepts:\n\n\n\n\n\n\n\n\n\nConcept\nWhat It Is\nHow It’s Measured\nRelationship to Time\n\n\n\n\nVoltage (\\(V\\))\nElectric “pressure” or potential to move charge.\nVolts (\\(\\text{V}\\))\nIndependent of time.\n\n\nEnergy (\\(E\\))\nTotal work done or available to be done.\nJoules (\\(\\text{J}\\)) or \\(\\text{kWh}\\)\nDepends on the duration of time.\n\n\nPower (\\(P\\))\nRate of energy transfer (how fast work is done).\nWatts (\\(\\text{W}\\))\nDepends on instantaneous rate of change (energy per second).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#ideal-components",
    "href": "Basic_concepts.html#ideal-components",
    "title": "2  Basic Concepts",
    "section": "2.4 Ideal Components",
    "text": "2.4 Ideal Components\nIdeal components are theoretical abstractions used in circuit analysis that represent perfect behavior without the imperfections of real-world components.\n\n\n\n\n\n\n\n\nComponent\nIdeal Property\nReal-World Imperfection\n\n\n\n\nResistor\nConstant resistance, no inductance or capacitance.\nResistance changes with temperature.\n\n\nCapacitor\nStores charge with no resistance or leakage current.\nHas a small equivalent series resistance (ESR).\n\n\nInductor\nStores energy in a magnetic field with no resistance.\nHas a small internal winding resistance.\n\n\nVoltage Source\nProvides a constant voltage regardless of the current drawn.\nHas internal resistance, causing voltage to drop under load.\n\n\n\nIdeal components are used primarily for simplification and education. By assuming perfect behavior, engineers can derive simpler mathematical models and establish foundational laws (like Ohm’s Law) that clearly illustrate the circuit’s core principles. This makes initial analysis and hand calculations much easier, providing a strong starting point before factoring in non-ideal effects for a more precise real-world design.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#schematics-and-netlists",
    "href": "Basic_concepts.html#schematics-and-netlists",
    "title": "2  Basic Concepts",
    "section": "2.5 Schematics and Netlists",
    "text": "2.5 Schematics and Netlists\nA schematic is the graphical blueprint of an electronic circuit. It uses standardized symbols for components (resistors, batteries, etc.) and lines to visually represent the electrical connections, or nets, between them. The schematic captures the logical and functional connectivity of the circuit, illustrating how signals flow and components interact, but it does not represent the physical layout or size of the components.\nIn this book the Schematics and netlists were drawn and generated with LTSpice. In almost all cases, the nodes have been manually labeled using “Net Name” symbol. The netlist captures the fundamental connectivity - the “what connects to what” - without worrying about the physical location or visual aesthetics (which are handled by the layout and schematic tools, respectively).\nA netlist is a text-based data structure generated from the schematic. Instead of a drawing, it is a sequential listing that describes all the component connections in a structured format. It lists the components, their unique identifiers (reference designators), their pins and which specific nets they are connected to.\nIn simple terms, it’s a list of all the electronic components (resistors, capacitors, voltage source etc.) in a circuit and a list of the nodes connected to their terminals. Each line of a netlist typically provides three pieces of information:\n\nComponents (Instances): A list of every part used in the circuit, usually by its reference designator (e.g., \\(R_1\\), \\(C_3\\), \\(L_5\\)).\nTerminals: The specific connection points on each component (e.g., pin 1 and pin 2 of \\(R_5\\)).\nComponent Value: The value of the component (e.g., \\(5k\\)).\n\nFor example, the netlist for Figure 2.1 (exported from LTSpice) looks like this:\n* \\Fig_9-16.asc\nV1 1 0 1 AC 1\nR1 1 2 3.349k\nC1 2 0 27.24p\nC2 2 3 0.9085p\nC3 3 0 26.77p\nC4 3 4 0.4578p\nC5 4 0 27.1p\nC6 4 5 0.5742p\nR2 5 0 10.317k\nL1 2 0 1µ\nL2 3 0 1µ\nL3 4 0 1µ\nL4 5 0 1µ\nC7 5 0 27.57p\n.ac lin 200 27e6 33e6\n.backanno\n.end\nThe netlist above was generated from the schematic shown in the figure below.\n\n\n\n\n\n\nFigure 2.1\n\n\n\nThis circuit comes from Zverev (1967), Figure 9.16, which is the lumped element representation of a helical filter which has a Center frequency of 30 MHz and a - 3dB band width of approx 1MHz.\nTable 2.1 shows each line of the netlist along with an explanantion. A SPICE netlist, often called a SPICE deck, is a plain-text file that describes an electronic circuit’s topology, component values, and simulation instructions for processing by a SPICE-based simulator. The “deck” terminology is a legacy of the era when circuit descriptions were fed into mainframe computers using physical punched cards. Every netlist must follow a specific structural order: the first line is the title and is ignored by SPICE, since the first character on the line is “*“, which makes the line a comment line. The last line is the .end directive. Between these, the file contains”instance lines” for components (like resistors and transistors), “dot commands” for simulation control (like .tran or .ac).\nEach line as the format:\nAname node1 node 2 &lt;node3 … &gt; &lt;value1 … &gt;\nThe format of a standard device line is highly structured and typically follows this sequence:\n\nReference Designator: The first character of the line identifies the component type (e.g., R for resistor and C for capacitor).\nNodes: The next set of alphanumeric strings defines the “nets” or connection points. For example, a resistor line lists two nodes, while an Op Amp has three. Node 0 is strictly reserved for the global ground.\nValue: For passive components, this is the numerical value which can have a scale factor. The Python MNA code requires numerical values without the scale factor.\nOptional Parameters: Additional characteristics like temperature coefficients or initial conditions can be appended to the end of the line.\n\n\n\n\nTable 2.1: LTSpice netlist\n\n\n\n\n\n\n\n\n\n\n\nline #\nLTSpice netlist lines\nExplanation\nEdited netlist\n\n\n\n\n1\n*\\Fig_9-16.asc\nTitle of the netlist, file name\n\n\n\n2\nV1 1 0 1 AC 1\nVoltage source, 1 volt DC and 1 volt AC\nV1 1 0 1\n\n\n3\nR1 1 2 3.349k\nResistor between nodes 1 &2 of value 349k\nR1 1 2 3.349e3\n\n\n4\nC1 2 0 27.24p\nCapacitor between nodes 2 & ground of value 27.24pF\nC1 2 0 27.24e-12\n\n\n5\nC2 2 3 0.9085p\nCapacitor between nodes 2 & 3 of value 0.9085pF\nC2 2 3 0.9085e-12\n\n\n6\nC3 3 0 26.77p\nCapacitor between nodes 3 & ground of value 26.77pF\nC3 3 0 26.77e-12\n\n\n7\nC4 3 4 0.4578p\nCapacitor between nodes 3 & 4 of value 0.4578pF\nC4 3 4 0.4578e-12\n\n\n8\nC5 4 0 27.1p\nCapacitor between nodes 4 & ground of value 27.1pF\nC5 4 0 27.1e-12\n\n\n9\nC6 4 5 0.5742p\nCapacitor between nodes 4 & 5 of value 0.5742pF\nC6 4 5 0.5742e-12\n\n\n10\nR2 5 0 10.317k\nResistor between nodes 1 &2 of value 10.317k\nR2 5 0 10.317e3\n\n\n11\nL1 2 0 1µ\nInductor between nodes 2 and ground of value 1uH\nL1 2 0 1e-6\n\n\n12\nL2 3 0 1µ\nInductor between nodes 3 and ground of value 1uH\nL2 3 0 1e-6\n\n\n13\nL3 4 0 1µ\nInductor between nodes 4 and ground of value 1uH\nL3 4 0 1e-6\n\n\n14\nL4 5 0 1µ\nInductor between nodes 5 and ground of value 1uH\nL4 5 0 1e-6\n\n\n15\nC7 5 0 27.57p\ncapacitor between nodes 5 & ground of value 27.57pF\nC7 5 0 27.57e-12\n\n\n16\n.ac lin 200 27e6 33e6\nSPICE directive use to set up AC analysis\n\n\n\n17\n.backanno\nSPICE directive to view a graph of the current flowing into that pin\n\n\n\n18\n.end\nSPICE directive used to mark the end of the file\n\n\n\n\n\n\n\nThe netlist generated by LTSpice usually needs a bit of editing to replace the scale factors (e.g. \\(\\mu, k, p \\text{ etc.}\\)) with the numerical values as shown in the last column of Table 2.1 and shown below. Only the component lines are used by the Python MNA code.\nV1 1 0 1\nR1 1 2 3.349e3\nC1 2 0 27.24e-12\nC2 2 3 0.9085e-12\nC3 3 0 26.77e-12\nC4 3 4 0.4578e-12\nC5 4 0 27.1e-12\nC6 4 5 0.5742e-12\nR2 5 0 10.317e3\nL1 2 0 1e-6\nL2 3 0 1e-6\nL3 4 0 1e-6\nL4 5 0 1e-6\nC7 5 0 27.57e-12",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#conventions",
    "href": "Basic_concepts.html#conventions",
    "title": "2  Basic Concepts",
    "section": "2.6 Conventions",
    "text": "2.6 Conventions\nThe following conventions are used in this book. Expressions generated by SymPy that have imaginary quantities will use \\(i\\) for the imaginary number. Typically, electrical engineers will use \\(j\\) for the imaginary number since \\(i\\) is the variable used for electrical current. Depending on who generates the equation, either \\(i\\) or \\(j\\) might be used and the reader should short these out based on context. Usually, the variables used for current have a number, e.g. \\(i_1\\) or \\(i_2\\) and a lone \\(i\\) would be the imaginary number.\nThe Laplace variable, \\(s=j\\omega\\), and the one letter abbreviation for seconds, \\(s\\) use the same letter. It should be clear from the context whether “s” is being used for time or radian frequency.\nThe conventions used in this book are designed to ensure clarity and consistency in presenting circuit analysis concepts and their implementation in Python. The book adopts standard electrical engineering practices, such as representing voltages using the symbol \\(V \\text{ or } v\\) and currents using \\(I \\text{ or } i\\).\nThe sign convention for current - where current flows into the positive terminal of a passive element (like a resistor) - is a critical convention for ensuring the correct formulation of Kirchhoff’s Laws.\nWhen translating circuits into netlists, the variables used in the symbolic and numerical calculations (like \\(R_1\\), \\(C_2\\), \\(V_{source}\\)) directly map to the component reference designators shown in the circuit schematics.\nI’ve tried to be consistent with the use of variable names throughout the JupyterLab notebooks. Resistors, capacitors and inductors use R, L and C as reference designators. The names chosen for the other variables are listed in Table G.2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#circuit-laws",
    "href": "Basic_concepts.html#circuit-laws",
    "title": "2  Basic Concepts",
    "section": "2.7 Circuit Laws",
    "text": "2.7 Circuit Laws\nMove text from resistive circuits and RLC circuits here.\n\nOhm’s Law: This law states that the current flowing through a resistor is directly proportional to the voltage across it and inversely proportional to its resistance. The mathematical representation is: \\(V = IR\\), where:\n\n\\(V\\) is the voltage (potential difference) measured across the resistor (in Volts).\n\\(I\\) is the current flowing through the resistor (in Amperes).\n\n\\(R\\) is the resistance of the element (in Ohms, \\(\\Omega\\)).\n\nKirchhoff’s circuit laws are two equalities that deal with the current and potential difference (commonly known as voltage) in the lumped element model of electrical circuits. They were first described in 1845 by German physicist Gustav Kirchhoff.[1] This generalized the work of Georg Ohm and preceded the work of James Clerk Maxwell. Widely used in electrical engineering, they are also called Kirchhoff’s rules or simply Kirchhoff’s laws. These laws can be applied in time and frequency domains and form the basis for network analysis.\nBoth of Kirchhoff’s laws can be understood as corollaries of Maxwell’s equations in the low-frequency limit. They are accurate for DC circuits, and for AC circuits at frequencies where the wavelengths of electromagnetic radiation are very large compared to the circuits.\n\nKirchhoff’s Laws: These laws provide a framework for analyzing more complex circuits:\n\nKirchhoff’s Current Law (KCL): The total current entering a junction (or node) must equal the total current leaving that junction. This is a statement of the conservation of charge.\n\nKirchhoff’s Voltage Law (KVL): The sum of all the voltage drops around any closed loop in a circuit must equal zero. This reflects the conservation of energy.\n\nThe analysis of electric circuits relies on fundamental laws that govern the behavior of voltage and current. The most basic is Ohm’s Law, which establishes the relationship between voltage (\\(V\\)), current (\\(I\\)), and resistance (\\(R\\)), stating that the voltage across a conductor is directly proportional to the current flowing through it, often expressed as \\(V = IR\\).\nFor more complex circuits, Kirchhoff’s Laws are essential: Kirchhoff’s Current Law (KCL), based on the conservation of electric charge, dictates that the sum of currents entering any junction (node) must equal the sum of currents leaving that junction (\\(\\sum I_{in} = \\sum I_{out}\\)).\nSimilarly, Kirchhoff’s Voltage Law (KVL), based on the conservation of energy, states that the algebraic sum of all potential differences (voltages) around any closed path (loop) in a circuit must be zero (\\(\\sum V = 0\\)).\nTogether, these laws provide the necessary framework for calculating and predicting the electrical quantities in any circuit configuration.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#node-and-loop-analysis",
    "href": "Basic_concepts.html#node-and-loop-analysis",
    "title": "2  Basic Concepts",
    "section": "2.8 Node and Loop Analysis",
    "text": "2.8 Node and Loop Analysis\nNode and Loop Analysis are two fundamental techniques used in electrical circuit analysis to determine unknown voltages and currents. Node Analysis (also known as the Nodal Voltage Method) applies Kirchhoff’s Current Law (KCL) - the algebraic sum of currents entering a node is zero - to all nodes in a circuit, except the reference node (ground). The unknowns in this method are the node voltages, which are solved by setting up a system of linear equations based on KCL.\nIn contrast, Loop Analysis (or the Mesh Current Method) uses Kirchhoff’s Voltage Law (KVL) - the algebraic sum of voltages around any closed loop (mesh) is zero - to find unknown mesh currents. A system of linear equations is established by applying KVL around each independent loop in the circuit.\nChoosing between the two often depends on the circuit’s structure: Node Analysis is generally easier when the number of essential nodes is less than the number of independent loops, and vice versa.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#modified-nodal-analysis",
    "href": "Basic_concepts.html#modified-nodal-analysis",
    "title": "2  Basic Concepts",
    "section": "2.9 Modified Nodal Analysis",
    "text": "2.9 Modified Nodal Analysis\nModified Nodal Analysis (MNA) is an advanced circuit analysis technique used primarily in computer-aided design (CAD) tools like SPICE to overcome the limitations of standard Nodal Analysis. While standard nodal analysis only solves for node voltages by applying Kirchhoff’s Current Law (KCL), it struggles with components where the current isn’t easily expressed as a function of node voltages, notably ideal voltage sources and inductors. MNA addresses this by including the unknown branch currents through these specific components as additional variables in the system of equations. This results in a larger but more comprehensive matrix equation, combining KCL equations for the circuit nodes with the constitutive relations (e.g., \\(V = E\\) for a voltage source) for the added current variables. This systematic approach allows for the efficient formulation and solution of linear and nonlinear circuit equations, making it essential for robust circuit simulation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#laplace-transformed-circuit-elements",
    "href": "Basic_concepts.html#laplace-transformed-circuit-elements",
    "title": "2  Basic Concepts",
    "section": "2.10 Laplace Transformed Circuit Elements",
    "text": "2.10 Laplace Transformed Circuit Elements\nLaplace transformed circuit elements are a powerful method used in electrical engineering to analyze complex linear circuits, especially those with energy storage elements (inductors and capacitors) and time-varying inputs. This method converts the circuit from the time domain (\\(t\\)) into the s-domain (a complex frequency domain) using the Laplace transform.\nPierre-Simon, Marquis de Laplace (1749 - 1827), was an immensely influential French polymath, often referred to as the “French Newton” for his foundational work in celestial mechanics, which mathematically demonstrated the long-term stability of the solar system based on Newtonian gravity. His wide-ranging contributions also revolutionized probability theory and mathematical physics.\nAmong his many mathematical tools, the Laplace transform is an integral transform that converts a function of a real variable (like time, \\(t\\)) into a function of a complex variable (often \\(s\\), in the frequency domain). This transformation converts linear differential equations into simpler algebraic equations, which are much easier to solve, making the Laplace transform a crucial technique in physics and engineering, particularly for analyzing linear time-invariant systems like electrical circuits and control systems.\nThe key benefit is that it transforms the calculus-based equations (differential and integral equations) that describe circuit behavior into simple algebraic equations, which are much easier to solve.\nThe Laplace transform is a mathematical operation defined by an integral that takes a time-domain function \\(f(t)\\) to an s-domain function \\(F(s)\\): \\[\\mathcal{L}\\{f(t)\\} = F(s)\\]\n\nFrom Differential Equations to Algebraic Equations\n\n\nIn the time domain, circuits with L’s and C’s are described by differential equations. For instance, the voltage across an inductor is \\(v_L(t) = L \\frac{di_L(t)}{dt}\\).\nWhen transformed to the s-domain, differentiation becomes simple multiplication by \\(s\\), and integration becomes division by \\(s\\). This makes standard circuit analysis techniques (like nodal or mesh analysis) applicable using only algebra.\n\n\nElement Models in the s-Domain\n\n\nThe time-domain components are replaced by their \\(s\\)-domain equivalents, including their initial conditions (like initial current \\(i_L(0)\\) or initial voltage \\(v_C(0)\\)).\n\n\n\n\n\n\n\n\n\nTime-Domain Element\nV-I Relationship\ns-Domain Impedance (\\(Z(s)\\))\n\n\n\n\nResistor (R)\n\\(v_R(t) = R i_R(t)\\)\n\\(Z_R(s) = R\\)\n\n\nInductor (L)\n\\(v_L(t) = L \\frac{di_L(t)}{dt}\\)\n\\(Z_L(s) = sL\\)\n\n\nCapacitor (C)\n\\(i_C(t) = C \\frac{dv_C(t)}{dt}\\)\n\\(Z_C(s) = \\frac{1}{sC}\\)\n\n\n\nIn the s-domain, the Inductor and Capacitor are modeled as complex impedances dependent on the complex frequency \\(s\\).\nApplications of s-Domain Models\nUsing the Laplace transform provides several powerful analytical tools:\n\nTransient Response: It easily solves for the circuit’s complete response—both the transient (short-term switching behavior) and steady-state (long-term) response, especially for non-sinusoidal inputs like step or impulse functions.\nTransfer Function: The ratio of the output voltage/current transform to the input voltage/current transform gives the circuit’s Transfer Function, \\(H(s)\\). \\[H(s) = \\frac{\\text{Output}(s)}{\\text{Input}(s)}\\] This single function contains all the information needed to analyze the system’s stability, frequency response, and transient behavior (via its poles and zeros).\nInitial Conditions: The transformation naturally incorporates the circuit’s initial energy storage (non-zero initial currents or voltages) as independent voltage or current sources in the s-domain equivalent circuit.\n\nThe resulting solution \\(V(s)\\) or \\(I(s)\\) is then converted back to the time domain \\(v(t)\\) or \\(i(t)\\) using the inverse Laplace transform.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Basic_concepts.html#python-and-jupyterlab",
    "href": "Basic_concepts.html#python-and-jupyterlab",
    "title": "2  Basic Concepts",
    "section": "2.11 Python and JupyterLab",
    "text": "2.11 Python and JupyterLab\nPython and JupyterLab are two fundamental tools in modern data science and software development workflows. Python is a highly versatile, high-level, interpreted programming language known for its readability and extensive ecosystem of libraries (like NumPy, Pandas, and Matplotlib). It serves as the primary language for writing code, performing analysis and building applications.\nJupyterLab, on the other hand, is a web-based interactive development environment (IDE) that provides a flexible interface for working with Jupyter Notebooks, code and data. It allows users to combine live Python code, narrative text (Markdown), equations (LaTeX), and visualizations into a single, shareable document, making it an ideal environment for exploratory data analysis, data cleaning, statistical modeling, and documentation. Together, Python’s power and JupyterLab’s interactive capabilities create a seamless and productive platform for computational tasks.\nSymPy is an open-source Python library dedicated to symbolic mathematics, aiming to become a full-featured computer algebra system (CAS) while maintaining a simple, extensible code base. Unlike standard numerical libraries like NumPy, which calculate approximate decimal values, SymPy performs computations on mathematical objects exactly. It provides a wide range of capabilities, including polynomial simplification, calculus (limits, derivatives, and integrals), linear algebra, and solving differential equations, all within a native Python environment.\nNumPy, short for Numerical Python, is the fundamental library for scientific computing in Python. It provides a high-performance multidimensional array object and a comprehensive collection of functions for performing fast operations on these arrays, including mathematical, logical, shape manipulation, sorting, and linear algebra.\nSciPy is an open-source Python library used primarily for scientific and technical computing, building directly upon the foundational array structures of NumPy. It provides a massive collection of high-level functions and mathematical algorithms designed to handle complex tasks like numerical integration, linear algebra, optimization, signal processing, and statistics. Because it is highly optimized and written in low-level languages like C and Fortran, SciPy allows researchers and engineers to perform heavy-duty computations with the ease of Python’s syntax while maintaining near-native execution speeds. It is a core component of the “scientific Python stack,” serving as the bridge between basic data manipulation and advanced domain-specific analysis.\n\n\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley & Sons.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Concepts</span>"
    ]
  },
  {
    "objectID": "Modified_Nodal_Analysis.html",
    "href": "Modified_Nodal_Analysis.html",
    "title": "3  Modified Nodal Analysis",
    "section": "",
    "text": "3.1 Pros and Cons of MNA\nIn 1975, Ho, Ruehli, and Brennan (1975) published a paper titled, The Modified Nodal Approach to Network Analysis. This was the original scholarly paper on the subject. The analysis method they presented allows for the ability to process voltage sources and current-dependent circuit elements in a simple and efficient manner. The paper describes the formulation of the matrices, the use of stamps and a pivot ordering strategy. The authors compare their algorithm to the tableau method, a circuit analysis technique, which was an analysis technique being described in scholarly papers at the time. At the time of this publication, the authors were affiliated with the IBM Thomas J. Watson Research Center in Yorktown Heights, N.Y.\nThe development of MNA was driven by the critical need for efficient circuit equation formulation in computer-aided design programs, particularly for integrated circuits. While the traditional nodal approach offered flexibility and efficiency for manual analysis, its inherent limitations—especially concerning the treatment of voltage sources and current-dependent elements—demanded a more generalized and computationally friendly method. This highlights a pattern of industry-driven innovation; the practical demands of integrated circuit design within a leading industrial research center directly spurred this fundamental analytical advancement.\nThe timing of MNA’s publication in 1975 was opportune, coinciding with the maturation of digital computing capabilities, which enabled its rapid and widespread adoption as the computational infrastructure became ready to fully leverage its algorithmic advantages. If MNA had been proposed much earlier, the computational resources might not have been sufficient to efficiently handle the large matrices generated. By 1975, digital computers had advanced to a point where MNA’s sophisticated matrix operations and iterative solutions became practically feasible and efficient. This technological readiness allowed MNA’s inherent algorithmic advantages to be fully exploited, leading to its rapid integration into circuit simulation software and its eventual dominance.\nCircuit analysis and theory are fundamental to electrical engineering and is usually one of the first topics taught to electrical engineering students. The purpose of this book is to describe a circuit analysis method called Modified Nodal Analysis (MNA) implemented in Python and using the SymPy library.\nConsider the example circuit shown in Figure 3.1. This circuit has five branches and three nodes. There is a voltage source \\(V_1\\), which drives the circuit and each of the nodes is labeled along with the ground node.\nFor this circuit, the MNA procedure generates the following system of equations:\nwhere, \\(s\\) is the Laplace variable, \\(C_1\\) and \\(C_2\\) are capacitors, \\(R_1\\) is a resistor, \\(L_1\\) is an inductor, \\(v_1\\), \\(v_2\\) and \\(v_3\\) are the unknown node voltages, \\(V_1\\) is the input voltage source, \\(I_{V1}\\) is the unknown current flowing through \\(V_1\\) and \\(I_{L1}\\) is the unknown current flowing in \\(L_1\\).\nThe first of theses five equations is the KVL equation for node 1, where current through \\(R_1\\) is equal to the current from \\(V_1\\). The second equation describes the current flowing from branches connected to node 2. For node 2, the unknown current in \\(L_1\\) is assigned to \\(I_{L1}\\). The third equation describes the current flowing from the branches into node 3. The fourth equations just says that the voltage at node 2 is equal to \\(V_1\\). The last equation describes the current in \\(L_1\\). There are five network equations in total, but one of the equations, \\(v_1=V_1\\) is trivial.\nSolving this set of equations is easily accomplished by using a computer with MATLAB, Python with NumPy, an on-line matrix calculator or a modern graphical calculator that has matrix algebra capabilities. Inverting a 4 by 4 matrix by hand is probably the largest matrix that would be attempted given the numerous modern calculating tools available.\nThese equations can be solved by the afore mentioned tools to obtain the unknown voltages and currents as either numerical or analytic expressions. The analytical expression for the unknown voltages and currents are displayed below.\nIn the following chapters, Python will be used to automatically generate and solve circuit analysis problems using Python, SymPy, NumPy and SciPy.\nThe MNA approach is a suitable technique for hand analysis of small circuits as well as for computer analysis of larger circuits using the same algorithm as illustrated in this book. One disadvantage of the MNA technique is that often additional equations are generated, when a smaller number would be sufficient. For students doing homework problems and solving sets of equations by hand, the extra equation or two, generated by the MNA technique makes matrix inversions much harder.\nFor example, the circuit in Figure 3.1, can be described by the following two mesh equations:\n\\(\\displaystyle L_{1} s \\left(i_{1} - i_{2}\\right) + R_{1} i_{1} + \\frac{i_{1} - i_{2}}{C_{1} s} = V_{1}\\)\n\\(\\displaystyle L_{1} s \\left(- i_{1} + i_{2}\\right) + \\frac{i_{2}}{C_{2} s} + \\frac{- i_{1} + i_{2}}{C_{1} s} = 0\\)\nwhere \\(i_1\\) and \\(i_2\\) are the unknown currents.\nThe MNA procedure generated five equations (but one of them was trivial) to find the node voltages, whereas only two equations are need to be solved to find the mesh currents, which are:\n\\(i_{1} = \\frac{C_{1} C_{2} L_{1} V_{1} s^{3} + C_{1} V_{1} s + C_{2} V_{1} s}{C_{1} C_{2} L_{1} R_{1} s^{3} + C_{1} L_{1} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + 1}\\)\\(i_{2} = \\frac{C_{1} C_{2} L_{1} V_{1} s^{3} + C_{2} V_{1} s}{C_{1} C_{2} L_{1} R_{1} s^{3} + C_{1} L_{1} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + 1}\\)\nModern pocket scientific calculators that engineering students now use can solve sets of linear equations relatively easily. However, some effort is required to enter the equations into the calculator.\nWhen a computer is used to generate the schematic for a circuit and the net list is exported to the Python code, the extra equations that the MNA approach generates is not a practical concern. Using the examples in this book as templates for problem solving makes the work flow very easy, which is the main benefit of using MNA.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modified Nodal Analysis</span>"
    ]
  },
  {
    "objectID": "Modified_Nodal_Analysis.html#summary",
    "href": "Modified_Nodal_Analysis.html#summary",
    "title": "3  Modified Nodal Analysis",
    "section": "3.2 Summary",
    "text": "3.2 Summary\n\n\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modified Nodal Analysis</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html",
    "href": "MNA_with_python.html",
    "title": "4  MNA with Python",
    "section": "",
    "text": "4.1 Circuit description\nThis chapter walks through the Python code used to generate and solve a circuit’s network equations from its netlist. Figure 4.1 is the schematic for the circuit used in this example. The analysis procedure first requires a circuit netlist, which can be generated by hand with a text editor. For small circuits, such as those assigned as homework problems, this is not difficult since the number of nodes and components is small. College textbook problems are usually meant by the authors to be solved by hand with pencil and paper. In this example LTSpice was used to draw the schematic and label the components and nodes. Most schematic capture programs have the ability to export a SPICE net list, which then can be pasted into the procedure described here.\nThe circuit in Figure 4.1 is a 2nd order band pass filter with magnetic coupling. The netlist generated by LTSpice is shown below.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#netlist-description",
    "href": "MNA_with_python.html#netlist-description",
    "title": "4  MNA with Python",
    "section": "4.2 Netlist Description",
    "text": "4.2 Netlist Description\nV1 1 0 AC 1\nR1 3 1 1k\nR4 2 0 10k\nC1 3 0 0.01µ\nC2 2 0 0.01µ\nL1 4 0 1µ\nL2 5 0 1µ\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe LTSpice netlist may require some editing. The line in the netlist that defines the independent AC source, V1, needs to be formatted as if it were a DC source. For symbolic analysis we are only concerned with the label for the source at this time. Later, in this example, an AC analysis will be performed and \\(j \\omega s\\) will be substituted for the Laplace variable, \\(s\\). Also, the suffixes that SPICE allows in the component values e.g., k and \\(\\mu\\), need to be replaced by their corresponding multiplication factors as shown below.\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\nThe following Python modules are used:\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom tabulate import tabulate\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#symbolic-mna-code",
    "href": "MNA_with_python.html#symbolic-mna-code",
    "title": "4  MNA with Python",
    "section": "4.3 Symbolic MNA code",
    "text": "4.3 Symbolic MNA code\nThe following code and text cells walk through the procedure accomplish the following:\n\nprocess the netlist\ngenerate the MNA matrices\nformulate the network equations in terms of unknow node voltages and component currents\nsolve the network equations\ndiplay and plot the results\n\nA count of the component types are initialized to zero.\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#read-the-net-list-and-preprocess-it",
    "href": "MNA_with_python.html#read-the-net-list-and-preprocess-it",
    "title": "4  MNA with Python",
    "section": "4.4 Read the net list and preprocess it",
    "text": "4.4 Read the net list and preprocess it\nThe circuit netlist is pasted into the code cell below. A new line character is required at the end of each line and the triple quotes in the code cell below preserve the line breaks.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 L1 L2 0.15\n'''\n\nThe code cell below performs the following operations:\n\nsplit the net list into a list of lines at the line breaks\nremove blank lines and comments\n\nconvert first letter of element name to uppercase\n\nremoves extra spaces between entries\n\n\ncontent = net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove SPICE directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\n# display the cleaned up netlist\nfor i in content:\n    print(i)\n\nV1 1 0 1\nR1 3 1 1e3\nR4 2 0 10e3\nC1 3 0 0.01e-6\nC2 2 0 0.01e-6\nL1 4 0 1e-6\nL2 5 0 1e-6\nR2 4 3 0.5\nR3 2 5 0.5\nK1 l1 l2 0.15\n\n\n\n4.4.1 Process each line in the netlist\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#parser",
    "href": "MNA_with_python.html#parser",
    "title": "4  MNA with Python",
    "section": "4.5 Parser",
    "text": "4.5 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTSpice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: Op Amp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n4.5.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in SymPy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n4.5.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list data frame before any calculations are performed.\n\n# Check for the position of voltage sources in the data frame.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # reorder the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#print-netlist-report",
    "href": "MNA_with_python.html#print-netlist-report",
    "title": "4  MNA with Python",
    "section": "4.6 Print netlist report",
    "text": "4.6 Print netlist report\n\n# print a report\nprint('Netlist report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNetlist report\nnumber of lines in netlist: 10\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 3\nnumber of RLC (passive components): 8\nnumber of inductors: 2\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of op amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 1\n\n\n\ndf\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n3\n1\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n2\nR4\n2\n0\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n3\nC1\n3\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n4\nC2\n2\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nL1\n4\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n6\nL2\n5\n0\nNaN\nNaN\nNaN\n0.000001\nNaN\nNaN\nNaN\n\n\n7\nR2\n4\n3\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nR3\n2\n5\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n9\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.15\nNaN\nL1\nL2\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nL1\n4\n0\n\n\n2\nL2\n5\n0\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#initialize-matrices",
    "href": "MNA_with_python.html#initialize-matrices",
    "title": "4  MNA with Python",
    "section": "4.7 Initialize matrices",
    "text": "4.7 Initialize matrices\n\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\nDebugging notes: Is it possible to have i_unk == 0, what about a network with only current sources? This would make B = 0. See test_14 and test_15.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-g_matrix",
    "href": "MNA_with_python.html#sec-g_matrix",
    "title": "4  MNA with Python",
    "section": "4.8 G matrix",
    "text": "4.8 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\nThe general form of the G matrix is:\n\\(\\begin{eqnarray}\nG = \\left(\n  \\begin{array}{cccc}\n    Y_{ 11 } & Y_{ 12 } & \\ldots & Y_{ 1n } \\\\\n    Y_{ 21 } & Y_{ 22 } & \\ldots & Y_{ 2n } \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    Y_{ n1 } & Y_{ n2 } & \\ldots & Y_{ nn }\n  \\end{array}\n\\right)\n\\end{eqnarray}\\)\nThe G matrix is constructed using ‘stamps’. Starting with a zero filled matrix of the correct size, the branch admittances described by the reference designators for any resistors, capacitors and VCCS in the netlist are placed into the G matrix at positions determined by their nodes. In the case of a VCCS, the controlling nodes are used to position the gain values in the off diagonal positions in the the matrix. In the diagram below, \\(j\\) and \\(k\\) are the node numbers and \\(Y\\) is the admittance of the element.\n\\(\\begin{eqnarray}\nG = \\left(\n  \\begin{array}{ccccc}\n           & \\vdots &     & \\vdots &    \\\\\n    \\ldots & Y_{ jj } & \\ldots & -Y_{ kj } & \\ldots\\\\\n           & \\vdots &          & \\vdots & \\\\\n    \\ldots & -Y_{ jk } & \\ldots & Y_{ kk } & \\ldots \\\\\n           & \\vdots &          & \\vdots  &\n  \\end{array}\n\\right)\n\\end{eqnarray}\\)\nThe Python code below implements the algorithum for populating the G matrix using the concept of ‘stamps’.\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   # get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}}\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-b_matrix",
    "href": "MNA_with_python.html#sec-b_matrix",
    "title": "4  MNA with Python",
    "section": "4.9 B Matrix",
    "text": "4.9 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The Python code loops through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOp Amps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\\(B\\) is an \\(m\\) by \\((n − 1)\\) matrix with topology information of the independent voltage sources, where \\(a_{jk}\\) is 0, 1 or -1.\n\\(\\begin{eqnarray}\nB = \\left(\n  \\begin{array}{cccc}\n    a_{ 11 } & a_{ 12 } & \\ldots & a_{ 1n-1 } \\\\\n    a_{ 21 } & a_{ 22 } & \\ldots & a_{ 2n-1 } \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    a_{ m1 } & a_{ m2 } & \\ldots & a_{ mn-1 }\n  \\end{array}\n\\right)\n\\end{eqnarray}\\)\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the Op Amp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & 0\\\\0 & 1 & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-c_matrix",
    "href": "MNA_with_python.html#sec-c_matrix",
    "title": "4  MNA with Python",
    "section": "4.10 C matrix",
    "text": "4.10 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOp Amps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\\(C = B^T\\) for networks that have independent voltage sources.\n\\(\\begin{eqnarray}\nC = \\left(\n  \\begin{array}{cccc}\n    a_{ 11 } & a_{ 12 } & \\ldots & a_{ 1n } \\\\\n    a_{ 21 } & a_{ 22 } & \\ldots & a_{ 2n } \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    a_{ m1 } & a_{ m2 } & \\ldots & a_{ mn }\n  \\end{array}\n\\right)\n\\end{eqnarray}\\)\n\n4.10.1 Op Amp elements\nThe Op Amp element is assumed to be an ideal Op Amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the Op Amp. No error checking is provided and if the condition is violated, the results likely will be erroneous. Chen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the Op Amp stamp.\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # Op Amp type, input connections of the Op Amp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 1\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-d_matrix",
    "href": "MNA_with_python.html#sec-d_matrix",
    "title": "4  MNA with Python",
    "section": "4.11 D matrix",
    "text": "4.11 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n\nm = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes: 12/6/2017 doing some debugging on with coupled inductors; LTSpice seems to put the phasing dot on the neg node when it generates the netlist. This Python code uses M for mutual inductance, LTSpice uses k for the coupling coefficient. Inductors in LTSpice have a \\(20m\\Omega\\) series resistance that needs to be set to zero.\n\\(\\begin{eqnarray}\nD = \\left(\n  \\begin{array}{cccc}\n    a_{ 11 } & a_{ 12 } & \\ldots & a_{ 1m } \\\\\n    a_{ 21 } & a_{ 22 } & \\ldots & a_{ 2m } \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    a_{ m1 } & a_{ m2 } & \\ldots & a_{ mm }\n  \\end{array}\n\\right)\n\\end{eqnarray}\\)\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0\\\\0 & - L_{1} s & - M_{1} s\\\\0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-v_matrix",
    "href": "MNA_with_python.html#sec-v_matrix",
    "title": "4  MNA with Python",
    "section": "4.12 V matrix",
    "text": "4.12 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at a node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\\(V=\\left(\n  \\begin{array}{c}\n    v_1 \\\\\n    v_2 \\\\\n    \\vdots \\\\\n    v_n\n  \\end{array}\n\\right)\\)\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-j_matrix",
    "href": "MNA_with_python.html#sec-j_matrix",
    "title": "4  MNA with Python",
    "section": "4.13 J matrix",
    "text": "4.13 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\\(J=\\left(\n  \\begin{array}{c}\n    I_{V1} \\\\\n    \\vdots \\\\\n    I_{O1} \\\\\n    \\vdots \\\\\n    I_{L1}\\\\\n    \\vdots \\\\\n    I_{E1} \\\\\n    \\vdots \\\\\n    I_{H1} \\\\\n    \\vdots \\\\\n    I_{F1}\n  \\end{array}\n\\right)\\)\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{L1}\\\\I_{L2}\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-i_matrix",
    "href": "MNA_with_python.html#sec-i_matrix",
    "title": "4  MNA with Python",
    "section": "4.14 I matrix",
    "text": "4.14 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\\(I=\\left(\n  \\begin{array}{c}\n    I_1 \\\\\n    I_2 \\\\\n    \\vdots \\\\\n    I_n\n  \\end{array}\n\\right)\\)\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-ev_matrix",
    "href": "MNA_with_python.html#sec-ev_matrix",
    "title": "4  MNA with Python",
    "section": "4.15 Ev matrix",
    "text": "4.15 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\\(E_v=\\left(\n  \\begin{array}{c}\n    V_1 \\\\\n    V_2 \\\\\n    \\vdots \\\\\n    V_n\n  \\end{array}\n\\right)\\)\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-z_matrix",
    "href": "MNA_with_python.html#sec-z_matrix",
    "title": "4  MNA with Python",
    "section": "4.16 Z matrix",
    "text": "4.16 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\\(Z=\\left(\n  \\begin{array}{c}\n    I_1 \\\\\n    I_2 \\\\\n    \\vdots \\\\\n    I_n \\\\\n    E_{v1} \\\\\n    E_{v2} \\\\\n    \\vdots \\\\\n    E_{vn} \\\\\n  \\end{array}\n\\right)\\)\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-x_matrix",
    "href": "MNA_with_python.html#sec-x_matrix",
    "title": "4  MNA with Python",
    "section": "4.17 X matrix",
    "text": "4.17 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources.\n\\(X=\\left(\n  \\begin{array}{c}\n    v_1 \\\\\n    v_2 \\\\\n    \\vdots \\\\\n    v_n \\\\\n    I_{V1} \\\\\n    I_{V2} \\\\\n    \\vdots \\\\\n    I_{L1} \\\\\n    \\vdots \\\\\n    I_{Ln} \\\\\n  \\end{array}\n\\right)\\)\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-a_matrix",
    "href": "MNA_with_python.html#sec-a_matrix",
    "title": "4  MNA with Python",
    "section": "4.18 A matrix",
    "text": "4.18 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\\(\\begin{eqnarray}\nA = \\left(\n  \\begin{array}{cccccccc}\n    G_{ 11 } & G_{ 12 } & \\ldots & G_{ 1n } & B_{11} & B_{12} & \\ldots & B_{1n} \\\\\n    G_{ 21 } & G_{ 22 } & \\ldots & G_{ 2n } & B_{21} & B_{22} & \\ldots & B_{2n} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\n    G_{ m1 } & G_{ m2 } & \\ldots & G_{ mn } & B_{m1} & B_{m2} & \\ldots & B_{mn} \\\\\n    C_{ 11 } & C_{ 12 } & \\ldots & C_{ 1n } & M_{11} & M_{12} & \\ldots & M_{1n} \\\\\n    C_{ 21 } & C_{ 22 } & \\ldots & C_{ 2n } & M_{21} & M_{22} & \\ldots & M_{2n} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\\n    C_{ m1 } & C_{ m2 } & \\ldots & C_{ mn } & M_{m1} & M_{m2} & \\ldots & M_{mn} \\\\\n  \\end{array}\n\\right)\n\\end{eqnarray}\\)\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n    A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & 0 & 0 & - \\frac{1}{R_{3}} & 0 & 0 & 0\\\\- \\frac{1}{R_{1}} & 0 & C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{2}} & \\frac{1}{R_{2}} & 0 & 0 & 1 & 0\\\\0 & - \\frac{1}{R_{3}} & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 1\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & - L_{1} s & - M_{1} s\\\\0 & 0 & 0 & 0 & 1 & 0 & - M_{1} s & - L_{2} s\\end{matrix}\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#sec-generate_the_circuit_equations",
    "href": "MNA_with_python.html#sec-generate_the_circuit_equations",
    "title": "4  MNA with Python",
    "section": "4.19 Generate the circuit equations",
    "text": "4.19 Generate the circuit equations\n\nNE_sym = Eq(A*Matrix(X),Matrix(Z))\n\nDisplay the network equations.\n\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = v_{2} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}}\\)\\(0 = v_{3} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\)\\(0 = I_{L1} - \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}}\\)\\(0 = I_{L2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{5}}{R_{3}}\\)\\(V_{1} = v_{1}\\)\\(0 = - I_{L1} L_{1} s - I_{L2} M_{1} s + v_{4}\\)\\(0 = - I_{L1} M_{1} s - I_{L2} L_{2} s + v_{5}\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#symbolic-solution",
    "href": "MNA_with_python.html#symbolic-solution",
    "title": "4  MNA with Python",
    "section": "4.20 Symbolic solution",
    "text": "4.20 Symbolic solution\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  v_{2}, \\  C_{2}, \\  L_{1}, \\  I_{L1}, \\  I_{V1}, \\  R_{3}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  s, \\  R_{4}, \\  R_{1}, \\  I_{L2}, \\  V_{1}, \\  R_{2}, \\  L_{2}, \\  v_{1}, \\  M_{1}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the solution.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{M_{1} R_{4} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{3} = \\frac{C_{2} L_{1} L_{2} R_{4} V_{1} s^{3} + C_{2} L_{1} R_{3} R_{4} V_{1} s^{2} + C_{2} L_{2} R_{2} R_{4} V_{1} s^{2} - C_{2} M_{1}^{2} R_{4} V_{1} s^{3} + C_{2} R_{2} R_{3} R_{4} V_{1} s + L_{1} L_{2} V_{1} s^{2} + L_{1} R_{3} V_{1} s + L_{1} R_{4} V_{1} s + L_{2} R_{2} V_{1} s - M_{1}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1} + R_{2} R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{4} = \\frac{C_{2} L_{1} L_{2} R_{4} V_{1} s^{3} + C_{2} L_{1} R_{3} R_{4} V_{1} s^{2} - C_{2} M_{1}^{2} R_{4} V_{1} s^{3} + L_{1} L_{2} V_{1} s^{2} + L_{1} R_{3} V_{1} s + L_{1} R_{4} V_{1} s - M_{1}^{2} V_{1} s^{2}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{5} = \\frac{C_{2} M_{1} R_{3} R_{4} V_{1} s^{2} + M_{1} R_{3} V_{1} s + M_{1} R_{4} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} L_{1} L_{2} R_{4} V_{1} s^{4} - C_{1} C_{2} L_{1} R_{3} R_{4} V_{1} s^{3} - C_{1} C_{2} L_{2} R_{2} R_{4} V_{1} s^{3} + C_{1} C_{2} M_{1}^{2} R_{4} V_{1} s^{4} - C_{1} C_{2} R_{2} R_{3} R_{4} V_{1} s^{2} - C_{1} L_{1} L_{2} V_{1} s^{3} - C_{1} L_{1} R_{3} V_{1} s^{2} - C_{1} L_{1} R_{4} V_{1} s^{2} - C_{1} L_{2} R_{2} V_{1} s^{2} + C_{1} M_{1}^{2} V_{1} s^{3} - C_{1} R_{2} R_{3} V_{1} s - C_{1} R_{2} R_{4} V_{1} s - C_{2} L_{2} R_{4} V_{1} s^{2} - C_{2} R_{3} R_{4} V_{1} s - L_{2} V_{1} s - R_{3} V_{1} - R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{L1} = \\frac{C_{2} L_{2} R_{4} V_{1} s^{2} + C_{2} R_{3} R_{4} V_{1} s + L_{2} V_{1} s + R_{3} V_{1} + R_{4} V_{1}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{L2} = \\frac{- C_{2} M_{1} R_{4} V_{1} s^{2} - M_{1} V_{1} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} s^{3} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4} s^{4} + C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} R_{1} R_{3} s^{2} + C_{1} L_{1} R_{1} R_{4} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} - C_{1} M_{1}^{2} R_{1} s^{3} + C_{1} R_{1} R_{2} R_{3} s + C_{1} R_{1} R_{2} R_{4} s + C_{2} L_{1} L_{2} R_{4} s^{3} + C_{2} L_{1} R_{3} R_{4} s^{2} + C_{2} L_{2} R_{1} R_{4} s^{2} + C_{2} L_{2} R_{2} R_{4} s^{2} - C_{2} M_{1}^{2} R_{4} s^{3} + C_{2} R_{1} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{4} s + L_{1} L_{2} s^{2} + L_{1} R_{3} s + L_{1} R_{4} s + L_{2} R_{1} s + L_{2} R_{2} s - M_{1}^{2} s^{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\n\n\nThe transfer function can be simplified with the help of SymPy and the coefficients of the Laplace term can be collected. The transfer function at node 2 is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).simplify().collect(s)\nH_sym\n\n\\(\\displaystyle \\frac{M_{1} R_{4} s}{R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)}\\)\n\n\nThe numerator and denominator can be extracted from the expression.\n\nnum_sym, denom_sym = fraction(H_sym)\n\nDisplay the numerator:\n\nnum_sym\n\n\\(\\displaystyle M_{1} R_{4} s\\)\n\n\nDisplay the denominator:\n\ndenom_sym\n\n\\(\\displaystyle R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4} + s^{4} \\left(C_{1} C_{2} L_{1} L_{2} R_{1} R_{4} - C_{1} C_{2} M_{1}^{2} R_{1} R_{4}\\right) + s^{3} \\left(C_{1} C_{2} L_{1} R_{1} R_{3} R_{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{4} + C_{1} L_{1} L_{2} R_{1} - C_{1} M_{1}^{2} R_{1} + C_{2} L_{1} L_{2} R_{4} - C_{2} M_{1}^{2} R_{4}\\right) + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} + C_{1} L_{1} R_{1} R_{3} + C_{1} L_{1} R_{1} R_{4} + C_{1} L_{2} R_{1} R_{2} + C_{2} L_{1} R_{3} R_{4} + C_{2} L_{2} R_{1} R_{4} + C_{2} L_{2} R_{2} R_{4} + L_{1} L_{2} - M_{1}^{2}\\right) + s \\left(C_{1} R_{1} R_{2} R_{3} + C_{1} R_{1} R_{2} R_{4} + C_{2} R_{1} R_{3} R_{4} + C_{2} R_{2} R_{3} R_{4} + L_{1} R_{3} + L_{1} R_{4} + L_{2} R_{1} + L_{2} R_{2}\\right)\\)\n\n\nSolve for the roots of the denominator.\n\n#solve(denom_sym,s)\n\nThe code above was taking a long time, so it was interrupted and commented out.\n\n4.20.1 Built a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n\nelement_values = dict(zip(element_value_keys, element_value_values))\n\nThe mutual inductance between L1 and L2 is calculated from the coupling coeeficient.\n\\(M = k\\sqrt{L_1L_2}\\)\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.000000150\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  K_{1} : 0.15, \\  L_{1} : 1.0 \\cdot 10^{-6}, \\  L_{2} : 1.0 \\cdot 10^{-6}, \\  M_{1} : 1.5 \\cdot 10^{-7}, \\  R_{1} : 1000.0, \\  R_{2} : 0.5, \\  R_{3} : 0.5, \\  R_{4} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#numeric-solution",
    "href": "MNA_with_python.html#numeric-solution",
    "title": "4  MNA with Python",
    "section": "4.21 Numeric solution",
    "text": "4.21 Numeric solution\nSubstitute the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\)\\(0 = v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.0001\\right) - 2.0 v_{5}\\)\\(0 = - 0.001 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.001\\right) - 2.0 v_{4}\\)\\(0 = I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\)\\(0 = I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - 1.0 \\cdot 10^{-6} I_{L1} s - 1.5 \\cdot 10^{-7} I_{L2} s + v_{4}\\)\\(0 = - 1.5 \\cdot 10^{-7} I_{L1} s - 1.0 \\cdot 10^{-6} I_{L2} s + v_{5}\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s and displaying the transfer function.\n\nU = solve(NE,X)\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\nThe numerator and denominator can be extracted from the expression.\n\nnum, denom = fraction(H)\n\nDisplay the numerator:\n\nnum\n\n\\(\\displaystyle 6.0 \\cdot 10^{20} s\\)\n\n\nDisplay the denominator:\n\ndenom\n\n\\(\\displaystyle 391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}\\)\n\n\nThe roots of the denominator can be obtained with the solve function.\n\nsolve(denom,s)\n\n\\(\\displaystyle \\left[ -321649.557914015 - 10842889.0903087 i, \\  -321649.557914015 + 10842889.0903087 i, \\  -244859.393492634 - 9323420.66838014 i, \\  -244859.393492634 + 9323420.66838014 i\\right]\\)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#ac-analysis",
    "href": "MNA_with_python.html#ac-analysis",
    "title": "4  MNA with Python",
    "section": "4.22 AC analysis",
    "text": "4.22 AC analysis\nSolve equations a frequency of 1.491MHz or \\(\\omega\\) equal to 9.3682292e6 radians per second, s = 9.3682292e6j.\n\nNE_1rad_per_s = NE.subs({s:9.3682292e6j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_1rad_per_s.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_1rad_per_s.rhs[i]),latex(NE_1rad_per_s.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\)\\(0 = v_{2} \\cdot \\left(2.0001 + 0.093682292 i\\right) - 2.0 v_{5}\\)\\(0 = - 0.001 v_{1} + v_{3} \\cdot \\left(2.001 + 0.093682292 i\\right) - 2.0 v_{4}\\)\\(0 = I_{L1} - 2.0 v_{3} + 2.0 v_{4}\\)\\(0 = I_{L2} - 2.0 v_{2} + 2.0 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - 9.3682292 i I_{L1} - 1.40523438 i I_{L2} + v_{4}\\)\\(0 = - 1.40523438 i I_{L1} - 9.3682292 i I_{L2} + v_{5}\\)\n\n\n\nU_1rad_per_s = solve(NE_1rad_per_s,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_1rad_per_s.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.101262    -21.012442\nv3         0.101577     -5.111761\nv4         0.101240     -2.443264\nv5         0.101378    -18.330736\nI_V1       0.000899   -179.423099\nI_L1       0.009469    -89.691641\nI_L2       0.009486   -111.073602",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#ac-sweep",
    "href": "MNA_with_python.html#ac-sweep",
    "title": "4  MNA with Python",
    "section": "4.23 AC Sweep",
    "text": "4.23 AC Sweep\nLooking at node 2 voltage, calculate the transfer function.\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{6.0 \\cdot 10^{20} s}{391.0 s^{4} + 443010000.0 s^{3} + 8.0144391 \\cdot 10^{16} s^{2} + 4.44114 \\cdot 10^{22} s + 4.0022001 \\cdot 10^{30}}\\)\n\n\nGet the coefficients of the numerator and denominator polynomials.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit\n\nUse the SciPy bode function to calculate the magnitude and phase response of the transfer function.\n\nx = np.logspace(6, 6.5, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results with Matplotlib.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w/(2*np.pi), phase,':',color='b')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('peak: {:.2f} dB at {:.3f} MHz'.format(mag.max(),w[np.argmax(mag)]/(2*np.pi)/1e6,))\n\npeak: -19.89 dB at 1.490 MHz",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#smna-python-function",
    "href": "MNA_with_python.html#smna-python-function",
    "title": "4  MNA with Python",
    "section": "4.24 SMNA Python Function",
    "text": "4.24 SMNA Python Function\nThe python code described above has been converted into a function called SymMNA.smna(net_list). A listing for the function can be found in Appendix A as well as on GitHub. This function will be used extensively in the chapters that follow.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "MNA_with_python.html#summary",
    "href": "MNA_with_python.html#summary",
    "title": "4  MNA with Python",
    "section": "4.25 Summary",
    "text": "4.25 Summary\nIn this chapter a walk through of the Python code that implements the symbolic MNA procedure was presented. The network equations in symbolic form were solved and the filter’s symbolic transfer function was obtained. Then the component values were substituted into the network equations and solved again. The node voltages were obtained at a discrete frequency and then an AC sweep was done for the transfer function.\n\nBulleted list of the most important points.\n\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press. https://www.gbv.de/dms/ilmenau/toc/585302871.PDF.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis. https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MNA with Python</span>"
    ]
  },
  {
    "objectID": "Resistive_networks.html",
    "href": "Resistive_networks.html",
    "title": "5  Resistive Networks",
    "section": "",
    "text": "5.1 Circuit Example 1\nThis chapter focuses on the analysis of electric circuits containing independed sources, dependent sources and resistors. The simplest and most common circuit element is the resistor. Many principles of circuit analysis can be explored by considereing circuits that only have components that don’t store energy and are frequency independent.\nThe study and analysis of resistive circuits can serve as an introduction to the essential framework for understanding how energy is distributed and controlled in nearly every electronic device by applying Ohm’s Law and Kirchhoff’s Laws to predict how electric current will flow in resistive circuits. For circuits having many nodes or branches, modified nodal analysis is an algorithmic method which can be used to obtain network equations for almost any electric circuit.\nThis chapter examines several resistive circuits, each selected to illustrate different facets of circuit analysis and the corresponding techniques required to solve them. These examples illustrate the variety of complexity encountered in circuit theory, ranging from problems easily handled by manual calculation to those necessitating algorithmic, computer-aided methods.\nThe circuit shown in the schematic below has five reisistors and two indpendent sources, \\(V_1\\) and \\(I_1\\). The schematics was drawn using LTSpice and the netlist was copied by using the View/SPICE netlist command.\nThe circuit has four nodes and a solution by pencil and paper is doable on a circuit of this size. The system of equations obtained by either node or loop analysis could be solved by hand or on a scientific calculator. Solutions to the network equations are shown in the example.\nThe circuit is notable in that neither \\(V_1\\) or \\(I_1\\) are connected to the reference node. If loop equations are written for the circuit, two equations can describe the operation of the circuit. If node equations are written, four equations are required and \\(V_1\\) will form a supernode between nodes 3 and 4. As show below, the MNA method will generate five equations. The increase in number of equations is the price paid for using an algorithmic method that can be implemented in computer code.\nThe circuit shown above is can be analyzed by hand with pencil and paper and is the type of problem students would encounter in an engineering circuit analysis classes.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resistive Networks</span>"
    ]
  },
  {
    "objectID": "Resistive_networks.html#sec-resistive_circuit_1",
    "href": "Resistive_networks.html#sec-resistive_circuit_1",
    "title": "5  Resistive Networks",
    "section": "",
    "text": "Figure 5.1: Schematic for example 1.\n\n\n\n\n\n\n5.1.0.1 Python MNA Solution\nThe schematic above was drawn using LTSpice and the netlist was obtained and copied below. The nodes were numbered in no particular order, except to keep \\(V_1\\) away from the reference node.\nLoad the net list of Figure 5.1.\n\nnet_list = '''\nR1 0 4 5\nR2 0 3 7\nR3 0 2 2\nR4 2 3 4\nV1 4 3 2\nI1 2 1 3\nR5 1 4 3\n'''\n\nCall the symbolic modified nodal analysis function, SymMNA.smna(net_list). The internals of this function were explained in Chapter 4. Several parameters are returned by the function, but only the matrices \\(A\\), \\(X\\) and \\(Z\\) are used in the analysis below.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe \\(A\\) matrix is shown below. As describe in the introduction, it is compised of the \\(G\\), \\(B\\), \\(C\\) and \\(M\\) matricies.\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{5}} & 0\\\\0 & \\frac{1}{R_{4}} + \\frac{1}{R_{3}} & - \\frac{1}{R_{4}} & 0 & 0\\\\0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & -1\\\\- \\frac{1}{R_{5}} & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{1}} & 1\\\\0 & 0 & -1 & 1 & 0\\end{matrix}\\right]\\)\n\n\nThe \\(X\\) matrix contains the symbols for the unknown node voltages and the current from \\(V_1\\).\n\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}\\right]\\)\n\n\nThe \\(Z\\) matrix contains the symbols for the left side of the newtork equations.\n\n\n\\(\\displaystyle \\left[ I_{1}, \\  - I_{1}, \\  0, \\  0, \\  V_{1}\\right]\\)\n\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(I_{1} = \\frac{v_{1}}{R_{5}} - \\frac{v_{4}}{R_{5}}\\)\\(- I_{1} = v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{4}}\\)\\(0 = - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{4}}\\)\\(0 = I_{V1} + v_{4} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{5}}\\)\\(V_{1} = - v_{3} + v_{4}\\)\n\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df) # get element vales from netlist\n\nThe %%time below is an IPython magic command that will time the excution of the code in the cell. CPU times indicate the time spent in the CPU. Wall time is the total elapsed time, including any time spent waiting for resources.\nThe network equations for the netlist can be solved symbolically and the node voltages and dependent currents are displayed using symbolic notation.\n\n%%time\nU_sym = solve(NE_sym,X)\n\nCPU times: user 63.3 ms, sys: 0 ns, total: 63.3 ms\nWall time: 63.1 ms\n\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{I_{1} R_{1} R_{2} R_{4} + I_{1} R_{1} R_{2} R_{5} + I_{1} R_{1} R_{3} R_{5} + I_{1} R_{1} R_{4} R_{5} + I_{1} R_{2} R_{3} R_{5} + I_{1} R_{2} R_{4} R_{5} + R_{1} R_{2} V_{1} + R_{1} R_{3} V_{1} + R_{1} R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{2} = \\frac{- I_{1} R_{1} R_{3} R_{4} - I_{1} R_{2} R_{3} R_{4} - R_{2} R_{3} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{3} = \\frac{I_{1} R_{1} R_{2} R_{4} - R_{2} R_{3} V_{1} - R_{2} R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(v_{4} = \\frac{I_{1} R_{1} R_{2} R_{4} + R_{1} R_{2} V_{1} + R_{1} R_{3} V_{1} + R_{1} R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\\(I_{V1} = \\frac{I_{1} R_{1} R_{2} + I_{1} R_{1} R_{3} + I_{1} R_{1} R_{4} + I_{1} R_{2} R_{3} - R_{2} V_{1} - R_{3} V_{1} - R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{1} R_{4} + R_{2} R_{3} + R_{2} R_{4}}\\)\n\n\nFind the numerical solution for the node voltages by substituting the element values into the network equation and display the equations.\n\nNE = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(3.0 = 0.333333333333333 v_{1} - 0.333333333333333 v_{4}\\)\\(-3.0 = 0.75 v_{2} - 0.25 v_{3}\\)\\(0 = - I_{V1} - 0.25 v_{2} + 0.392857142857143 v_{3}\\)\\(0 = I_{V1} - 0.333333333333333 v_{1} + 0.533333333333333 v_{4}\\)\\(2.0 = - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\n%%time\nU = solve(NE,X)\n\nCPU times: user 41.4 ms, sys: 109 µs, total: 41.5 ms\nWall time: 55 ms\n\n\nDisplay the numerical solution using six digits to the right of the decimal so that results can be compared to the solution obtained from LTSpice.\n\ntable_header = ['unknowns', 'values','units']\ntable_row = []\n\nfor name, value in U.items():\n    if str(name)[0] == 'I':\n        unit = 'device current'\n    else:\n        unit = 'voltage'\n    table_row.append([str(name),float(value),str(unit)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('right','decimal','left'),\n    tablefmt=\"simple\",floatfmt=('5s','.6f','20s')))\n\n  unknowns     values  units\n----------  ---------  --------------\n        v1  14.140187  voltage\n        v2  -2.953271  voltage\n        v3   3.140187  voltage\n        v4   5.140187  voltage\n      I_V1   1.971963  device current\n\n\nThe Sympy generated solution matches the LTSpice results:\nV(1):    14.1402     voltage\nV(2):    -2.95327    voltage\nV(3):    3.14019     voltage\nV(4):    5.14019     voltage\nI(V1):   1.97196     device_current",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resistive Networks</span>"
    ]
  },
  {
    "objectID": "Resistive_networks.html#example-circuit-3",
    "href": "Resistive_networks.html#example-circuit-3",
    "title": "5  Resistive Networks",
    "section": "5.2 Example Circuit 3",
    "text": "5.2 Example Circuit 3\nThe circuit shown in the schematic below is a nonplanar assembly of resistors, independent and dependent sources. The circuit can be visualized as a cube. The nodes 1, 2, 0, 9, 4, 5, 6, and 7 form the corners of a cube and the compoenets in the circuit are the edges of the cube. The junction of \\(R_2\\), \\(R_{11}\\) and \\(R_3\\) was arbitrailary chosen as the reference node.\nThe circuit has 12 resistors, 3 independent voltage sources, two of which are set to zero inorder to measure the current through the branch. There is one independent current source and there are 4 dependent sources, one of each type. It would be rather difficult and tedious to derive the network equations for this circuit by manual procedures employing either traditional nodal or loop analysis. In this example, the MNA procedure with SymPy can easily generate network equations and symbolically solve for the node voltages. As shown below the symbolic expressions can be very long and do not provide much insight into the circuit’s behavor.\n\n\n\n\n\n\nFigure 5.2: Schematic for exapmple 3.\n\n\n\nAdditionally, the most efficient way to generate netlists is from a schematic capture program. If the schematic is drawn corretly, the netlist will be correct.\nLoad the net list\n\nnet_list = '''\nR1 2 15 2\nR2 0 2 3\nR3 9 0 4\nR4 1 10 3\nR5 4 6 3\nR6 5 13 3\nR7 7 14 2\nR8 12 7 5\nR9 3 2 7\nR10 7 11 4\nR11 5 0 9\nR12 6 8 3\nI1 4 3 2\nV1 11 9 3\nE1 13 4 9 2 2\nF1 1 8 V3 2\nG1 1 15 4 7 3\nH1 5 14 V2 3\nV2 9 10 0\nV3 12 6 0\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nWhy no \\(I_{G1}\\) ?\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{F1} + g_{1} v_{4} - g_{1} v_{7} + \\frac{v_{1}}{R_{4}} - \\frac{v_{10}}{R_{4}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{9}} - \\frac{v_{15}}{R_{1}} = 0\\)\\(- \\frac{v_{2}}{R_{9}} + \\frac{v_{3}}{R_{9}} = I_{1}\\)\\(- I_{Ea1} + \\frac{v_{4}}{R_{5}} - \\frac{v_{6}}{R_{5}} = - I_{1}\\)\\(I_{H1} + v_{5} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{13}}{R_{6}} = 0\\)\\(- I_{V3} + v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{8}}{R_{12}} = 0\\)\\(v_{7} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{12}}{R_{8}} - \\frac{v_{14}}{R_{7}} - \\frac{v_{11}}{R_{10}} = 0\\)\\(- I_{F1} - \\frac{v_{6}}{R_{12}} + \\frac{v_{8}}{R_{12}} = 0\\)\\(- I_{V1} + I_{V2} + \\frac{v_{9}}{R_{3}} = 0\\)\\(- I_{V2} - \\frac{v_{1}}{R_{4}} + \\frac{v_{10}}{R_{4}} = 0\\)\\(I_{V1} + \\frac{v_{11}}{R_{10}} - \\frac{v_{7}}{R_{10}} = 0\\)\\(I_{V3} + \\frac{v_{12}}{R_{8}} - \\frac{v_{7}}{R_{8}} = 0\\)\\(I_{Ea1} + \\frac{v_{13}}{R_{6}} - \\frac{v_{5}}{R_{6}} = 0\\)\\(- I_{H1} + \\frac{v_{14}}{R_{7}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- g_{1} v_{4} + g_{1} v_{7} + \\frac{v_{15}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(v_{11} - v_{9} = V_{1}\\)\\(- v_{10} + v_{9} = V_{2}\\)\\(v_{12} - v_{6} = V_{3}\\)\\(ea_{1} v_{2} - ea_{1} v_{9} + v_{13} - v_{4} = 0\\)\\(I_{F1} - I_{V3} f_{1} = 0\\)\\(- I_{V2} h_{1} - v_{14} + v_{5} = 0\\)\n\n\nBuild the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\nSymbolic solution\n\n%%time\nU_sym = solve(NE_sym,X)\n\nCPU times: user 55.3 s, sys: 8.57 ms, total: 55.3 s\nWall time: 55.3 s\n\n\nDisplay the symbolic solution.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{10} R_{2} R_{4} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{4} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{4} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{4} ea_{1} f_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{10} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{10} R_{3} R_{6} f_{1} - I_{1} R_{10} R_{4} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{10} R_{4} R_{5} R_{6} g_{1} - I_{1} R_{10} R_{4} R_{6} R_{8} g_{1} + I_{1} R_{10} R_{4} R_{6} f_{1} + I_{1} R_{11} R_{2} R_{4} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{4} R_{5} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{4} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{4} ea_{1} f_{1} + I_{1} R_{11} R_{3} R_{4} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{11} R_{3} R_{4} R_{5} ea_{1} g_{1} + I_{1} R_{11} R_{3} R_{4} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{4} ea_{1} f_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} - I_{1} R_{11} R_{4} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{4} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{4} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{4} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{4} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{4} R_{6} f_{1} - I_{1} R_{11} R_{4} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{4} R_{7} f_{1} + I_{1} R_{2} R_{3} R_{4} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{4} R_{5} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{4} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{4} ea_{1} f_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} + I_{1} R_{2} R_{4} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{4} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{4} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{4} R_{7} ea_{1} f_{1} - I_{1} R_{3} R_{4} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{3} R_{4} R_{5} R_{6} g_{1} - I_{1} R_{3} R_{4} R_{6} R_{8} g_{1} + I_{1} R_{3} R_{4} R_{6} f_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} - I_{1} R_{4} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{4} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{4} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{4} R_{6} R_{7} f_{1} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{4} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{5} V_{2} ea_{1} g_{1} - R_{10} R_{2} R_{8} V_{2} ea_{1} g_{1} - R_{10} R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{10} R_{3} R_{5} V_{2} ea_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} g_{1} - R_{10} R_{3} R_{7} V_{3} g_{1} - R_{10} R_{3} R_{8} V_{2} ea_{1} g_{1} + R_{10} R_{3} V_{2} ea_{1} f_{1} - R_{10} R_{3} V_{3} f_{1} - R_{10} R_{4} R_{6} V_{3} f_{1} g_{1} - R_{10} R_{4} R_{6} V_{3} g_{1} - R_{10} R_{4} R_{7} V_{3} g_{1} - R_{10} R_{4} V_{3} f_{1} - R_{10} R_{5} V_{2} f_{1} g_{1} h_{1} + R_{10} R_{5} V_{2} f_{1} - R_{10} R_{5} V_{2} g_{1} h_{1} + R_{10} R_{5} V_{2} + R_{10} R_{6} V_{2} f_{1} + R_{10} R_{6} V_{2} + R_{10} R_{7} V_{2} - R_{10} R_{8} V_{2} g_{1} h_{1} + R_{10} R_{8} V_{2} + R_{10} V_{2} f_{1} h_{1} + R_{11} R_{2} R_{4} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{5} V_{2} ea_{1} g_{1} - R_{11} R_{2} R_{8} V_{2} ea_{1} g_{1} + R_{11} R_{3} R_{4} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{5} V_{2} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} - R_{11} R_{3} R_{8} V_{2} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} - R_{11} R_{4} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{4} R_{6} V_{3} g_{1} - R_{11} R_{4} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{4} R_{7} V_{3} g_{1} - R_{11} R_{4} V_{3} f_{1} - R_{11} R_{5} V_{2} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{2} f_{1} - R_{11} R_{5} V_{2} g_{1} h_{1} + R_{11} R_{5} V_{2} + R_{11} R_{6} V_{2} f_{1} + R_{11} R_{6} V_{2} + R_{11} R_{7} V_{2} f_{1} + R_{11} R_{7} V_{2} - R_{11} R_{8} V_{2} g_{1} h_{1} + R_{11} R_{8} V_{2} + R_{11} V_{2} f_{1} h_{1} + R_{2} R_{3} R_{4} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{2} R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{2} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{2} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{2} R_{3} R_{8} V_{2} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{4} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{5} R_{7} V_{2} ea_{1} f_{1} g_{1} - R_{2} R_{5} R_{7} V_{2} ea_{1} g_{1} - R_{2} R_{7} R_{8} V_{2} ea_{1} g_{1} + R_{3} R_{4} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{4} R_{5} V_{1} ea_{1} g_{1} - R_{3} R_{4} R_{6} V_{3} f_{1} g_{1} - R_{3} R_{4} R_{6} V_{3} g_{1} - R_{3} R_{4} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{4} R_{7} V_{3} g_{1} + R_{3} R_{4} R_{8} V_{1} ea_{1} g_{1} - R_{3} R_{4} V_{1} ea_{1} f_{1} - R_{3} R_{4} V_{3} f_{1} - R_{3} R_{5} R_{7} V_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} ea_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} g_{1} - R_{3} R_{5} V_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} f_{1} - R_{3} R_{5} V_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} - R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{2} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{2} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{2} f_{1} - R_{3} R_{5} V_{2} g_{1} h_{1} + R_{3} R_{5} V_{2} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} + R_{3} R_{6} V_{1} f_{1} + R_{3} R_{6} V_{1} + R_{3} R_{6} V_{2} f_{1} + R_{3} R_{6} V_{2} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} - R_{3} R_{7} R_{8} V_{1} g_{1} - R_{3} R_{7} R_{8} V_{2} ea_{1} g_{1} - R_{3} R_{7} R_{8} V_{2} g_{1} + R_{3} R_{7} V_{1} f_{1} + R_{3} R_{7} V_{1} + R_{3} R_{7} V_{2} ea_{1} f_{1} + R_{3} R_{7} V_{2} ea_{1} + R_{3} R_{7} V_{2} f_{1} + R_{3} R_{7} V_{2} - R_{3} R_{7} V_{3} f_{1} - R_{3} R_{7} V_{3} - R_{3} R_{8} V_{1} g_{1} h_{1} + R_{3} R_{8} V_{1} - R_{3} R_{8} V_{2} ea_{1} g_{1} h_{1} - R_{3} R_{8} V_{2} g_{1} h_{1} + R_{3} R_{8} V_{2} + R_{3} V_{1} f_{1} h_{1} + R_{3} V_{2} ea_{1} f_{1} h_{1} + R_{3} V_{2} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1} - R_{4} R_{5} R_{7} V_{1} f_{1} g_{1} - R_{4} R_{5} R_{7} V_{1} g_{1} - R_{4} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{4} R_{6} R_{7} V_{3} g_{1} - R_{4} R_{7} R_{8} V_{1} g_{1} + R_{4} R_{7} V_{1} f_{1} - R_{4} R_{7} V_{3} f_{1} + R_{5} R_{7} V_{2} f_{1} + R_{5} R_{7} V_{2} + R_{6} R_{7} V_{2} f_{1} + R_{6} R_{7} V_{2} + R_{7} R_{8} V_{2}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{2} = \\frac{I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{10} R_{2} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{5} R_{6} g_{1} + I_{1} R_{10} R_{2} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} f_{1} + I_{1} R_{10} R_{2} R_{5} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} + I_{1} R_{10} R_{2} R_{6} R_{8} g_{1} - I_{1} R_{10} R_{2} R_{6} f_{1} - I_{1} R_{10} R_{2} R_{6} - I_{1} R_{10} R_{2} R_{7} + I_{1} R_{10} R_{2} R_{8} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} - I_{1} R_{10} R_{2} f_{1} h_{1} + I_{1} R_{11} R_{2} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{6} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{7} g_{1} + I_{1} R_{11} R_{2} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} f_{1} + I_{1} R_{11} R_{2} R_{5} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} + I_{1} R_{11} R_{2} R_{6} R_{8} g_{1} - I_{1} R_{11} R_{2} R_{6} f_{1} - I_{1} R_{11} R_{2} R_{6} + I_{1} R_{11} R_{2} R_{7} R_{8} g_{1} - I_{1} R_{11} R_{2} R_{7} f_{1} - I_{1} R_{11} R_{2} R_{7} + I_{1} R_{11} R_{2} R_{8} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{8} - I_{1} R_{11} R_{2} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} f_{1} + I_{1} R_{2} R_{3} R_{5} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} + I_{1} R_{2} R_{3} R_{6} R_{8} g_{1} - I_{1} R_{2} R_{3} R_{6} f_{1} - I_{1} R_{2} R_{3} R_{6} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} - I_{1} R_{2} R_{3} R_{7} f_{1} - I_{1} R_{2} R_{3} R_{7} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{8} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{5} R_{6} R_{7} f_{1} g_{1} + I_{1} R_{2} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{2} R_{5} R_{7} f_{1} - I_{1} R_{2} R_{5} R_{7} + I_{1} R_{2} R_{6} R_{7} R_{8} g_{1} - I_{1} R_{2} R_{6} R_{7} f_{1} - I_{1} R_{2} R_{6} R_{7} - I_{1} R_{2} R_{7} R_{8} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{6} V_{3} f_{1} g_{1} + R_{10} R_{2} R_{6} V_{3} g_{1} + R_{10} R_{2} R_{7} V_{3} g_{1} + R_{10} R_{2} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{2} R_{6} V_{3} f_{1} g_{1} + R_{11} R_{2} R_{6} V_{3} g_{1} + R_{11} R_{2} R_{7} V_{3} f_{1} g_{1} + R_{11} R_{2} R_{7} V_{3} g_{1} + R_{11} R_{2} V_{3} f_{1} g_{1} h_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{2} R_{3} R_{6} V_{3} f_{1} g_{1} + R_{2} R_{3} R_{6} V_{3} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} g_{1} - R_{2} R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} g_{1} + R_{2} R_{6} R_{7} V_{3} f_{1} g_{1} + R_{2} R_{6} R_{7} V_{3} g_{1} + R_{2} R_{7} R_{8} V_{1} g_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{3} = \\frac{I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{10} R_{2} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{5} R_{6} g_{1} + I_{1} R_{10} R_{2} R_{5} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{5} R_{9} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} f_{1} + I_{1} R_{10} R_{2} R_{5} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} + I_{1} R_{10} R_{2} R_{6} R_{8} g_{1} - I_{1} R_{10} R_{2} R_{6} f_{1} - I_{1} R_{10} R_{2} R_{6} - I_{1} R_{10} R_{2} R_{7} + I_{1} R_{10} R_{2} R_{8} R_{9} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{8} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} - I_{1} R_{10} R_{2} f_{1} h_{1} + I_{1} R_{10} R_{3} R_{5} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{3} R_{5} R_{9} ea_{1} g_{1} + I_{1} R_{10} R_{3} R_{8} R_{9} ea_{1} g_{1} - I_{1} R_{10} R_{3} R_{9} ea_{1} f_{1} + I_{1} R_{10} R_{5} R_{9} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{9} f_{1} + I_{1} R_{10} R_{5} R_{9} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{9} - I_{1} R_{10} R_{6} R_{9} f_{1} - I_{1} R_{10} R_{6} R_{9} - I_{1} R_{10} R_{7} R_{9} + I_{1} R_{10} R_{8} R_{9} g_{1} h_{1} - I_{1} R_{10} R_{8} R_{9} - I_{1} R_{10} R_{9} f_{1} h_{1} + I_{1} R_{11} R_{2} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{6} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{7} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{9} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} f_{1} + I_{1} R_{11} R_{2} R_{5} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} + I_{1} R_{11} R_{2} R_{6} R_{8} g_{1} - I_{1} R_{11} R_{2} R_{6} f_{1} - I_{1} R_{11} R_{2} R_{6} + I_{1} R_{11} R_{2} R_{7} R_{8} g_{1} - I_{1} R_{11} R_{2} R_{7} f_{1} - I_{1} R_{11} R_{2} R_{7} + I_{1} R_{11} R_{2} R_{8} R_{9} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{8} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{8} - I_{1} R_{11} R_{2} f_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{11} R_{3} R_{5} R_{9} ea_{1} g_{1} + I_{1} R_{11} R_{3} R_{8} R_{9} ea_{1} g_{1} + I_{1} R_{11} R_{5} R_{9} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{5} R_{9} f_{1} + I_{1} R_{11} R_{5} R_{9} g_{1} h_{1} - I_{1} R_{11} R_{5} R_{9} - I_{1} R_{11} R_{6} R_{9} f_{1} - I_{1} R_{11} R_{6} R_{9} - I_{1} R_{11} R_{7} R_{9} f_{1} - I_{1} R_{11} R_{7} R_{9} + I_{1} R_{11} R_{8} R_{9} g_{1} h_{1} - I_{1} R_{11} R_{8} R_{9} - I_{1} R_{11} R_{9} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{9} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} f_{1} + I_{1} R_{2} R_{3} R_{5} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} + I_{1} R_{2} R_{3} R_{6} R_{8} g_{1} - I_{1} R_{2} R_{3} R_{6} f_{1} - I_{1} R_{2} R_{3} R_{6} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} - I_{1} R_{2} R_{3} R_{7} f_{1} - I_{1} R_{2} R_{3} R_{7} + I_{1} R_{2} R_{3} R_{8} R_{9} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{8} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{5} R_{6} R_{7} f_{1} g_{1} + I_{1} R_{2} R_{5} R_{6} R_{7} g_{1} + I_{1} R_{2} R_{5} R_{7} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{5} R_{7} R_{9} ea_{1} g_{1} - I_{1} R_{2} R_{5} R_{7} f_{1} - I_{1} R_{2} R_{5} R_{7} + I_{1} R_{2} R_{6} R_{7} R_{8} g_{1} - I_{1} R_{2} R_{6} R_{7} f_{1} - I_{1} R_{2} R_{6} R_{7} + I_{1} R_{2} R_{7} R_{8} R_{9} ea_{1} g_{1} - I_{1} R_{2} R_{7} R_{8} + I_{1} R_{3} R_{5} R_{7} R_{9} ea_{1} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{7} R_{9} ea_{1} g_{1} + I_{1} R_{3} R_{5} R_{7} R_{9} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{7} R_{9} g_{1} + I_{1} R_{3} R_{5} R_{9} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{3} R_{5} R_{9} ea_{1} g_{1} h_{1} + I_{1} R_{3} R_{5} R_{9} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{9} f_{1} + I_{1} R_{3} R_{5} R_{9} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{9} - I_{1} R_{3} R_{6} R_{9} f_{1} - I_{1} R_{3} R_{6} R_{9} + I_{1} R_{3} R_{7} R_{8} R_{9} ea_{1} g_{1} + I_{1} R_{3} R_{7} R_{8} R_{9} g_{1} - I_{1} R_{3} R_{7} R_{9} ea_{1} f_{1} - I_{1} R_{3} R_{7} R_{9} ea_{1} - I_{1} R_{3} R_{7} R_{9} f_{1} - I_{1} R_{3} R_{7} R_{9} + I_{1} R_{3} R_{8} R_{9} ea_{1} g_{1} h_{1} + I_{1} R_{3} R_{8} R_{9} g_{1} h_{1} - I_{1} R_{3} R_{8} R_{9} - I_{1} R_{3} R_{9} ea_{1} f_{1} h_{1} - I_{1} R_{3} R_{9} f_{1} h_{1} - I_{1} R_{5} R_{7} R_{9} f_{1} - I_{1} R_{5} R_{7} R_{9} - I_{1} R_{6} R_{7} R_{9} f_{1} - I_{1} R_{6} R_{7} R_{9} - I_{1} R_{7} R_{8} R_{9} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{6} V_{3} f_{1} g_{1} + R_{10} R_{2} R_{6} V_{3} g_{1} + R_{10} R_{2} R_{7} V_{3} g_{1} + R_{10} R_{2} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{2} R_{6} V_{3} f_{1} g_{1} + R_{11} R_{2} R_{6} V_{3} g_{1} + R_{11} R_{2} R_{7} V_{3} f_{1} g_{1} + R_{11} R_{2} R_{7} V_{3} g_{1} + R_{11} R_{2} V_{3} f_{1} g_{1} h_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{2} R_{3} R_{6} V_{3} f_{1} g_{1} + R_{2} R_{3} R_{6} V_{3} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} g_{1} - R_{2} R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} g_{1} + R_{2} R_{6} R_{7} V_{3} f_{1} g_{1} + R_{2} R_{6} R_{7} V_{3} g_{1} + R_{2} R_{7} R_{8} V_{1} g_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{4} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} ea_{1} - I_{1} R_{10} R_{2} R_{7} ea_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} ea_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{5} R_{6} f_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{10} R_{5} R_{6} + I_{1} R_{10} R_{6} R_{7} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{8} + I_{1} R_{10} R_{6} f_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{11} R_{5} R_{6} f_{1} + I_{1} R_{11} R_{5} R_{6} + I_{1} R_{11} R_{5} R_{7} f_{1} + I_{1} R_{11} R_{5} R_{7} + I_{1} R_{11} R_{6} R_{8} + I_{1} R_{11} R_{7} R_{8} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{5} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{5} R_{7} ea_{1} - I_{1} R_{2} R_{7} R_{8} ea_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} + I_{1} R_{3} R_{5} R_{6} f_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{3} R_{5} R_{6} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} R_{8} + I_{1} R_{3} R_{6} f_{1} h_{1} + I_{1} R_{5} R_{6} R_{7} f_{1} + I_{1} R_{5} R_{6} R_{7} + I_{1} R_{6} R_{7} R_{8} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} + R_{10} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{10} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{3} V_{3} ea_{1} f_{1} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{6} V_{3} f_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} + R_{10} R_{6} V_{3} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} + R_{11} R_{6} V_{3} f_{1} + R_{11} R_{6} V_{3} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{7} V_{3} f_{1} + R_{11} R_{7} V_{3} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{11} V_{3} f_{1} h_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{1} ea_{1} f_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{1} ea_{1} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{3} R_{6} V_{3} f_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{6} V_{3} + R_{3} R_{7} R_{8} V_{1} ea_{1} g_{1} - R_{3} R_{7} V_{1} ea_{1} f_{1} - R_{3} R_{7} V_{1} ea_{1} + R_{3} R_{7} V_{3} ea_{1} f_{1} + R_{3} R_{7} V_{3} ea_{1} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{8} V_{1} ea_{1} - R_{3} V_{1} ea_{1} f_{1} h_{1} + R_{3} V_{3} ea_{1} f_{1} h_{1} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} + R_{6} R_{7} V_{3} f_{1} + R_{6} R_{7} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{5} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{7} ea_{1} f_{1} + I_{1} R_{11} R_{2} R_{7} ea_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} h_{1} + I_{1} R_{11} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} ea_{1} f_{1} + I_{1} R_{11} R_{3} R_{7} ea_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} ea_{1} f_{1} h_{1} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{11} R_{5} R_{6} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{11} R_{5} R_{7} f_{1} + I_{1} R_{11} R_{5} R_{7} + I_{1} R_{11} R_{6} R_{8} g_{1} h_{1} - I_{1} R_{11} R_{6} f_{1} h_{1} + I_{1} R_{11} R_{7} R_{8} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} + R_{11} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{6} V_{3} g_{1} h_{1} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{7} V_{3} f_{1} + R_{11} R_{7} V_{3} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{11} V_{3} f_{1} h_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{6} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{7} ea_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} ea_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{7} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{8} + I_{1} R_{10} R_{6} f_{1} h_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{11} R_{6} R_{8} + I_{1} R_{11} R_{7} R_{8} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{7} R_{8} ea_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} R_{8} + I_{1} R_{3} R_{6} f_{1} h_{1} + I_{1} R_{6} R_{7} R_{8} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} - R_{10} R_{2} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{5} V_{3} ea_{1} g_{1} + R_{10} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{10} R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{3} R_{5} V_{3} ea_{1} g_{1} + R_{10} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{3} V_{3} ea_{1} f_{1} - R_{10} R_{5} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{5} V_{3} f_{1} - R_{10} R_{5} V_{3} g_{1} h_{1} + R_{10} R_{5} V_{3} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{6} V_{3} f_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} + R_{10} R_{6} V_{3} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{2} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{5} V_{3} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{5} V_{3} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{5} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{3} f_{1} - R_{11} R_{5} V_{3} g_{1} h_{1} + R_{11} R_{5} V_{3} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} + R_{11} R_{6} V_{3} f_{1} + R_{11} R_{6} V_{3} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{7} V_{3} f_{1} + R_{11} R_{7} V_{3} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{11} V_{3} f_{1} h_{1} - R_{2} R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{3} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} g_{1} - R_{2} R_{5} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{5} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} g_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{3} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{3} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{3} f_{1} - R_{3} R_{5} V_{3} g_{1} h_{1} + R_{3} R_{5} V_{3} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{3} R_{6} V_{3} f_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{6} V_{3} + R_{3} R_{7} R_{8} V_{1} ea_{1} g_{1} - R_{3} R_{7} V_{1} ea_{1} f_{1} - R_{3} R_{7} V_{1} ea_{1} + R_{3} R_{7} V_{3} ea_{1} f_{1} + R_{3} R_{7} V_{3} ea_{1} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{8} V_{1} ea_{1} - R_{3} V_{1} ea_{1} f_{1} h_{1} + R_{3} V_{3} ea_{1} f_{1} h_{1} - R_{5} R_{7} V_{1} f_{1} - R_{5} R_{7} V_{1} + R_{5} R_{7} V_{3} f_{1} + R_{5} R_{7} V_{3} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} + R_{6} R_{7} V_{3} f_{1} + R_{6} R_{7} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{7} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{7} ea_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{7} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} f_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} + R_{10} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{10} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} - R_{10} R_{7} V_{3} - R_{10} V_{3} f_{1} h_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{7} R_{8} V_{1} ea_{1} g_{1} - R_{3} R_{7} V_{1} ea_{1} f_{1} - R_{3} R_{7} V_{1} ea_{1} - R_{3} R_{7} V_{3} f_{1} - R_{3} R_{7} V_{3} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} V_{1} ea_{1} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1} - R_{5} R_{7} V_{1} f_{1} - R_{5} R_{7} V_{1} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} - R_{7} R_{8} V_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{8} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} + I_{1} R_{10} R_{12} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{12} R_{6} f_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{7} ea_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} ea_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{7} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{8} + I_{1} R_{10} R_{6} f_{1} h_{1} + I_{1} R_{11} R_{12} R_{2} ea_{1} f_{1} + I_{1} R_{11} R_{12} R_{3} ea_{1} f_{1} - I_{1} R_{11} R_{12} R_{6} f_{1} - I_{1} R_{11} R_{12} R_{7} f_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{11} R_{6} R_{8} + I_{1} R_{11} R_{7} R_{8} + I_{1} R_{12} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{12} R_{2} R_{7} ea_{1} f_{1} - I_{1} R_{12} R_{3} R_{6} f_{1} - I_{1} R_{12} R_{6} R_{7} f_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{7} R_{8} ea_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} R_{8} + I_{1} R_{3} R_{6} f_{1} h_{1} + I_{1} R_{6} R_{7} R_{8} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} - R_{10} R_{12} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{12} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{12} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{12} V_{3} f_{1} - R_{10} R_{2} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{5} V_{3} ea_{1} g_{1} + R_{10} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{10} R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{3} R_{5} V_{3} ea_{1} g_{1} + R_{10} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{3} V_{3} ea_{1} f_{1} - R_{10} R_{5} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{5} V_{3} f_{1} - R_{10} R_{5} V_{3} g_{1} h_{1} + R_{10} R_{5} V_{3} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{6} V_{3} f_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} + R_{10} R_{6} V_{3} - R_{11} R_{12} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{12} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{12} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{12} V_{3} f_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{2} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{5} V_{3} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{5} V_{3} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{5} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{3} f_{1} - R_{11} R_{5} V_{3} g_{1} h_{1} + R_{11} R_{5} V_{3} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} + R_{11} R_{6} V_{3} f_{1} + R_{11} R_{6} V_{3} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{7} V_{3} f_{1} + R_{11} R_{7} V_{3} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{11} V_{3} f_{1} h_{1} - R_{12} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{12} R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{12} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{12} R_{3} R_{7} V_{3} f_{1} g_{1} + R_{12} R_{3} V_{1} ea_{1} f_{1} - R_{12} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{12} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{12} R_{3} V_{3} f_{1} - R_{12} R_{7} V_{1} f_{1} + R_{12} R_{7} V_{3} f_{1} - R_{2} R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{3} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} g_{1} - R_{2} R_{5} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{5} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{3} g_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{3} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{3} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{3} f_{1} - R_{3} R_{5} V_{3} g_{1} h_{1} + R_{3} R_{5} V_{3} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{3} R_{6} V_{3} f_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{6} V_{3} + R_{3} R_{7} R_{8} V_{1} ea_{1} g_{1} - R_{3} R_{7} V_{1} ea_{1} f_{1} - R_{3} R_{7} V_{1} ea_{1} + R_{3} R_{7} V_{3} ea_{1} f_{1} + R_{3} R_{7} V_{3} ea_{1} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{8} V_{1} ea_{1} - R_{3} V_{1} ea_{1} f_{1} h_{1} + R_{3} V_{3} ea_{1} f_{1} h_{1} - R_{5} R_{7} V_{1} f_{1} - R_{5} R_{7} V_{1} + R_{5} R_{7} V_{3} f_{1} + R_{5} R_{7} V_{3} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} + R_{6} R_{7} V_{3} f_{1} + R_{6} R_{7} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{9} = \\frac{I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{10} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{10} R_{3} R_{6} f_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} g_{1} - R_{10} R_{3} R_{7} V_{3} g_{1} - R_{10} R_{3} V_{3} f_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{2} R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} R_{7} V_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{1} g_{1} - R_{3} R_{5} V_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} f_{1} - R_{3} R_{5} V_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} + R_{3} R_{6} V_{1} f_{1} + R_{3} R_{6} V_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} - R_{3} R_{7} R_{8} V_{1} g_{1} + R_{3} R_{7} V_{1} f_{1} + R_{3} R_{7} V_{1} - R_{3} R_{7} V_{3} f_{1} - R_{3} R_{7} V_{3} - R_{3} R_{8} V_{1} g_{1} h_{1} + R_{3} R_{8} V_{1} + R_{3} V_{1} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{10} = \\frac{I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{10} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{10} R_{3} R_{6} f_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{5} V_{2} ea_{1} g_{1} - R_{10} R_{2} R_{8} V_{2} ea_{1} g_{1} - R_{10} R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{10} R_{3} R_{5} V_{2} ea_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} g_{1} - R_{10} R_{3} R_{7} V_{3} g_{1} - R_{10} R_{3} R_{8} V_{2} ea_{1} g_{1} + R_{10} R_{3} V_{2} ea_{1} f_{1} - R_{10} R_{3} V_{3} f_{1} - R_{10} R_{5} V_{2} f_{1} g_{1} h_{1} + R_{10} R_{5} V_{2} f_{1} - R_{10} R_{5} V_{2} g_{1} h_{1} + R_{10} R_{5} V_{2} + R_{10} R_{6} V_{2} f_{1} + R_{10} R_{6} V_{2} + R_{10} R_{7} V_{2} - R_{10} R_{8} V_{2} g_{1} h_{1} + R_{10} R_{8} V_{2} + R_{10} V_{2} f_{1} h_{1} - R_{11} R_{2} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{5} V_{2} ea_{1} g_{1} - R_{11} R_{2} R_{8} V_{2} ea_{1} g_{1} - R_{11} R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{5} V_{2} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} - R_{11} R_{3} R_{8} V_{2} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{2} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{2} f_{1} - R_{11} R_{5} V_{2} g_{1} h_{1} + R_{11} R_{5} V_{2} + R_{11} R_{6} V_{2} f_{1} + R_{11} R_{6} V_{2} + R_{11} R_{7} V_{2} f_{1} + R_{11} R_{7} V_{2} - R_{11} R_{8} V_{2} g_{1} h_{1} + R_{11} R_{8} V_{2} + R_{11} V_{2} f_{1} h_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{2} R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{2} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{2} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{2} R_{3} R_{8} V_{2} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{2} R_{5} R_{7} V_{2} ea_{1} f_{1} g_{1} - R_{2} R_{5} R_{7} V_{2} ea_{1} g_{1} - R_{2} R_{7} R_{8} V_{2} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} ea_{1} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} ea_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} f_{1} g_{1} - R_{3} R_{5} R_{7} V_{2} g_{1} - R_{3} R_{5} V_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} f_{1} - R_{3} R_{5} V_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} - R_{3} R_{5} V_{2} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{2} ea_{1} g_{1} h_{1} - R_{3} R_{5} V_{2} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{2} f_{1} - R_{3} R_{5} V_{2} g_{1} h_{1} + R_{3} R_{5} V_{2} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} + R_{3} R_{6} V_{1} f_{1} + R_{3} R_{6} V_{1} + R_{3} R_{6} V_{2} f_{1} + R_{3} R_{6} V_{2} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} - R_{3} R_{7} R_{8} V_{1} g_{1} - R_{3} R_{7} R_{8} V_{2} ea_{1} g_{1} - R_{3} R_{7} R_{8} V_{2} g_{1} + R_{3} R_{7} V_{1} f_{1} + R_{3} R_{7} V_{1} + R_{3} R_{7} V_{2} ea_{1} f_{1} + R_{3} R_{7} V_{2} ea_{1} + R_{3} R_{7} V_{2} f_{1} + R_{3} R_{7} V_{2} - R_{3} R_{7} V_{3} f_{1} - R_{3} R_{7} V_{3} - R_{3} R_{8} V_{1} g_{1} h_{1} + R_{3} R_{8} V_{1} - R_{3} R_{8} V_{2} ea_{1} g_{1} h_{1} - R_{3} R_{8} V_{2} g_{1} h_{1} + R_{3} R_{8} V_{2} + R_{3} V_{1} f_{1} h_{1} + R_{3} V_{2} ea_{1} f_{1} h_{1} + R_{3} V_{2} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1} + R_{5} R_{7} V_{2} f_{1} + R_{5} R_{7} V_{2} + R_{6} R_{7} V_{2} f_{1} + R_{6} R_{7} V_{2} + R_{7} R_{8} V_{2}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{11} = \\frac{I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{10} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{10} R_{3} R_{6} f_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} V_{1} ea_{1} g_{1} + R_{10} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{10} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} g_{1} - R_{10} R_{3} R_{7} V_{3} g_{1} + R_{10} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{10} R_{3} V_{1} ea_{1} f_{1} - R_{10} R_{3} V_{3} f_{1} + R_{10} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{10} R_{5} V_{1} f_{1} + R_{10} R_{5} V_{1} g_{1} h_{1} - R_{10} R_{5} V_{1} - R_{10} R_{6} V_{1} f_{1} - R_{10} R_{6} V_{1} - R_{10} R_{7} V_{1} + R_{10} R_{8} V_{1} g_{1} h_{1} - R_{10} R_{8} V_{1} - R_{10} V_{1} f_{1} h_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{7} R_{8} V_{1} ea_{1} g_{1} - R_{3} R_{7} V_{1} ea_{1} f_{1} - R_{3} R_{7} V_{1} ea_{1} - R_{3} R_{7} V_{3} f_{1} - R_{3} R_{7} V_{3} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} V_{1} ea_{1} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1} - R_{5} R_{7} V_{1} f_{1} - R_{5} R_{7} V_{1} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} - R_{7} R_{8} V_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{12} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{7} ea_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} ea_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{7} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{8} + I_{1} R_{10} R_{6} f_{1} h_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} ea_{1} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{11} R_{6} R_{8} + I_{1} R_{11} R_{7} R_{8} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{7} R_{8} ea_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} R_{8} + I_{1} R_{3} R_{6} f_{1} h_{1} + I_{1} R_{6} R_{7} R_{8} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} + R_{10} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{2} R_{8} V_{3} ea_{1} g_{1} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{10} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{10} R_{3} R_{8} V_{3} ea_{1} g_{1} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} - R_{10} R_{7} V_{3} + R_{10} R_{8} V_{3} g_{1} h_{1} - R_{10} R_{8} V_{3} - R_{10} V_{3} f_{1} h_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{3} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{8} V_{3} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} + R_{11} R_{8} V_{3} g_{1} h_{1} - R_{11} R_{8} V_{3} - R_{11} V_{1} f_{1} h_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} R_{8} V_{3} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{2} R_{7} R_{8} V_{3} ea_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} V_{1} ea_{1} g_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{7} R_{8} V_{1} ea_{1} g_{1} + R_{3} R_{7} R_{8} V_{3} ea_{1} g_{1} + R_{3} R_{7} R_{8} V_{3} g_{1} - R_{3} R_{7} V_{1} ea_{1} f_{1} - R_{3} R_{7} V_{1} ea_{1} - R_{3} R_{7} V_{3} f_{1} - R_{3} R_{7} V_{3} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{8} V_{1} ea_{1} + R_{3} R_{8} V_{3} ea_{1} g_{1} h_{1} + R_{3} R_{8} V_{3} g_{1} h_{1} - R_{3} R_{8} V_{3} - R_{3} V_{1} ea_{1} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1} - R_{5} R_{7} V_{1} f_{1} - R_{5} R_{7} V_{1} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} - R_{7} R_{8} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{13} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} R_{6} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{2} R_{5} R_{6} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{6} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{6} ea_{1} f_{1} + I_{1} R_{10} R_{2} R_{6} ea_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{3} R_{5} R_{6} ea_{1} g_{1} - I_{1} R_{10} R_{3} R_{6} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{3} R_{6} ea_{1} f_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{5} R_{6} f_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{10} R_{5} R_{6} + I_{1} R_{10} R_{6} R_{7} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} R_{8} + I_{1} R_{10} R_{6} f_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} R_{6} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} R_{6} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{6} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{6} ea_{1} f_{1} + I_{1} R_{11} R_{2} R_{6} ea_{1} - I_{1} R_{11} R_{2} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{7} ea_{1} f_{1} + I_{1} R_{11} R_{2} R_{7} ea_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} h_{1} + I_{1} R_{11} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} ea_{1} f_{1} + I_{1} R_{11} R_{3} R_{6} ea_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} ea_{1} f_{1} + I_{1} R_{11} R_{3} R_{7} ea_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} ea_{1} f_{1} h_{1} + I_{1} R_{11} R_{3} f_{1} h_{1} + I_{1} R_{11} R_{5} R_{6} f_{1} + I_{1} R_{11} R_{5} R_{6} + I_{1} R_{11} R_{5} R_{7} f_{1} + I_{1} R_{11} R_{5} R_{7} + I_{1} R_{11} R_{6} R_{8} + I_{1} R_{11} R_{7} R_{8} - I_{1} R_{2} R_{3} R_{5} R_{6} ea_{1} f_{1} g_{1} - I_{1} R_{2} R_{3} R_{5} R_{6} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{6} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{6} ea_{1} f_{1} + I_{1} R_{2} R_{3} R_{6} ea_{1} - I_{1} R_{2} R_{5} R_{6} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{2} R_{5} R_{6} R_{7} ea_{1} g_{1} - I_{1} R_{2} R_{6} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{6} R_{7} ea_{1} f_{1} + I_{1} R_{2} R_{6} R_{7} ea_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} ea_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} f_{1} g_{1} - I_{1} R_{3} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{3} R_{5} R_{6} ea_{1} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} ea_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} + I_{1} R_{3} R_{5} R_{6} f_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{3} R_{5} R_{6} - I_{1} R_{3} R_{6} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{3} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{3} R_{6} R_{7} ea_{1} f_{1} + I_{1} R_{3} R_{6} R_{7} ea_{1} + I_{1} R_{3} R_{6} R_{7} f_{1} + I_{1} R_{3} R_{6} R_{7} - I_{1} R_{3} R_{6} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} R_{8} + I_{1} R_{3} R_{6} ea_{1} f_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} + I_{1} R_{5} R_{6} R_{7} f_{1} + I_{1} R_{5} R_{6} R_{7} + I_{1} R_{6} R_{7} R_{8} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} - R_{10} R_{2} R_{6} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{2} R_{6} V_{3} ea_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{3} R_{6} V_{3} ea_{1} g_{1} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{6} V_{3} f_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} + R_{10} R_{6} V_{3} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{2} R_{6} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{6} V_{3} ea_{1} g_{1} - R_{11} R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} + R_{11} R_{6} V_{3} f_{1} + R_{11} R_{6} V_{3} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} + R_{11} R_{7} V_{3} f_{1} + R_{11} R_{7} V_{3} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{11} V_{3} f_{1} h_{1} - R_{2} R_{3} R_{6} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{6} V_{3} ea_{1} g_{1} - R_{2} R_{6} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{6} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} f_{1} g_{1} - R_{3} R_{6} R_{7} V_{3} g_{1} + R_{3} R_{6} V_{1} ea_{1} f_{1} + R_{3} R_{6} V_{1} ea_{1} - R_{3} R_{6} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} ea_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} + R_{3} R_{6} V_{3} f_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} + R_{3} R_{6} V_{3} - R_{6} R_{7} V_{1} f_{1} - R_{6} R_{7} V_{1} + R_{6} R_{7} V_{3} f_{1} + R_{6} R_{7} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{14} = \\frac{- I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{10} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} f_{1} - I_{1} R_{10} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{5} + I_{1} R_{10} R_{11} R_{6} + I_{1} R_{10} R_{11} R_{7} - I_{1} R_{10} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{11} R_{8} + I_{1} R_{10} R_{11} f_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{10} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{10} R_{6} f_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{7} ea_{1} f_{1} + I_{1} R_{11} R_{2} R_{7} ea_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{6} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} R_{7} g_{1} - I_{1} R_{11} R_{3} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} f_{1} - I_{1} R_{11} R_{3} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{5} - I_{1} R_{11} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{6} f_{1} + I_{1} R_{11} R_{3} R_{6} - I_{1} R_{11} R_{3} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{7} R_{8} g_{1} + I_{1} R_{11} R_{3} R_{7} ea_{1} f_{1} + I_{1} R_{11} R_{3} R_{7} ea_{1} + I_{1} R_{11} R_{3} R_{7} f_{1} + I_{1} R_{11} R_{3} R_{7} - I_{1} R_{11} R_{3} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{3} R_{8} + I_{1} R_{11} R_{3} f_{1} h_{1} - I_{1} R_{11} R_{5} R_{7} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{5} R_{7} f_{1} - I_{1} R_{11} R_{5} R_{7} g_{1} h_{1} + I_{1} R_{11} R_{5} R_{7} - I_{1} R_{11} R_{7} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{7} R_{8} + I_{1} R_{11} R_{7} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} + I_{1} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{5} R_{7} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{7} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{7} ea_{1} f_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{3} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{3} R_{6} f_{1} h_{1} - I_{1} R_{5} R_{6} R_{7} f_{1} g_{1} h_{1} - I_{1} R_{5} R_{6} R_{7} g_{1} h_{1} - I_{1} R_{6} R_{7} R_{8} g_{1} h_{1} + I_{1} R_{6} R_{7} f_{1} h_{1} - R_{10} R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{11} V_{3} f_{1} g_{1} h_{1} + R_{10} R_{11} V_{3} f_{1} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{10} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{10} R_{6} V_{3} g_{1} h_{1} - R_{10} R_{7} V_{3} g_{1} h_{1} - R_{10} V_{3} f_{1} h_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{11} R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} V_{1} ea_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{6} V_{3} g_{1} - R_{11} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} f_{1} g_{1} - R_{11} R_{3} R_{7} V_{3} g_{1} + R_{11} R_{3} R_{8} V_{1} ea_{1} g_{1} - R_{11} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{5} V_{1} f_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} f_{1} + R_{11} R_{5} V_{1} g_{1} h_{1} - R_{11} R_{5} V_{1} - R_{11} R_{6} V_{1} f_{1} - R_{11} R_{6} V_{1} - R_{11} R_{7} V_{1} f_{1} - R_{11} R_{7} V_{1} - R_{11} R_{7} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{7} V_{3} f_{1} - R_{11} R_{7} V_{3} g_{1} h_{1} + R_{11} R_{7} V_{3} + R_{11} R_{8} V_{1} g_{1} h_{1} - R_{11} R_{8} V_{1} - R_{11} V_{1} f_{1} h_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} V_{1} ea_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} f_{1} g_{1} h_{1} - R_{3} R_{6} V_{3} g_{1} h_{1} - R_{3} R_{7} V_{3} ea_{1} g_{1} h_{1} - R_{3} R_{7} V_{3} g_{1} h_{1} + R_{3} R_{8} V_{1} ea_{1} g_{1} h_{1} - R_{3} V_{1} ea_{1} f_{1} h_{1} - R_{3} V_{3} f_{1} h_{1} - R_{5} R_{7} V_{1} f_{1} g_{1} h_{1} - R_{5} R_{7} V_{1} g_{1} h_{1} - R_{6} R_{7} V_{3} f_{1} g_{1} h_{1} - R_{6} R_{7} V_{3} g_{1} h_{1} - R_{7} R_{8} V_{1} g_{1} h_{1} + R_{7} V_{1} f_{1} h_{1} - R_{7} V_{3} f_{1} h_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(v_{15} = \\frac{- I_{1} R_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{1} R_{10} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{1} R_{10} R_{5} R_{6} g_{1} + I_{1} R_{1} R_{10} R_{6} R_{8} g_{1} - I_{1} R_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} - I_{1} R_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{1} R_{11} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{1} R_{11} R_{5} R_{6} g_{1} + I_{1} R_{1} R_{11} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{1} R_{11} R_{5} R_{7} g_{1} + I_{1} R_{1} R_{11} R_{6} R_{8} g_{1} + I_{1} R_{1} R_{11} R_{7} R_{8} g_{1} - I_{1} R_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{1} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{1} R_{2} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{1} R_{2} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{1} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{1} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{1} R_{3} R_{6} R_{8} g_{1} + I_{1} R_{1} R_{5} R_{6} R_{7} f_{1} g_{1} + I_{1} R_{1} R_{5} R_{6} R_{7} g_{1} + I_{1} R_{1} R_{6} R_{7} R_{8} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{10} R_{2} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{5} R_{6} g_{1} + I_{1} R_{10} R_{2} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} f_{1} + I_{1} R_{10} R_{2} R_{5} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{5} + I_{1} R_{10} R_{2} R_{6} R_{8} g_{1} - I_{1} R_{10} R_{2} R_{6} f_{1} - I_{1} R_{10} R_{2} R_{6} - I_{1} R_{10} R_{2} R_{7} + I_{1} R_{10} R_{2} R_{8} g_{1} h_{1} - I_{1} R_{10} R_{2} R_{8} - I_{1} R_{10} R_{2} f_{1} h_{1} + I_{1} R_{11} R_{2} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{6} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} R_{7} g_{1} + I_{1} R_{11} R_{2} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} f_{1} + I_{1} R_{11} R_{2} R_{5} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{5} + I_{1} R_{11} R_{2} R_{6} R_{8} g_{1} - I_{1} R_{11} R_{2} R_{6} f_{1} - I_{1} R_{11} R_{2} R_{6} + I_{1} R_{11} R_{2} R_{7} R_{8} g_{1} - I_{1} R_{11} R_{2} R_{7} f_{1} - I_{1} R_{11} R_{2} R_{7} + I_{1} R_{11} R_{2} R_{8} g_{1} h_{1} - I_{1} R_{11} R_{2} R_{8} - I_{1} R_{11} R_{2} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} R_{7} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} f_{1} + I_{1} R_{2} R_{3} R_{5} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} + I_{1} R_{2} R_{3} R_{6} R_{8} g_{1} - I_{1} R_{2} R_{3} R_{6} f_{1} - I_{1} R_{2} R_{3} R_{6} + I_{1} R_{2} R_{3} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{7} R_{8} g_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{3} R_{7} ea_{1} - I_{1} R_{2} R_{3} R_{7} f_{1} - I_{1} R_{2} R_{3} R_{7} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{3} R_{8} g_{1} h_{1} - I_{1} R_{2} R_{3} R_{8} - I_{1} R_{2} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{2} R_{3} f_{1} h_{1} + I_{1} R_{2} R_{5} R_{6} R_{7} f_{1} g_{1} + I_{1} R_{2} R_{5} R_{6} R_{7} g_{1} - I_{1} R_{2} R_{5} R_{7} f_{1} - I_{1} R_{2} R_{5} R_{7} + I_{1} R_{2} R_{6} R_{7} R_{8} g_{1} - I_{1} R_{2} R_{6} R_{7} f_{1} - I_{1} R_{2} R_{6} R_{7} - I_{1} R_{2} R_{7} R_{8} + R_{1} R_{10} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{1} R_{10} R_{6} V_{3} f_{1} g_{1} + R_{1} R_{10} R_{6} V_{3} g_{1} + R_{1} R_{10} R_{7} V_{3} g_{1} + R_{1} R_{10} V_{3} f_{1} g_{1} h_{1} + R_{1} R_{11} R_{6} V_{3} f_{1} g_{1} + R_{1} R_{11} R_{6} V_{3} g_{1} + R_{1} R_{11} R_{7} V_{3} f_{1} g_{1} + R_{1} R_{11} R_{7} V_{3} g_{1} + R_{1} R_{11} V_{3} f_{1} g_{1} h_{1} - R_{1} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{1} R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{1} R_{3} R_{6} V_{3} f_{1} g_{1} + R_{1} R_{3} R_{6} V_{3} g_{1} + R_{1} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{1} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{1} R_{3} R_{7} V_{3} f_{1} g_{1} + R_{1} R_{3} R_{7} V_{3} g_{1} - R_{1} R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{1} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{1} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{1} R_{5} R_{7} V_{1} f_{1} g_{1} + R_{1} R_{5} R_{7} V_{1} g_{1} + R_{1} R_{6} R_{7} V_{3} f_{1} g_{1} + R_{1} R_{6} R_{7} V_{3} g_{1} + R_{1} R_{7} R_{8} V_{1} g_{1} + R_{10} R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{6} V_{3} f_{1} g_{1} + R_{10} R_{2} R_{6} V_{3} g_{1} + R_{10} R_{2} R_{7} V_{3} g_{1} + R_{10} R_{2} V_{3} f_{1} g_{1} h_{1} + R_{11} R_{2} R_{6} V_{3} f_{1} g_{1} + R_{11} R_{2} R_{6} V_{3} g_{1} + R_{11} R_{2} R_{7} V_{3} f_{1} g_{1} + R_{11} R_{2} R_{7} V_{3} g_{1} + R_{11} R_{2} V_{3} f_{1} g_{1} h_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{2} R_{3} R_{6} V_{3} f_{1} g_{1} + R_{2} R_{3} R_{6} V_{3} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} f_{1} g_{1} + R_{2} R_{3} R_{7} V_{3} g_{1} - R_{2} R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{2} R_{3} V_{3} f_{1} g_{1} h_{1} + R_{2} R_{5} R_{7} V_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} V_{1} g_{1} + R_{2} R_{6} R_{7} V_{3} f_{1} g_{1} + R_{2} R_{6} R_{7} V_{3} g_{1} + R_{2} R_{7} R_{8} V_{1} g_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(I_{V1} = \\frac{- I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{5} f_{1} - I_{1} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{5} + I_{1} R_{11} R_{6} + I_{1} R_{11} R_{7} - I_{1} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{8} + I_{1} R_{11} f_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{5} ea_{1} g_{1} h_{1} - I_{1} R_{2} R_{7} ea_{1} + I_{1} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} ea_{1} f_{1} h_{1} + I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{3} R_{6} R_{8} g_{1} - I_{1} R_{3} R_{6} f_{1} - I_{1} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{5} R_{6} g_{1} h_{1} + I_{1} R_{6} R_{7} - I_{1} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{6} f_{1} h_{1} - R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{11} V_{3} f_{1} g_{1} h_{1} + R_{11} V_{3} f_{1} - R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{5} V_{1} ea_{1} g_{1} + R_{2} R_{7} V_{3} ea_{1} g_{1} - R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{3} R_{6} V_{3} f_{1} g_{1} + R_{3} R_{6} V_{3} g_{1} + R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{3} R_{7} V_{3} g_{1} - R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{3} V_{1} ea_{1} f_{1} + R_{3} V_{3} f_{1} - R_{5} V_{1} f_{1} g_{1} h_{1} + R_{5} V_{1} f_{1} - R_{5} V_{1} g_{1} h_{1} + R_{5} V_{1} + R_{6} V_{1} f_{1} + R_{6} V_{1} - R_{6} V_{3} f_{1} g_{1} h_{1} - R_{6} V_{3} g_{1} h_{1} + R_{7} V_{1} - R_{7} V_{3} - R_{8} V_{1} g_{1} h_{1} + R_{8} V_{1} + V_{1} f_{1} h_{1} - V_{3} f_{1} h_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(I_{V2} = \\frac{- I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{10} R_{2} ea_{1} f_{1} + I_{1} R_{10} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{10} R_{5} R_{6} g_{1} + I_{1} R_{10} R_{6} R_{8} g_{1} - I_{1} R_{10} R_{6} f_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{3} ea_{1} f_{1} + I_{1} R_{11} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{11} R_{5} R_{6} g_{1} + I_{1} R_{11} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{11} R_{5} R_{7} g_{1} + I_{1} R_{11} R_{6} R_{8} g_{1} - I_{1} R_{11} R_{6} f_{1} + I_{1} R_{11} R_{7} R_{8} g_{1} - I_{1} R_{11} R_{7} f_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} ea_{1} f_{1} - I_{1} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} - I_{1} R_{2} R_{5} R_{7} ea_{1} g_{1} - I_{1} R_{2} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{7} ea_{1} f_{1} + I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{3} R_{6} R_{8} g_{1} - I_{1} R_{3} R_{6} f_{1} + I_{1} R_{5} R_{6} R_{7} f_{1} g_{1} + I_{1} R_{5} R_{6} R_{7} g_{1} + I_{1} R_{6} R_{7} R_{8} g_{1} - I_{1} R_{6} R_{7} f_{1} - R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{6} V_{3} f_{1} g_{1} + R_{10} R_{6} V_{3} g_{1} + R_{10} R_{7} V_{3} g_{1} + R_{10} V_{3} f_{1} - R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{11} R_{6} V_{3} f_{1} g_{1} + R_{11} R_{6} V_{3} g_{1} + R_{11} R_{7} V_{3} f_{1} g_{1} + R_{11} R_{7} V_{3} g_{1} + R_{11} V_{3} f_{1} - R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{3} R_{6} V_{3} f_{1} g_{1} + R_{3} R_{6} V_{3} g_{1} + R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{3} R_{7} V_{3} g_{1} - R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{3} V_{1} ea_{1} f_{1} + R_{3} V_{3} f_{1} + R_{5} R_{7} V_{1} f_{1} g_{1} + R_{5} R_{7} V_{1} g_{1} + R_{6} R_{7} V_{3} f_{1} g_{1} + R_{6} R_{7} V_{3} g_{1} + R_{7} R_{8} V_{1} g_{1} - R_{7} V_{1} f_{1} + R_{7} V_{3} f_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(I_{V3} = \\frac{I_{1} R_{10} R_{2} ea_{1} - I_{1} R_{10} R_{6} + I_{1} R_{11} R_{2} ea_{1} + I_{1} R_{11} R_{3} ea_{1} - I_{1} R_{11} R_{6} - I_{1} R_{11} R_{7} + I_{1} R_{2} R_{3} ea_{1} + I_{1} R_{2} R_{7} ea_{1} - I_{1} R_{3} R_{6} - I_{1} R_{6} R_{7} - R_{10} R_{2} V_{3} ea_{1} g_{1} - R_{10} R_{3} V_{3} ea_{1} g_{1} - R_{10} V_{3} g_{1} h_{1} + R_{10} V_{3} - R_{11} R_{2} V_{3} ea_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} g_{1} - R_{11} V_{3} g_{1} h_{1} + R_{11} V_{3} - R_{2} R_{3} V_{3} ea_{1} g_{1} - R_{2} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{7} V_{3} ea_{1} g_{1} - R_{3} R_{7} V_{3} g_{1} + R_{3} V_{1} ea_{1} - R_{3} V_{3} ea_{1} g_{1} h_{1} - R_{3} V_{3} g_{1} h_{1} + R_{3} V_{3} - R_{7} V_{1} + R_{7} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(I_{Ea1} = \\frac{I_{1} R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{2} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{2} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{2} ea_{1} + I_{1} R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{10} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{10} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{10} R_{3} ea_{1} f_{1} + I_{1} R_{10} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{10} R_{5} f_{1} + I_{1} R_{10} R_{5} g_{1} h_{1} - I_{1} R_{10} R_{5} - I_{1} R_{10} R_{7} + I_{1} R_{10} R_{8} g_{1} h_{1} - I_{1} R_{10} R_{8} - I_{1} R_{10} f_{1} h_{1} + I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} + I_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{2} ea_{1} f_{1} - I_{1} R_{11} R_{2} ea_{1} + I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{11} R_{3} ea_{1} + I_{1} R_{11} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{11} R_{5} f_{1} + I_{1} R_{11} R_{5} g_{1} h_{1} - I_{1} R_{11} R_{5} + I_{1} R_{11} R_{8} g_{1} h_{1} - I_{1} R_{11} R_{8} - I_{1} R_{11} f_{1} h_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} + I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{3} ea_{1} f_{1} - I_{1} R_{2} R_{3} ea_{1} + I_{1} R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{2} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{2} R_{7} R_{8} ea_{1} g_{1} - I_{1} R_{2} R_{7} ea_{1} f_{1} - I_{1} R_{2} R_{7} ea_{1} + I_{1} R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{7} ea_{1} g_{1} + I_{1} R_{3} R_{5} R_{7} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{7} g_{1} + I_{1} R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{3} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{3} R_{5} f_{1} g_{1} h_{1} - I_{1} R_{3} R_{5} f_{1} + I_{1} R_{3} R_{5} g_{1} h_{1} - I_{1} R_{3} R_{5} + I_{1} R_{3} R_{7} R_{8} ea_{1} g_{1} + I_{1} R_{3} R_{7} R_{8} g_{1} - I_{1} R_{3} R_{7} ea_{1} f_{1} - I_{1} R_{3} R_{7} ea_{1} - I_{1} R_{3} R_{7} f_{1} - I_{1} R_{3} R_{7} + I_{1} R_{3} R_{8} ea_{1} g_{1} h_{1} + I_{1} R_{3} R_{8} g_{1} h_{1} - I_{1} R_{3} R_{8} - I_{1} R_{3} ea_{1} f_{1} h_{1} - I_{1} R_{3} f_{1} h_{1} - I_{1} R_{5} R_{7} f_{1} - I_{1} R_{5} R_{7} - I_{1} R_{7} R_{8} + R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{2} V_{3} ea_{1} g_{1} + R_{10} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{10} R_{3} V_{3} ea_{1} g_{1} + R_{10} V_{3} f_{1} g_{1} h_{1} - R_{10} V_{3} f_{1} + R_{10} V_{3} g_{1} h_{1} - R_{10} V_{3} + R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} + R_{11} R_{2} V_{3} ea_{1} g_{1} + R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{11} R_{3} V_{3} ea_{1} g_{1} + R_{11} V_{3} f_{1} g_{1} h_{1} - R_{11} V_{3} f_{1} + R_{11} V_{3} g_{1} h_{1} - R_{11} V_{3} + R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{3} V_{3} ea_{1} g_{1} + R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{2} R_{7} V_{3} ea_{1} g_{1} + R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} + R_{3} R_{7} V_{3} ea_{1} g_{1} + R_{3} R_{7} V_{3} f_{1} g_{1} + R_{3} R_{7} V_{3} g_{1} - R_{3} V_{1} ea_{1} f_{1} - R_{3} V_{1} ea_{1} + R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} + R_{3} V_{3} ea_{1} g_{1} h_{1} + R_{3} V_{3} f_{1} g_{1} h_{1} - R_{3} V_{3} f_{1} + R_{3} V_{3} g_{1} h_{1} - R_{3} V_{3} + R_{7} V_{1} f_{1} + R_{7} V_{1} - R_{7} V_{3} f_{1} - R_{7} V_{3}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(I_{F1} = \\frac{I_{1} R_{10} R_{2} ea_{1} f_{1} - I_{1} R_{10} R_{6} f_{1} + I_{1} R_{11} R_{2} ea_{1} f_{1} + I_{1} R_{11} R_{3} ea_{1} f_{1} - I_{1} R_{11} R_{6} f_{1} - I_{1} R_{11} R_{7} f_{1} + I_{1} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{2} R_{7} ea_{1} f_{1} - I_{1} R_{3} R_{6} f_{1} - I_{1} R_{6} R_{7} f_{1} - R_{10} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{10} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{10} V_{3} f_{1} g_{1} h_{1} + R_{10} V_{3} f_{1} - R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{11} V_{3} f_{1} g_{1} h_{1} + R_{11} V_{3} f_{1} - R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{3} R_{7} V_{3} ea_{1} f_{1} g_{1} - R_{3} R_{7} V_{3} f_{1} g_{1} + R_{3} V_{1} ea_{1} f_{1} - R_{3} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} V_{3} f_{1} g_{1} h_{1} + R_{3} V_{3} f_{1} - R_{7} V_{1} f_{1} + R_{7} V_{3} f_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\\(I_{H1} = \\frac{I_{1} R_{10} R_{2} ea_{1} - I_{1} R_{10} R_{6} - I_{1} R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{2} R_{5} ea_{1} g_{1} - I_{1} R_{11} R_{2} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{2} ea_{1} f_{1} + I_{1} R_{11} R_{2} ea_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{11} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{11} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{11} R_{3} ea_{1} f_{1} + I_{1} R_{11} R_{3} ea_{1} - I_{1} R_{11} R_{5} f_{1} g_{1} h_{1} + I_{1} R_{11} R_{5} f_{1} - I_{1} R_{11} R_{5} g_{1} h_{1} + I_{1} R_{11} R_{5} - I_{1} R_{11} R_{8} g_{1} h_{1} + I_{1} R_{11} R_{8} + I_{1} R_{11} f_{1} h_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} - I_{1} R_{2} R_{3} R_{5} ea_{1} g_{1} - I_{1} R_{2} R_{3} R_{8} ea_{1} g_{1} + I_{1} R_{2} R_{3} ea_{1} f_{1} + I_{1} R_{2} R_{3} ea_{1} + I_{1} R_{2} R_{5} ea_{1} f_{1} g_{1} h_{1} + I_{1} R_{2} R_{5} ea_{1} g_{1} h_{1} + I_{1} R_{2} R_{8} ea_{1} g_{1} h_{1} - I_{1} R_{2} ea_{1} f_{1} h_{1} + I_{1} R_{3} R_{5} R_{6} f_{1} g_{1} + I_{1} R_{3} R_{5} R_{6} g_{1} + I_{1} R_{3} R_{6} R_{8} g_{1} - I_{1} R_{3} R_{6} f_{1} - I_{1} R_{3} R_{6} - I_{1} R_{5} R_{6} f_{1} g_{1} h_{1} - I_{1} R_{5} R_{6} g_{1} h_{1} - I_{1} R_{6} R_{8} g_{1} h_{1} + I_{1} R_{6} f_{1} h_{1} - R_{10} R_{2} V_{3} ea_{1} g_{1} - R_{10} R_{3} V_{3} ea_{1} g_{1} - R_{10} V_{3} g_{1} h_{1} + R_{10} V_{3} - R_{11} R_{2} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{2} V_{3} ea_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{11} R_{3} V_{3} ea_{1} g_{1} - R_{11} V_{3} f_{1} g_{1} h_{1} + R_{11} V_{3} f_{1} - R_{11} V_{3} g_{1} h_{1} + R_{11} V_{3} - R_{2} R_{3} V_{3} ea_{1} f_{1} g_{1} - R_{2} R_{3} V_{3} ea_{1} g_{1} - R_{2} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{2} R_{5} V_{1} ea_{1} g_{1} - R_{2} R_{8} V_{1} ea_{1} g_{1} + R_{2} V_{3} ea_{1} f_{1} g_{1} h_{1} - R_{3} R_{5} V_{1} ea_{1} f_{1} g_{1} - R_{3} R_{5} V_{1} ea_{1} g_{1} + R_{3} R_{6} V_{3} f_{1} g_{1} + R_{3} R_{6} V_{3} g_{1} - R_{3} R_{8} V_{1} ea_{1} g_{1} + R_{3} V_{1} ea_{1} f_{1} + R_{3} V_{1} ea_{1} - R_{3} V_{3} ea_{1} g_{1} h_{1} + R_{3} V_{3} f_{1} - R_{3} V_{3} g_{1} h_{1} + R_{3} V_{3} - R_{5} V_{1} f_{1} g_{1} h_{1} + R_{5} V_{1} f_{1} - R_{5} V_{1} g_{1} h_{1} + R_{5} V_{1} + R_{6} V_{1} f_{1} + R_{6} V_{1} - R_{6} V_{3} f_{1} g_{1} h_{1} - R_{6} V_{3} g_{1} h_{1} - R_{8} V_{1} g_{1} h_{1} + R_{8} V_{1} + V_{1} f_{1} h_{1} - V_{3} f_{1} h_{1}}{R_{10} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{2} R_{5} ea_{1} g_{1} + R_{10} R_{2} R_{8} ea_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{10} R_{3} R_{5} ea_{1} g_{1} + R_{10} R_{3} R_{8} ea_{1} g_{1} - R_{10} R_{3} ea_{1} f_{1} + R_{10} R_{5} f_{1} g_{1} h_{1} - R_{10} R_{5} f_{1} + R_{10} R_{5} g_{1} h_{1} - R_{10} R_{5} - R_{10} R_{6} f_{1} - R_{10} R_{6} - R_{10} R_{7} + R_{10} R_{8} g_{1} h_{1} - R_{10} R_{8} - R_{10} f_{1} h_{1} + R_{11} R_{2} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{2} R_{5} ea_{1} g_{1} + R_{11} R_{2} R_{8} ea_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{11} R_{3} R_{5} ea_{1} g_{1} + R_{11} R_{3} R_{8} ea_{1} g_{1} + R_{11} R_{5} f_{1} g_{1} h_{1} - R_{11} R_{5} f_{1} + R_{11} R_{5} g_{1} h_{1} - R_{11} R_{5} - R_{11} R_{6} f_{1} - R_{11} R_{6} - R_{11} R_{7} f_{1} - R_{11} R_{7} + R_{11} R_{8} g_{1} h_{1} - R_{11} R_{8} - R_{11} f_{1} h_{1} + R_{2} R_{3} R_{5} ea_{1} f_{1} g_{1} + R_{2} R_{3} R_{5} ea_{1} g_{1} + R_{2} R_{3} R_{8} ea_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{2} R_{5} R_{7} ea_{1} g_{1} + R_{2} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} f_{1} g_{1} + R_{3} R_{5} R_{7} ea_{1} g_{1} + R_{3} R_{5} R_{7} f_{1} g_{1} + R_{3} R_{5} R_{7} g_{1} + R_{3} R_{5} ea_{1} f_{1} g_{1} h_{1} + R_{3} R_{5} ea_{1} g_{1} h_{1} + R_{3} R_{5} f_{1} g_{1} h_{1} - R_{3} R_{5} f_{1} + R_{3} R_{5} g_{1} h_{1} - R_{3} R_{5} - R_{3} R_{6} f_{1} - R_{3} R_{6} + R_{3} R_{7} R_{8} ea_{1} g_{1} + R_{3} R_{7} R_{8} g_{1} - R_{3} R_{7} ea_{1} f_{1} - R_{3} R_{7} ea_{1} - R_{3} R_{7} f_{1} - R_{3} R_{7} + R_{3} R_{8} ea_{1} g_{1} h_{1} + R_{3} R_{8} g_{1} h_{1} - R_{3} R_{8} - R_{3} ea_{1} f_{1} h_{1} - R_{3} f_{1} h_{1} - R_{5} R_{7} f_{1} - R_{5} R_{7} - R_{6} R_{7} f_{1} - R_{6} R_{7} - R_{7} R_{8}}\\)\n\n\nConstruct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\nDC operating point\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{F1} + 0.333333333333333 v_{1} - 0.333333333333333 v_{10} + 3.0 v_{4} - 3.0 v_{7}\\)\\(0 = - 0.5 v_{15} + 0.976190476190476 v_{2} - 0.142857142857143 v_{3}\\)\\(2.0 = - 0.142857142857143 v_{2} + 0.142857142857143 v_{3}\\)\\(-2.0 = - I_{Ea1} + 0.333333333333333 v_{4} - 0.333333333333333 v_{6}\\)\\(0 = I_{H1} - 0.333333333333333 v_{13} + 0.444444444444444 v_{5}\\)\\(0 = - I_{V3} - 0.333333333333333 v_{4} + 0.666666666666667 v_{6} - 0.333333333333333 v_{8}\\)\\(0 = - 0.25 v_{11} - 0.2 v_{12} - 0.5 v_{14} + 0.95 v_{7}\\)\\(0 = - I_{F1} - 0.333333333333333 v_{6} + 0.333333333333333 v_{8}\\)\\(0 = - I_{V1} + I_{V2} + 0.25 v_{9}\\)\\(0 = - I_{V2} - 0.333333333333333 v_{1} + 0.333333333333333 v_{10}\\)\\(0 = I_{V1} + 0.25 v_{11} - 0.25 v_{7}\\)\\(0 = I_{V3} + 0.2 v_{12} - 0.2 v_{7}\\)\\(0 = I_{Ea1} + 0.333333333333333 v_{13} - 0.333333333333333 v_{5}\\)\\(0 = - I_{H1} + 0.5 v_{14} - 0.5 v_{7}\\)\\(0 = 0.5 v_{15} - 0.5 v_{2} - 3.0 v_{4} + 3.0 v_{7}\\)\\(3.0 = v_{11} - v_{9}\\)\\(0 = - v_{10} + v_{9}\\)\\(0 = v_{12} - v_{6}\\)\\(0 = v_{13} + 2.0 v_{2} - v_{4} - 2.0 v_{9}\\)\\(0 = I_{F1} - 2.0 I_{V3}\\)\\(0 = - 3.0 I_{V2} - v_{14} + v_{5}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\nThis code window is too wide.\n\ntable_header = ['unknown', 'value','unit']\ntable_row = []\n\nfor name, value in U.items():\n    if str(name)[0] == 'I':\n        unit = 'device current'\n    else:\n        unit = 'voltage'\n    table_row.append([str(name),float(value),str(unit)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('right','decimal','left'),\n    tablefmt=\"simple\",floatfmt=('5s','.6f','20s')))\n\n  unknown       value  unit\n---------  ----------  --------------\n       v1    0.845718  voltage\n       v2    3.586400  voltage\n       v3   17.586400  voltage\n       v4   -3.238966  voltage\n       v5   -7.490063  voltage\n       v6   -3.066566  voltage\n       v7   -2.970788  voltage\n       v8   -2.951632  voltage\n       v9   -1.452949  voltage\n      v10   -1.452949  voltage\n      v11    1.547051  voltage\n      v12   -3.066566  voltage\n      v13  -13.317663  voltage\n      v14   -5.191396  voltage\n      v15    1.977333  voltage\n     I_V1   -1.129460  device current\n     I_V2   -0.766222  device current\n     I_V3    0.019156  device current\n    I_Ea1    1.942533  device current\n     I_F1    0.038311  device current\n     I_H1   -1.110304  device current\n\n\nComment on why G1 is not part of the solution.\nVCCS\nContributes to G\nNote the asymmetry (rows k, l, columns m, n)\nNo inputs to X or Z\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    3.36639     voltage\nV(15):   1.61065     voltage\nV(9):    -1.29974    voltage\nV(1):    1.04125     voltage\nV(10):   -1.29974    voltage\nV(4):    -3.40358    voltage\nV(6):    -2.96464    voltage\nV(5):    -7.17476    voltage\nV(13):   -12.7358    voltage\nV(7):    -2.72079    voltage\nV(14):   -4.83377    voltage\nV(12):   -2.96464    voltage\nV(3):    17.3664     voltage\nV(11):   1.70026     voltage\nV(8):    -2.67202    voltage\n\nI(F1):   0.0975412   device_current\nI(H1):   -1.05649    device_current\n\nI(G1):   -0.87787    device_current\n\nI(E1):   1.85369     device_current\n\nI(V1):   -1.10526    device_current\nI(V2):   -0.780329   device_current\nI(V3):   0.0487706   device_current\n\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resistive Networks</span>"
    ]
  },
  {
    "objectID": "Resistive_networks.html#example-circuit-6",
    "href": "Resistive_networks.html#example-circuit-6",
    "title": "5  Resistive Networks",
    "section": "5.3 Example Circuit 6",
    "text": "5.3 Example Circuit 6\nThe schematic shown in Figure 5.3 is ment to represent a wheel shaped spider web known as an Orb web. A resistor in the schematic is connected between each junction in the web. The web is connected to ground at three of the corners. The schematic was drawn using LTSpice which places components either horizontally or verticaly, so it was not possible to have the resistors aling with radial lines that would be present in an Orb Web. The schematic is my best attempt to position all the resistors along radial paths.\nThe network has 45 branches, 22 nodes and 44 resistors. For simplicity all the resistor values are \\(1 \\Omega\\).\n\n\n\n\n\n\nFigure 5.3: Schematic for example 6.\n\n\n\nIn the schematic, LTSpice assigned the node numbers, which are not shown. If the mouse pointer hovers over a node (when the schematic is viewed with LTSpice), the node number is displayed in the lower left corner within LTSpice. The netlist for the schematic was copied below. As you can see, LTSpice numbers the nodes as N001, N002, …\n\nnet_list = '''\nR1 N005 N010 1\nR2 N010 N015 1\nR3 N007 N012 1\nR4 N012 N017 1\nR5 N006 N005 1\nR6 N007 N006 1\nR7 N016 N015 1\nR8 N017 N016 1\nR9 N011 N010 1\nR10 N012 N011 1\nR11 N011 N006 1\nR12 N016 N011 1\nI1 0 N011 1\nR13 N004 N013 1\nR14 N013 N020 1\nR15 N009 N018 1\nR16 N002 N009 1\nR17 N010 N009 1\nR18 N013 N012 1\nR19 N019 N016 1\nR20 N006 N003 1\nR21 N002 N003 1\nR22 N003 N004 1\nR23 N019 N020 1\nR24 N018 N019 1\nR25 N015 N018 1\nR26 N017 N020 1\nR27 N004 N007 1\nR28 N002 N005 1\nR29 0 N008 1\nR30 N008 0 1\nR31 N014 N022 1\nR32 0 N014 1\nR33 0 N001 1\nR34 N001 0 1\nR35 N021 0 1\nR36 N022 N021 1\nR37 N022 N020 1\nR38 0 N018 1\nR39 N002 0 1\nR40 N004 0 1\nR41 N003 N001 1\nR42 N021 N019 1\nR43 N013 N014 1\nR44 N008 N009 1\n'''\n\nUsing the following code, the netlist was modified to use interger values for the node numbers.\n\n# Pattern: 'N' followed by one or more digits, captured.\npattern = r\"N(\\d+)\"\n\n# Replacement: Use the captured group 1 (the digits)\nreplacement = r\"\\1\"\n\nmodified_net_list = re.sub(pattern, replacement, net_list)\n\nGenerate and display the node equations.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(modified_net_list)\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{41}} + \\frac{1}{R_{34}} + \\frac{1}{R_{33}}\\right) - \\frac{v_{3}}{R_{41}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{39}} + \\frac{1}{R_{28}} + \\frac{1}{R_{21}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{5}}{R_{28}} - \\frac{v_{3}}{R_{21}} - \\frac{v_{9}}{R_{16}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{41}} + \\frac{1}{R_{22}} + \\frac{1}{R_{21}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{1}}{R_{41}} - \\frac{v_{4}}{R_{22}} - \\frac{v_{2}}{R_{21}} - \\frac{v_{6}}{R_{20}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{40}} + \\frac{1}{R_{27}} + \\frac{1}{R_{22}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{7}}{R_{27}} - \\frac{v_{3}}{R_{22}} - \\frac{v_{13}}{R_{13}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{28}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{2}}{R_{28}} - \\frac{v_{10}}{R_{1}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{20}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{7}}{R_{6}} - \\frac{v_{5}}{R_{5}} - \\frac{v_{3}}{R_{20}} - \\frac{v_{11}}{R_{11}} = 0\\)\\(v_{7} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{12}}{R_{3}} - \\frac{v_{4}}{R_{27}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{44}} + \\frac{1}{R_{30}} + \\frac{1}{R_{29}}\\right) - \\frac{v_{9}}{R_{44}} = 0\\)\\(v_{9} \\cdot \\left(\\frac{1}{R_{44}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{8}}{R_{44}} - \\frac{v_{10}}{R_{17}} - \\frac{v_{2}}{R_{16}} - \\frac{v_{18}}{R_{15}} = 0\\)\\(v_{10} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{2}} + \\frac{1}{R_{17}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{11}}{R_{9}} - \\frac{v_{15}}{R_{2}} - \\frac{v_{9}}{R_{17}} - \\frac{v_{5}}{R_{1}} = 0\\)\\(v_{11} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{16}}{R_{12}} - \\frac{v_{6}}{R_{11}} - \\frac{v_{12}}{R_{10}} = I_{1}\\)\\(v_{12} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}} + \\frac{1}{R_{18}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{17}}{R_{4}} - \\frac{v_{7}}{R_{3}} - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{10}} = 0\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{43}} + \\frac{1}{R_{18}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{14}}{R_{43}} - \\frac{v_{12}}{R_{18}} - \\frac{v_{20}}{R_{14}} - \\frac{v_{4}}{R_{13}} = 0\\)\\(v_{14} \\cdot \\left(\\frac{1}{R_{43}} + \\frac{1}{R_{32}} + \\frac{1}{R_{31}}\\right) - \\frac{v_{13}}{R_{43}} - \\frac{v_{22}}{R_{31}} = 0\\)\\(v_{15} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{25}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{16}}{R_{7}} - \\frac{v_{18}}{R_{25}} - \\frac{v_{10}}{R_{2}} = 0\\)\\(v_{16} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{19}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{17}}{R_{8}} - \\frac{v_{15}}{R_{7}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{11}}{R_{12}} = 0\\)\\(v_{17} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{16}}{R_{8}} - \\frac{v_{12}}{R_{4}} - \\frac{v_{20}}{R_{26}} = 0\\)\\(v_{18} \\cdot \\left(\\frac{1}{R_{38}} + \\frac{1}{R_{25}} + \\frac{1}{R_{24}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{15}}{R_{25}} - \\frac{v_{19}}{R_{24}} - \\frac{v_{9}}{R_{15}} = 0\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{42}} + \\frac{1}{R_{24}} + \\frac{1}{R_{23}} + \\frac{1}{R_{19}}\\right) - \\frac{v_{21}}{R_{42}} - \\frac{v_{18}}{R_{24}} - \\frac{v_{20}}{R_{23}} - \\frac{v_{16}}{R_{19}} = 0\\)\\(v_{20} \\cdot \\left(\\frac{1}{R_{37}} + \\frac{1}{R_{26}} + \\frac{1}{R_{23}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{22}}{R_{37}} - \\frac{v_{17}}{R_{26}} - \\frac{v_{19}}{R_{23}} - \\frac{v_{13}}{R_{14}} = 0\\)\\(v_{21} \\cdot \\left(\\frac{1}{R_{42}} + \\frac{1}{R_{36}} + \\frac{1}{R_{35}}\\right) - \\frac{v_{19}}{R_{42}} - \\frac{v_{22}}{R_{36}} = 0\\)\\(v_{22} \\cdot \\left(\\frac{1}{R_{37}} + \\frac{1}{R_{36}} + \\frac{1}{R_{31}}\\right) - \\frac{v_{20}}{R_{37}} - \\frac{v_{21}}{R_{36}} - \\frac{v_{14}}{R_{31}} = 0\\)\n\n\nBuild the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\nThe symbolic solution of the newtork equations will take a long time on an i3 machine. So the following code is commented out.\n\n%%time\nU_sym = solve(NE_sym,X)\n\n# Display the symbolic solution.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\nConstruct a dictionary of random element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# assign random component values\nfor k,v in element_values.items():\n    element_values[k] = random.randint(1, 10)\n\n# reset current source back to 1 Amp\nelement_values[I1] = 1    \n    \n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nThe following code substitutes numerical values into the network equations.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = \\frac{43 v_{1}}{30} - \\frac{v_{3}}{3}\\)\\(0 = \\frac{54 v_{2}}{35} - v_{3} - \\frac{v_{5}}{5} - \\frac{v_{9}}{5}\\)\\(0 = - \\frac{v_{1}}{3} - v_{2} + \\frac{5 v_{3}}{3} - \\frac{v_{4}}{6} - \\frac{v_{6}}{6}\\)\\(0 = - \\frac{v_{13}}{10} - \\frac{v_{3}}{6} + \\frac{14 v_{4}}{15} - \\frac{v_{7}}{2}\\)\\(0 = - \\frac{v_{10}}{4} - \\frac{v_{2}}{5} + \\frac{47 v_{5}}{60} - \\frac{v_{6}}{3}\\)\\(0 = - \\frac{v_{11}}{9} - \\frac{v_{3}}{6} - \\frac{v_{5}}{3} + \\frac{95 v_{6}}{126} - \\frac{v_{7}}{7}\\)\\(0 = - \\frac{v_{12}}{2} - \\frac{v_{4}}{2} - \\frac{v_{6}}{7} + \\frac{8 v_{7}}{7}\\)\\(0 = \\frac{59 v_{8}}{120} - \\frac{v_{9}}{5}\\)\\(0 = - \\frac{v_{10}}{6} - \\frac{v_{18}}{8} - \\frac{v_{2}}{5} - \\frac{v_{8}}{5} + \\frac{83 v_{9}}{120}\\)\\(0 = \\frac{277 v_{10}}{420} - \\frac{v_{11}}{7} - \\frac{v_{15}}{10} - \\frac{v_{5}}{4} - \\frac{v_{9}}{6}\\)\\(1 = - \\frac{v_{10}}{7} + \\frac{58 v_{11}}{63} - \\frac{v_{12}}{2} - \\frac{v_{16}}{6} - \\frac{v_{6}}{9}\\)\\(0 = - \\frac{v_{11}}{2} + \\frac{87 v_{12}}{70} - \\frac{v_{13}}{10} - \\frac{v_{17}}{7} - \\frac{v_{7}}{2}\\)\\(0 = - \\frac{v_{12}}{10} + \\frac{7 v_{13}}{15} - \\frac{v_{14}}{10} - \\frac{v_{20}}{6} - \\frac{v_{4}}{10}\\)\\(0 = - \\frac{v_{13}}{10} + \\frac{31 v_{14}}{60} - \\frac{v_{22}}{4}\\)\\(0 = - \\frac{v_{10}}{10} + \\frac{17 v_{15}}{40} - \\frac{v_{16}}{8} - \\frac{v_{18}}{5}\\)\\(0 = - \\frac{v_{11}}{6} - \\frac{v_{15}}{8} + \\frac{119 v_{16}}{120} - \\frac{v_{17}}{5} - \\frac{v_{19}}{2}\\)\\(0 = - \\frac{v_{12}}{7} - \\frac{v_{16}}{5} + \\frac{19 v_{17}}{35} - \\frac{v_{20}}{5}\\)\\(0 = - \\frac{v_{15}}{5} + \\frac{337 v_{18}}{360} - \\frac{v_{19}}{9} - \\frac{v_{9}}{8}\\)\\(0 = - \\frac{v_{16}}{2} - \\frac{v_{18}}{9} + \\frac{443 v_{19}}{504} - \\frac{v_{20}}{8} - \\frac{v_{21}}{7}\\)\\(0 = - \\frac{v_{13}}{6} - \\frac{v_{17}}{5} - \\frac{v_{19}}{8} + \\frac{179 v_{20}}{120} - v_{22}\\)\\(0 = - \\frac{v_{19}}{7} + \\frac{27 v_{21}}{70} - \\frac{v_{22}}{7}\\)\\(0 = - \\frac{v_{14}}{4} - v_{20} - \\frac{v_{21}}{7} + \\frac{39 v_{22}}{28}\\)\n\n\nSolve for the node voltages.\n\n%%time\nU = solve(NE,X)\n\nCPU times: user 65.1 ms, sys: 4 µs, total: 65.1 ms\nWall time: 64.8 ms\n\n\nDisplay the numerical solution.\n\ntable_header = ['unknowns', 'values','units']\ntable_row = []\n\nfor name, value in U.items():\n    if str(name)[0] == 'I':\n        unit = 'device current'\n    else:\n        unit = 'voltage'\n    table_row.append([str(name),float(value),str(unit)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('right','decimal','left'),\n    tablefmt=\"simple\",floatfmt=('5s',',.7f','20s')))\n\n  unknowns     values  units\n----------  ---------  -------\n        v1  0.1682948  voltage\n        v2  0.7260135  voltage\n        v3  0.7236677  voltage\n        v4  1.1049195  voltage\n        v5  1.2570513  voltage\n        v6  1.4390871  voltage\n        v7  1.5701145  voltage\n        v8  0.2950314  voltage\n        v9  0.7252856  voltage\n       v10  1.4391672  voltage\n       v11  2.8898595  voltage\n       v12  2.0727459  voltage\n       v13  1.2558963  voltage\n       v14  0.7530286  voltage\n       v15  1.0118421  voltage\n       v16  1.5518326  voltage\n       v17  1.5438532  voltage\n       v18  0.4606855  voltage\n       v19  1.2440130  voltage\n       v20  1.1580931  voltage\n       v21  0.8510791  voltage\n       v22  1.0539006  voltage\n\n\nThese don’t apply if random values are used.\nV(n005):     0.276391    voltage\nV(n010):     0.334586    voltage\nV(n015):     0.286466    voltage\nV(n007):     0.286466    voltage\nV(n012):     0.352782    voltage\nV(n017):     0.311128    voltage\nV(n006):     0.334586    voltage\nV(n016):     0.352782    voltage\nV(n011):     0.593684    voltage\nV(n004):     0.17203     voltage\nV(n013):     0.21985     voltage\nV(n020):     0.22782     voltage\nV(n009):     0.181805    voltage\nV(n018):     0.17203     voltage\nV(n002):     0.16            voltage\nV(n019):     0.21985     voltage\nV(n003):     0.181805    voltage\nV(n008):     0.0606015   voltage\nV(n014):     0.126767    voltage\nV(n022):     0.160451    voltage\nV(n001):     0.0606015   voltage\nV(n021):     0.126767    voltage\nSince the circuit consists of only resistors and one current source, the \\(A\\) matrix is the Nodal Addmittance Matrix or NAM, which is oftern designated as \\(Y\\) in circuit analysis text books. The following code converts the SymPy matrix to a NumPy matrix. This is done because symbolic matrix inversion takes much longer than numerical inversion.\n\nY = np.array(A.subs(element_values), dtype=float)\n\nThe inverse of \\(Y\\) is the impedance matrix, \\(Z\\).\n\nZ = np.linalg.inv(Y)\n\nDriving-point impedance\nThe impedance at a single node \\(k\\) with respect to the reference node (the Thevenin impedance \\(Z_{Th,k}\\)), it is simply the diagonal element: \\(Z_{Th,k} = Z_{kk}\\). This is the impedance seen looking into node \\(k\\) with respect to ground (the reference node) when all independent sources are set to zero (voltage sources short-circuited, current sources open-circuited).\n\nnode_A = 11\nprint(f'Equalivent resistance between node {node_A:d} and ground is: {Z[node_A-1,node_A-1]:,.3f}')\n\nEqualivent resistance between node 11 and ground is: 2.890\n\n\nTransfer impedance\nThe transfer impedance between node \\(j\\) and node \\(i\\) is \\(Z_{ji}\\), if \\(i \\neq j\\). It is the voltage at node \\(i\\) per unit current injected at node \\(j\\), with all other current injections being zero. For reciprocal networks (like those made only of resistors, capacitors, and inductors), \\(Z_{kj} = Z_{jk}\\). A higher transfer impedance indicates a weaker connection and less effective voltage support from that generator to the load.\n\nnode_A = 11\nnode_B = 19\nprint(f'The transfer impedance between node {node_A:d} and node {node_B:d} is: {Z[node_A-1,node_B-1]:,.4f}')\n\nThe transfer impedance between node 11 and node 19 is: 1.2440",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resistive Networks</span>"
    ]
  },
  {
    "objectID": "Resistive_networks.html#summary",
    "href": "Resistive_networks.html#summary",
    "title": "5  Resistive Networks",
    "section": "5.4 Summary",
    "text": "5.4 Summary\nIn this chapter we examined resistive electrical circuits. The Python MNA code is useful in cases where the newtork equations in symbolic form are desired. What this chapter as shown is the following:\n\nComplexity vs. Method: The examples demonstrate a clear progression in circuit complexity. Circuit 1 is small enough for manual methods. Circuit 2 is a specific problem with a focus on an unconventional analysis question. Circuit 3 is highly complex (nonplanar, dependent sources), making manual analysis impractical.\nAnalysis Tools: The text highlights the use of the Modified Nodal Analysis (MNA) as an algorithmic method suitable for computer implementation (like in Circuit 3 with SymPy) compared to traditional Nodal or Loop analysis, even noting that MNA can increase the number of equations (Circuit 1).\nSymbolic Solutions: For complex circuits like Circuit 3, symbolic analysis can generate correct expressions but may not provide immediate, useful insight due to their length.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resistive Networks</span>"
    ]
  },
  {
    "objectID": "RLC_networks.html",
    "href": "RLC_networks.html",
    "title": "6  RLC Networks",
    "section": "",
    "text": "6.1 RLC Circuit 1\nAn RLC network is an electrical circuit composed of passive components: Resistors (\\(R\\)), Inductors (\\(L\\)), and Capacitors (\\(C\\)), as well as dependent and independent sources. This chapter presents the analysis of example RLC networks using MNA and Python. These examples will illustrate application of the code to find the node voltages for these circuits.\nThe following Python libraries are used in this notebook.\nThe circuit shown in the schematic below contains three resistors, one capacitor, one inductor and one independent voltage source. The nodes have been numbered and the reference node is indicated by the ground symbol. The schematic was drawn using LTSpice and the netlist was expored and copied into the code cell below.\nThe circuit is a typical of circuits found in circuit analysis text books. The independed voltage source spans nodes 1 and 2. Typically, these nodes would be considred a super-node when applying KCL to obtain a set of network equations. When using the MNA procedure, extra equations are generated to deal with voltage sourses that span circuit nodes.\nThe netlist is loaded as a string and applied to the variable.\nnet_list = '''\nR1 1 0 3\nR2 3 2 7\nR3 3 0 11\nC 3 1 0.5\nL 2 0 1\nV 1 2 2\n'''\nThe netlist is passed to the function SymMNA.smna(net_list) to generate the MNA matrices.\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\nThe matrices are converted to SymPy types and the symbolic network equations are displayed using markdown.\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C s v_{3} + I_{V} + v_{1} \\left(C s + \\frac{1}{R_{1}}\\right) = 0\\)\\(I_{L} - I_{V} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(- C s v_{1} + v_{3} \\left(C s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(v_{1} - v_{2} = V\\)\\(- I_{L} L s + v_{2} = 0\\)\nTurn the free symbols into SymPy variables.\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L, \\  v_{2}, \\  R_{2}, \\  I_{V}, \\  v_{1}, \\  s, \\  R_{3}, \\  V, \\  R_{1}, \\  v_{3}, \\  I_{L}, \\  C\\right)\\)\nThe SymPy function solve is used to solve the system of equations. The magic function %%time is used to measure the time it takes to generate a solution. For the circuit shown in Figure 6.1, a few hundred milli seconds is needed on my i3 processor.\n%%time\nU_sym = solve(NE_sym,X)\n\nCPU times: user 132 ms, sys: 118 µs, total: 132 ms\nWall time: 171 ms\nThe node voltages in symbolic form are displayed below.\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C R_{1} R_{2} R_{3} V s + L R_{1} V s + R_{1} R_{2} V + R_{1} R_{3} V}{C L R_{1} R_{2} s^{2} + C L R_{2} R_{3} s^{2} + C R_{1} R_{2} R_{3} s + L R_{1} s + L R_{2} s + L R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{2} = \\frac{- C L R_{1} R_{2} V s^{2} - C L R_{2} R_{3} V s^{2} - L R_{2} V s - L R_{3} V s}{C L R_{1} R_{2} s^{2} + C L R_{2} R_{3} s^{2} + C R_{1} R_{2} R_{3} s + L R_{1} s + L R_{2} s + L R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{3} = \\frac{C R_{1} R_{2} R_{3} V s - L R_{3} V s}{C L R_{1} R_{2} s^{2} + C L R_{2} R_{3} s^{2} + C R_{1} R_{2} R_{3} s + L R_{1} s + L R_{2} s + L R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{V} = \\frac{- C L R_{1} V s^{2} - C L R_{3} V s^{2} - C R_{1} R_{2} V s - C R_{1} R_{3} V s - C R_{2} R_{3} V s - L V s - R_{2} V - R_{3} V}{C L R_{1} R_{2} s^{2} + C L R_{2} R_{3} s^{2} + C R_{1} R_{2} R_{3} s + L R_{1} s + L R_{2} s + L R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L} = \\frac{- C R_{1} R_{2} V s - C R_{2} R_{3} V s - R_{2} V - R_{3} V}{C L R_{1} R_{2} s^{2} + C L R_{2} R_{3} s^{2} + C R_{1} R_{2} R_{3} s + L R_{1} s + L R_{2} s + L R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\nThe function SymMNA.get_part_values is used to build a dictionary of component values from the netlist dataframe and the values are printed below.\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV = 2.0\nR1 = 3.0\nR2 = 7.0\nR3 = 11.0\nC = 0.5\nL = 1.0\nSubstitute numerical values in place of the symbolic reference designators and display the equations with numeric values.\nNE = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V} - 0.5 s v_{3} + v_{1} \\cdot \\left(0.5 s + 0.333333333333333\\right)\\)\\(0 = I_{L} - I_{V} + 0.142857142857143 v_{2} - 0.142857142857143 v_{3}\\)\\(0 = - 0.5 s v_{1} - 0.142857142857143 v_{2} + v_{3} \\cdot \\left(0.5 s + 0.233766233766234\\right)\\)\\(2.0 = v_{1} - v_{2}\\)\\(0 = - 1.0 I_{L} s + v_{2}\\)\nUse the solve function to obtain the expressions for the node voltages and unknown currents.\nU = solve(NE,X)\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{474.0 s + 216.0}{98.0 s^{2} + 273.0 s + 108.0}\\)\\(v_{2} = \\frac{- 196.0 s^{2} - 72.0 s}{98.0 s^{2} + 273.0 s + 108.0}\\)\\(v_{3} = \\frac{418.0 s}{98.0 s^{2} + 273.0 s + 108.0}\\)\\(I_{V} = \\frac{- 28.0 s^{2} - 266.0 s - 72.0}{98.0 s^{2} + 273.0 s + 108.0}\\)\\(I_{L} = \\frac{- 196.0 s - 72.0}{98.0 s^{2} + 273.0 s + 108.0}\\)\nThe expressions above contain the Laplace variable, \\(s=j\\omega\\).\nThe circuit’s node voltages and unknwon currents can be solved for at individual frequencies. In the code cell below, a frequency of 1 Hz is used to evaluate the equations at a particular frequency. The frequency in Hz must be converted to radians/s as shown below.\nfreq = 1 # Hz\nomega = 2*np.pi*freq\nprint(f'frequency = {omega:0.2f} radians/s')\n\nfrequency = 6.28 radians/s\nThe element values are inserted in to the newtork equatons and \\(j\\omega\\) is also substituded into the equations. Notice that \\(1j\\) is being used as the imaginary operator.\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j*omega})\nThe code below displays the equations with numeric values. Notice that Python and SymPy have generated a solution which use \\(i\\) as the imaginary operator.\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V} + v_{1} \\cdot \\left(0.333333333333333 + 3.14159265358979 i\\right) - 3.14159265358979 i v_{3}\\)\\(0 = I_{L} - I_{V} + 0.142857142857143 v_{2} - 0.142857142857143 v_{3}\\)\\(0 = - 3.14159265358979 i v_{1} - 0.142857142857143 v_{2} + v_{3} \\cdot \\left(0.233766233766234 + 3.14159265358979 i\\right)\\)\\(2.0 = v_{1} - v_{2}\\)\\(0 = - 6.28318530717959 i I_{L} + v_{2}\\)\nAgain using solve to obtain solutions for voltages and currents.\nU_w1 = solve(NE_w1,X)\nThe code cell below tabulates the results for the node voltages and unknown currents as magnitude and phase values. Six significant digits are displayed so that results can be compared to solutions obtained from LTSpice.\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.722388    -69.630838\nv2         1.875123   -158.828643\nv3         0.635373    -65.482650\nI_V        0.475375    146.246200\nI_L        0.298435    111.171357",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RLC Networks</span>"
    ]
  },
  {
    "objectID": "RLC_networks.html#sec-rlc_circuit_1",
    "href": "RLC_networks.html#sec-rlc_circuit_1",
    "title": "6  RLC Networks",
    "section": "",
    "text": "Figure 6.1: RLC circuit 1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RLC Networks</span>"
    ]
  },
  {
    "objectID": "RLC_networks.html#sec-rlc_circuit_2",
    "href": "RLC_networks.html#sec-rlc_circuit_2",
    "title": "6  RLC Networks",
    "section": "6.2 RLC Circuit 2",
    "text": "6.2 RLC Circuit 2\nThe circuit shown below is a more complex circuit containing dependent sources, which would make the circuit analysis a bit difficult to tackle manually with pencil and paper.\n\n\n\n\n\n\nFigure 6.2: RLC circuit 2\n\n\n\nThe netlist is loaded as a string and applied to the variable.\n\nnet_list = '''\nR2 4 3 2\nR1 0 6 5\nC 6 5 0.5\nL 1 2 3\nV1 4 1 1\nF 0 1 V2 2\nV2 4 5 0\nR3 0 1 3\nE 2 3 1 6 1\n'''\n\n# generate the MNA matrices. \nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\n# assemble the system of equations\nNE_sym = Eq(A*X,Z)\n\n# turn the free symbols into SymPy variables.\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n# display the network equations\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- I_{F} + I_{L} - I_{V1} + \\frac{v_{1}}{R_{3}} = 0\\)\\(I_{Ea} - I_{L} = 0\\)\\(- I_{Ea} + \\frac{v_{3}}{R_{2}} - \\frac{v_{4}}{R_{2}} = 0\\)\\(I_{V1} + I_{V2} - \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}} = 0\\)\\(C s v_{5} - C s v_{6} - I_{V2} = 0\\)\\(- C s v_{5} + v_{6} \\left(C s + \\frac{1}{R_{1}}\\right) = 0\\)\\(- v_{1} + v_{4} = V_{1}\\)\\(v_{4} - v_{5} = V_{2}\\)\\(- I_{L} L s + v_{1} - v_{2} = 0\\)\\(I_{F} - I_{V2} f = 0\\)\\(- ea v_{1} + ea v_{6} + v_{2} - v_{3} = 0\\)\n\n\nNotice that the symbole ea is being used as the gain for the VCVS componet \\(E\\) in Figure 6.2. This is because SymPy uses the symbol \\(e\\) for the Euler value.\nUs the solve function to obtain the expressions for the node voltages and unknown currents. The node voltages in symbolic form are displayed below.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C R_{3} V_{1} f s + C R_{3} V_{1} s + C R_{3} V_{2} f s - C R_{3} V_{2} s}{- C R_{1} s + C R_{3} f s - C R_{3} s - 1}\\)\\(v_{2} = \\frac{C L R_{1} V_{1} ea s^{2} - C L R_{1} V_{1} s^{2} - C L R_{1} V_{2} ea s^{2} - C L R_{3} V_{1} ea f s^{2} + C L R_{3} V_{1} ea s^{2} + C L R_{3} V_{2} ea f s^{2} - C L R_{3} V_{2} ea s^{2} + C L R_{3} V_{2} f s^{2} - C L R_{3} V_{2} s^{2} - C R_{2} R_{3} V_{1} f s + C R_{2} R_{3} V_{1} s + C R_{2} R_{3} V_{2} f s - C R_{2} R_{3} V_{2} s - L V_{1} s}{- C L R_{1} s^{2} + C L R_{3} f s^{2} - C L R_{3} s^{2} - C R_{1} R_{2} s + C R_{2} R_{3} f s - C R_{2} R_{3} s - L s - R_{2}}\\)\\(v_{3} = \\frac{- C L R_{1} V_{1} s^{2} + C L R_{3} V_{2} f s^{2} - C L R_{3} V_{2} s^{2} - C R_{1} R_{2} V_{1} ea s + C R_{1} R_{2} V_{2} ea s + C R_{2} R_{3} V_{1} ea f s - C R_{2} R_{3} V_{1} ea s - C R_{2} R_{3} V_{1} f s + C R_{2} R_{3} V_{1} s - C R_{2} R_{3} V_{2} ea f s + C R_{2} R_{3} V_{2} ea s + C R_{2} R_{3} V_{2} f s - C R_{2} R_{3} V_{2} s - L V_{1} s}{- C L R_{1} s^{2} + C L R_{3} f s^{2} - C L R_{3} s^{2} - C R_{1} R_{2} s + C R_{2} R_{3} f s - C R_{2} R_{3} s - L s - R_{2}}\\)\\(v_{4} = \\frac{- C R_{1} V_{1} s + C R_{3} V_{2} f s - C R_{3} V_{2} s - V_{1}}{- C R_{1} s + C R_{3} f s - C R_{3} s - 1}\\)\\(v_{5} = \\frac{- C R_{1} V_{1} s + C R_{1} V_{2} s - V_{1} + V_{2}}{- C R_{1} s + C R_{3} f s - C R_{3} s - 1}\\)\\(v_{6} = \\frac{- C R_{1} V_{1} s + C R_{1} V_{2} s}{- C R_{1} s + C R_{3} f s - C R_{3} s - 1}\\)\\(I_{V1} = \\frac{C L V_{1} s^{2} - C L V_{2} s^{2} - C R_{1} V_{1} ea s + C R_{1} V_{1} s + C R_{1} V_{2} ea s + C R_{2} V_{1} s - C R_{2} V_{2} s + C R_{3} V_{1} ea f s - C R_{3} V_{1} ea s - C R_{3} V_{1} f s + C R_{3} V_{1} s - C R_{3} V_{2} ea f s + C R_{3} V_{2} ea s + V_{1}}{- C L R_{1} s^{2} + C L R_{3} f s^{2} - C L R_{3} s^{2} - C R_{1} R_{2} s + C R_{2} R_{3} f s - C R_{2} R_{3} s - L s - R_{2}}\\)\\(I_{V2} = \\frac{- C V_{1} s + C V_{2} s}{- C R_{1} s + C R_{3} f s - C R_{3} s - 1}\\)\\(I_{L} = \\frac{- C R_{1} V_{1} ea s + C R_{1} V_{1} s + C R_{1} V_{2} ea s + C R_{3} V_{1} ea f s - C R_{3} V_{1} ea s - C R_{3} V_{1} f s + C R_{3} V_{1} s - C R_{3} V_{2} ea f s + C R_{3} V_{2} ea s + V_{1}}{- C L R_{1} s^{2} + C L R_{3} f s^{2} - C L R_{3} s^{2} - C R_{1} R_{2} s + C R_{2} R_{3} f s - C R_{2} R_{3} s - L s - R_{2}}\\)\\(I_{F} = \\frac{- C V_{1} f s + C V_{2} f s}{- C R_{1} s + C R_{3} f s - C R_{3} s - 1}\\)\\(I_{Ea} = \\frac{- C R_{1} V_{1} ea s + C R_{1} V_{1} s + C R_{1} V_{2} ea s + C R_{3} V_{1} ea f s - C R_{3} V_{1} ea s - C R_{3} V_{1} f s + C R_{3} V_{1} s - C R_{3} V_{2} ea f s + C R_{3} V_{2} ea s + V_{1}}{- C L R_{1} s^{2} + C L R_{3} f s^{2} - C L R_{3} s^{2} - C R_{1} R_{2} s + C R_{2} R_{3} f s - C R_{2} R_{3} s - L s - R_{2}}\\)\n\n\nNumerical valuses can be substituded into the equations.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# substitute numerical values\nNE = NE_sym.subs(element_values)\n\n# solve and display\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{3.0 s}{2.0 s + 2.0}\\)\\(v_{2} = \\frac{9.0 s^{2} + 12.0 s}{6.0 s^{2} + 10.0 s + 4.0}\\)\\(v_{3} = \\frac{15.0 s^{2} + 16.0 s}{6.0 s^{2} + 10.0 s + 4.0}\\)\\(v_{4} = \\frac{5.0 s + 2.0}{2.0 s + 2.0}\\)\\(v_{5} = \\frac{5.0 s + 2.0}{2.0 s + 2.0}\\)\\(v_{6} = \\frac{5.0 s}{2.0 s + 2.0}\\)\\(I_{V1} = \\frac{- 3.0 s^{2} - 2.0 s - 2.0}{6.0 s^{2} + 10.0 s + 4.0}\\)\\(I_{V2} = \\frac{s}{2.0 s + 2.0}\\)\\(I_{L} = - \\frac{1}{3.0 s^{2} + 5.0 s + 2.0}\\)\\(I_{F} = \\frac{s}{s + 1.0}\\)\\(I_{Ea} = - \\frac{1}{3.0 s^{2} + 5.0 s + 2.0}\\)\n\n\nThe circuit’s node voltages and unknwon currents can be solved for at individual frequencies. In the code cell below, a frequency of 1 Hz is used to evaluate the equations at a particular frequency.\n\nfreq = 1 # Hz\nomega = 2*np.pi*freq\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j*omega})\n\nU_w1 = solve(NE_w1,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.481356      9.043061\nv2         1.505890      3.118858\nv3         2.490273      5.464698\nv4         2.473924      5.400414\nv5         2.473924      5.400414\nv6         2.468926      9.043061\nI_V1       0.485540   -171.060180\nI_V2       0.493785      9.043061\nI_L        0.008292     15.099672\nI_F        0.987570      9.043061\nI_Ea       0.008292     15.099672",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RLC Networks</span>"
    ]
  },
  {
    "objectID": "RLC_networks.html#phasor-analysis",
    "href": "RLC_networks.html#phasor-analysis",
    "title": "6  RLC Networks",
    "section": "6.3 Phasor Analysis",
    "text": "6.3 Phasor Analysis\nIn this example the use of phasors is examined. Phasor analysis is a fundamental technique in electrical engineering used to simplify the steady-state analysis of Alternating Current (AC) circuits by converting time-varying sinusoidal voltage and current signals into complex numbers, known as phasors.\nA phasor represents the signal’s magnitude (amplitude) and its phase angle, effectively transforming the complex differential equations required for time-domain analysis into simple algebraic equations in the frequency domain. This algebraic simplification allows engineers to easily apply DC circuit analysis laws, like Ohm’s Law and Kirchhoff’s Laws, to AC components (resistors, inductors, and capacitors) by representing them with a complex quantity called impedance (\\(Z\\)). The origin of the phasor concept is attributed primarily to Charles Proteus Steinmetz, who, working at General Electric in the late 19th century, formalized the use of complex numbers to analyze AC systems, building upon the operational calculus work of Oliver Heaviside.\n\n\n\n\n\n\nFigure 6.3: impedance for element values\n\n\n\nThe functions polar2rec and rec2polar perform conversion between rectangular notation and magnitude and phase notation.\n\ndef polar2rec(mag, ang, units='deg'):\n    ''' polar to rectangular conversion\n        mag: float\n            magnitude of the time invarient sinusudial signal\n        ang: float\n            the angle of the time invarient sinusudial signal\n        units: string\n            if units is set to deg, and is in degrees not radians\n        returns: complex\n            rectangular corrdinates of voltage vector\n    '''\n    if units == 'deg':\n        ang = ang * np.pi / 180\n    return mag * np.exp(1j * ang)\n\ndef rec2polar(value):\n    '''rectangular to polar conversion\n    value: complex float\n    returns:\n        magnitude, phase (in degrees)\n    '''\n    return float(abs(value)), float(arg(value)*180/np.pi)\n\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values. The componet values are set to 1 for now. Later the phasor quantities will be substituted.\n\nnet_list = '''\nV1 1 0 1\nV2 0 3 1\nV3 5 0 1\nR1 2 1 1\nR2 4 2 1\nR3 3 2 1\nR4 0 4 1\nR5 5 4 1\n'''\n\nThe network equations are generated from the netlist and displayed below.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- I_{V2} - \\frac{v_{2}}{R_{3}} + \\frac{v_{3}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{5}} - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V3} - \\frac{v_{4}}{R_{5}} + \\frac{v_{5}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} = V_{2}\\)\\(v_{5} = V_{3}\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables. Then the equations are solved and the results are displayed.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n# The newtork equations can be solved symbolically. \nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{1} R_{2} R_{4} V_{2} - R_{1} R_{2} R_{5} V_{2} + R_{1} R_{3} R_{4} V_{3} - R_{1} R_{4} R_{5} V_{2} + R_{2} R_{3} R_{4} V_{1} + R_{2} R_{3} R_{5} V_{1} + R_{3} R_{4} R_{5} V_{1}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(v_{3} = - V_{2}\\)\\(v_{4} = \\frac{R_{1} R_{2} R_{4} V_{3} + R_{1} R_{3} R_{4} V_{3} - R_{1} R_{4} R_{5} V_{2} + R_{2} R_{3} R_{4} V_{3} + R_{3} R_{4} R_{5} V_{1}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(v_{5} = V_{3}\\)\\(I_{V1} = \\frac{- R_{2} R_{4} V_{1} - R_{2} R_{4} V_{2} - R_{2} R_{5} V_{1} - R_{2} R_{5} V_{2} - R_{3} R_{4} V_{1} + R_{3} R_{4} V_{3} - R_{3} R_{5} V_{1} - R_{4} R_{5} V_{1} - R_{4} R_{5} V_{2}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(I_{V2} = \\frac{- R_{1} R_{4} V_{2} - R_{1} R_{4} V_{3} - R_{1} R_{5} V_{2} - R_{2} R_{4} V_{1} - R_{2} R_{4} V_{2} - R_{2} R_{5} V_{1} - R_{2} R_{5} V_{2} - R_{4} R_{5} V_{1} - R_{4} R_{5} V_{2}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\\(I_{V3} = \\frac{- R_{1} R_{2} V_{3} - R_{1} R_{3} V_{3} - R_{1} R_{4} V_{2} - R_{1} R_{4} V_{3} - R_{2} R_{3} V_{3} + R_{3} R_{4} V_{1} - R_{3} R_{4} V_{3}}{R_{1} R_{2} R_{4} + R_{1} R_{2} R_{5} + R_{1} R_{3} R_{4} + R_{1} R_{3} R_{5} + R_{1} R_{4} R_{5} + R_{2} R_{3} R_{4} + R_{2} R_{3} R_{5} + R_{3} R_{4} R_{5}}\\)\n\n\nA dictionary is created for the element values and the numerical values are assigned.\n\nelement_values = SymMNA.get_part_values(network_df)\n\nelement_values[V1] = polar2rec(10, 0, units='deg')\nelement_values[V2] = polar2rec(10, 30, units='deg')\nelement_values[V3] = polar2rec(5, 0, units='deg')\n\nelement_values[R1] = 10\nelement_values[R2] = 4+4j\nelement_values[R3] = 5j\nelement_values[R4] = 6-8j\nelement_values[R5] = 5\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations for \\(\\omega=1\\).\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{10} - \\frac{v_{2}}{10}\\)\\(0 = - \\frac{v_{1}}{10} + v_{2} \\cdot \\left(\\frac{1}{10} - 0.2 i + 0.03125 \\cdot \\left(4.0 - 4.0 i\\right)\\right) + 0.2 i v_{3} - 0.03125 v_{4} \\cdot \\left(4.0 - 4.0 i\\right)\\)\\(0 = - I_{V2} + 0.2 i v_{2} - 0.2 i v_{3}\\)\\(0 = - 0.03125 v_{2} \\cdot \\left(4.0 - 4.0 i\\right) + v_{4} \\cdot \\left(\\frac{1}{5} + 0.03125 \\cdot \\left(4.0 - 4.0 i\\right) + 0.01 \\cdot \\left(6.0 + 8.0 i\\right)\\right) - \\frac{v_{5}}{5}\\)\\(0 = I_{V3} - \\frac{v_{4}}{5} + \\frac{v_{5}}{5}\\)\\(10.0 = v_{1}\\)\\(8.66025403784439 + 5.0 i = - v_{3}\\)\\(5.0 = v_{5}\\)\n\n\nSolve the network equations and display the results.\n\nU = solve(NE,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1         10.000000      0.000000\nv2          4.574219    124.771754\nv3         10.000000   -150.000000\nv4          3.594255     41.498814\nv5          5.000000      0.000000\nI_V1        1.315666    163.405921\nI_V2        2.128974    145.354766\nI_V3        0.663289    134.101376",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RLC Networks</span>"
    ]
  },
  {
    "objectID": "RLC_networks.html#summary",
    "href": "RLC_networks.html#summary",
    "title": "6  RLC Networks",
    "section": "6.4 Summary",
    "text": "6.4 Summary\nIn this chapter three RLC circuits were analyized using MNA with Python. The main points illustrated are:\n\nNetwork equations are easily generated and solutions can be found for almost any linear circuit.\nResults are the same as from the LTSpice simulations.\nThe use of phasors were explored in circuit 3.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>RLC Networks</span>"
    ]
  },
  {
    "objectID": "Transfer_function.html",
    "href": "Transfer_function.html",
    "title": "7  Transfer Function",
    "section": "",
    "text": "7.1 Summary\nA transfer function is a fundamental mathematical representation used in circuit design to characterize the relationship between a circuit’s output signal and its input signal. Specifically, it is defined as the ratio of the Laplace transform of the output (response) to the Laplace transform of the input (excitation), assuming all initial conditions are zero. This function, typically denoted as \\(H(s)\\) where \\(s\\) is the complex frequency variable equal to \\((j\\omega)\\), allows engineers to analyze and predict the circuit’s behavior across different frequencies. By examining the poles (roots of the denominator) and zeros (roots of the numerator) of the transfer function, one can determine crucial circuit properties such as gain, stability, frequency response (e.g., whether it acts as a low-pass or high-pass filter), and transient behavior, making it an indispensable tool for designing and optimizing filters, amplifiers, and control systems.\nThis notebook walks through the Python code used to find the transfer function of the circuit shown in Figure 7.1.\nThe circuit above is a 2nd order low pass filter from Stout (1976). The schematic of the circuit is shown with each node annotated. The filter shown is being used to illustrate the application of Python to obtain the transfer function, \\(\\frac {V_2} {V_1}\\).\nThis circuit has two complex poles and by proper choice of \\(R_1\\), \\(R_2\\), \\(C_1\\) and \\(C_2\\) the complex poles can be positioned to realize Bessel, Butterworth or Chebyshev filter characteristics. The component values shown in the schematic produce a low pass filter with a cut off frequency of 1000 Hz and a 3 dB Chebyshev response.\nThe Python MNA code supports the Op Amp component type designated with the letter ‘O’ and is shown on the send line of the netlist.\nThe following Python modules are used in this notebook.\nLoad the net list\nCall the symbolic modified nodal analysis function to generate the MNA matrices.\nAssemble and build the network equations.\nUse the SymPy function solve to deterermine the unknown node voltages and device currents.\nThe symbolic transfer function, \\(H_{sym}=\\frac {v_2}{v_1}\\).\nThe numerator and denominator of the transfer function can be obtained as follows:\nThe roots of the numerator can be obtained symbolically. Since the degree of the polynominal is a second order function of \\(s\\), SymPy can solve for the roots and obtain a solution very quickly. The roots expressed in symbolic form are sometimes not very useful, but are easily obtained, something that would be almost impossible to do by hand with pencil and paper for higher order polynominals.\nThe characteristic equation of a transfer function, \\(H(s) = \\frac{N(s)}{D(s)}\\), is the polynomial equation obtained by setting the denominator polynomial, \\(D(s)\\), equal to zero: \\(D(s) = 0\\). The roots of this equation are the poles of the transfer function, which are critical for determining the system’s fundamental dynamic behavior and its stability. In circuit design, for linear time-invariant (LTI) systems, the location of these roots in the complex \\(s\\)-plane dictates whether the system is stable (all poles have negative real parts, lying in the left-half plane), marginally stable (non-repeated poles on the \\(j\\omega\\)-axis), or unstable (at least one pole in the right-half plane or repeated poles on the \\(j\\omega\\)-axis). The characteristic equation, therefore, directly governs the natural or transient response of the circuit without considering the specific input signal, revealing essential properties like damping ratio, natural frequency, and time constants.\nThe roots of the denominator can be obtained symbolically.\nConstruct a dictionary of element values.\nPut the component values into the equations.\nDisplay the network equations with numerical component values.\nSolve for voltages and currents and display the results.\nPlot the frequency response of the transfer function\nThe magnitude response and phase response together form the frequency response of a transfer function, \\(H(s)\\), which is essential for understanding how a circuit processes different sinusoidal input signals. The frequency response is obtained by substituting \\(s = j\\omega\\) into the transfer function, yielding the complex function \\(H(j\\omega)\\). The magnitude response, \\(|H(j\\omega)|\\), represents the gain or attenuation of the circuit at a specific angular frequency \\(\\omega\\). It shows how the amplitude of the output signal changes relative to the input signal’s amplitude as the input frequency varies. The phase response, \\(\\angle H(j\\omega)\\), represents the phase shift (or delay) introduced by the circuit between the output and input signals at that same frequency \\(\\omega\\). These two components are typically plotted separately against frequency on a Bode plot and are crucial for applications like filter design, where specific gain and phase characteristics are required over a range of frequencies.\nPlot the results.\nThe poles and zeros of the transfer function can easly be obtained with the following code:\nThe pole-zero plot, also known as the s-plane plot, is a graphical representation of a transfer function, \\(H(s)\\), where the locations of its poles and zeros are marked on the complex \\(s\\)-plane. The zeros (roots of the numerator \\(N(s)\\)) are traditionally marked with a circle (\\(\\circ\\)), and the poles (roots of the denominator \\(D(s)\\)) are marked with a cross (\\(\\times\\)). The horizontal axis of the \\(s\\)-plane represents the real part (\\(\\sigma\\)) which relates to the damping and transient response (decay or growth), while the vertical axis represents the imaginary part (\\(j\\omega\\)) which relates to the oscillation frequency and sinusoidal steady-state response. This plot is a crucial visual aid because the relative positions of the poles and zeros immediately reveal key insights into the circuit’s characteristics, such as its stability, natural frequencies, and how it will selectively amplify or attenuate signals at different frequencies, which is fundamental in filter design.\nThe proximity of a poles to the imaginary axis (\\(j\\omega\\) axis) in the pole-zero plot has a profound impact on the frequency response of the circuit. The closer a pole is to the \\(j\\omega\\) axis, the greater its influence on the magnitude of the transfer function \\(|H(j\\omega)|\\) for frequencies near the pole’s imaginary part. Specifically, a pole close to the axis corresponds to a higher Q-factor (quality factor), resulting in a sharp peak or resonance in the magnitude response curve at the pole’s natural frequency, \\(\\omega_d\\) (which is the imaginary part of the pole). This means the circuit will selectively amplify signals at that specific frequency. Conversely, a pole located farther to the left (more negative real part \\(\\sigma\\)) corresponds to a highly damped system, resulting in a much broader and flatter frequency response peak, or potentially no noticeable peak at all, as the system’s energy quickly dissipates.\nThe poles and zeros of the preamp transfer function are plotted.\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\nThe impulse response, \\(h(t)\\), and the step response, \\(r(t)\\), are two fundamental time-domain characteristics of a circuit defined by its transfer function, \\(H(s)\\). The impulse response is the circuit’s output when the input is an ideal Dirac delta function, \\(\\delta(t)\\), which is useful because \\(h(t)\\) is the inverse Laplace transform of the transfer function itself: \\(h(t) = \\mathcal{L}^{-1}\\{H(s)\\}\\). It essentially reveals the natural, unforced behavior of the system. In contrast, the step response is the output when the input is a unit step function, \\(u(t)\\) (a signal that jumps from zero to one at \\(t=0\\)), and it is related to the impulse response by integration: \\(r(t) = \\int_0^t h(\\tau) d\\tau\\). Analyzing the step response is especially practical in circuit testing as it allows engineers to easily assess key performance metrics like rise time, settling time, overshoot, and steady-state error, all of which are crucial for evaluating the speed and quality of a circuit’s transient behavior.\nRise time and settling time are key metrics derived from the step response that quantify the speed and convergence of a circuit’s transient behavior.\nBoth measurements are essential for evaluating system performance, where rise time reflects the initial speed, and settling time reflects the overall stability and convergence of the output.\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe transfer function for a 2nd order low pass filter was obtained. Key points from this analysis:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Transfer Function</span>"
    ]
  },
  {
    "objectID": "Transfer_function.html#summary",
    "href": "Transfer_function.html#summary",
    "title": "7  Transfer Function",
    "section": "",
    "text": "Frequency response plots can easily be make by use of the Python libraries.\nThe poles and zeros of the transfer function can be plotted\nThe impulse and step response are easily obtained and plotted\n\n\n\n\n\nStout, D. 1976. Handbook of Operational Amplifier Circuit Design. McGraw-Hill.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Transfer Function</span>"
    ]
  },
  {
    "objectID": "Transient_analysis.html",
    "href": "Transient_analysis.html",
    "title": "8  Transient Analysis",
    "section": "",
    "text": "8.1 Circuit 1\nTransient analysis in electrical circuit analysis is the study of a circuit’s behavior during the time it transitions from one steady-state condition to another, typically following a sudden change, such as the opening or closing of a switch or an abrupt change in the input signal. This period, known as the transient period, is characterized by time-varying voltages and currents, especially in circuits containing energy-storage elements like capacitors and inductors, whose voltage and current, respectively, cannot change instantaneously.\nThe circuit in Figure 8.1 is an Chebyshev low pass filter, with a 1 MHz cut off frequency, \\(50\\Omega\\) termination and 3 dB of ripple in the pass band. Three dB of ripple in the pass band was designed in so that the transient response would have some ringing. The filter design tool from Marki Microwave (2025) was used to design the filter.\nLoad the following Python modules.\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent source, V1, is set to a value of one.\nnet_list = '''\nV1 1 0 1\nR1 3 1 50\nR2 2 0 50\nC1 3 0 10.66e-9\nL1 3 2 5.664e-6\nC2 2 0 10.66e-9\n'''\nGenerate the network equations.\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nGenerate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L1} + v_{2} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) = 0\\)\\(I_{L1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s - v_{2} + v_{3} = 0\\)\nAs shown above MNA generated many equations and these would be difficult to solve by hand. The equations are displade in matrix notation below.\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\nBuilt a dictionary of element values.\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n# built a dictionary of element values.\nelement_values = SymMNA.get_part_values(network_df)\nSince the circuit is not too large, a symbolic solution can be easily obtained and displayed.\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{2} V_{1}}{C_{1} C_{2} L_{1} R_{1} R_{2} s^{3} + C_{1} L_{1} R_{1} s^{2} + C_{1} R_{1} R_{2} s + C_{2} L_{1} R_{2} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C_{2} L_{1} R_{2} V_{1} s^{2} + L_{1} V_{1} s + R_{2} V_{1}}{C_{1} C_{2} L_{1} R_{1} R_{2} s^{3} + C_{1} L_{1} R_{1} s^{2} + C_{1} R_{1} R_{2} s + C_{2} L_{1} R_{2} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} L_{1} R_{2} V_{1} s^{3} - C_{1} L_{1} V_{1} s^{2} - C_{1} R_{2} V_{1} s - C_{2} R_{2} V_{1} s - V_{1}}{C_{1} C_{2} L_{1} R_{1} R_{2} s^{3} + C_{1} L_{1} R_{1} s^{2} + C_{1} R_{1} R_{2} s + C_{2} L_{1} R_{2} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{C_{2} R_{2} V_{1} s + V_{1}}{C_{1} C_{2} L_{1} R_{1} R_{2} s^{3} + C_{1} L_{1} R_{1} s^{2} + C_{1} R_{1} R_{2} s + C_{2} L_{1} R_{2} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + R_{1} + R_{2}}\\)\nAfter substituting the numeric component values for the elements, a numerical solution for the note voltages can be obtained.\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nThe transfer function \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is obtained below and plotted.\nH = U[v2]/U[v1]\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nx = np.logspace(4, 7, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a,b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\nThe SciPy functions square and lsim can be used to create an input squarewave and simulate the output response as shown below.\nsys_tf = signal.TransferFunction(a,b)\n\n# define the time interval and create a square wave\nt = np.linspace(0, 20e-6, 1000, endpoint=False)\nref_sqr_signal = signal.square(2*np.pi*1e5*t, duty=0.5)\n\n# call lsim to generate the response signal\nref_t_step, ref_y_step, ref_x_step = signal.lsim(sys_tf, U=ref_sqr_signal, T=t)\n\nplt.plot(ref_t_step*1e6, ref_sqr_signal, 'r', alpha = 1.0, linewidth=1, label='$v_1(t)$')\nplt.plot(ref_t_step*1e6, ref_y_step,'b', linewidth = 1.0, label='$v_2(t)$')\nplt.title('Square Wave Response')\nplt.ylabel('volts')\nplt.xlabel('time, usec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\nadd comments …",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Transient Analysis</span>"
    ]
  },
  {
    "objectID": "Transient_analysis.html#circuit-2",
    "href": "Transient_analysis.html#circuit-2",
    "title": "8  Transient Analysis",
    "section": "8.2 Circuit 2",
    "text": "8.2 Circuit 2\n\n\n\n\n\n\nFigure 8.2: Circuit schematic\n\n\n\nThe circuit above is a filter designed to explore transient analysis of a circuit using Python. The dependent source, V1, will be a time varying signal described below.\nThe circuit in Figure 8.2 is an elliptic low pass filter with a 1 Hz cut off and 3 dB of ripple in the pass band and 40 dB of attenuation in the stop band. Three dB of ripple in the pass band was designed in so that the transient response would have some ringing. The filter design tool linked here was used to design the filter.\n\n8.2.1 Circuit analysis\nThe circuit analysis follows the steps listed below.\n\nDraw circuit in LTSpice, export netlist\nGenerate network equations\nSymbolic solution\nAC sweep and plot the frequency response at the output\nTransient analysis\n\nGenerate input signal for transient analysis\nMostly following the procedure outlined here\ndisplay the results\n\n\nTransient analysis is somewhat more involved than the other types of circuit analysis, primarily because SymPy’s inverse Laplace transform is not very robust and can’t handle complicated expressions. The output equation needs to be simplified by writing some code to put the equation into forms that SymPy can deal with.\nLoad the following Python modules.\n\n\n8.2.2 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent source, V1, is set to a value of one.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1\nR2 2 0 1\nL1 3 4 0.4925\nL2 5 0 0.05081\nC2 4 5 0.09876\nL3 4 2 0.4925\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L3} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(C_{2} s v_{4} - C_{2} s v_{5} - I_{L1} + I_{L3} = 0\\)\\(- C_{2} s v_{4} + C_{2} s v_{5} + I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{3} - v_{4} = 0\\)\\(- I_{L2} L_{2} s + v_{5} = 0\\)\\(- I_{L3} L_{3} s - v_{2} + v_{4} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand. The equations are displade in matrix notation below.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\\\- I_{L3} + \\frac{v_{2}}{R_{2}}\\\\I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}}\\\\C_{2} s v_{4} - C_{2} s v_{5} - I_{L1} + I_{L3}\\\\- C_{2} s v_{4} + C_{2} s v_{5} + I_{L2}\\\\v_{1}\\\\- I_{L1} L_{1} s + v_{3} - v_{4}\\\\- I_{L2} L_{2} s + v_{5}\\\\- I_{L3} L_{3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{1}, \\  I_{L2}, \\  I_{L3}, \\  v_{4}, \\  v_{1}, \\  V_{1}, \\  I_{V1}, \\  I_{L1}, \\  v_{5}, \\  L_{2}, \\  R_{1}, \\  s, \\  v_{2}, \\  L_{3}, \\  C_{2}, \\  R_{2}, \\  v_{3}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{2} : 0.09876, \\  L_{1} : 0.4925, \\  L_{2} : 0.05081, \\  L_{3} : 0.4925, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\n\n8.2.3 Symbolic solution\nSince the circuit is not too large, a symbolic solution can be easily obtained.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} L_{2} R_{2} V_{1} s^{2} + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C_{2} L_{1} L_{2} V_{1} s^{3} + C_{2} L_{1} L_{3} V_{1} s^{3} + C_{2} L_{1} R_{2} V_{1} s^{2} + C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2} + L_{1} V_{1} s + L_{3} V_{1} s + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{4} = \\frac{C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2} + L_{3} V_{1} s + R_{2} V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(v_{5} = \\frac{C_{2} L_{2} L_{3} V_{1} s^{3} + C_{2} L_{2} R_{2} V_{1} s^{2}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C_{2} L_{2} V_{1} s^{2} - C_{2} L_{3} V_{1} s^{2} - C_{2} R_{2} V_{1} s - V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{C_{2} L_{2} V_{1} s^{2} + C_{2} L_{3} V_{1} s^{2} + C_{2} R_{2} V_{1} s + V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L2} = \\frac{C_{2} L_{3} V_{1} s^{2} + C_{2} R_{2} V_{1} s}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\\(I_{L3} = \\frac{C_{2} L_{2} V_{1} s^{2} + V_{1}}{C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{1} R_{2} s^{2} + C_{2} L_{2} L_{3} s^{3} + C_{2} L_{2} R_{1} s^{2} + C_{2} L_{2} R_{2} s^{2} + C_{2} L_{3} R_{1} s^{2} + C_{2} R_{1} R_{2} s + L_{1} s + L_{3} s + R_{1} + R_{2}}\\)\n\n\n\n\n8.2.4 AC Sweep\nAfter substituting the numeric component values for the elements, a numerical solution for the note voltages can be obtained.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\\\- I_{L3} + 1.0 v_{2}\\\\I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\\\- I_{L1} + I_{L3} + 0.09876 s v_{4} - 0.09876 s v_{5}\\\\I_{L2} - 0.09876 s v_{4} + 0.09876 s v_{5}\\\\v_{1}\\\\- 0.4925 I_{L1} s + v_{3} - v_{4}\\\\- 0.05081 I_{L2} s + v_{5}\\\\- 0.4925 I_{L3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU_ac = solve(NE,X)\n\n\n\n8.2.5 Plot the frequency response at node 2\n\nH = U_ac[v2]\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\nx = np.logspace(-1, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n8.2.6 Low pass filter impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(system,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(system,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe results obtained from SciPy’s step2 function can be compared to the transient response results obtained below.\n\n\n8.2.7 Transient Analysis\nThe input signal for the filter circuit is defined by using SymPy’s Heaveside function. The signal has a positive step at t=0, followed by a return to zero amplitude at t=5.\nDeclare SymPy symbols needed during the analysis.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nV1_t = 1*Heaviside(t)*(1-Heaviside(t-5))\nV1_t\n\n\\(\\displaystyle 1 - \\theta\\left(t - 5\\right)\\)\n\n\nUse the lambdify function to convert the input signal to a function for plotting.\n\nfunc_V1_t = lambdify(t, V1_t) \n\nThe time domain description of the input signal is comvertered to the frequency domain with SymPy’s Laplace transform function.\n\nV1_s = laplace_transform(V1_t, t, s, noconds=True)\nV1_s\n\n\\(\\displaystyle \\frac{1}{s} - \\frac{e^{- 5 s}}{s}\\)\n\n\nPut the component values into the network equations and set V1 equal to the Laplace of the input signal.\n\nelement_values[V1] = V1_s\nNE_trans = NE_sym.subs(element_values)\nNE_trans\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\\\- I_{L3} + 1.0 v_{2}\\\\I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\\\- I_{L1} + I_{L3} + 0.09876 s v_{4} - 0.09876 s v_{5}\\\\I_{L2} - 0.09876 s v_{4} + 0.09876 s v_{5}\\\\v_{1}\\\\- 0.4925 I_{L1} s + v_{3} - v_{4}\\\\- 0.05081 I_{L2} s + v_{5}\\\\- 0.4925 I_{L3} s - v_{2} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s} - \\frac{e^{- 5 s}}{s}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the newtork equations for the transient input and display the results.\n\nU_trans = solve(NE_trans,X)\n\ntemp = ''\nfor i in U_trans.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_trans[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s} - \\frac{e^{- 5.0 s}}{s}\\)\\(v_{2} = \\frac{1254498900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{1254498900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(v_{3} = \\frac{7224395229.0 s^{3} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{7224395229.0 s^{3}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{246250000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{246250000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(v_{4} = \\frac{12544989.0 s^{2} e^{5.0 s}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} - \\frac{12544989.0 s^{2}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} + \\frac{2500000000.0 e^{5.0 s}}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}} - \\frac{2500000000.0}{146688228.0 s^{3} e^{5.0 s} + 246900000.0 s^{2} e^{5.0 s} + 5000000000.0 s e^{5.0 s}}\\)\\(v_{5} = \\frac{12544989.0 s e^{5.0 s}}{146688228.0 s^{2} e^{5.0 s} + 246900000.0 s e^{5.0 s} + 5000000000.0 e^{5.0 s}} - \\frac{12544989.0 s}{146688228.0 s^{2} e^{5.0 s} + 246900000.0 s e^{5.0 s} + 5000000000.0 e^{5.0 s}}\\)\\(I_{V1} = - \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{24690000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{24690000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(I_{L1} = \\frac{13414323900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{13414323900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{24690000000.0 s e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{24690000000.0 s}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\\(I_{L2} = \\frac{61725000.0 e^{5.0 s}}{36672057.0 s^{2} e^{5.0 s} + 61725000.0 s e^{5.0 s} + 1250000000.0 e^{5.0 s}} - \\frac{61725000.0}{36672057.0 s^{2} e^{5.0 s} + 61725000.0 s e^{5.0 s} + 1250000000.0 e^{5.0 s}}\\)\\(I_{L3} = \\frac{1254498900.0 s^{2} e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{1254498900.0 s^{2}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} + \\frac{250000000000.0 e^{5.0 s}}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}} - \\frac{250000000000.0}{7224395229.0 s^{4} e^{5.0 s} + 26828647800.0 s^{3} e^{5.0 s} + 270940000000.0 s^{2} e^{5.0 s} + 500000000000.0 s e^{5.0 s}}\\)\n\n\nThe equations for the solution are complex and long, but are easy to obtain and display.\nThe voltage on node 2 is the output of the filter. The expression is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together().\n\nH = U_trans[v2].nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{100 \\cdot \\left(12544989 s^{2} e^{5 s} - 12544989 s^{2} + 2500000000 e^{5 s} - 2500000000\\right) e^{- 5 s}}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}\\)\n\n\nAll the time dealy terms are in the numerator.\nExtract the numerator and denominator and display.\n\nn, d = fraction(H)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle 1254498900 s^{2} e^{5 s} - 1254498900 s^{2} + 250000000000 e^{5 s} - 250000000000\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right) e^{5 s}\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ - \\frac{250000000000 e^{- 5 s}}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}, \\  - \\frac{1254498900 s e^{- 5 s}}{7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000}, \\  \\frac{250000000000}{s \\left(7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000\\right)}, \\  \\frac{1254498900 s}{7224395229 s^{3} + 26828647800 s^{2} + 270940000000 s + 500000000000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nThe time delay operator \\(e^{-ts}\\) is removed from the xpression and the value of the time delay is saved in a list.\nuse the SciPy residue function to get the partial-fraction expansion residues and poles\nbuild the partial expansion terms and find the inverse Laplace of each one and save\n\n\n\ntime_delay = []\ndelay = []\nN = []\n\nfor p1 in terms:\n    # look for and remove the time delay\n    if len(p1.find(exp)) == 1:\n        delay = p1.find(exp).pop()\n        time_delay.append(list(delay.atoms())[0])\n        ans = p1/p1.find(exp).pop()\n    else:\n        ans = p1\n        time_delay.append(0)\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(ans)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n    \n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i])) #.nsimplify()\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\n31 Aug 2025: fixed loop index in 1st for loop, was i now p1.\nThe time delays associated with each term are:\n\ntime_delay\n\n\\(\\displaystyle \\left[ -5, \\  -5, \\  0, \\  0\\right]\\)\n\n\nThe time domain version of each of the terms is displayed below.\n\nN\n\n\\(\\displaystyle \\left[ 1.0 \\left(\\left(0.0868202525095611 - 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(\\left(0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561563 - 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} - 0.5 + 0.489865675268769 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(-0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} - \\left(0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(- \\left(0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(-0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 0.0101343247312312 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(-0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} - \\left(0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(- \\left(0.0868202525095611 + 0.00506716236561563 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(-0.00506716236561563 + 0.0868202525095611 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 0.5 - 0.489865675268769 e^{- 2.03045685279188 t}, \\  1.0 \\left(\\left(0.0139856047826648 - 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561562 + 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} + 1.0 \\left(\\left(0.0139856047826648 + 0.00506716236561562 i\\right) \\sin{\\left(5.77733847617481 t \\right)} + \\left(0.00506716236561562 - 0.0139856047826648 i\\right) \\cos{\\left(5.77733847617481 t \\right)}\\right) e^{- 0.841580825422473 t} - 0.0101343247312312 e^{- 2.03045685279188 t}\\right]\\)\n\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\n\nout0 = lambdify(t, N[0])\nout1 = lambdify(t, N[1])\nout2 = lambdify(t, N[2])\nout3 = lambdify(t, N[3])\n\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 10, 2000, endpoint=True)\n\nout0a = out0(x)\nout1a = out1(x)\nout2a = out2(x)\nout3a = out3(x)\n\nThe arrays, out2a and out3a, do not have any delay so they can be summed and used to create the final array for plotting.\n\nout = out2a + out3a\n\nThe arrays, out0a and out1a, have a delay associated with them, so and offset in the time is included by shifting right by the corrrect amount.\n\noffset = 1000\nout[offset:] = out[offset:] + (out0a[0:-offset] + out1a[0:-offset])\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(out),label='v2(t)')\nplt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n8.2.8 Summary\nThe transient response as seen with a square wave inout was explored.\nIn circuit example 2, the inverse Laplace transform of complicated expressions requires that they be reduced to a set of simple terms by particial fraction expansion.\n\n\n\n\nMarki Microwave. 2025. “LC Filter Design Tool.” Marki Microwave. 2025. https://markimicrowave.com/technical-resources/tools/lc-filter-design-tool/.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Transient Analysis</span>"
    ]
  },
  {
    "objectID": "Mutual_inductance.html",
    "href": "Mutual_inductance.html",
    "title": "9  Mutual Inductance",
    "section": "",
    "text": "9.1 Coupling Coefficient\nMutual inductance is an electromagnetic phenomenon that quantifies the degree to which a time varying electric current in one coil induces a voltage in another coil through the interaction of their magnetic fields. This effect, often termed mutual induction, arises because the changing current in the first coil generates a magnetic flux, some fraction of which links with the turns of the second coil. The magnitude of mutual inductance depends entirely on the geometric arrangement of the two coils, including their relative orientation, distance, size, number of turns, and the magnetic permeability of the medium between them. It is the fundamental operating principle behind transformers and various other coupled circuits used for intentional energy transfer or signal coupling. The SI unit is the Henry (H).\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe Dot Convention is a graphical method used to indicate on electrical schematics to indicate the polarity of the voltage induced by mutual inductance when writing Kirchhoff’s Voltage Law (KVL) equations. The convention uses a small dot placed at one terminal of each coupled coil. The placement of the dot indicates the relative direction of the windings around the core. If a current \\(i_1\\) enters the dotted terminal of one coil, it induces a voltage in the second coil \\(v_2\\) that is positive at the dotted terminal of the second coil.\nThe coupling coefficient, \\(K\\), is a dimensionless value between 0 and 1 that quantifies the fraction of magnetic flux from one winding that links the other and is typically measured indirectly through inductance measurements. The most common and accurate method involves using an LCR meter to measure two specific inductance values on a winding (e.g., the primary, \\(L_p\\)): the open-circuit inductance (\\(L_{open}\\)), which is the self-inductance of the primary winding with the secondary winding open-circuited, and the short-circuit inductance (\\(L_{short}\\)), which is the inductance measured across the primary when the secondary winding is short-circuited. The short-circuit inductance represents the leakage inductance (\\(L_{leak}\\)) seen from the primary side. The coupling coefficient is then calculated using the formula: \\(k = \\sqrt{1 - \\frac{L_{short}}{L_{open}}}\\). This technique leverages the fact that perfect coupling (\\(k=1\\)) would result in zero leakage and therefore zero short-circuit inductance, whereas poor coupling (\\(k \\ll 1\\)) results in \\(L_{short}\\) approaching \\(L_{open}\\).\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\nThe following models are used in the chapter.\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\nThe functions polar2rec and rec2polar perform conversion between rectangular notation and magnitude and phase notation.\ndef polar2rec(mag, ang, units='deg'):\n    ''' polar to rectangular conversion\n        mag: float\n            magnitude of the time invarient sinusudial signal\n        ang: float\n            the angle of the time invarient sinusudial signal\n        units: string\n            if units is set to deg, and is in degrees not radians\n        returns: complex\n            rectangular corrdinates of voltage vector\n    '''\n    if units == 'deg':\n        ang = ang * np.pi / 180\n    return mag * np.exp(1j * ang)\n\ndef rec2polar(value):\n    '''rectangular to polar conversion\n    value: complex float\n    returns:\n        magnitude, phase (in degrees)\n    '''\n    return float(abs(value)), float(arg(value)*180/np.pi)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutual Inductance</span>"
    ]
  },
  {
    "objectID": "Mutual_inductance.html#test-circuits",
    "href": "Mutual_inductance.html#test-circuits",
    "title": "9  Mutual Inductance",
    "section": "9.2 Test Circuits",
    "text": "9.2 Test Circuits\nAdd circuits to illustrate the concepts above.\n\nbasic circuit to illustrate calculation of \\(M\\) from \\(K\\) and measured values\ntransformer circuit where turns ratio is specified (\\(N1\\) and \\(N2\\) or \\(1:2\\))",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutual Inductance</span>"
    ]
  },
  {
    "objectID": "Mutual_inductance.html#example-circuit-1",
    "href": "Mutual_inductance.html#example-circuit-1",
    "title": "9  Mutual Inductance",
    "section": "9.3 Example Circuit 1",
    "text": "9.3 Example Circuit 1\nThe circuit shown in Figure 9.1 …\nIn this example mutual inductance is examined.\n\n\n\n\n\n\nFigure 9.1: Schematic for mutual inductance\n\n\n\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values. The componet values are set to 1 for now. Later the phasor quantities will be substituted.\n\nnet_list = '''\nV1 1 0 1\nR1 3 1 1\nR2 2 0 1\nL1 3 0 1\nL2 2 0 1\nR3 3 0 1\nK L1 L2 1\n'''\n\nThe network equations are generated from the netlist and displayed below.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L2} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{L1} + v_{3} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s - I_{L2} M s + v_{3} = 0\\)\\(- I_{L1} M s - I_{L2} L_{2} s + v_{2} = 0\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables. Then the equations are solved and the results are displayed.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n# The newtork equations can be solved symbolically. \nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{M R_{2} R_{3} V_{1} s}{L_{1} L_{2} R_{1} s^{2} + L_{1} L_{2} R_{3} s^{2} + L_{1} R_{1} R_{2} s + L_{1} R_{2} R_{3} s + L_{2} R_{1} R_{3} s - M^{2} R_{1} s^{2} - M^{2} R_{3} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{3} = \\frac{L_{1} L_{2} R_{3} V_{1} s^{2} + L_{1} R_{2} R_{3} V_{1} s - M^{2} R_{3} V_{1} s^{2}}{L_{1} L_{2} R_{1} s^{2} + L_{1} L_{2} R_{3} s^{2} + L_{1} R_{1} R_{2} s + L_{1} R_{2} R_{3} s + L_{2} R_{1} R_{3} s - M^{2} R_{1} s^{2} - M^{2} R_{3} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{V1} = \\frac{- L_{1} L_{2} V_{1} s^{2} - L_{1} R_{2} V_{1} s - L_{2} R_{3} V_{1} s + M^{2} V_{1} s^{2} - R_{2} R_{3} V_{1}}{L_{1} L_{2} R_{1} s^{2} + L_{1} L_{2} R_{3} s^{2} + L_{1} R_{1} R_{2} s + L_{1} R_{2} R_{3} s + L_{2} R_{1} R_{3} s - M^{2} R_{1} s^{2} - M^{2} R_{3} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L1} = \\frac{L_{2} R_{3} V_{1} s + R_{2} R_{3} V_{1}}{L_{1} L_{2} R_{1} s^{2} + L_{1} L_{2} R_{3} s^{2} + L_{1} R_{1} R_{2} s + L_{1} R_{2} R_{3} s + L_{2} R_{1} R_{3} s - M^{2} R_{1} s^{2} - M^{2} R_{3} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L2} = - \\frac{M R_{3} V_{1} s}{L_{1} L_{2} R_{1} s^{2} + L_{1} L_{2} R_{3} s^{2} + L_{1} R_{1} R_{2} s + L_{1} R_{2} R_{3} s + L_{2} R_{1} R_{3} s - M^{2} R_{1} s^{2} - M^{2} R_{3} s^{2} + R_{1} R_{2} R_{3}}\\)\n\n\nSince \\(L1\\) and \\(L2\\) have been declared as being linked magnetically by the SPICE statement, K L1 L2 1, the mutual coupling is accounted for by the variable \\(M\\) which must be calculated as shown below.\n\n# a dictionary is created for the element values and the numerical values are assigned.\nelement_values = SymMNA.get_part_values(network_df)\n\nelement_values[V1] = polar2rec(10, 0, units='deg')\n\nelement_values[R1] = 10\nelement_values[R2] = 4+4j\nelement_values[R3] = 6-8j\n\n\n9.3.1 Mutual inductance\nIn Figure 9.1, the all values shown in the schematic have been entered as “1”, so the values used in the calculations are now assigned. In the netlist, K1 L1 L2 1 specifies that L1 and L2 are connected by a magnetic circuit. If \\(K\\) was specified we would calculate the value of \\(M\\).\nIn this example, let’s assume the inductance is across \\(L_1\\) is measured when \\(L_2\\) is shorted and open; and the inductance of \\(L_2\\) is measured when \\(L1\\) is open. The measured values are recorded below and the transformer coupling coefficient, \\(K_{meas}\\) is calculated from the measurments.\n\nL1_open = 3\nL1_short = 2\nL2_open = 2\nK_meas = sqrt(1-L1_short/L1_open)\nprint(f'K_meas={K_meas:0.3f}')\n\nK_meas=0.577\n\n\nThe measured inductance values and the calculated value for \\(K\\) is inserted into the Python dictionary which holds the numeric element values.\n\nelement_values[L1] = L1_open\nelement_values[L2] = L2_open\n\nBelow, \\(M\\) is calculated and added to the element value dictionary.\n\nK = symbols('K')\nelement_values[K] = K_meas\n# calculate the coupling constant from the mutual inductance\nelement_values[M] = element_values[K]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M]))\n\nmutual inductance, M1 = 1.414213562\n\n\nDisplay the equations for \\(\\omega=1\\).\n\nfreq = 1 # Hz\nomega = 2*np.pi*freq\n\n\nNE = NE_sym.subs(element_values)\nNE = NE.subs({s:1j*omega})\n\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{10} - \\frac{v_{3}}{10}\\)\\(0 = I_{L2} + 0.03125 v_{2} \\cdot \\left(4.0 - 4.0 i\\right)\\)\\(0 = I_{L1} - \\frac{v_{1}}{10} + v_{3} \\cdot \\left(\\frac{1}{10} + 0.01 \\cdot \\left(6.0 + 8.0 i\\right)\\right)\\)\\(10.0 = v_{1}\\)\\(0 = - 18.8495559215388 i I_{L1} - 8.88576587631673 i I_{L2} + v_{3}\\)\\(0 = - 8.88576587631673 i I_{L1} - 12.5663706143592 i I_{L2} + v_{2}\\)\n\n\nSolve the network equations and display the results.\n\nU = solve(NE,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1         10.000000      0.000000\nv2          1.237956    -30.793053\nv3          6.038688     -3.702067\nI_V1        0.399300   -174.396256\nI_L1        0.419727    -89.367478\nI_L2        0.218842    104.206947",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutual Inductance</span>"
    ]
  },
  {
    "objectID": "Mutual_inductance.html#example-circuit-2",
    "href": "Mutual_inductance.html#example-circuit-2",
    "title": "9  Mutual Inductance",
    "section": "9.4 Example Circuit 2",
    "text": "9.4 Example Circuit 2\nThe circuit shown in …",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutual Inductance</span>"
    ]
  },
  {
    "objectID": "Mutual_inductance.html#summary",
    "href": "Mutual_inductance.html#summary",
    "title": "9  Mutual Inductance",
    "section": "9.5 Summary",
    "text": "9.5 Summary\nComments …",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutual Inductance</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html",
    "href": "Initial_conditions.html",
    "title": "10  Initial Conditions",
    "section": "",
    "text": "10.1 Capacitor Test Jig 1\nInitial conditions for capacitors and inductors are essential in transient circuit analysis as they represent the energy stored in these components immediately prior to a change in the circuit, such as a switch opening or closing at time \\(t=0\\).\nBecause capacitors store energy in an electric field and inductors store energy in a magnetic field, they possess a fundamental property: the voltage across a capacitor cannot change instantaneously, and the current through an inductor cannot change instantaneously.\nMathematically, this is expressed as \\(v_C(0^-) = v_C(0^+)\\) and \\(i_L(0^-) = i_L(0^+)\\), where \\(0^-\\) is the instant just before the change and \\(0^+\\) is the instant just after.\nTo find these initial values, one typically analyzes the circuit for \\(t&lt;0\\) (often assuming it has been in a steady-state for a long time) by replacing the capacitor with an open circuit (since DC current is zero) and the inductor with a short circuit (since DC voltage is zero) and then solving for the capacitor voltage and inductor current at \\(t=0^-\\).\nThese continuous values then carry over to \\(t=0^+\\) and serve as the necessary constants for solving the differential equations that describe the circuit’s transient response for \\(t&gt;0\\).\nC_IC_test_jig_1_net_list = '''\n* C_IC_test_jig_1.asc\nC1 2 1 1e-6\nV1 1 0 1\nR1 2 0 1e3\n'''\nThe MNA equations are generated from the function SymMNA.smna.\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(C_IC_test_jig_1_net_list)\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{1} s v_{1} - C_{1} s v_{2} + I_{V1}\\)\\(0 = - C_{1} s v_{1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{1}}\\right)\\)\\(V_{1} = v_{1}\\)\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df) # get dummy element vales from netlist\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} R_{1} V_{1} s}{C_{1} R_{1} s + 1}\\)\\(I_{V1} = - \\frac{C_{1} V_{1} s}{C_{1} R_{1} s + 1}\\)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#capacitor-test-jig-1",
    "href": "Initial_conditions.html#capacitor-test-jig-1",
    "title": "10  Initial Conditions",
    "section": "",
    "text": "10.1.1 Initial conditions\nInitial conditions for the capacitor \\(C_1\\) is set by making \\(V_1\\) a step voltage equal to the value of the initial voltage condition. \\(1/s\\) is substituted for the value of \\(V_1\\).\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nSubstitute \\(1/s\\) for \\(V_1\\)\n\nelement_values[V1] = 1/s #laplace_transform(Heaviside(t), t, s)[0]\nNE_ic = NE_sym.subs(element_values)\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-6}, \\  R_{1} : 1000.0, \\  V_{1} : \\frac{1}{s}\\right\\}\\)\n\n\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_ic.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_ic.rhs[i]),latex(NE_ic.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-6} s v_{1} - 1.0 \\cdot 10^{-6} s v_{2}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{1} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(\\frac{1}{s} = v_{1}\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{1}{s + 1000.0}\\)\\(I_{V1} = - \\frac{1}{1000.0 s + 1000000.0}\\)\n\n\nThe voltage on node 2 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nnode_2_voltage_s = U_ic[v2].nsimplify().simplify().expand().together()\nnode_2_voltage_s\n\n\\(\\displaystyle \\frac{1}{s + 1000}\\)\n\n\n\nnode_2_voltage_t = inverse_laplace_transform(node_2_voltage_s, s, t)\nnode_2_voltage_t\n\n\\(\\displaystyle e^{- 1000 t}\\)\n\n\n\nfunc_node_2_voltage_t = lambdify(t, node_2_voltage_t) \n\n\n\n10.1.2 Plot the voltage at node 2\n\nx_axis = np.linspace(0, 10e-3, 2000, endpoint=True)\n\nplt.title('Node 2 voltage')\n\nplt.plot(x_axis*1e3, func_node_2_voltage_t(x_axis),'-b')\n\n#plt.ylim((0,1))\n#plt.xlim((0,10))\n#plt.yticks(list(np.linspace(0, 1.1, 12)))\n#plt.xticks(list(np.linspace(0, 10, 11)))\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n10.1.3 Plot the current in the capacitor\nThis is the same as \\(I_{V1}\\)\n\nV1_current_s = U_ic[I_V1].nsimplify().simplify().expand().together()\nV1_current_s\n\n\\(\\displaystyle - \\frac{1}{1000 \\left(s + 1000\\right)}\\)\n\n\n\nV1_current_t = inverse_laplace_transform(V1_current_s, s, t)\nV1_current_t\n\n\\(\\displaystyle - \\frac{e^{- 1000 t}}{1000}\\)\n\n\n\nfunc_V1_current_t = lambdify(t, V1_current_t) \n\nThe plot below shows the node voltages versus time.\n\nx_axis = np.linspace(0, 10e-3, 2000, endpoint=True)\n\nplt.title('V1 current')\n\nplt.plot(x_axis*1e3, func_V1_current_t(x_axis),'-b')\n\n#plt.ylim((0,1))\n#plt.xlim((0,10))\n#plt.yticks(list(np.linspace(0, 1.1, 12)))\n#plt.xticks(list(np.linspace(0, 10, 11)))\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, msec')\n\n#plt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#inductor-test-jig-1-with-ut-as-ic",
    "href": "Initial_conditions.html#inductor-test-jig-1-with-ut-as-ic",
    "title": "10  Initial Conditions",
    "section": "10.2 Inductor Test Jig 1 with \\(u(t)\\) as IC",
    "text": "10.2 Inductor Test Jig 1 with \\(u(t)\\) as IC\n\nneed to update values\nswap polarity of I1, change \\(L_1\\) value to 1\n\nIn the LTSpice simulation \\(I_1=0\\) which since there is no current folowing is an open circuit. The initial conditions for \\(L_1\\) is set by .ic I(L1)=-1e-3, notice the negative sign.\n\n\nL_IC_test_jig_1_net_list = '''\n* L_IC_test_jig_1.asc\nR1 1 0 1e3\nL1 1 0 1\nI1 0 1 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(L_IC_test_jig_1_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(I_{1} = I_{L1} + \\frac{v_{1}}{R_{1}}\\)\\(0 = - I_{L1} L_{1} s + v_{1}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df) # get dummy element vales from netlist\n\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{I_{1} L_{1} R_{1} s}{L_{1} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} R_{1}}{L_{1} s + R_{1}}\\)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#initial-conditions-1",
    "href": "Initial_conditions.html#initial-conditions-1",
    "title": "10  Initial Conditions",
    "section": "10.3 Initial conditions",
    "text": "10.3 Initial conditions\nThe initial conditions for the inductor is set by the current source \\(I_1\\). A step function with a value of the step is used. The steady state value, a DC level, of the step is shorted by the inductor and the voltage across the inductor from this contribution is 0.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nelement_values[I1] = 1/s #laplace_transform(1e-3*Heaviside(t), t, s)[0]\nNE_ic = NE_sym.subs(element_values)\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : \\frac{1}{s}, \\  L_{1} : 1.0, \\  R_{1} : 1000.0\\right\\}\\)\n\n\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_ic.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_ic.rhs[i]),latex(NE_ic.lhs[i]))\nMarkdown(temp)\n\n\\(\\frac{1}{s} = I_{L1} + 0.001 v_{1}\\)\\(0 = - 1.0 I_{L1} s + v_{1}\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1000.0}{s + 1000.0}\\)\\(I_{L1} = \\frac{1000.0}{s^{2} + 1000.0 s}\\)\n\n\nThe voltage on node 2 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\ntemp = U_ic[v1].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{1000}{s + 1000}\\)\n\n\n\nnode_1_voltage = inverse_laplace_transform(temp, s, t)\nnode_1_voltage\n\n\\(\\displaystyle 1000 e^{- 1000 t}\\)\n\n\n\nfunc_node_1_voltage = lambdify(t, node_1_voltage) \n\nThe plot below shows the node voltages versus time.\n\nx_axis = np.linspace(0, 10e-3, 2000, endpoint=True)\n\nplt.title('title')\n\nplt.plot(x_axis*1e3, func_node_1_voltage(x_axis),'-b',label='v2(t)')\n\n#plt.ylim((-1,2))\n#plt.xlim((0,10))\n\nplt.xticks(list(np.linspace(0, 10, 11)))\n\nplt.ylabel('v2(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe voltage at node 2 in the above plot has a decay different than below. The plot above agrees with LTSpice.\n\n10.3.1 Inductor current\n\nL1_current_s = U_ic[I_L1].nsimplify().simplify().expand().together()\nL1_current_s\n\n\\(\\displaystyle \\frac{1000}{s \\left(s + 1000\\right)}\\)\n\n\n\nL1_current_t = inverse_laplace_transform(L1_current_s, s, t)\nL1_current_t\n\n\\(\\displaystyle 1 - e^{- 1000 t}\\)\n\n\n\nfunc_L1_current_t = lambdify(t, L1_current_t) \n\nThe plot below shows inductor current versus time.\n\nx_axis = np.linspace(0, 10e-3, 2000, endpoint=True)\n\nplt.title('title')\n\nplt.plot(x_axis*1e3, func_L1_current_t(x_axis),'-b',label='I(t)')\n\n#plt.ylim((-1,2))\n#plt.xlim((0,10))\n\nplt.xticks(list(np.linspace(0, 10, 11)))\n\nplt.ylabel('L1 current, amps')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nInductor current should approach zero. Maybe can’t determine the inductor current since it’s being driven by \\(I_1\\) and \\(I_1\\) is a step function which has a final value of 1.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#circuit-2",
    "href": "Initial_conditions.html#circuit-2",
    "title": "10  Initial Conditions",
    "section": "10.4 Circuit 2",
    "text": "10.4 Circuit 2\nA circuit with initial conditions consisting of a capacitor with an inital voltage and an inductor with initial current is analysed. The circuit in Figure 10.1 has seven branches and four nodes. Capacitor, C1, has an initial voltage at t(0) and the inductor, L1, has an initial current at t(0). The voltage source V2 represents the initial voltage on the capacitor and current source, I1, represents the initial current flowing in the inductor. The circuit has a DC voltage source, V1. There a current controlled current source, F1, that is controlled by the current in V1.\nThe circuit was drawn using LTSpice and the netlist was pasted into the code. The Heaviside function is used to define the initial current and voltage on the inductor and capacitor. The Heaviside function is named after Oliver Heaviside, who made significant contributions to electrical engineering.\nThe following Python modules are used.\n\n\n\n\n\n\nFigure 10.1: Circuit schematic\n\n\n\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\n10.4.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nR2 3 2 5\nC1 3 4 1\nV2 4 0 1\nL1 1 2 3 \nI1 1 2 1\nF1 2 0 V1 2\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + I_{V1} = - I_{1}\\)\\(I_{F1} - I_{L1} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}} = I_{1}\\)\\(- C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C_{1} s v_{3} + C_{1} s v_{4} + I_{V2} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{4} = V_{2}\\)\\(- I_{L1} L_{1} s + v_{1} - v_{2} = 0\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1}\\\\I_{F1} - I_{L1} + \\frac{v_{2}}{R_{2}} - \\frac{v_{3}}{R_{2}}\\\\- C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\\\- C_{1} s v_{3} + C_{1} s v_{4} + I_{V2}\\\\v_{1}\\\\v_{4}\\\\- I_{L1} L_{1} s + v_{1} - v_{2}\\\\I_{F1} - I_{V1} f_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}- I_{1}\\\\I_{1}\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{1}, \\  v_{3}, \\  s, \\  C_{1}, \\  I_{L1}, \\  I_{V1}, \\  I_{F1}, \\  R_{2}, \\  I_{V2}, \\  v_{1}, \\  I_{1}, \\  V_{1}, \\  V_{2}, \\  f_{1}, \\  v_{2}, \\  v_{4}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  I_{1} : 1.0, \\  L_{1} : 3.0, \\  R_{2} : 5.0, \\  V_{1} : 1.0, \\  V_{2} : 1.0, \\  f_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#initial-conditions-2",
    "href": "Initial_conditions.html#initial-conditions-2",
    "title": "10  Initial Conditions",
    "section": "10.5 Initial conditions",
    "text": "10.5 Initial conditions\nThe SymPy Heaviside function is used to define the initial current and voltage on the inductor and capacitor.\n\nelement_values[V1] = laplace_transform(Heaviside(t), t, s)[0]\nelement_values[V2] = laplace_transform(-0.2*Heaviside(t), t, s)[0]\nelement_values[I1] = laplace_transform(0.1*Heaviside(t), t, s)[0]\nNE_ic = NE_sym.subs(element_values)\nNE_ic\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1}\\\\I_{F1} - I_{L1} + 0.2 v_{2} - 0.2 v_{3}\\\\- 1.0 s v_{4} - 0.2 v_{2} + v_{3} \\cdot \\left(1.0 s + 0.2\\right)\\\\I_{V2} - 1.0 s v_{3} + 1.0 s v_{4}\\\\v_{1}\\\\v_{4}\\\\- 3.0 I_{L1} s + v_{1} - v_{2}\\\\I_{F1} - 2.0 I_{V1}\\end{matrix}\\right] = \\left[\\begin{matrix}- \\frac{0.1}{s}\\\\\\frac{0.1}{s}\\\\0\\\\0\\\\\\frac{1}{s}\\\\- \\frac{0.2}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{13.0 s^{2} + 53.0 s + 10.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(v_{3} = \\frac{- 2.0 s^{2} - 7.0 s + 10.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(v_{4} = - \\frac{0.2}{s}\\)\\(I_{V1} = \\frac{- s - 4.0}{10.0 s^{2} + 50.0 s + 10.0}\\)\\(I_{V2} = \\frac{3.0 s + 12.0}{10.0 s^{2} + 50.0 s + 10.0}\\)\\(I_{L1} = \\frac{- s - 1.0}{10.0 s^{3} + 50.0 s^{2} + 10.0 s}\\)\\(I_{F1} = \\frac{- s - 4.0}{5.0 s^{2} + 25.0 s + 5.0}\\)\n\n\nThe voltage on node 2 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\ntemp = U_ic[v2].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{13 s^{2} + 53 s + 10}{10 s \\left(s^{2} + 5 s + 1\\right)}\\)\n\n\n\nnode_2_voltage = inverse_laplace_transform(temp, s, t)\nnode_2_voltage\n\n\\(\\displaystyle \\left(\\frac{\\sqrt{21} \\cdot \\left(3 e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} + \\sqrt{21} e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} - 3 e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}} + \\sqrt{21} e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}}\\right)}{140} + e^{5 t}\\right) e^{- 5 t}\\)\n\n\n\nfunc_node_2_voltage = lambdify(t, node_2_voltage) \n\nThe voltage on node 3 is obtained in a sumular way.\n\ntemp = U_ic[v3].nsimplify().simplify().expand().together()\ntemp\n\n\\(\\displaystyle \\frac{- 2 s^{2} - 7 s + 10}{10 s \\left(s^{2} + 5 s + 1\\right)}\\)\n\n\n\nnode_3_voltage = inverse_laplace_transform(temp, s, t)\nnode_3_voltage\n\n\\(\\displaystyle \\left(\\frac{\\sqrt{21} \\left(- 2 \\sqrt{21} e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} + 9 e^{\\frac{t \\left(5 - \\sqrt{21}\\right)}{2}} - 2 \\sqrt{21} e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}} - 9 e^{\\frac{t \\left(\\sqrt{21} + 5\\right)}{2}}\\right)}{70} + e^{5 t}\\right) e^{- 5 t}\\)\n\n\n\nfunc_node_3_voltage = lambdify(t, node_3_voltage) \n\nThe plot below shows the node voltages versus time.\n\nx = np.linspace(0, 10, 2000, endpoint=True)\n\nplt.title('Node voltages vs time')\n\nplt.plot(x, func_node_2_voltage(x),label='v2(t)')\nplt.plot(x, func_node_3_voltage(x),label='v3(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Initial_conditions.html#summary",
    "href": "Initial_conditions.html#summary",
    "title": "10  Initial Conditions",
    "section": "10.6 Summary",
    "text": "10.6 Summary\nIn this notebook, newtork equations were solved which had initial conditions, which were included in the network equations with their Laplace equilivents.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Initial Conditions</span>"
    ]
  },
  {
    "objectID": "Example-problems.html",
    "href": "Example-problems.html",
    "title": "Example Problems",
    "section": "",
    "text": "The table below is a list of the example problems with a short discription.\n\n\n\n\n\n\n\nTitle\nCircuit Description\n\n\n\n\nTwo port parameters\nTwo port parameters are derived from the circuit’s netlist.\n\n\nThevenin equivalent circuit\nThe Thevenin equivalent circuit is obtained from a netlist.\n\n\nState variable filter\nNetwork equations for a state variable filter are obtained from the netlist which are solved in symbolic form.\n\n\nSuperposition\nA circuit to illustrate superposition and polyphase circuit analysis.\n\n\n2nd order BRF\nWalk through of the NMA code\n\n\nElliptic Function LPF\nA circuit too complex for quick symbolic solution\n\n\nTransient circuit\nExamining the transient response of a circuit\n\n\nBridge T\nInitial conditions and transient solution\n\n\nPi Filter\nTransfer function using the FACTS method\n\n\nSIDO filter\nDeriving the symbolic transfer function of a filter\n\n\nSuper node\nAnalysis of a circuit with a super node\n\n\nModeling Op Amps\nAnalysis of Op Amp model and stamp\n\n\nOp Amp circuits\nTypical Op Amp circuits and the use of the Op Amp element type\n\n\nTwo amplifier RIAA Phono Preamp\nA circuit for a phono preamp is analyzed.\n\n\nMechanical systems\nElectric circuit analogs for a translational and a rotational mechanical system\n\n\nKlon Centuar• part 1• part 2• part 3\nAnalysis of the Klon Centuar guitar pedal• Introduction and effects path linear analysis• Effects path non-linear analysis• Design review and reactive branch analysis\n\n\nWien bridge oscillator\nAnalysis of a Wien bridge oscillator circuit\n\n\nDiode circuit\nCircuit analysis with one or more diodes in the circuit\n\n\nBridged T-coil\nA circuit with a coupled inductor and a bridging capacitor",
    "crumbs": [
      "Example Problems"
    ]
  },
  {
    "objectID": "Two port parameters.html",
    "href": "Two port parameters.html",
    "title": "11  Two Port Parameters",
    "section": "",
    "text": "11.1 Circuit description\nThis notebook describes the calculation of two port parameters derived from the circuit’s netlist. A Two-port network is a circuit that has two pairs of ports or terminals and the circuit is characterized by the currents and voltages at the ports by a 2 by 2 matrix. From a two port matrix the response of the network to signals applied to the ports can be calculated easily, without solving for all the internal voltages and currents in the network. For example filters, matching networks, transmission lines, and transistors are characterized by two port parameters.\nThe first circuit is an attenuator, which could be easily analyzed by hand with a pencil, paper and a calculator, but here I’m using python to step through the calculations. These same steps can be applied to larger, more complex circuits which would be difficult to analyze by hand. The Sympy and SciPy libraries can be used to obtain symbolic and numerical results, however as is shown below, when the circuit is large, symbolic results are not that useful nor do they provide much insight.\nThe procedure starts by first drawing a schematic of the circuit with a schematic capture program such as EasyEDA (links to the schematics are provided below) then the netlist is generated and exported as a text file. The netlist is used to generate modified nodal equations with the python program described here. The equations are solved for voltages and currents at the port terminals by using SymPy to generate the z-paramters. Z-parameters are also known as open-circuit impedance parameters as they are calculated under open circuit conditions. Once the z-parameters are obtained, these can be converted into other parameters, such as Y, H, S or others.\nThe second circuit is a band pass filter. The filter is designed from a low pass prototype by using normalized values from a filter design handbook. Z and s-parameters are calculated and the results are plotted using Matplotlib.\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#circuit-description",
    "href": "Two port parameters.html#circuit-description",
    "title": "11  Two Port Parameters",
    "section": "",
    "text": "11.1.1 Pi-attenuator\nThe pi-attenuator, shown in Figure 11.1, is formed by three resistors with R1 and R3 as the shunt resistors on the input and output ports and R2 as the series resistor in a circuit topology in the shape of the greek letter pi. For R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms, the attenuation is 10 dB and the port impedance is 50 ohms. Pasternack’s Pi Attenuator Calculator (Pi pad attenuator) was used to design the attenuator.\nThe selection of which type a network parameter is somewhat a matter of convenience. However, some circuits can’t have their ports shorted or left open for proper operation, so s-parameters are the appropriate choice in this situation. Solving for the z-parameters is convenient since all we need to do is apply a voltage source to the input port, with the output port unterminated, and solve for the voltage and currents at each port. Since the output port is unterminated, the current into this port is zero and we can find z11 and z21. To find z21 and z22, the voltage source is applied to port 2 with port 1 unterminated.\nTo find Z-parameters attach voltage sources to both ports and find the node equations. LTSpice was used to draw the schematic.\n\n\n\n\n\n\nFigure 11.1: Pi attenuator schematic\n\n\n\nThe netlist for the circuit:\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\nV2 2 0 1\n\n11.1.1.1 Find z11 & z21\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\n\nnet_list = '''\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\nV1 1 0 1\n*V2 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}}\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\V_{1}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  V_{1}, \\  v_{2}, \\  v_{1}, \\  R_{1}, \\  I_{V1}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p1 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p1.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p1[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{3} V_{1}}{R_{2} + R_{3}}\\)\\(I_{V1} = \\frac{- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}}{R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\nA negative sign was placed in the equation to make the direction of the current flow match the definition of the two port parameters.\n\nz11 = -U_sym_p1[v1]/U_sym_p1[I_V1]\nz11.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{2} + R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = -U_sym_p1[v2]/U_sym_p1[I_V1]\nz21.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\n\n\n11.1.1.2 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the net list.\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\n\nnet_list = '''\nR1 0 1 96.25\nR2 1 2 71.15\nR3 0 2 96.25\n*V1 1 0 1\nV2 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V2} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{2} = V_{2}\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\I_{V2} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{2}}\\\\v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\V_{2}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  I_{V2}, \\  V_{2}, \\  v_{2}, \\  v_{1}, \\  R_{1}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p2 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p2.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p2[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{R_{1} V_{2}}{R_{1} + R_{2}}\\)\\(v_{2} = V_{2}\\)\\(I_{V2} = \\frac{- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}}{R_{1} R_{3} + R_{2} R_{3}}\\)\n\n\n\n\\(z_{12}=\\frac{V_1}{I_2}\\text{  when  }I_1=0\\)\n\nz12 = -U_sym_p2[v1]/U_sym_p2[I_V2]\nz12.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\n\\(z_{22}=\\frac{V_2}{I_2}\\text{  when  }I_1=0\\)\n\nz22 = -U_sym_p2[v2]/U_sym_p2[I_V2]\nz22.cancel()\n\n\\(\\displaystyle \\frac{R_{1} R_{3} + R_{2} R_{3}}{R_{1} + R_{2} + R_{3}}\\)\n\n\nThe common names for the z-parameters are:\nz11: input driving point impedance\nz12: reverse transfer impedance\nz21: forward transfer impedance\nz22: output driving point impedance\nThe elements of the matrix can be displayed:\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\frac{V_{1} \\left(R_{1} R_{2} + R_{1} R_{3}\\right)}{- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}} & - \\frac{R_{3} V_{1} \\left(R_{1} R_{2} + R_{1} R_{3}\\right)}{\\left(R_{2} + R_{3}\\right) \\left(- R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1}\\right)}\\\\- \\frac{R_{1} V_{2} \\left(R_{1} R_{3} + R_{2} R_{3}\\right)}{\\left(R_{1} + R_{2}\\right) \\left(- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}\\right)} & - \\frac{V_{2} \\left(R_{1} R_{3} + R_{2} R_{3}\\right)}{- R_{1} V_{2} - R_{2} V_{2} - R_{3} V_{2}}\\end{matrix}\\right]\\)\n\n\nActual values for each of the components can be substituted for the symbols with R1 = R3 = 96.25 ohms and R2 equal to 71.15 ohms\n\natten_values = {R1:96.25,R2:71.15,R3:96.25}\n\n\nz11_val = z11.subs(atten_values)\nz12_val = z12.subs(atten_values)\nz21_val = z21.subs(atten_values)\nz22_val = z22.subs(atten_values)\n\nThe numeric values of the impedance matrix\n\nnp.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=float)\n\narray([[61.11227005, 35.13772995],\n       [35.13772995, 61.11227005]])\n\n\n\n\n11.1.1.3 Calculate Z in and Z out, ki and kv\nA two-port circuit is typically driven at port 1 and loaded at port 2, and four equations needed to solve the four unknowns. The link here has a nice explnation of two port analysis.\n\\(\\begin{align*}\n\\begin{bmatrix} -1 & 0 & z11 & z12 \\\\\\ 0 & -1 & z21 & z22 \\\\\\ 1 & 0 & Z_S & 0 \\\\\\ 0 & 1 & 0 & Z_L\n\\end{bmatrix}\n\\begin{bmatrix}\n  V_1  \\\\\n  V_2  \\\\\n  I_1 \\\\\n  I_2\n\\end{bmatrix}\n{} &= \\begin{bmatrix}\n  0  \\\\\n  0  \\\\\n  V_g \\\\\n  0\n\\end{bmatrix}\n\\end{align*}\\)\nPutting into SymPy\n\nZ11, Z12, Z21, Z22 = symbols('Z11 Z12 Z21 Z22')\nZ_s, Z_l, Vg = symbols('Z_s Z_l Vg')\n\neqZ = Eq(Matrix([[-1,0,Z11,Z12],[0,-1,Z21,Z22],[1,0,Z_s,0],[0,1,0,Z_l]])*Matrix([V1,V2,I_V1,I_V2]),Matrix([0,0,Vg,0]))\neqZ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} Z_{11} + I_{V2} Z_{12} - V_{1}\\\\I_{V1} Z_{21} + I_{V2} Z_{22} - V_{2}\\\\I_{V1} Z_{s} + V_{1}\\\\I_{V2} Z_{l} + V_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\Vg\\\\0\\end{matrix}\\right]\\)\n\n\n\nansZ = solve(eqZ,[V1, V2, I_V1,I_V2])\nansZ\n\n\\(\\displaystyle \\left\\{ I_{V1} : \\frac{Vg Z_{22} + Vg Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  I_{V2} : - \\frac{Vg Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  V_{1} : \\frac{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}, \\  V_{2} : \\frac{Vg Z_{21} Z_{l}}{Z_{11} Z_{22} + Z_{11} Z_{l} - Z_{12} Z_{21} + Z_{22} Z_{s} + Z_{l} Z_{s}}\\right\\}\\)\n\n\n\n# current gain\nansZ[I_V2]/ansZ[I_V1]\n\n\\(\\displaystyle - \\frac{Vg Z_{21}}{Vg Z_{22} + Vg Z_{l}}\\)\n\n\n\n# voltage gain\nansZ[V2]/ansZ[V1]\n\n\\(\\displaystyle \\frac{Vg Z_{21} Z_{l}}{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}\\)\n\n\n\n# Z input\nansZ[V1]/ansZ[I_V1]\n\n\\(\\displaystyle \\frac{Vg Z_{11} Z_{22} + Vg Z_{11} Z_{l} - Vg Z_{12} Z_{21}}{Vg Z_{22} + Vg Z_{l}}\\)\n\n\n\n# Z out\nansZ[V2]/ansZ[I_V2]\n\n\\(\\displaystyle - Z_{l}\\)\n\n\nSympy returns the output impedance as simply \\(-Z_l\\), since this is the algebraic simplification of the equations. Most textbooks will give the output impedance in terms of the z-parameters and the source impedance: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\)\n\n\n11.1.1.4 Calculate input and output impedance for the attenuator\nThe input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\)\nTextbook equation: \\(Z_{in}=Z_{11}-\\frac{Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\) where \\(Z_{L}\\) is the impedance of the load connected to port two.\nThe output impedance from textbooks is: \\(Z_{out}=Z_{22}-\\frac{Z_{12}Z_{21}}{Z_{11}+Z_{S}}\\), where \\(Z_{S}\\) is the impedance of the source connected to port one.\n\n# Zin\nZl = 50 # load impedance\nprint('input impedance of network from z-parameters: {:.2f}'.format(np.abs((z11_val*z22_val+z11_val*Zl-z12_val*z21_val)/(z22_val+Zl))))\n\ninput impedance of network from z-parameters: 50.00\n\n\n\n# Zout\nZs = 50 # source impedance\nprint('output impedance of network from z-parameters: {:.2f}'.format(np.abs(z22_val-(z12_val*z21_val)/(z11_val+Zs))))\n\noutput impedance of network from z-parameters: 50.00\n\n\n\n\n11.1.1.5 Calculate the voltage gain for the attenuator\nVoltage gain: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), from text books: \\(K_v=\\frac{Z_{21}Z_{L}}{\\Delta _Z+Z_{11}Z_L}\\)\n\n#Kv\nprint('voltage gain of network from z-parameters: {:.2f} dB'.format(20*np.log10(float((z21_val*Zl)/(z11_val*z22_val + z11_val*Zl - z12_val*z21_val)))))\n\nvoltage gain of network from z-parameters: -10.00 dB\n\n\n\n\n11.1.1.6 Convert z-parameters to y-parameters\nThe z-parameters can be converted to admittance or y-parameters with the following code:\nFind the determinant of the z-parameter matrix:\n\ndet_z = np.linalg.det(np.array([[z11_val, z12_val],[z21_val, z22_val]],dtype=float))\nprint('determinant = {:.2f}'.format(det_z))\n\ndeterminant = 2500.05\n\n\nDisplay the y-parameter matrix.\n\nnp.array([[z22_val/det_z,-z12_val/det_z],[-z21_val/det_z,z11_val/det_z]],dtype=float)\n\narray([[ 0.02444442, -0.01405481],\n       [-0.01405481,  0.02444442]])\n\n\n\n\n11.1.1.7 Convert z-parameters to s-parameters\nThe 2-port S-parameters have the following generic descriptions:\n\\(S_{11} \\text{ is the input port voltage reflection coefficient}\\)\n\\(S_{12} \\text{ is the reverse voltage gain}\\)\n\\(S_{21} \\text{ is the forward voltage gain}\\)\n\\(S_{22} \\text{ is the output port voltage reflection coefficient}\\)\nThe z-parameter can be converted to scattering or s-parameters with the following:\n\\(s_{11} = \\frac {(Z_{11}-Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\n\\(s_{12} = \\frac {2Z_{12}Z_o} {\\Delta Z}\\)\n\\(s_{21} = \\frac {2Z_{21}Z_o} {\\Delta Z}\\)\n\\(s_{22} = \\frac {(Z_{11}+Z_o)(Z_{22}-Z_o)-Z_{12}Z_{21}} {\\Delta Z}\\)\nwhere: \\(\\Delta Z = (Z_{11}+Z_o)(Z_{22}+Z_o)-Z_{12}Z_{21}\\) and \\(Z_o\\) is the characteristic impedance.\n\nZ_o = 50 # characteristic impedance\ndel_z = (z11_val+Z_o)*(z22_val+Z_o)-z12_val*z21_val\n\nS = np.array([[((z11_val-Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z,(2*z12_val*Z_o)/del_z],\n              [(2*z21_val*Z_o)/del_z,((z11_val+Z_o)*(z22_val-Z_o)-z12_val*z21_val)/del_z]],dtype=float)\nS # display the s-parameter matrix\n\narray([[-1.00004488e-01,  3.16234863e-01],\n       [ 3.16234863e-01,  4.45363654e-06]])\n\n\n\n\n11.1.1.8 Input return loss\nInput return loss \\(RL_{in}\\) indicates impedance match of the port to the source. A number of 10 dB or greater, indicates that the match is probably acceptable.\n\\(RL_{in} =-20\\log_{10}\\left|S_{11}\\right|\\)\n\nprint('Input return loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[0,0]))))\n\nInput return loss = 20.00 dB\n\n\n\n\n11.1.1.9 Insertion loss\nInsertion loss \\(IL\\) is the reciprocal of the magnitude of the transmission coefficient, S21, expressed in decibels.\n\\(IL=-20\\log _{10} \\left|S_{21} \\right|\\)\n\nprint('Insertion loss = {:.2f} dB'.format(-20*np.log10(np.abs(S[1,0]))))\n\nInsertion loss = 10.00 dB\n\n\nThis value agrees with the design of the attenuator as being a 10 dB attenuator.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#band-pass-filter",
    "href": "Two port parameters.html#band-pass-filter",
    "title": "11  Two Port Parameters",
    "section": "11.2 Band Pass Filter",
    "text": "11.2 Band Pass Filter\nThe circuit in Figure 11.2 is a band pass filter designed from normalized filter design tables. The third order low pass filter prototype was transformed into a bandpass filter as shown in the figure below. Butterworth filter coefficients were chosen for this design. A Butterworth filter is a type of signal processing filter that has a flat passband response.\n\n\n\n\n\n\nFigure 11.2: Band pass filter schematic\n\n\n\nThe low pass to bandpass transformation calculations are shown below. The filter was designed to have a center frequency of 10 MHz and a 3 dB bandwidth of 1 MHz. The normalized filter values were obtained from Williams and Taylor (1995):\n3rd order Butterworth LPF prototype\nRs/Rl = 1\nC1 = 1\nL2 = 2\nC1 = 1\nThe bandpass filter has the following design parameters: The source and load impedance is 50 ohms, the filter bandwidth is 1 MHz and the center frequency is 10 MHz. Following the example from Williams and Taylor (1995) (example 5-2), but with the following changes:\n\ncenter freq = 10MHz\n\nbandwidth 1MHz\n\nRs=Rl=50\n\n\nf_center = 10e6\nf_3dB_BW = 1e6 # 3dB bandwidth\nfo = np.sqrt((f_center-f_3dB_BW/2)*(f_center+f_3dB_BW/2)) # geometric center frequency\nprint('geometric center frequency = {:.3f}MHz'.format(fo/1e6))\n\ngeometric center frequency = 9.987MHz\n\n\n\nZ = 50 # load and source resistance\nFSF = 2*np.pi*f_3dB_BW\nprint('frequency scaling factor = {:.3f}'.format(FSF))\n\nfrequency scaling factor = 6283185.307\n\n\nThe first element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled.\n\n# C1 is 1st shunt capacitor\nC1n = 1 # normalized value from the tables in the filter handbook\nC1p = C1n/(FSF*Z)\nprint('capacitor = {:.3f}nF'.format(C1p*1e9))\n\nwo = 2*np.pi*fo\nL1p = 1/(wo**2*C1p) # calculate the value of the inductor that resonates with the capacitor at the center frequency\nprint('inductor = {:.3f}nH'.format(L1p*1e9))\n\ncapacitor = 3.183nF\ninductor = 79.777nH\n\n\nThe second element in the lowpass prototype is a series capacitor and for the lowpass to bandpass transformation the capacitor is replaced by a capacitor and inductor in series with the same normalized value. The normalized values are then frequency scaled.\n\n# L2 is the 2nd series inductor\nL2n = 2 # normalized value from the tables in the filter handbook\nL2p = L2n*Z/FSF\nprint('inductor = {:.3f}uH'.format(L2p*1e6))\n\nC2p = 1/(wo**2*L2p) # calculate the value of the capacitor that resonates with the inductor at the center frequency\nprint('capacitor = {:.3f}pF'.format(C2p*1e12))\n\ninductor = 15.915uH\ncapacitor = 15.955pF\n\n\nThe last element in the lowpass prototype is a shunt inductor and for the lowpass to bandpass transformation the inductor is replaced by a capacitor and inductor in parallel with the same normalized value. The normalized values are then frequency scaled. The values for this branch of the circuit are the same as for the first shunt element.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z11-and-z12",
    "href": "Two port parameters.html#find-z11-and-z12",
    "title": "11  Two Port Parameters",
    "section": "11.3 Find z11 and z12",
    "text": "11.3 Find z11 and z12\nTo find \\(z_{11}\\) and \\(z_{21}\\), remove V2 from the net list by commenting out the V2 line in the net list. This will make \\(I_2\\) equal to zero. \\(z_{11}\\) is equal to \\(\\frac{V_1}{I_1}\\text{  when  }I_2=0\\) and \\(z_{21}\\) is equal to \\(\\frac{V_2}{I_1}\\text{  when  }I_2=0\\).\nThe net list below was run through the NMA code to generate the circuit equations. The component values in the netlist have all been set to one. Later, the actual component values will be used.\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n\nnet_list = '''\nV1 1 0 1\n*V2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1} = 0\\)\\(- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s - v_{1} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{2} = 0\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2} + I_{V1}\\\\- C_{2} s v_{3} - I_{L3} + v_{2} \\left(C_{2} s + C_{3} s\\right)\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2}\\\\v_{1}\\\\- I_{L1} L_{1} s - v_{1}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\\\- I_{L3} L_{3} s - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L3}, \\  C_{2}, \\  L_{1}, \\  C_{3}, \\  I_{L1}, \\  v_{3}, \\  L_{2}, \\  V_{1}, \\  I_{L2}, \\  s, \\  v_{2}, \\  C_{1}, \\  v_{1}, \\  I_{V1}, \\  L_{3}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p1 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p1.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p1[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} L_{3} V_{1} s^{2}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(v_{3} = \\frac{C_{2} L_{3} V_{1} s^{2} + C_{3} L_{3} V_{1} s^{2} + V_{1}}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} V_{1} s^{6} - C_{1} C_{2} L_{1} L_{2} V_{1} s^{4} - C_{1} C_{2} L_{1} L_{3} V_{1} s^{4} - C_{1} C_{3} L_{1} L_{3} V_{1} s^{4} - C_{1} L_{1} V_{1} s^{2} - C_{2} C_{3} L_{1} L_{3} V_{1} s^{4} - C_{2} C_{3} L_{2} L_{3} V_{1} s^{4} - C_{2} L_{1} V_{1} s^{2} - C_{2} L_{2} V_{1} s^{2} - C_{2} L_{3} V_{1} s^{2} - C_{3} L_{3} V_{1} s^{2} - V_{1}}{C_{2} C_{3} L_{1} L_{2} L_{3} s^{5} + C_{2} L_{1} L_{2} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{3} L_{1} L_{3} s^{3} + L_{1} s}\\)\\(I_{L1} = - \\frac{V_{1}}{L_{1} s}\\)\\(I_{L2} = \\frac{C_{2} C_{3} L_{3} V_{1} s^{3} + C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\\(I_{L3} = - \\frac{C_{2} V_{1} s}{C_{2} C_{3} L_{2} L_{3} s^{4} + C_{2} L_{2} s^{2} + C_{2} L_{3} s^{2} + C_{3} L_{3} s^{2} + 1}\\)\n\n\n\n\nelement_values = {L1:L1p,C1:C1p,C2:C2p,L2:L2p,L3:L1p,C3:C1p}\n\n\nU_p1 = solve(NE_sym.subs(element_values),X)\n\nSubstituting actual values for the circuit elements, we get:\n\nU_p1\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{12534954.6878233 V_{1}}{s}, \\  I_{L2} : \\frac{6.33074196165529 \\cdot 10^{60} V_{1} s^{3} + 2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  I_{L3} : - \\frac{2.49302855720388 \\cdot 10^{76} V_{1} s}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  I_{V1} : \\frac{- 6.39649568809606 \\cdot 10^{83} V_{1} s^{6} - 7.58201892757332 \\cdot 10^{99} V_{1} s^{4} - 2.98577794233115 \\cdot 10^{115} V_{1} s^{2} - 3.90625 \\cdot 10^{130} V_{1}}{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{1.98886124385089 \\cdot 10^{69} V_{1} s^{2}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}, \\  v_{3} : \\frac{3.98766679392103 \\cdot 10^{71} V_{1} s^{2} + 1.5625 \\cdot 10^{87} V_{1}}{1.00756887663672 \\cdot 10^{56} s^{4} + 7.95544497540355 \\cdot 10^{71} s^{2} + 1.5625 \\cdot 10^{87}}\\right\\}\\)\n\n\n\n\\(z_{11} = \\frac {V_1}{I_1} \\text{  when  } I_2=0\\)\n\nz11 = (-U_p1[v1]/U_p1[I_V1]).cancel()\nz11 #.simplify()\n\n\\(\\displaystyle \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\)\n\n\n\\(z_{21} = \\frac {V_2}{I_1} \\text{  when  } I_2=0\\)\n\nz21 = (-U_p1[v2]/U_p1[I_V1]).cancel()\nz21 #.simplify()\n\n\\(\\displaystyle \\frac{3.99665323720675 \\cdot 10^{161} s^{7} + 3.1556309103651 \\cdot 10^{177} s^{5} + 6.19785984654536 \\cdot 10^{192} s^{3}}{6.44490997486657 \\cdot 10^{139} s^{10} + 1.27281032416988 \\cdot 10^{156} s^{8} + 1.00396628165841 \\cdot 10^{172} s^{6} + 3.95359126276846 \\cdot 10^{187} s^{4} + 7.77287372840943 \\cdot 10^{202} s^{2} + 6.103515625 \\cdot 10^{217}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#find-z12-z22-1",
    "href": "Two port parameters.html#find-z12-z22-1",
    "title": "11  Two Port Parameters",
    "section": "11.4 Find z12 & z22",
    "text": "11.4 Find z12 & z22\nTo find \\(z_{12}\\) and \\(z_{22}\\), remove V1 from the net list by commenting out the V1 line in the netlist. This will make \\(I_1\\) equal to zero. \\(z_{12}\\) is equal to \\(\\frac{V_1}{I_2}\\text{  when  }I_1=0\\) and \\(z_{22}\\) is equal to \\(\\frac{V_2}{I_2}\\text{  when  }I_1=0\\).\nThe net list below was run through the NMA code to generate the circuit equations.\nRemove V1 from the netlist.\n\nnet_list = '''\n*V1 1 0 1\nV2 2 0 1\nL1 0 1 1\nL2 1 3 1\nL3 0 2 1\nC1 1 0 1\nC2 3 2 1\nC3 2 0 1\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - I_{L1} + I_{L2} = 0\\)\\(- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2} = 0\\)\\(v_{2} = V_{2}\\)\\(- I_{L1} L_{1} s - v_{1} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{2} = 0\\)\n\n\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - I_{L1} + I_{L2}\\\\- C_{2} s v_{3} - I_{L3} + I_{V2} + v_{2} \\left(C_{2} s + C_{3} s\\right)\\\\- C_{2} s v_{2} + C_{2} s v_{3} - I_{L2}\\\\v_{2}\\\\- I_{L1} L_{1} s - v_{1}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\\\- I_{L3} L_{3} s - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L3}, \\  C_{2}, \\  L_{1}, \\  C_{3}, \\  I_{V2}, \\  I_{L1}, \\  v_{3}, \\  L_{2}, \\  I_{L2}, \\  s, \\  v_{2}, \\  C_{1}, \\  v_{1}, \\  V_{2}, \\  L_{3}\\right)\\)\n\n\nSymbolic solution\n\nU_sym_p2 = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym_p2.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym_p2[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{2} L_{1} V_{2} s^{2}}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(v_{2} = V_{2}\\)\\(v_{3} = \\frac{C_{1} C_{2} L_{1} L_{2} V_{2} s^{4} + C_{2} L_{1} V_{2} s^{2} + C_{2} L_{2} V_{2} s^{2}}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{V2} = \\frac{- C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} V_{2} s^{6} - C_{1} C_{2} L_{1} L_{2} V_{2} s^{4} - C_{1} C_{2} L_{1} L_{3} V_{2} s^{4} - C_{1} C_{3} L_{1} L_{3} V_{2} s^{4} - C_{1} L_{1} V_{2} s^{2} - C_{2} C_{3} L_{1} L_{3} V_{2} s^{4} - C_{2} C_{3} L_{2} L_{3} V_{2} s^{4} - C_{2} L_{1} V_{2} s^{2} - C_{2} L_{2} V_{2} s^{2} - C_{2} L_{3} V_{2} s^{2} - C_{3} L_{3} V_{2} s^{2} - V_{2}}{C_{1} C_{2} L_{1} L_{2} L_{3} s^{5} + C_{1} L_{1} L_{3} s^{3} + C_{2} L_{1} L_{3} s^{3} + C_{2} L_{2} L_{3} s^{3} + L_{3} s}\\)\\(I_{L1} = - \\frac{C_{2} V_{2} s}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{L2} = \\frac{- C_{1} C_{2} L_{1} V_{2} s^{3} - C_{2} V_{2} s}{C_{1} C_{2} L_{1} L_{2} s^{4} + C_{1} L_{1} s^{2} + C_{2} L_{1} s^{2} + C_{2} L_{2} s^{2} + 1}\\)\\(I_{L3} = - \\frac{V_{2}}{L_{3} s}\\)\n\n\n\n\nU_p2 = solve(NE_sym.subs(element_values),X)\nU_p2\n\n\\(\\displaystyle \\left\\{ I_{L1} : - \\frac{9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  I_{L2} : \\frac{- 2.53229678466212 \\cdot 10^{59} V_{2} s^{3} - 9.9721142288155 \\cdot 10^{74} V_{2} s}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  I_{L3} : - \\frac{12534954.6878233 V_{2}}{s}, \\  I_{V2} : \\frac{- 6.39649568809606 \\cdot 10^{83} V_{2} s^{6} - 7.58201892757332 \\cdot 10^{99} V_{2} s^{4} - 2.98577794233115 \\cdot 10^{115} V_{2} s^{2} - 3.90625 \\cdot 10^{130} V_{2}}{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}, \\  v_{1} : \\frac{7.95544497540356 \\cdot 10^{67} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}, \\  v_{2} : V_{2}, \\  v_{3} : \\frac{4.03027550654688 \\cdot 10^{54} V_{2} s^{4} + 1.59506671756841 \\cdot 10^{70} V_{2} s^{2}}{4.03027550654688 \\cdot 10^{54} s^{4} + 3.18217799016142 \\cdot 10^{70} s^{2} + 6.25 \\cdot 10^{85}}\\right\\}\\)\n\n\n\\(z_{12} = \\frac {V_1}{I_2} \\text{  when  } I_1=0\\)\n\nz12 = (-U_p2[v1]/U_p2[I_V2]).cancel()\nz12 #.simplify()\n\n\\(\\displaystyle \\frac{1.5986612948827 \\cdot 10^{160} s^{7} + 1.26225236414604 \\cdot 10^{176} s^{5} + 2.47914393861815 \\cdot 10^{191} s^{3}}{2.57796398994663 \\cdot 10^{138} s^{10} + 5.09124129667954 \\cdot 10^{154} s^{8} + 4.01586512663364 \\cdot 10^{170} s^{6} + 1.58143650510738 \\cdot 10^{186} s^{4} + 3.10914949136377 \\cdot 10^{201} s^{2} + 2.44140625 \\cdot 10^{216}}\\)\n\n\n\\(z_{22} = \\frac {V_2}{I_2} \\text{  when  } I_1=0\\)\n\nz22 = (-U_p2[v2]/U_p2[I_V2]).cancel()\nz22 #.simplify()\n\n\\(\\displaystyle \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\)\n\n\ndisplaying the z-parameter matrix\n\nMatrix([[z11,z21],[z12,z22]])\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}} & \\frac{3.99665323720675 \\cdot 10^{161} s^{7} + 3.1556309103651 \\cdot 10^{177} s^{5} + 6.19785984654536 \\cdot 10^{192} s^{3}}{6.44490997486657 \\cdot 10^{139} s^{10} + 1.27281032416988 \\cdot 10^{156} s^{8} + 1.00396628165841 \\cdot 10^{172} s^{6} + 3.95359126276846 \\cdot 10^{187} s^{4} + 7.77287372840943 \\cdot 10^{202} s^{2} + 6.103515625 \\cdot 10^{217}}\\\\\\frac{1.5986612948827 \\cdot 10^{160} s^{7} + 1.26225236414604 \\cdot 10^{176} s^{5} + 2.47914393861815 \\cdot 10^{191} s^{3}}{2.57796398994663 \\cdot 10^{138} s^{10} + 5.09124129667954 \\cdot 10^{154} s^{8} + 4.01586512663364 \\cdot 10^{170} s^{6} + 1.58143650510738 \\cdot 10^{186} s^{4} + 3.10914949136377 \\cdot 10^{201} s^{2} + 2.44140625 \\cdot 10^{216}} & \\frac{2.00951838624414 \\cdot 10^{92} s^{5} + 1.58665212071561 \\cdot 10^{108} s^{3} + 3.11628569650484 \\cdot 10^{123} s}{6.39649568809606 \\cdot 10^{83} s^{6} + 7.58201892757332 \\cdot 10^{99} s^{4} + 2.98577794233115 \\cdot 10^{115} s^{2} + 3.90625 \\cdot 10^{130}}\\end{matrix}\\right]\\)\n\n\nThe complete z-parameter matrix is shown above. It’s kind of interesting that the exponents on many of the coefficients are so large. Using the SymPy function lambdify to turn the symbolic expression into a function.\n\nfunc_z11_s = lambdify(s, z11)\nfunc_z12_s = lambdify(s, z12) \nfunc_z21_s = lambdify(s, z21) \nfunc_z22_s = lambdify(s, z22) \n\nUsing the results from above, the input impedance of a two-port network is given by: The input impedance of a two-port network is: \\(Z_{in}=\\frac{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}{Z_{22}+Z_{L}}\\), where \\(Z_{L}\\) is the impedance of the load connected to port two.\n\n# set the source and load impedance\nZl = Zs = 50\n\nw = np.linspace(9e6*2*np.pi, 11e6*2*np.pi, 1000, endpoint=True)\n\nplt.title('Input impedance')\n\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='|Zin|')\nplt.plot(w/(2*np.pi)/1e6, np.real((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Re Zin')\nplt.plot(w/(2*np.pi)/1e6, np.imag((func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))/(func_z22_s(1j*w)+Zl)),'-',label='Im Zin')\n\nplt.ylabel('impedance, ohms')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitude of the input impedance (in blue), the real part of the input impedance (in orange) and the imaginary part of the input impedance (in green). Near 10Hz, the magnitude and real part of the input impedance is 50 ohms and the imaginary part is about zero. This shows that the design equations produced the desired results. The input impedance bandwidth of the filter is about 1 MHz.\nThe voltage gain of the filter calculated from the z-parameters is: \\(K_v=\\frac{Z_{21}Z_{L}}{Z_{11}Z_{22}+Z_{11}Z_{L}-Z_{12}Z_{21}}\\), which is plotted below:\n\nplt.title('Voltage gain')\nplt.plot(w/(2*np.pi)/1e6, np.abs((func_z21_s(1j*w)*Zl)/(func_z11_s(1j*w)*func_z22_s(1j*w)+func_z11_s(1j*w)*Zl-func_z12_s(1j*w)*func_z21_s(1j*w))),'-',label='|Kv|')\nplt.ylabel('Kv')\nplt.xlabel('Frequency, MHz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the voltage gain of the filter (in blue) plotted from the z-parameters. The filter is centered at 10MHz and the bandwidth appears to be 1 MHz.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "href": "Two port parameters.html#convert-z-parameters-to-s-parameters-1",
    "title": "11  Two Port Parameters",
    "section": "11.5 Convert z-parameters to s-parameters",
    "text": "11.5 Convert z-parameters to s-parameters\nAlthough applicable at any frequency, s-parameters are mostly used for networks operating at radio frequency (RF) and microwave frequencies. The s-parameters can be calculated from the z-parameters with the following formulas:\n\nZ_o = 50 # characteristic impedance\n\nw = np.linspace(8e6*2*np.pi, 12e6*2*np.pi, 2000, endpoint=True)\ns11 = np.zeros(len(w),dtype=complex)\ns12 = np.zeros(len(w),dtype=complex)\ns21 = np.zeros(len(w),dtype=complex)\ns22 = np.zeros(len(w),dtype=complex)\n\nfor i in range(len(w)):\n    del_z = (func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i])\n    s11[i] = ((func_z11_s(1j*w[i])-Z_o)*(func_z22_s(1j*w[i])+Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n    s12[i] = (2*func_z12_s(1j*w[i])*Z_o)/del_z\n    s21[i] = (2*func_z21_s(1j*w[i])*Z_o)/del_z\n    s22[i] = ((func_z11_s(1j*w[i])+Z_o)*(func_z22_s(1j*w[i])-Z_o)-func_z12_s(1j*w[i])*func_z21_s(1j*w[i]))/del_z\n\nplt.title('S-parameters')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s11)),'-',label='|s11|dB')\nplt.plot(w/(2*np.pi)/1e6, 20*np.log10(np.abs(s21)),'-',label='|s21|dB')\nplt.ylabel('|S11| & |S21|, dB')\nplt.xlabel('Frequency, MHz')\nplt.ylim((-20,1))\nplt.yticks(np.arange(-20, 1, 5))\n#plt.xlim((-1,20))\n#plt.xticks(np.arange(0, 20+1, 2.0))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the magnitudes in dB of the input reflection coefficient (in blue) and the forward voltage gain (in orange).\nThe magnitude of the input reflection coefficient indicates the amount of energy reflected back to the source due to the impedance mismatch. The smaller the reflection coefficient the better the match, and in dB, large negative values are very small small numbers. A rule of thumb is that |S11| less than about -9.5 dB is a reasonable match, since this corresponds to about a 2:1 VSWR or a mismatch loss of about 0.5 dB. The frequency range over which this match occurs is called the impedance bandwidth.\nThe plot of |S21| shows the forward voltage gain of the filter in dB. The filter was designed to be a band pass filter with a center frequency of 10 MHz, which is clearly shown in the plot. The plot is similar to what would be seen on a network analyzer.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Two port parameters.html#summary",
    "href": "Two port parameters.html#summary",
    "title": "11  Two Port Parameters",
    "section": "11.6 Summary",
    "text": "11.6 Summary\nIn this notebook the parameters for two port networks were generated from the circuit’s netlist. Using python, the circuit equations were automatically generated by using modified nodal analysis, then SymPy was used to solve for the network currents and voltages. Z-parameters were calculated for the circuits, from which y and s parameters were generated. The z-parameters were used to generate input impedance and transfer functions.\nThis notebook has demonstrated that two port parameters can easily be generated from a circuit’s netlist with python.\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Two Port Parameters</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html",
    "href": "Thevenin equivalent circuit.html",
    "title": "12  Thevenin Equivalent Circuit",
    "section": "",
    "text": "12.1 Find the open circuit voltage, Voc\nThe Thevenin equivalent circuit is the reduction of a linear one port circuit to a single source and impedance and is based on Thevenin’s Theorem. This notebook describes solving problem 11.25, given in chapter 11 of Johnson, Hilburn, and Johnson (1978). The Python libraries of SimPy and NumPy are used to perform the math in the proposed solution. The problem asks the student to replace the circuit to the left of terminals a-b by its Thevenin equivalent and find V. The schematic was drawn using LTspice and the nodes were numbered. Terminals a-b are across the resistor R3. The circuit given in the textbook does not include a reference node, however the node at the bottom of the schematic was chosen as the reference node, ground.\nHaving drawn the circuit in LTspice, the following netlist was exported as a text file.\nThe component values for the inductors and capacitors are complex as well as the value of the current source. It is assumed that the impedance of the inductors and capacitors are at a frequency of 1 radian per second. So accordingly, the values in the net list used by the Python code to generate the network equations has been adjusted as follows:\nThe component values are not used when the symbolic network equations are generated, only the reference designators, R1, C1, L1 etc. are used.\nRemoving R3 and C2 from the netlist, this gives Voc = V3. The net list is:\nLoad the net list\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.3333333333\n*C2 3 0 0.5\n'''\nCall the symbolic modified nodal analysis function\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\nDisplay the equations\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\nBuild the network equation matrix\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\- I_{L2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}}\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  s, \\  v_{2}, \\  I_{L2}, \\  v_{3}, \\  R_{2}\\right)\\)\nGenerate the symbolic solution\nU_sym = solve(NE_sym,X)\nDisplay the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} L_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} L_{2} R_{1} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\)\\(v_{2} = \\frac{I_{1} L_{1} R_{1} s}{L_{1} s + R_{1}}\\)\\(v_{3} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} R_{1}}{L_{1} s + R_{1}}\\)\\(I_{L2} = \\frac{I_{1}}{C_{1} L_{2} s^{2} + C_{1} R_{2} s + 1}\\)\nConstruct a dictionary of element values\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.3333333333, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0\\right\\}\\)\nTo solve numerically, replace symbols with the element values and the Laplace variable, s, with \\(j\\omega\\) where \\(\\omega=1\\).\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.3333333333 i v_{1} - 0.3333333333 i v_{2}\\\\I_{L1} - 0.3333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.3333333333 i\\right) - 0.166666666666667 v_{3}\\\\- I_{L2} - 0.166666666666667 v_{2} + 0.166666666666667 v_{3}\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\nSolving the system of equations for the open circuit voltage at node v3.\nVoc = solve(NE,X)[v3]\nVoc\n\n\\(\\displaystyle -1.8 + 0.6 i\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Thevenin Equivalent Circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "href": "Thevenin equivalent circuit.html#find-the-open-circuit-voltage-voc",
    "title": "12  Thevenin Equivalent Circuit",
    "section": "",
    "text": "I1 0 1 1\nR1 2 0 6\nR2 3 2 6\n*R3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\n*C2 3 0 0.5",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Thevenin Equivalent Circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "href": "Thevenin equivalent circuit.html#find-the-short-circuit-current-isc",
    "title": "12  Thevenin Equivalent Circuit",
    "section": "12.2 Find the short circuit current, Isc",
    "text": "12.2 Find the short circuit current, Isc\nRemove C2 and R3, set node 3 to zero, find current in L2 and R2. New net list:\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 0 2 6\nL1 2 0 2\nL2 1 0 3\nC1 1 2 0.33333333333333\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right)\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  s, \\  v_{2}, \\  I_{L2}, \\  R_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + I_{1} L_{1} L_{2} R_{1} s^{2} + I_{1} L_{1} L_{2} R_{2} s^{2} + I_{1} L_{2} R_{1} R_{2} s}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(v_{2} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(I_{L1} = \\frac{C_{1} I_{1} L_{2} R_{1} R_{2} s^{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\\(I_{L2} = \\frac{C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\n\n\n\nU_sym[v2]/R2 + U_sym[I_L2]\n\n\\(\\displaystyle \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} s^{3}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}} + \\frac{C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} R_{1} R_{2}}{C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + L_{1} R_{1} s + L_{1} R_{2} s + R_{1} R_{2}}\\)\n\n\nConstruct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.33333333333333, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0\\right\\}\\)\n\n\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.33333333333333 i v_{1} - 0.33333333333333 i v_{2}\\\\I_{L1} - 0.33333333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.33333333333333 i\\right)\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\nU\n\n\\(\\displaystyle \\left\\{ I_{L1} : -1.5 - 1.5 i, \\  I_{L2} : -0.5 + 1.5 i, \\  v_{1} : -4.5 - 1.5 i, \\  v_{2} : 3.0 - 3.0 i\\right\\}\\)\n\n\n\nIsc = U[v2]/6 + U[I_L2]\nIsc\n\n\\(\\displaystyle 1.0 i\\)\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\(\\displaystyle 0.6 + 1.8 i\\)\n\n\n\nCurrent in I_R2 = V2/R2\n\nIsc = U[v2]/6 + U[I_L2]\nIsc\n\n\\(\\displaystyle 1.0 i\\)\n\n\n\nZth = simplify(Voc/Isc)\nZth\n\n\\(\\displaystyle 0.6 + 1.8 i\\)\n\n\nVoc along with Zth are the values to the Thevenin equivalent circuit.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Thevenin Equivalent Circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-thevenin-equivalent-circuit",
    "title": "12  Thevenin Equivalent Circuit",
    "section": "12.3 Find V3 using the Thevenin equivalent circuit",
    "text": "12.3 Find V3 using the Thevenin equivalent circuit\nThe load attached to the Thevenin equivalent circuit is the parallel of the resistor and capacitor.\n\\(Z = \\frac{1}{\\frac{1}{R}+\\frac{1}{C}}\\)\nThe load \\(Z\\) is the parallel combination of R = 6 and C = -j2.\n\nZ = (1)/(1/(6)+1/(-2j))\nZ\n\n(0.6-1.7999999999999998j)\n\n\nUsing the values for \\(V_{oc}\\) and \\(Z_{th}\\) obtained above, we write the equation for V3 as a voltage divider and have SymPy simplify the result.\n\nsimplify(Z*Voc/(Zth+Z))\n\n\\(\\displaystyle 4.62592926927148 \\cdot 10^{-16} + 3.0 i\\)\n\n\nWe can get SymPy to ignore small numbers by using the round function set to 3 digits.\n\nsimplify(Z*Voc/(Zth+Z)).round(3)\n\n\\(\\displaystyle 3.0 i\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Thevenin Equivalent Circuit</span>"
    ]
  },
  {
    "objectID": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "href": "Thevenin equivalent circuit.html#find-v3-using-the-complete-circuit",
    "title": "12  Thevenin Equivalent Circuit",
    "section": "12.4 Find V3 using the complete circuit",
    "text": "12.4 Find V3 using the complete circuit\nChecking the answer for V3, by solving the equations for the complete circuit. The net list is:\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.33\nC2 3 0 0.5\nDeclare the symbols and equations for the complete circuit.\n\nnet_list = '''\nI1 0 1 1\nR1 2 0 6\nR2 3 2 6\nR3 0 3 6\nL1 2 0 2\nL2 1 3 3\nC1 1 2 0.333333333333333\nC2 3 0 0.5\n'''\n\nCall the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L2} = I_{1}\\)\\(- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{3} = 0\\)\n\n\nBuild the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s v_{1} - C_{1} s v_{2} + I_{L2}\\\\- C_{1} s v_{1} + I_{L1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\\\- I_{L2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\\\- I_{L1} L_{1} s + v_{2}\\\\- I_{L2} L_{2} s + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  L_{1}, \\  v_{1}, \\  R_{1}, \\  C_{1}, \\  I_{L1}, \\  I_{1}, \\  R_{3}, \\  s, \\  v_{2}, \\  I_{L2}, \\  v_{3}, \\  R_{2}, \\  C_{2}\\right)\\)\n\n\nSymbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{1} C_{2} I_{1} L_{1} L_{2} R_{1} R_{2} R_{3} s^{4} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + C_{2} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{2} I_{1} L_{1} L_{2} R_{2} R_{3} s^{3} + C_{2} I_{1} L_{2} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} L_{2} R_{1} s^{2} + I_{1} L_{1} L_{2} R_{2} s^{2} + I_{1} L_{1} L_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} L_{2} R_{1} R_{2} s + I_{1} L_{2} R_{1} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{2} = \\frac{C_{1} C_{2} I_{1} L_{1} L_{2} R_{1} R_{2} R_{3} s^{4} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{2} s^{3} + C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(v_{3} = \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L1} = \\frac{C_{1} C_{2} I_{1} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} I_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} I_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} I_{1} R_{1} R_{2} R_{3} s + I_{1} R_{1} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\\(I_{L2} = \\frac{C_{1} C_{2} I_{1} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} s^{2} + C_{2} I_{1} L_{1} R_{1} R_{3} s^{2} + C_{2} I_{1} L_{1} R_{2} R_{3} s^{2} + C_{2} I_{1} R_{1} R_{2} R_{3} s + I_{1} L_{1} R_{1} s + I_{1} L_{1} R_{2} s + I_{1} L_{1} R_{3} s + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\n\nU_sym[v3]\n\n\\(\\displaystyle \\frac{C_{1} I_{1} L_{1} L_{2} R_{1} R_{3} s^{3} + C_{1} I_{1} L_{1} R_{1} R_{2} R_{3} s^{2} + I_{1} L_{1} R_{1} R_{3} s + I_{1} L_{1} R_{2} R_{3} s + I_{1} R_{1} R_{2} R_{3}}{C_{1} C_{2} L_{1} L_{2} R_{1} R_{3} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{2} L_{1} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} L_{1} L_{2} R_{1} s^{3} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{3} s^{3} + C_{1} L_{1} R_{1} R_{2} s^{2} + C_{1} L_{1} R_{2} R_{3} s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{3} s^{2} + C_{1} R_{1} R_{2} R_{3} s + C_{2} L_{1} R_{1} R_{3} s^{2} + C_{2} L_{1} R_{2} R_{3} s^{2} + C_{2} R_{1} R_{2} R_{3} s + L_{1} R_{1} s + L_{1} R_{2} s + L_{1} R_{3} s + R_{1} R_{2} + R_{1} R_{3}}\\)\n\n\nConstruct a dictionary of element values\nelement_values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.333333333333333, \\  C_{2} : 0.5, \\  I_{1} : 1.0, \\  L_{1} : 2.0, \\  L_{2} : 3.0, \\  R_{1} : 6.0, \\  R_{2} : 6.0, \\  R_{3} : 6.0\\right\\}\\)\n\n\n\n#NE = NE_sym.subs({L1:2, L2:3, R1:6, R2:6, C1:1/3, I1:-1-1j, s:1j})\nNE = NE_sym.subs({s:1j,I1:-1-1j})\nNE = NE.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + 0.333333333333333 i v_{1} - 0.333333333333333 i v_{2}\\\\I_{L1} - 0.333333333333333 i v_{1} + v_{2} \\cdot \\left(0.333333333333333 + 0.333333333333333 i\\right) - 0.166666666666667 v_{3}\\\\- I_{L2} - 0.166666666666667 v_{2} + v_{3} \\cdot \\left(0.333333333333333 + 0.5 i\\right)\\\\- 2.0 i I_{L1} + v_{2}\\\\- 3.0 i I_{L2} + v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}-1.0 - 1.0 i\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving the system of equations for v3 using the SymPy solve function.\n\nU = solve(NE,X)\nU[v3]\n\n\\(\\displaystyle 3.0 i\\)\n\n\n\nThe value obtained by solving the system equations for the complete network agrees with the Thevenin equivalent circuit solution.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Thevenin Equivalent Circuit</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html",
    "href": "State-variable-filter.html",
    "title": "13  State Variable Filter",
    "section": "",
    "text": "13.1 Introduction\nA state variable filter using opamps was first described by Tow (1968). The filter shown in the schematic below has low pass (LP), high pass (HP) and band pass (BP) outputs. For certain combinations of resistors and capacitors, the natural frequency and Q of filter can be independently determined. All the element values are assigned a value of 1, since they will be assigned as part of the filter design process.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#introduction",
    "href": "State-variable-filter.html#introduction",
    "title": "13  State Variable Filter",
    "section": "",
    "text": "Figure 13.1: State variable filter",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#circuit-description",
    "href": "State-variable-filter.html#circuit-description",
    "title": "13  State Variable Filter",
    "section": "13.2 Circuit description",
    "text": "13.2 Circuit description\nThe circuit in Figure 13.1 has 10 branches and eight nodes. There are two capacitors, seven resistors in the circuit and three Op Amps. The circuit has a low pass, a high pass and band pass outputs.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#circuit-analysis",
    "href": "State-variable-filter.html#circuit-analysis",
    "title": "13  State Variable Filter",
    "section": "13.3 Circuit analysis",
    "text": "13.3 Circuit analysis\nThe circuit was drawn using LTSpice and the netlist was pasted into the code. Network equations were generated using the smna() function and a symbolic solution for the equations was obtained. The characteristic equation was obtained and coeficients of the equation were extracted so that the symbols could be equated to parameters known as Q and damping ratio. These were symplified by by letting R = R1 = R3 = R4 = R5 = R6 = R7 and C = C1 = C2. By letting C = 0.1\\(\\mu\\)F, R was solved for to get a natural frequency of 1kHz. R2 was then solved for to get a Q of 3. Substituting component values into the equations, the filter was analyzed to obtain frequency and phase plots, impulse and step response and group delay.\nThe net list for the filter is:\nR3 3 1 1\nR6 6 4 1\nR7 8 7 1\nR5 4 3 1\nR2 7 5 1\nC1 7 6 1\nC2 2 8 1\nO1 3 5 4 \nO2 6 0 7 \nV1 1 0 1\nO3 8 0 2 \nR1 5 0 1\nR4 2 3 1\nThe following Python modules are used.\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#load-the-net-list",
    "href": "State-variable-filter.html#load-the-net-list",
    "title": "13  State Variable Filter",
    "section": "13.4 Load the net list",
    "text": "13.4 Load the net list\n\nnet_list = '''\nR3 3 1 1\nR6 6 4 1\nR7 8 7 1\nR5 4 3 1\nR2 7 5 1\nC1 7 6 1\nC2 2 8 1\nO1 3 5 4 \nO2 6 0 7 \nV1 1 0 1\nO3 8 0 2 \nR1 5 0 1\nR4 2 3 1\n'''",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "State-variable-filter.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "13  State Variable Filter",
    "section": "13.5 Call the symbolic modified nodal analysis function",
    "text": "13.5 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}} = 0\\)\\(- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}} = 0\\)\\(I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}} = 0\\)\\(- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}} = 0\\)\\(- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{5} = 0\\)\\(v_{6} = 0\\)\\(v_{8} = 0\\)\n\n\n\n13.5.1 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{3}}\\\\- C_{2} s v_{8} + I_{O3} + v_{2} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{3}}{R_{4}}\\\\v_{3} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{4}}{R_{5}} - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{3}}\\\\I_{O1} + v_{4} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{6}}{R_{6}} - \\frac{v_{3}}{R_{5}}\\\\v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{7}}{R_{2}}\\\\- C_{1} s v_{7} + v_{6} \\left(C_{1} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{4}}{R_{6}}\\\\- C_{1} s v_{6} + I_{O2} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{5}}{R_{2}}\\\\- C_{2} s v_{2} + v_{8} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}}\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  v_{8}, \\  v_{2}, \\  R_{7}, \\  C_{2}, \\  I_{O3}, \\  v_{3}, \\  R_{3}, \\  s, \\  R_{1}, \\  v_{1}, \\  I_{O1}, \\  R_{6}, \\  v_{7}, \\  I_{O2}, \\  v_{5}, \\  R_{5}, \\  V_{1}, \\  R_{2}, \\  I_{V1}, \\  v_{6}, \\  v_{4}, \\  R_{4}\\right)\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#symbolic-solution",
    "href": "State-variable-filter.html#symbolic-solution",
    "title": "13  State Variable Filter",
    "section": "13.6 Symbolic solution",
    "text": "13.6 Symbolic solution\nThe symbolic solution of the network equations takes about 50 seconds to solve on my laptop (i3-8130U CPU @ 2.20GHz).\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{1} R_{4} R_{5} V_{1} - R_{2} R_{4} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{3} = \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{4} = \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{6} R_{7} V_{1} s^{2}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{5} = \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{6} = 0\\)\\(v_{7} = \\frac{C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(v_{8} = 0\\)\\(I_{V1} = \\frac{- C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{7} V_{1} s - C_{2} R_{1} R_{5} R_{7} V_{1} s - R_{1} R_{5} V_{1} - R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(I_{O1} = \\frac{C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} + C_{1} C_{2} R_{2} R_{4} R_{6} R_{7} V_{1} s^{2} + C_{2} R_{1} R_{4} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(I_{O2} = \\frac{- C_{1} C_{2} R_{1} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{1} C_{2} R_{2} R_{4} R_{5} R_{7} V_{1} s^{2} - C_{2} R_{1} R_{4} R_{5} V_{1} s - C_{2} R_{2} R_{4} R_{5} V_{1} s - C_{2} R_{4} R_{5} R_{7} V_{1} s}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)\\(I_{O3} = \\frac{C_{2} R_{1} R_{4} R_{5} V_{1} s + C_{2} R_{1} R_{5} R_{7} V_{1} s + C_{2} R_{2} R_{4} R_{5} V_{1} s + R_{1} R_{5} V_{1} + R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7} s^{2} + C_{2} R_{1} R_{3} R_{4} R_{7} s + C_{2} R_{1} R_{3} R_{5} R_{7} s + C_{2} R_{1} R_{4} R_{5} R_{7} s + R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#low-pass",
    "href": "State-variable-filter.html#low-pass",
    "title": "13  State Variable Filter",
    "section": "13.7 Low Pass",
    "text": "13.7 Low Pass\nThe low pass transfer function.\n\nH_sym_lp = cancel(U_sym[v2]/V1,s)\nH_sym_lp\n\n\\(\\displaystyle \\frac{- R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}}{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)}\\)\n\n\n\nsym_num, sym_denom = fraction(H_sym_lp,s) #returns numerator and denominator\n\n\nsym_num\n\n\\(\\displaystyle - R_{1} R_{4} R_{5} - R_{2} R_{4} R_{5}\\)\n\n\n\n13.7.1 Characteristic equation\n\nsym_denom\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5} + s^{2} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right) + s \\left(C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\right)\\)\n\n\nGet the coefficients of the Laplace variable, s, from the quadratic equation:\n\\(as^{2}+bs+c=0\\)\n\na = sym_denom.coeff(s**2)\na\n\n\\(\\displaystyle C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\)\n\n\n\nb = sym_denom.coeff(s)\nb\n\n\\(\\displaystyle C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}\\)\n\n\nTo find the c coefficient just subract off \\(bs\\) and \\(cs^2\\) from the quadratic equation.\n\nc = sym_denom - b*s - a*s**2\nc\n\n\\(\\displaystyle R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}\\)\n\n\n\n\n13.7.2 Natural frequency and Q factor\nThe expressions for the natural frequency and Q factor are shown below:\n\\(\\omega _n = \\sqrt {\\frac {c}{a}}\\)\n\\(Q = \\omega _n \\frac {a}{b}\\)\nThese xpressions have their orgin in classical mechanics describing harmonic oscillators and are applicable to 2nd order electrical systems.\nThe damping ratio is defined by the equation:\n\\(\\zeta = \\frac {1}{2Q}\\)\n\nomega_n = sqrt(c/a)\nomega_n\n\n\\(\\displaystyle \\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}}\\)\n\n\n\nQ = (a/b)*omega_n\nQ\n\n\\(\\displaystyle \\frac{\\sqrt{\\frac{R_{1} R_{3} R_{5} + R_{2} R_{3} R_{5}}{C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}}} \\left(C_{1} C_{2} R_{1} R_{3} R_{4} R_{6} R_{7} + C_{1} C_{2} R_{2} R_{3} R_{4} R_{6} R_{7}\\right)}{C_{2} R_{1} R_{3} R_{4} R_{7} + C_{2} R_{1} R_{3} R_{5} R_{7} + C_{2} R_{1} R_{4} R_{5} R_{7}}\\)\n\n\nSimply the expressions for Q and \\(\\omega _n\\) by letting R = R1 = R3 = R4 = R5 = R6 = R7 and C = C1 = C2.\n\nR, C = symbols('R C')\n\n\nsimplify = {\n    R1:R,\n    R3:R,\n    R4:R,\n    R5:R,\n    R6:R,\n    R7:R,\n    C1:C,\n    C2:C}\n\n\nomega_n_simp = omega_n.subs(simplify).factor()\nomega_n_simp\n\n\\(\\displaystyle \\sqrt{\\frac{1}{C^{2} R^{2}}}\\)\n\n\n\nQ_simp = Q.subs(simplify).factor()\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nBy inspection Q could be simplified more, because C cancels out, but we will leave it.\nLet C = 0.1\\(\\mu\\)F, solve for R to get a natural frequency of 1kHz.\n\nomega_n_simp = omega_n_simp.subs({C:0.1e-6})\nomega_n_simp\n\n\\(\\displaystyle 10000000.0 \\sqrt{\\frac{1}{R^{2}}}\\)\n\n\n\nRnew = solve(Eq(omega_n_simp,1e3*2*np.pi),R)\nRnew\n\n\\(\\displaystyle \\left[ -1591.54943091895, \\  1591.54943091895\\right]\\)\n\n\n\nRnew = float(Rnew[1])\nRnew\n\n\\(\\displaystyle 1591.54943091895\\)\n\n\nWith R and C chosen,\n\nQ_simp\n\n\\(\\displaystyle \\frac{C \\sqrt{\\frac{1}{C^{2} R^{2}}} \\left(R + R_{2}\\right)}{3}\\)\n\n\nSubstituting C=0.1\\(\\mu\\)F and R = Rnew into Q_simp\n\nQ_simp = Q_simp.subs({C:0.1e-6,R:Rnew})\nQ_simp\n\n\\(\\displaystyle 0.00020943951023932 R_{2} + 0.333333333333333\\)\n\n\nSolve for R2 for the desired Q=3.\n\nR2new = solve(Eq(Q_simp,3),R2)\nR2new = R2new[0]\nR2new\n\n\\(\\displaystyle 12732.3954473516\\)\n\n\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {\n    V1:1,\n    R3:Rnew,\n    R6:Rnew,\n    R7:Rnew,\n    R5:Rnew,\n    R2:R2new,\n    C1:0.1e-6,\n    C2:0.1e-6,\n    R1:Rnew,\n    R4:Rnew}\n\n\nQ.subs(nominal_component_value)\n\n\\(\\displaystyle 3.0\\)\n\n\n\nomega_n.subs(nominal_component_value)/(2*np.pi)\n\n\\(\\displaystyle 1000.0\\)\n\n\n\ndamping_ratio = 1/(2*Q.subs(nominal_component_value))\ndamping_ratio\n\n\\(\\displaystyle 0.166666666666667\\)\n\n\n\n\n13.7.3 Numerical solution\n\n# put the element values into the equations\nNE = NE_sym.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instead of symbols.\n\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.000628318530717959 v_{1} - 0.000628318530717959 v_{3}\\\\I_{O3} - 1.0 \\cdot 10^{-7} s v_{8} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right) - 0.000628318530717959 v_{3}\\\\- 0.000628318530717959 v_{1} - 0.000628318530717959 v_{2} + 0.00188495559215388 v_{3} - 0.000628318530717959 v_{4}\\\\I_{O1} - 0.000628318530717959 v_{3} + 0.00125663706143592 v_{4} - 0.000628318530717959 v_{6}\\\\0.000706858347057704 v_{5} - 7.8539816339745 \\cdot 10^{-5} v_{7}\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000628318530717959 v_{4} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-7} s v_{6} - 7.8539816339745 \\cdot 10^{-5} v_{5} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000706858347057704\\right) - 0.000628318530717959 v_{8}\\\\- 1.0 \\cdot 10^{-7} s v_{2} - 0.000628318530717959 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\\\v_{1}\\\\v_{3} - v_{5}\\\\v_{6}\\\\v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU = solve(NE,X)\n\n\n\n13.7.4 Low pass filter transfer function\n\nH_lp = U[v2]/U[v1]\nH_lp.factor()\n\n\\(\\displaystyle - \\frac{1.0}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\nThe SymPy function, factor(), takes a polynomial and factors it into irreducible factors over the rational numbers. Notice that the value is negative, indicating that the filter configuration is inverting.\n\n13.7.4.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_lp_num, H_lp_denom = fraction(H_lp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\nlp_a = np.array(Poly(H_lp_num, s).all_coeffs(), dtype=float)\nlp_b = np.array(Poly(H_lp_denom, s).all_coeffs(), dtype=float)\nlp_sys = signal.TransferFunction(lp_a,lp_b)\n\n\n\n\n13.7.5 High pass filter transfer function\n\nH_hp = U[v4]/U[v1]\nH_hp.factor()\n\n\\(\\displaystyle - \\frac{2.53302959105844 \\cdot 10^{-8} s^{2}}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_hp_num, H_hp_denom = fraction(H_hp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nhp_a = np.array(Poly(H_hp_num, s).all_coeffs(), dtype=float)\nhp_b = np.array(Poly(H_hp_denom, s).all_coeffs(), dtype=float)\nhp_sys = signal.TransferFunction(hp_a,hp_b)\n\n\n\n13.7.6 Band pass filter transfer function\n\nH_bp = U[v7]/U[v1]\nH_bp.factor()\n\n\\(\\displaystyle \\frac{0.000159154943091895 s}{2.53302959105844 \\cdot 10^{-8} s^{2} + 5.30516476972986 \\cdot 10^{-5} s + 1.0}\\)\n\n\n\nH_bp_num, H_bp_denom = fraction(H_bp) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\nbp_a = np.array(Poly(H_bp_num, s).all_coeffs(), dtype=float)\nbp_b = np.array(Poly(H_bp_denom, s).all_coeffs(), dtype=float)\nbp_sys = signal.TransferFunction(bp_a,bp_b)\n\n\n\n13.7.7 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nlp_sys_zeros = np.roots(lp_sys.num)\nlp_sys_poles = np.roots(lp_sys.den)\n\n\n13.7.7.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(lp_sys_zeros), np.imag(lp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(lp_sys_poles), np.imag(lp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(lp_sys_zeros)))\nfor i in lp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(lp_sys_poles)))\nfor i in lp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-166.67+986.01j Hz\n-166.67-986.01j Hz\n\n\n\n\n\n13.7.8 Stability\nBy inspecting the plot above, we can tell the filter is stable since all the poles of the transfer function are in the left hand plane.\n\n\n13.7.9 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nx_axis_range = np.logspace(2, 4, 5000, endpoint=True)*2*np.pi\nw, lp_mag, lp_phase = lp_sys.bode(w=x_axis_range)\nw, hp_mag, hp_phase = hp_sys.bode(w=x_axis_range)\nw, bp_mag, bp_phase = bp_sys.bode(w=x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# Bode magnitude plot\nplt.semilogx(w/(2*np.pi), lp_mag,'-r')\nplt.semilogx(w/(2*np.pi), hp_mag,'-b')\nplt.semilogx(w/(2*np.pi), bp_mag,'-g')\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k' #'tab:blue'\n\n# Bode phase plot\nplt.semilogx(w/(2*np.pi), lp_phase,':r',label='LP phase')\nplt.semilogx(w/(2*np.pi), hp_phase,':b',label='HP phase')\nplt.semilogx(w/(2*np.pi), bp_phase,':g',label='BP phase')\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='r', label='LP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='b', label='HP magnitude')\nax2.plot(np.NaN, np.NaN, '-', color='g', label='BP magnitude')\n\nplt.legend(loc=0)\nplt.title('Filter Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe Bode plot for the preamplifier is plotted from 100 Hz to 1 kHz.\n\n\n13.7.10 Low pass filter impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(lp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n13.7.11 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(lp_phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#sec-state-space",
    "href": "State-variable-filter.html#sec-state-space",
    "title": "13  State Variable Filter",
    "section": "13.8 State-Space",
    "text": "13.8 State-Space\nThe low pass filter transfer function described above can be converted into a state space representation. The four matrices - A, B, C and D that define the state-space can be obtained with the following code:\n\nlp_ss = lp_sys.to_ss()\n\nThe matrices that form the state equations are printed below:\n\nprint(lp_ss.A)\n\n[[-2.09439510e+03 -3.94784176e+07]\n [ 1.00000000e+00  0.00000000e+00]]\n\n\n\nprint(lp_ss.B)\n\n[[1.]\n [0.]]\n\n\n\nprint(lp_ss.C)\n\n[[        0.         -39478417.60435748]]\n\n\n\nprint(lp_ss.D)\n\n[[0.]]",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "State-variable-filter.html#summary",
    "href": "State-variable-filter.html#summary",
    "title": "13  State Variable Filter",
    "section": "13.9 Summary",
    "text": "13.9 Summary\nA state variable filter was analized. Component values for a filter of Q=3 and natural frequency of 1kHz were derived. Various typical filter performance plots were generated.\n\n\n\n\nTow, J. 1968. “Active RC Filters a State-Space Realization.” Proceedings of the IEEE 56 (6): 1137–39. https://doi.org/10.1109/PROC.1968.6502.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>State Variable Filter</span>"
    ]
  },
  {
    "objectID": "Superposition.html",
    "href": "Superposition.html",
    "title": "14  Superposition",
    "section": "",
    "text": "14.1 Circuit description\nThe circuit shown above is a large non-planar circuit designed to look at the problem of multiple sources with different phases and frequencies.\nIn linear circuit analysis, the superposition theorem states that the total response (voltage or current) in any branch of a linear circuit containing multiple independent sources is equal to the algebraic sum of the responses caused by each source acting alone. To apply this principle, you “turn off” all independent sources except one: voltage sources are replaced by a short circuit (setting \\(V=0\\)), and current sources are replaced by an open circuit (setting \\(I=0\\)). This allows you to simplify a complex, multi-source network into several single-source sub-circuits that are easier to solve using basic Ohm’s Law and Kirchhoff’s Laws.\nThe circuit in Figure 14.1 is has 23 branches and 14 nodes. There are two dependent sources. V1 is a voltage source with a DC value of 5 volts and an AC value of 7 volts which has a phase of 135 degrees with a frequency of 3 Hz. I1 is a current source with a DC value of 2 amps and an AC value of 3 amps which has a phase of 300 degrees and a frequency of 7 Hz, as shaown in Table 14.1. There are two dependent sources. H1 is a current controlled voltage source with a gain of 2 and the controlling current is the current through V2. The voltage source V2, set to a value of zero volts, was included in the circuit to provide a monitoring point for the current in R9. The other dependednt source, G1, is a voltage controlled voltage source which has a gain of 2 and is controlled by the votages on nodes 2 and 8. The circuit also has a pair of coupled inductors, two inductors, three capacitors and 11 resistors.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#circuit-description",
    "href": "Superposition.html#circuit-description",
    "title": "14  Superposition",
    "section": "",
    "text": "Table 14.1: Dependent sources\n\n\n\n\n\nsource\nDC\nMagnitude \\(\\angle\\) angle\nfrequency, Hz\n\n\n\n\nV1\n5\n\\(7 \\angle 135^{\\circ}\\)\n3\n\n\nI1\n2\n\\(3 \\angle 300^{\\circ}\\)\n7",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#circuit-analysis",
    "href": "Superposition.html#circuit-analysis",
    "title": "14  Superposition",
    "section": "14.2 Circuit analysis",
    "text": "14.2 Circuit analysis\nThe MNA technique will be used analyze the circuit using the componet values shown in the schematic since the circuit is too large for meaninful symbolic analysis. The symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and removed the code. The analysis will cover the four areas listed below.\n\nDC operating point with \\(s=j \\omega\\) set to zero and the circuit driven by the DC values of the independent sources.\nAC analysis with V1 having a frequency of 3 Hz and I1 having a frequency of 7 Hz.\nTotal response of the DC and AC sources at the respective frequencies.\n\nThe results obtained from MNA will be compared to those obtained from LTSpice.\nThe netlist generated by LTSpice is listed below:\nV1 6 1 5 AC 7 135\nV2 10 12 0 AC 0 0\nI1 3 4 2 AC 3 300\nL3 11 14 3 Rser=0\nL1 1 5 5 Rser=0\nL4 14 13 2 Rser=0\nL2 4 8 7 Rser=0\nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\nThe following Python modules are used in this analysis.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\nIn electrical engineering, a time invarient sinusudial signals can be represented either by polar or rectangular notation. The function polar converts the polar representation, also called a phasor to rectangular notation and the second function converts rectangular notation to magnitude and phase.\n\ndef polar2rec(mag, ang, units='deg'):\n    ''' polar to rectangular conversion\n        mag: float\n            magnitude of the time invarient sinusudial signal\n        ang: float\n            the angle of the time invarient sinusudial signal\n        units: string\n            if units is set to deg, and is in degrees not radians\n        returns: complex\n            rectangular corrdinates of voltage vector\n    '''\n    if units == 'deg':\n        ang = ang * np.pi / 180\n    return mag * np.exp(1j * ang)\n\ndef rec2polar(value):\n    '''rectangular to polar conversion\n    value: complex float\n        \n    returns:\n        magnitude, phase (in degrees)\n    '''\n    return float(abs(value)), float(arg(value)*180/np.pi)\n\n\n14.2.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 6 1 5 \nV2 10 12 0 \nI1 3 4 2 \nL3 11 14 3 \nL1 1 5 5 \nL4 14 13 2 \nL2 4 8 7 \nH1 7 3 V2 2\nG1 12 14 8 2 2\nC1 3 1 0.02279\nC2 4 13 0.008443\nC3 13 12 0.01266\nR9 2 10 10\nR6 7 0 50\nR4 5 14 1\nR1 1 2 100\nR3 3 4 75\nR7 0 8 200\nR11 14 12 10\nR5 6 9 10\nR10 9 11 1\nR8 9 0 100\nR2 3 12 20\nK1 L3 L4 0.4\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}} = - I_{1}\\)\\(- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}} = I_{1}\\)\\(- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}} = 0\\)\\(I_{H1} + \\frac{v_{7}}{R_{6}} = 0\\)\\(- I_{L2} + \\frac{v_{8}}{R_{7}} = 0\\)\\(v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}} = 0\\)\\(I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}} = 0\\)\\(I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}} = 0\\)\\(- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}} = 0\\)\\(- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right) = 0\\)\\(- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}} = 0\\)\\(- v_{1} + v_{6} = V_{1}\\)\\(v_{10} - v_{12} = V_{2}\\)\\(- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14} = 0\\)\\(- I_{L2} L_{2} s + v_{4} - v_{8} = 0\\)\\(- I_{V2} h_{1} - v_{3} + v_{7} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{3} + I_{L1} - I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{9}} - \\frac{v_{1}}{R_{1}}\\\\- C_{1} s v_{1} - I_{H1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{12}}{R_{2}}\\\\- C_{2} s v_{13} + I_{L2} + v_{4} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\\\- I_{L1} - \\frac{v_{14}}{R_{4}} + \\frac{v_{5}}{R_{4}}\\\\I_{V1} + \\frac{v_{6}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\I_{H1} + \\frac{v_{7}}{R_{6}}\\\\- I_{L2} + \\frac{v_{8}}{R_{7}}\\\\v_{9} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{11}}{R_{10}}\\\\I_{V2} + \\frac{v_{10}}{R_{9}} - \\frac{v_{2}}{R_{9}}\\\\I_{L3} + \\frac{v_{11}}{R_{10}} - \\frac{v_{9}}{R_{10}}\\\\- C_{3} s v_{13} - I_{V2} - g_{1} v_{2} + g_{1} v_{8} + v_{12} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{14}}{R_{11}}\\\\- C_{2} s v_{4} - C_{3} s v_{12} - I_{L4} + v_{13} \\left(C_{2} s + C_{3} s\\right)\\\\- I_{L3} + I_{L4} + g_{1} v_{2} - g_{1} v_{8} + v_{14} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{12}}{R_{11}}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- I_{L3} L_{3} s - I_{L4} M_{1} s + v_{11} - v_{14}\\\\- I_{L1} L_{1} s + v_{1} - v_{5}\\\\- I_{L3} M_{1} s - I_{L4} L_{4} s - v_{13} + v_{14}\\\\- I_{L2} L_{2} s + v_{4} - v_{8}\\\\- I_{V2} h_{1} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\- I_{1}\\\\I_{1}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{10}, \\  R_{10}, \\  R_{3}, \\  R_{5}, \\  R_{9}, \\  V_{2}, \\  R_{7}, \\  s, \\  I_{1}, \\  C_{3}, \\  R_{2}, \\  v_{14}, \\  I_{L3}, \\  I_{L4}, \\  L_{3}, \\  R_{11}, \\  I_{H1}, \\  R_{6}, \\  R_{8}, \\  L_{4}, \\  C_{2}, \\  v_{13}, \\  v_{11}, \\  R_{1}, \\  g_{1}, \\  I_{V2}, \\  v_{3}, \\  v_{9}, \\  R_{4}, \\  v_{2}, \\  v_{12}, \\  v_{6}, \\  I_{L2}, \\  I_{L1}, \\  I_{V1}, \\  L_{2}, \\  C_{1}, \\  V_{1}, \\  L_{1}, \\  v_{8}, \\  h_{1}, \\  v_{4}, \\  v_{5}, \\  M_{1}, \\  v_{1}, \\  v_{7}\\right)\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#dc-operating-point",
    "href": "Superposition.html#dc-operating-point",
    "title": "14  Superposition",
    "section": "14.3 DC operating point",
    "text": "14.3 DC operating point\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\nK1 = symbols('K1')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.979795897\n\n\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\nNE_dc  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + 0.01 v_{1} - 0.01 v_{2}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.05 v_{12} + 0.0633333333333333 v_{3} - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.0133333333333333 v_{3} + 0.0133333333333333 v_{4}\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + 0.15 v_{12} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\v_{11} - v_{14}\\\\v_{1} - v_{5}\\\\- v_{13} + v_{14}\\\\v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_dc = solve(NE_dc,X)\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown             mag\n---------  ------------\nv1         -1444.606764\nv2           701.805800\nv3           626.530983\nv4           564.749806\nv5         -1444.606764\nv6         -1439.606764\nv7           583.602732\nv8           564.749806\nv9         -1449.580366\nv10          916.447056\nv11        -1465.073530\nv12          916.447056\nv13        -1465.073530\nv14        -1465.073530\nI_V1          -0.997360\nI_V2         -21.464126\nI_L3          15.493164\nI_L1          20.466765\nI_L4           0.000000\nI_L2           2.823749\nI_H1         -11.672055\n\n\nLTSpice results:\n       --- Operating Point ---\n\nV(6):    -1439.61    voltage\nV(1):    -1444.61    voltage\nV(10):   916.447     voltage\nV(12):   916.447     voltage\nV(3):    626.531     voltage\nV(4):    564.75  voltage\nV(11):   -1465.07    voltage\nV(14):   -1465.07    voltage\nV(5):    -1444.61    voltage\nV(13):   -1465.07    voltage\nV(8):    564.75  voltage\nV(7):    583.603     voltage\nV(2):    701.806     voltage\nV(9):    -1449.58    voltage\nI(C1):   4.72012e-11     device_current\nI(C2):   1.71378e-11     device_current\nI(C3):   -3.015e-11  device_current\nI(H1):   -11.6721    device_current\nI(L3):   15.4932     device_current\nI(L1):   20.4668     device_current\nI(L4):   -4.72875e-11    device_current\nI(L2):   2.82375     device_current\nI(I1):   2   device_current\nI(R9):   -21.4641    device_current\nI(R6):   11.6721     device_current\nI(R4):   20.4668     device_current\nI(R1):   -21.4641    device_current\nI(R3):   0.823749    device_current\nI(R7):   -2.82375    device_current\nI(R11):  -238.152    device_current\nI(R5):   0.99736     device_current\nI(R10):  15.4932     device_current\nI(R8):   -14.4958    device_current\nI(R2):   -14.4958    device_current\nI(G1):   -274.112    device_current\nI(V1):   -0.99736    device_current\nI(V2):   -21.4641    device_current\nStore the results in a Pandas dataframe.\n\nsolutions = pd.DataFrame(U_dc.items(), columns=['unk', 'w=DC'])\nsolutions = solutions.set_index('unk')\nsolutions['w=DC'] = solutions['w=DC'].astype(float)\n#solutions",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#independent-sources-each-with-a-different-frequency",
    "href": "Superposition.html#independent-sources-each-with-a-different-frequency",
    "title": "14  Superposition",
    "section": "14.4 Independent sources each with a different frequency",
    "text": "14.4 Independent sources each with a different frequency\nThe independent sources V1 and I1 each have different amplitudes, phases and frequencies. First we will solve the network equations for when V1 is active and I1 is set to zero. The following code set I1 to zero and calls the function polar2rec to convert the amplitude and phase to rectangular notation.\n\nelement_values[I1] = 0\nelement_values[V1] = polar2rec(7, 135, units='deg')\n\nSolve equations for \\(\\omega\\) equal to 3 Hz. The value for \\(\\omega\\) is calculated by: \\(\\omega = 2 \\pi 3\\), then use the substitute function to set \\(s = 2 \\pi 3j\\). Then display the network equations with numerical values.\n\nomega = 2*np.pi*3\nNE_w1 = NE_sym.subs(element_values)\nNE_w1 = NE_w1.subs({s:omega*1j})\nNE_w1\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 0.429581379451868 i\\right) - 0.01 v_{2} - 0.429581379451868 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 0.429581379451868 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 0.429581379451868 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.159146800645552 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.159146800645552 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.238635377966681 i\\right) - 0.238635377966681 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.238635377966681 i v_{12} + 0.397782178612232 i v_{13} - 0.159146800645552 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 56.5486677646163 i I_{L3} - 18.4687175543308 i I_{L4} + v_{11} - v_{14}\\\\- 94.2477796076938 i I_{L1} + v_{1} - v_{5}\\\\- 18.4687175543308 i I_{L3} - 37.6991118430775 i I_{L4} - v_{13} + v_{14}\\\\- 131.946891450771 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\-4.94974746830583 + 4.94974746830583 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_w1 = solve(NE_w1,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.214165    -42.658172\nv2         5.054599     39.141345\nv3         1.983213    -32.248064\nv4         5.501867     67.083943\nv5         7.598113    -22.913101\nv6         5.787062    134.508799\nv7         1.977375    -35.152486\nv8         4.592470     33.669731\nv9         5.241567    168.957875\nv10        5.544043     40.383410\nv11        5.350944    172.465292\nv12        5.544043     40.383410\nv13        5.619390     60.869229\nv14        7.602773    -23.429285\nI_V1       0.330707   -109.201912\nI_V2       0.050272   -127.028107\nI_L3       0.342104     62.074687\nI_L1       0.068631     70.722730\nI_L4       0.389029   -137.950576\nI_L2       0.022962     33.669731\nI_H1       0.039547    144.847514\n\n\nThe results from LTSpice as shown below and they agree with the Python results. The DC values for the sources, V1 and I1, are set to zero.\n       --- AC Analysis ---\n\nfrequency:  3   Hz\nV(6):   mag:    5.78706 phase:    134.509°  voltage\nV(1):   mag:    1.21416 phase:   -42.6582°  voltage\nV(10):  mag:    5.54404 phase:    40.3834°  voltage\nV(12):  mag:    5.54404 phase:    40.3834°  voltage\nV(3):   mag:    1.98321 phase:   -32.2481°  voltage\nV(4):   mag:    5.50187 phase:    67.0839°  voltage\nV(11):  mag:    5.35094 phase:    172.465°  voltage\nV(14):  mag:    7.60277 phase:   -23.4293°  voltage\nV(5):   mag:    7.59811 phase:   -22.9131°  voltage\nV(13):  mag:    5.61939 phase:    60.8692°  voltage\nV(8):   mag:    4.59247 phase:    33.6697°  voltage\nV(7):   mag:    1.97737 phase:   -35.1525°  voltage\nV(2):   mag:     5.0546 phase:    39.1413°  voltage\nV(9):   mag:    5.24157 phase:    168.958°  voltage\nI(C1):  mag:   0.351813 phase:    73.2905°  device_current\nI(C2):  mag:  0.0977425 phase:   -105.008°  device_current\nI(C3):  mag:   0.474046 phase:   -131.513°  device_current\nI(H1):  mag:  0.0395475 phase:    144.848°  device_current\nI(L3):  mag:   0.342104 phase:    62.0747°  device_current\nI(L1):  mag:  0.0686314 phase:    70.7227°  device_current\nI(L4):  mag:   0.389029 phase:   -137.951°  device_current\nI(L2):  mag:  0.0229624 phase:    33.6697°  device_current\nI(I1):  mag:          0 phase:         -0°  device_current\nI(R9):  mag:  0.0502717 phase:   -127.028°  device_current\nI(R6):  mag:  0.0395475 phase:   -35.1525°  device_current\nI(R4):  mag:  0.0686314 phase:    70.7227°  device_current\nI(R1):  mag:  0.0502717 phase:   -127.028°  device_current\nI(R3):  mag:  0.0819131 phase:   -94.3412°  device_current\nI(R7):  mag:  0.0229624 phase:    -146.33°  device_current\nI(R11): mag:   0.716494 phase:   -67.4048°  device_current\nI(R5):  mag:   0.330707 phase:    70.7981°  device_current\nI(R10): mag:   0.342104 phase:    62.0747°  device_current\nI(R8):  mag:  0.0524157 phase:    168.958°  device_current\nI(R2):  mag:   0.265071 phase:   -118.698°  device_current\nI(G1):  mag:      1.304 phase:   -98.6653°  device_current\nI(V1):  mag:   0.330707 phase:   -109.202°  device_current\nI(V2):  mag:  0.0502717 phase:   -127.028°  device_current\n\nw1 = pd.DataFrame(U_w1.items(), columns=['unk', 'w=3Hz'])\nw1 = w1.set_index('unk')\nw1['w=3Hz'] = w1['w=3Hz'].astype(complex)\nsolutions['w=3Hz'] = w1['w=3Hz']\n#solutions\n\nSolve the network equations with V1 set to zero and I1 active with a frequency of 7 Hz, an amplitude of 3 at a phase angle of 300.\n\nelement_values[I1] = polar2rec(3, 300, units='deg')\nelement_values[V1] = 0 #polar2rec(7, 135, units='deg')\n\nSolve equations for \\(\\omega\\) equal to 7 Hz. The value for \\(\\omega\\) is calculated by: \\(\\omega = 2 \\pi 7\\)\n\nomega = 2*np.pi*7\nNE_w2 = NE_sym.subs(element_values)\nNE_w2 = NE_w2.subs({s:omega*1j})\nNE_w2\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} - I_{V1} + v_{1} \\cdot \\left(0.01 + 1.00235655205436 i\\right) - 0.01 v_{2} - 1.00235655205436 i v_{3}\\\\- 0.01 v_{1} - 0.1 v_{10} + 0.11 v_{2}\\\\- I_{H1} - 1.00235655205436 i v_{1} - 0.05 v_{12} + v_{3} \\cdot \\left(0.0633333333333333 + 1.00235655205436 i\\right) - 0.0133333333333333 v_{4}\\\\I_{L2} - 0.371342534839621 i v_{13} - 0.0133333333333333 v_{3} + v_{4} \\cdot \\left(0.0133333333333333 + 0.371342534839621 i\\right)\\\\- I_{L1} - 1.0 v_{14} + 1.0 v_{5}\\\\I_{V1} + 0.1 v_{6} - 0.1 v_{9}\\\\I_{H1} + 0.02 v_{7}\\\\- I_{L2} + 0.005 v_{8}\\\\- 1.0 v_{11} - 0.1 v_{6} + 1.11 v_{9}\\\\I_{V2} + 0.1 v_{10} - 0.1 v_{2}\\\\I_{L3} + 1.0 v_{11} - 1.0 v_{9}\\\\- I_{V2} + v_{12} \\cdot \\left(0.15 + 0.556815881922255 i\\right) - 0.556815881922255 i v_{13} - 0.1 v_{14} - 2.0 v_{2} - 0.05 v_{3} + 2.0 v_{8}\\\\- I_{L4} - 0.556815881922255 i v_{12} + 0.928158416761876 i v_{13} - 0.371342534839621 i v_{4}\\\\- I_{L3} + I_{L4} - 0.1 v_{12} + 1.1 v_{14} + 2.0 v_{2} - 1.0 v_{5} - 2.0 v_{8}\\\\- v_{1} + v_{6}\\\\v_{10} - v_{12}\\\\- 131.946891450771 i I_{L3} - 43.0936742934386 i I_{L4} + v_{11} - v_{14}\\\\- 219.911485751286 i I_{L1} + v_{1} - v_{5}\\\\- 43.0936742934386 i I_{L3} - 87.9645943005142 i I_{L4} - v_{13} + v_{14}\\\\- 307.8760800518 i I_{L2} + v_{4} - v_{8}\\\\- 2.0 I_{V2} - v_{3} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-1.5 + 2.59807621135332 i\\\\1.5 - 2.59807621135332 i\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_w2 = solve(NE_w2,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w2.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown           mag    phase, deg\n---------  ----------  ------------\nv1           9.005916    163.707427\nv2          32.516027    143.867055\nv3           7.786210    133.896662\nv4          47.805605    173.317623\nv5         269.759059     42.448864\nv6           9.005916    163.707427\nv7           7.302031    133.715779\nv8          26.042563    116.325861\nv9          27.308899    -54.477160\nv10         34.921833    143.365554\nv11         31.025759    -53.448958\nv12         34.921833    143.365554\nv13         41.722434    164.330384\nv14        269.726939     42.183778\nI_V1         3.483553    -45.280685\nI_V2         0.242382    -43.377657\nI_L3         3.753386    134.053052\nI_L1         1.248412    130.841984\nI_L4         5.167787    -51.606488\nI_L2         0.130213    116.325861\nI_H1         0.146041    -46.284221\n\n\nThe results from LTSpice as shown below and they agree with the Python results.\n       --- AC Analysis ---\n\nfrequency:  7   Hz\nV(6):   mag:    9.00592 phase:    163.707°  voltage\nV(1):   mag:    9.00592 phase:    163.707°  voltage\nV(10):  mag:    34.9218 phase:    143.366°  voltage\nV(12):  mag:    34.9218 phase:    143.366°  voltage\nV(3):   mag:    7.78621 phase:    133.897°  voltage\nV(4):   mag:    47.8056 phase:    173.318°  voltage\nV(11):  mag:    31.0258 phase:    -53.449°  voltage\nV(14):  mag:    269.727 phase:    42.1838°  voltage\nV(5):   mag:    269.759 phase:    42.4489°  voltage\nV(13):  mag:    41.7224 phase:     164.33°  voltage\nV(8):   mag:    26.0426 phase:    116.326°  voltage\nV(7):   mag:    7.30203 phase:    133.716°  voltage\nV(2):   mag:     32.516 phase:    143.867°  voltage\nV(9):   mag:    27.3089 phase:   -54.4772°  voltage\nI(C1):  mag:    4.48781 phase:    133.539°  device_current\nI(C2):  mag:    3.44327 phase:   -52.0221°  device_current\nI(C3):  mag:      8.611 phase:   -51.7727°  device_current\nI(H1):  mag:   0.146041 phase:   -46.2842°  device_current\nI(L3):  mag:    3.75339 phase:    134.053°  device_current\nI(L1):  mag:    1.24841 phase:    130.842°  device_current\nI(L4):  mag:    5.16779 phase:   -51.6065°  device_current\nI(L2):  mag:   0.130213 phase:    116.326°  device_current\nI(I1):  mag:          3 phase:        -60°  device_current\nI(R9):  mag:   0.242382 phase:   -43.3777°  device_current\nI(R6):  mag:   0.146041 phase:    133.716°  device_current\nI(R4):  mag:    1.24841 phase:    130.842°  device_current\nI(R1):  mag:   0.242382 phase:   -43.3777°  device_current\nI(R3):  mag:   0.561096 phase:  0.0650338°  device_current\nI(R7):  mag:   0.130213 phase:   -63.6741°  device_current\nI(R11): mag:    27.8613 phase:    35.1207°  device_current\nI(R5):  mag:    3.48355 phase:    134.719°  device_current\nI(R10): mag:    3.75339 phase:    134.053°  device_current\nI(R8):  mag:   0.273089 phase:   -54.4772°  device_current\nI(R2):  mag:    1.36359 phase:   -33.9423°  device_current\nI(G1):  mag:    30.5828 phase:     15.818°  device_current\nI(V1):  mag:    3.48355 phase:   -45.2807°  device_current\nI(V2):  mag:   0.242382 phase:   -43.3777°  device_current\nStore the Python results in a dataframe.\n\nw2 = pd.DataFrame(U_w2.items(), columns=['unk', 'w=7Hz'])\nw2 = w2.set_index('unk')\nw2['w=7Hz'] = w2['w=7Hz'].astype(complex)\nsolutions['w=7Hz'] = w2['w=7Hz']\n#solutions\n\n\n14.4.1 Superposition solution\nUsing the principle of superposition, we can add the results obtained above to get the solution for the unknown node voltages and inductor and source currents.\n\nsolutions['w1+w2'] = solutions['w=3Hz'] + solutions['w=7Hz']\nsolutions['dc+w1+w2'] = solutions['w1+w2'] + solutions['w=DC']\nsolutions\n\n\n\n\n\n\n\n\nw=DC\nw=3Hz\nw=7Hz\nw1+w2\ndc+w1+w2\n\n\nunk\n\n\n\n\n\n\n\n\n\nv1\n-1444.606764\n0.892908-0.822746j\n-8.64425300+2.52654000j\n-7.75134500+1.70379400j\n-1452.3581009+1.7037940j\n\n\nv2\n701.805800\n3.920302+3.190643j\n-26.2616000+19.1734280j\n-22.3412980+22.3640710j\n679.4645010+22.3640710j\n\n\nv3\n626.530983\n1.677294-1.058215j\n-5.39864500+5.61067700j\n-3.72135100+4.55246200j\n622.8096302+4.5524620j\n\n\nv4\n564.749806\n2.142328+5.067639j\n-47.4808370+5.5629110j\n-45.3385090+10.6305500j\n519.4112970+10.6305500j\n\n\nv5\n-1444.606764\n6.998594-2.958208j\n199.049815+182.069001j\n206.048410+179.110793j\n-1238.558355+179.110793j\n\n\nv6\n-1439.606764\n-4.056839+4.127001j\n-8.64425300+2.52654000j\n-12.7010930+6.6535420j\n-1452.3078507+6.6535420j\n\n\nv7\n583.602732\n1.616746-1.138482j\n-5.04629800+5.27773900j\n-3.42955200+4.13925700j\n580.1731709+4.1392570j\n\n\nv8\n564.749806\n3.822070+2.546088j\n-11.5492460+23.3415940j\n-7.727175+025.8876810j\n557.0226300+25.8876810j\n\n\nv9\n-1449.580366\n-5.144528+1.003921j\n15.8672200-22.2262750j\n10.7226920-21.2223540j\n-1438.857674-21.222354j\n\n\nv10\n916.447056\n4.223041+3.591982j\n-28.0233350+20.8381170j\n-23.8002940+24.4300990j\n892.6467620+24.4300990j\n\n\nv11\n-1465.073530\n-5.304742+0.701652j\n18.4770390-24.9238190j\n13.1722970-24.2221670j\n-1451.901233-24.222167j\n\n\nv12\n916.447056\n4.223041+3.591982j\n-28.0233350+20.8381170j\n-23.8002940+24.4300990j\n892.6467620+24.4300990j\n\n\nv13\n-1465.073530\n2.735545+4.908599j\n-40.1718250+11.2688080j\n-37.4362800+16.1774060j\n-1502.509810+16.177406j\n\n\nv14\n-1465.073530\n6.975936-3.022991j\n199.866246+181.124557j\n206.842182+178.101566j\n-1258.231348+178.101566j\n\n\nI_V1\n-0.997360\n-0.108769-0.312308j\n2.45114700-2.47528100j\n2.34237800-2.78759000j\n1.34501800-2.78759000j\n\n\nI_V2\n-21.464126\n-0.030274-0.040134j\n0.17617300-0.16646900j\n0.14590000-0.20660300j\n-21.31822600-0.20660300j\n\n\nI_L3\n15.493164\n0.160214+0.302269j\n-2.60981900+2.69754400j\n-2.44960500+2.99981300j\n13.04355800+2.99981300j\n\n\nI_L1\n20.466765\n0.022658+0.064783j\n-0.81643100+0.94444400j\n-0.79377300+1.00922700j\n19.67299300+1.00922700j\n\n\nI_L4\n0.000000\n-0.288881-0.260561j\n3.20950100-4.05032500j\n2.92062100-4.31088500j\n2.92062100-4.31088500j\n\n\nI_L2\n2.823749\n0.019110+0.012730j\n-0.05774600+0.11670800j\n-0.03863600+0.12943800j\n2.78511300+0.12943800j\n\n\nI_H1\n-11.672055\n-0.032335+0.022770j\n0.10092600-0.10555500j\n0.06859100-0.08278500j\n-11.60346400-0.08278500j\n\n\n\n\n\n\n\nDisplay the superposition results in polar form.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in solutions['dc+w1+w2'].items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown            mag    phase, deg\n---------  -----------  ------------\nv1         1452.359109    179.932785\nv2          679.832450      1.885168\nv3          622.826270      0.418799\nv4          519.520071      1.172482\nv5         1251.442158    171.771369\nv6         1452.323098    179.737509\nv7          580.187945      0.408771\nv8          557.623872      2.660912\nv9         1439.014175   -179.154980\nv10         892.981003      1.567689\nv11        1452.103269   -179.044219\nv12         892.981003      1.567689\nv13        1502.596898    179.383125\nv14        1270.773895    171.943355\nI_V1          3.095114    -64.242586\nI_V2         21.319227   -179.444743\nI_L3         13.384069     12.951908\nI_L1         19.698863      2.936707\nI_L4          5.207087    -55.882399\nI_L2          2.788119      2.660912\nI_H1         11.603759   -179.591229",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "Superposition.html#summary",
    "href": "Superposition.html#summary",
    "title": "14  Superposition",
    "section": "14.5 Summary",
    "text": "14.5 Summary\nIn this notebook a large non-planar circuit having independent sources with different DC values, different AC amplitudes, phases and frequencies was analyzed. The results were summed to obtain a total solution by applying the superposition thereom.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Superposition</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html",
    "href": "2nd_order_BRF.html",
    "title": "15  2nd Order BRF",
    "section": "",
    "text": "15.1 Introduction\nThis notebook walks through the Python code used to find the transfer function of the circuit shown in Figure 15.1.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#introduction",
    "href": "2nd_order_BRF.html#introduction",
    "title": "15  2nd Order BRF",
    "section": "",
    "text": "Figure 15.1: Band reject filter schematic",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#circuit-description",
    "href": "2nd_order_BRF.html#circuit-description",
    "title": "15  2nd Order BRF",
    "section": "15.2 Circuit description",
    "text": "15.2 Circuit description\nThe circuit above is a 2nd order band reject filter, problem 13-20 from Budak (1974). The schematic of the circuit is shown with each node annotated. The problem asks to obtain the transfer function, \\(\\frac {V_2} {V_1}\\).\nThe net list for this circuit is:\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#load-the-net-list",
    "href": "2nd_order_BRF.html#load-the-net-list",
    "title": "15  2nd Order BRF",
    "section": "15.3 Load the net list",
    "text": "15.3 Load the net list\n\nnet_list = '''\nO1 2 5 2 \nV1 1 0 1\nC3 3 0 2\nC1 4 1 1\nC2 5 4 1\nR1 2 4 0.5\nR2 3 1 1\nR3 5 3 1\n'''",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "2nd_order_BRF.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "15  2nd Order BRF",
    "section": "15.4 Call the symbolic modified nodal analysis function",
    "text": "15.4 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\n\n15.4.1 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = - C_{1} s v_{4} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}}\\)\\(0 = I_{O1} + \\frac{v_{2}}{R_{1}} - \\frac{v_{4}}{R_{1}}\\)\\(0 = v_{3} \\left(C_{3} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\)\\(0 = - C_{1} s v_{1} - C_{2} s v_{5} + v_{4} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{1}}\\)\\(0 = - C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{2} - v_{5}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  R_{3}, \\  R_{1}, \\  C_{2}, \\  v_{1}, \\  v_{4}, \\  s, \\  v_{2}, \\  C_{3}, \\  I_{V1}, \\  V_{1}, \\  I_{O1}, \\  v_{5}, \\  v_{3}, \\  R_{2}\\right)\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#symbolic-solution",
    "href": "2nd_order_BRF.html#symbolic-solution",
    "title": "15  2nd Order BRF",
    "section": "15.5 Symbolic solution",
    "text": "15.5 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(v_{3} = \\frac{C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(v_{4} = \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} C_{3} R_{1} R_{2} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(v_{5} = \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} V_{1} s^{3} + C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{2} R_{1} V_{1} s + V_{1}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} R_{1} R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} V_{1} s^{3} - C_{1} C_{3} R_{1} V_{1} s^{2} - C_{1} C_{3} R_{2} V_{1} s^{2} - C_{2} C_{3} R_{1} V_{1} s^{2} - C_{3} V_{1} s}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\\(I_{O1} = \\frac{C_{1} C_{3} R_{2} V_{1} s^{2}}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{3} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} C_{3} R_{1} R_{2} s^{2} + C_{2} R_{1} s + C_{3} R_{2} s + 1}\\)\n\n\nSymbolic form of the transfer function.\n\nH_sym = (U_sym[v2]/U_sym[v1]).simplify().collect(s)\nH_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} + C_{1} C_{2} R_{1} R_{3}\\right) + s \\left(C_{1} R_{1} + C_{2} R_{1}\\right) + 1}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{3} + s^{2} \\left(C_{1} C_{2} R_{1} R_{2} + C_{1} C_{2} R_{1} R_{3} + C_{1} C_{3} R_{1} R_{2} + C_{2} C_{3} R_{1} R_{2}\\right) + s \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) + 1}\\)\n\n\nThe numerator and denominator of the transfer function can be obtained as follows:\n\nnum, den = fraction(H_sym)\n\nThe roots of the numerator can be obtained symbolically. Since the degree of the polynominal is a third order, SymPy can solve for the roots and obtain a solution very quickly. The roots expressed in symbolic form are not very useful, but are easily obtained, something that would be almost impossible to do by hand with pencil and paper.\n\nz = solve(num,s)\nz[0]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}}{3} - \\frac{R_{2} + R_{3}}{3 C_{3} R_{2} R_{3}}\\)\n\n\n\nz[1]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}}{3} - \\frac{R_{2} + R_{3}}{3 C_{3} R_{2} R_{3}}\\)\n\n\n\nz[2]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(R_{2} + R_{3}\\right)^{2}}{C_{3}^{2} R_{2}^{2} R_{3}^{2}} - \\frac{3 \\left(C_{1} + C_{2}\\right)}{C_{1} C_{2} C_{3} R_{2} R_{3}}\\right)^{3} + \\left(\\frac{2 \\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{2}}}{2} + \\frac{\\left(R_{2} + R_{3}\\right)^{3}}{C_{3}^{3} R_{2}^{3} R_{3}^{3}} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} + C_{2}\\right) \\left(R_{2} + R_{3}\\right)}{2 C_{1} C_{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}}{3} - \\frac{R_{2} + R_{3}}{3 C_{3} R_{2} R_{3}}\\)\n\n\nThe roots of the denominator can be obtained symbolically.\n\np = solve(den,s)\np[0]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}}{3} - \\frac{C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}}{3 C_{1} C_{2} C_{3} R_{2} R_{3}}\\)\n\n\n\np[1]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}}{3} - \\frac{C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}}{3 C_{1} C_{2} C_{3} R_{2} R_{3}}\\)\n\n\n\np[2]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right)}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{2}}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{2}^{2} R_{3}^{2}}\\right)^{3} + \\left(\\frac{27}{C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{2 \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}\\right)^{2}}}{2} + \\frac{27}{2 C_{1} C_{2} C_{3} R_{1} R_{2} R_{3}} - \\frac{9 \\left(C_{1} R_{1} + C_{2} R_{1} + C_{3} R_{2}\\right) \\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)}{2 C_{1}^{2} C_{2}^{2} C_{3}^{2} R_{1} R_{2}^{2} R_{3}^{2}} + \\frac{\\left(C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}\\right)^{3}}{C_{1}^{3} C_{2}^{3} C_{3}^{3} R_{2}^{3} R_{3}^{3}}}}{3} - \\frac{C_{1} C_{2} R_{2} + C_{1} C_{2} R_{3} + C_{1} C_{3} R_{2} + C_{2} C_{3} R_{2}}{3 C_{1} C_{2} C_{3} R_{2} R_{3}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "2nd_order_BRF.html#numerical-solution",
    "href": "2nd_order_BRF.html#numerical-solution",
    "title": "15  2nd Order BRF",
    "section": "15.6 Numerical solution",
    "text": "15.6 Numerical solution\nConstruct a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 1.0\nO1 = nan\nC3 = 2.0\nC1 = 1.0\nC2 = 1.0\nR1 = 0.5\nR2 = 1.0\nR3 = 1.0\n\n\nPut the component values into the equations.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} - 1.0 s v_{4} + v_{1} \\cdot \\left(1.0 s + 1.0\\right) - 1.0 v_{3}\\)\\(0 = I_{O1} + 2.0 v_{2} - 2.0 v_{4}\\)\\(0 = - 1.0 v_{1} + v_{3} \\cdot \\left(2.0 s + 2.0\\right) - 1.0 v_{5}\\)\\(0 = - 1.0 s v_{1} - 1.0 s v_{5} - 2.0 v_{2} + v_{4} \\cdot \\left(2.0 s + 2.0\\right)\\)\\(0 = - 1.0 s v_{4} - 1.0 v_{3} + v_{5} \\cdot \\left(1.0 s + 1.0\\right)\\)\\(1.0 = v_{1}\\)\\(0 = v_{2} - v_{5}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\)\\(v_{3} = \\frac{s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}\\)\\(v_{4} = \\frac{s^{3} + 2.0 s^{2} + s + 1.0}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}\\)\\(v_{5} = \\frac{s^{2} + 1.0}{s^{2} + 2.0 s + 1.0}\\)\\(I_{V1} = - \\frac{2.0 s}{s + 1.0}\\)\\(I_{O1} = \\frac{2.0 s^{2}}{s^{3} + 3.0 s^{2} + 3.0 s + 1.0}\\)\n\n\n\n15.6.1 Plot the frequency response of the transfer function\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(s^{2} + 1.0\\right)}{s^{2} + 2.0 s + 1.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 0, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('null: {:.2f} dB at {:.3f} Hz'.format(mag.min(),w[np.argmin(mag)]/(2*np.pi)))\n\nnull: -67.66 dB at 0.159 Hz\n\n\n\n\n15.6.2 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n15.6.2.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n0.00+0.16j Hz\n0.00-0.16j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-0.16+0.00j Hz\n-0.16-0.00j Hz\n\n\n\n\n\n15.6.3 Impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nBudak, A. 1974. Passive and Active Network Analysis and Synthesis. Houghton Mifflin.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2nd Order BRF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html",
    "href": "Elliptic-function-LPF.html",
    "title": "16  Elliptic Function LPF",
    "section": "",
    "text": "16.1 Introduction\nThe circuit shown above is an elliptic function low pass filter. The design of elliptic filters is somewhat complex and usually involves the use of tables found in filter design handbooks. The symbolic solution of the network equations takes about 2 hours on my i3 laptop. A symbolic solution can be obtained in a few seconds by running this notebook in Google’s Colab, see Appendix C. Initially I was thinking that with a symbolic solution of the equations and the use of SciPy’s filter functions to obtain the pole and zero locations, I could derive the element values for active elliptic filters. But since the subject of this book is MNA and not filter design, only the analysis of the filter is described.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#circuit-description",
    "href": "Elliptic-function-LPF.html#circuit-description",
    "title": "16  Elliptic Function LPF",
    "section": "16.2 Circuit description",
    "text": "16.2 Circuit description\nThe circuit in Figure 16.1 has 13 branches and 7 nodes. There are 12 passive components and one OpAmp. The circuit is from Williams and Taylor (1995), example 3-26, and is an elliptic function low pass filter with a cutoff frequency of 100 Hz. The schematic for the filter was entered into LTSpice and an the following netlist was obtained.\nR3 3 0 4750\nR4 5 0 73.2k\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10k\nC1 3 1 0.05µ\nC2 5 3 0.05µ\nC3 7 4 0.1µ\nC4 5 0 0.22µ\nC5 2 0 0.18µ\nXU1 6 5 7 opamp Aol=100K GBW=10Meg\nV1 1 0 AC 1\nR6 7 6 44.2k\nR5 6 0 10k\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n16.2.1 Network equations\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to fix up the formating of the component values and the OpAmp declaration.\n\nexample_net_list = '''\nR3 3 0 4750\nR4 5 0 73.2e3\nR1 4 1 9530\nR2 5 4 9530\nR7 2 7 10e3\nC1 3 1 0.05e-6\nC2 5 3 0.05e-6\nC3 7 4 0.1e-6\nC4 5 0 0.22e-6\nC5 2 0 0.18e-6\nO1 6 5 7 \nV1 1 0 1\nR6 7 6 44.2e3\nR5 6 0 10e3\n'''\n\nCallin smna() to generate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(example_net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nequ = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{3} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(v_{2} \\left(C_{5} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{1} s v_{1} - C_{2} s v_{5} + v_{3} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) = 0\\)\\(- C_{3} s v_{7} + v_{4} \\left(C_{3} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + C_{4} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{7}}{R_{6}} = 0\\)\\(- C_{3} s v_{4} + I_{O1} + v_{7} \\left(C_{3} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{2}}{R_{7}} - \\frac{v_{6}}{R_{6}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} + v_{6} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time.\nTurn the free symbols into SymPy variables.\n\nvar(str(equ.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  I_{O1}, \\  v_{6}, \\  C_{5}, \\  v_{4}, \\  v_{1}, \\  v_{2}, \\  I_{V1}, \\  v_{7}, \\  v_{5}, \\  R_{7}, \\  v_{3}, \\  R_{5}, \\  R_{2}, \\  C_{4}, \\  V_{1}, \\  R_{3}, \\  R_{1}, \\  C_{2}, \\  R_{6}, \\  s, \\  R_{4}, \\  C_{3}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 5.0 \\cdot 10^{-8}, \\  C_{2} : 5.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-7}, \\  C_{4} : 2.2 \\cdot 10^{-7}, \\  C_{5} : 1.8 \\cdot 10^{-7}, \\  O_{1} : \\text{NaN}, \\  R_{1} : 9530.0, \\  R_{2} : 9530.0, \\  R_{3} : 4750.0, \\  R_{4} : 73200.0, \\  R_{5} : 10000.0, \\  R_{6} : 44200.0, \\  R_{7} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#symbolic-solution",
    "href": "Elliptic-function-LPF.html#symbolic-solution",
    "title": "16  Elliptic Function LPF",
    "section": "16.3 Symbolic solution",
    "text": "16.3 Symbolic solution\nThe symbolic solution takes a long time, 2 hours, on my laptop (i3-8130U CPU @ 2.20GHz), so I commended the code. A symbolic solution can be obtained running this notebook in Google’s Colab, see Appendix C.\n\n#U_sym = solve(equ,X)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#numerical-solution",
    "href": "Elliptic-function-LPF.html#numerical-solution",
    "title": "16  Elliptic Function LPF",
    "section": "16.4 Numerical solution",
    "text": "16.4 Numerical solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ_N = equ.subs(element_values)\nequ_N\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 5.0 \\cdot 10^{-8} s v_{3} + v_{1} \\cdot \\left(5.0 \\cdot 10^{-8} s + 0.000104931794333683\\right) - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(1.8 \\cdot 10^{-7} s + 0.0001\\right) - 0.0001 v_{7}\\\\- 5.0 \\cdot 10^{-8} s v_{1} - 5.0 \\cdot 10^{-8} s v_{5} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000210526315789474\\right)\\\\- 1.0 \\cdot 10^{-7} s v_{7} - 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000209863588667366\\right) - 0.000104931794333683 v_{5}\\\\- 5.0 \\cdot 10^{-8} s v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(2.7 \\cdot 10^{-7} s + 0.000118592996519475\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 1.0 \\cdot 10^{-7} s v_{4} - 0.0001 v_{2} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.00012262443438914\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nU = solve(equ_N,X)\n\n\n16.4.1 Find the network transfer function \\(\\frac {v_2(s)}{v_1(s)}\\)\n\nH = (U[v2]/U[v1]).cancel()\nH\n\n\\(\\displaystyle \\frac{7.66402714932125 \\cdot 10^{50} s^{3} + 1.60840024120068 \\cdot 10^{54} s^{2} + 3.37544646631832 \\cdot 10^{57} s + 7.10620308698594 \\cdot 10^{60}}{2.49434389140272 \\cdot 10^{48} s^{4} + 7.82471226796141 \\cdot 10^{51} s^{3} + 7.48699036699101 \\cdot 10^{54} s^{2} + 5.1465987346903 \\cdot 10^{57} s + 1.65249706814803 \\cdot 10^{60}}\\)\n\n\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n16.4.2 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n16.4.2.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-334.53+0.00j Hz\n0.26+334.27j Hz\n0.26-334.27j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-335.18+0.00j Hz\n-37.83+113.63j Hz\n-37.83-113.63j Hz\n-88.42+0.00j Hz",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-analysis",
    "href": "Elliptic-function-LPF.html#ac-analysis",
    "title": "16  Elliptic Function LPF",
    "section": "16.5 AC analysis",
    "text": "16.5 AC analysis\nSolve the network equations at a frequency of 100 Hz or \\(\\omega\\) equal to 628.318 radians per second, s = 628.318j.\nLoad numerical values into the network equations.\n\nfreq_Hz = 100 #Hz\nw = 2*np.pi*freq_Hz\n\nequ_Nw = equ.subs(element_values)\nequ_Nw = equ_Nw.subs({s:1j*w})\nequ_Nw  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.000104931794333683 + 3.14159265358979 \\cdot 10^{-5} i\\right) - 3.14159265358979 \\cdot 10^{-5} i v_{3} - 0.000104931794333683 v_{4}\\\\v_{2} \\cdot \\left(0.0001 + 0.000113097335529233 i\\right) - 0.0001 v_{7}\\\\- 3.14159265358979 \\cdot 10^{-5} i v_{1} + v_{3} \\cdot \\left(0.000210526315789474 + 6.28318530717959 \\cdot 10^{-5} i\\right) - 3.14159265358979 \\cdot 10^{-5} i v_{5}\\\\- 0.000104931794333683 v_{1} + v_{4} \\cdot \\left(0.000209863588667366 + 6.28318530717959 \\cdot 10^{-5} i\\right) - 0.000104931794333683 v_{5} - 6.28318530717959 \\cdot 10^{-5} i v_{7}\\\\- 3.14159265358979 \\cdot 10^{-5} i v_{3} - 0.000104931794333683 v_{4} + v_{5} \\cdot \\left(0.000118592996519475 + 0.000169646003293849 i\\right)\\\\0.00012262443438914 v_{6} - 2.26244343891403 \\cdot 10^{-5} v_{7}\\\\I_{O1} - 0.0001 v_{2} - 6.28318530717959 \\cdot 10^{-5} i v_{4} - 2.26244343891403 \\cdot 10^{-5} v_{6} + v_{7} \\cdot \\left(0.00012262443438914 + 6.28318530717959 \\cdot 10^{-5} i\\right)\\\\v_{1}\\\\- v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the newtork equations and list the node voltages and unknown currents.\n\nU_Nw = solve(equ_Nw,X)\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_Nw .items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         4.264586   -108.662048\nv3         0.271069     40.463593\nv4         2.401757     -6.456457\nv5         1.187844    -60.144973\nv6         1.187844    -60.144973\nv7         6.438113    -60.144973\nI_V1       0.000150    -20.838911\nI_O1       0.000875    166.380500",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#ac-sweep",
    "href": "Elliptic-function-LPF.html#ac-sweep",
    "title": "16  Elliptic Function LPF",
    "section": "16.6 AC Sweep",
    "text": "16.6 AC Sweep\nPlot the magnitude and phase of the filter’s transfer function.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b) # system for circuit 1\n\nx = np.logspace(1, 3, 1000, endpoint=True)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Magnitude and phase plot')\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Elliptic-function-LPF.html#summary",
    "href": "Elliptic-function-LPF.html#summary",
    "title": "16  Elliptic Function LPF",
    "section": "16.7 Summary",
    "text": "16.7 Summary\nAn elliptic filter was analyized and a symbolic solution of the network equations takes a long time. Numerical solutions using component values are easily obtained.\n\n\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Elliptic Function LPF</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html",
    "href": "Bridge-T.html",
    "title": "17  Bridge-T",
    "section": "",
    "text": "17.1 Introduction\nA question posted on electronics stackexchange by Lees (2023) asked:\nFigure 17.1 shows that the independent source V1 is connected to ground by the series connection of C1, C2 and C3. Lees (2023) asked if the initial voltage on the capacitors, C1, C2 and C3 could violate Kirchhoff’s circuit laws by leading to a situation where the initial voltage on the capacitors do not sum to a value equal to V1. For example, if V1 is equal to 1 volt and the initial voltage on the capacitors are each equal to one volt, the sum of the three initial voltages on the capacitors would be 3 volts and not sum to zero around the loop. Lees (2023) provided some analysis in his question and discussed the voltage across C3 and stated that he needed to add a small series resistor to V1.\nThere were four answers provided by the comunity. The answer provided by Franc (2023) is long and detailed and in part 3 of his answer he adress the non zero initial condition and the transfer function at node 2.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#introduction",
    "href": "Bridge-T.html#introduction",
    "title": "17  Bridge-T",
    "section": "",
    "text": "I’m trying to figure out how to formulate and solve some differential equations for this circuit. … I run into an issue with the voltage/capacitor loop comprising Vin VC1 VC2 VC3 as I cannot arbitrarily assign an initial value to the voltage across C3.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#circuit-description",
    "href": "Bridge-T.html#circuit-description",
    "title": "17  Bridge-T",
    "section": "17.2 Circuit description",
    "text": "17.2 Circuit description\nThe circuit shown in Figure 17.1 has six branches and three nodes. The circuit has a three capacitor path from the independent source, V1 to ground. The circuit posted by Lees (2023) didn’t have any values for the components, so I’m going use values that are all set to one. The initial voltages on the capacitor can be set to any abritrairy value or left defaulted to zero volts. As described below, the circuit needs to be modified for the MNA.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#circuit-analysis",
    "href": "Bridge-T.html#circuit-analysis",
    "title": "17  Bridge-T",
    "section": "17.3 Circuit analysis",
    "text": "17.3 Circuit analysis\nLees (2023) asked for differential equations, but since this analysis is about using MNA, a frequency domain analysis will be presented. So I’m not going to derive the differential equations for the circuit.\n\ntransfer function at nodes 2 and 3\nSolve the equations for initial conditions\ncompare to LTSpice results\n\nVoltage sources, V2, v3 and V4 were added to the circuit shown in Figure 17.2 so that these sources can hold the capacitor’s initial voltage value at time equal to 0+. Frequency domain equivilent of C with an initial voltage condition is a series voltage source v(0+)/s\n\n\n\n\n\n\nFigure 17.2: Circuit used for MNA\n\n\n\nThe net list for the circuit is:\nV1 1 0 1\nC2 4 1 1\nC3 5 2 1\nC1 6 2 1\nL1 1 2 1\nR1 3 0 1\nV2 4 3 1\nV3 6 0 1\nV4 3 5 1\nThe following Python modules are used.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\n17.3.1 Load the netlist\nThe netlist for Figure 17.1 is pasted into the cell below and some edits were made to remove the inductor series resistance.\n\nnet_list = '''\nV1 1 0 1\nC2 3 1 1\nC3 3 2 1\nC1 0 2 1\nL 1 2 1\nR2 3 0 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{2} s v_{1} - C_{2} s v_{3} + I_{L} + I_{V1} = 0\\)\\(- C_{3} s v_{3} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right) = 0\\)\\(- C_{2} s v_{1} - C_{3} s v_{2} + v_{3} \\left(C_{2} s + C_{3} s + \\frac{1}{R_{2}}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L} L s + v_{1} - v_{2} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{2} s v_{1} - C_{2} s v_{3} + I_{L} + I_{V1}\\\\- C_{3} s v_{3} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right)\\\\- C_{2} s v_{1} - C_{3} s v_{2} + v_{3} \\left(C_{2} s + C_{3} s + \\frac{1}{R_{2}}\\right)\\\\v_{1}\\\\- I_{L} L s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\V_{1}\\\\0\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  s, \\  C_{3}, \\  R_{2}, \\  C_{1}, \\  C_{2}, \\  L, \\  I_{L}, \\  v_{1}, \\  I_{V1}, \\  V_{1}, \\  v_{3}\\right)\\)\n\n\n\n\n17.3.2 Transfer function\nSolving for the transfer function at node 2. Transfer functions are normally presented in the frequency domain and are steady state responses.\n\nU_sym = solve(NE_sym,X)\n\nH2_sym = U_sym[v2]/U_sym[v1]\nH2_sym\n\n\\(\\displaystyle \\frac{C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{2} R_{2} V_{1} s + C_{3} R_{2} V_{1} s + V_{1}}{V_{1} \\left(C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1\\right)}\\)\n\n\nCollecting the s terms:\n\ncancel(H2_sym,s)\n\n\\(\\displaystyle \\frac{C_{2} C_{3} L R_{2} s^{3} + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right) + 1}{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{1} C_{3} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right) + 1}\\)\n\n\nMy transfer function equation does not agree with the answer provided by Franc (2023).\nSolving for the transfer function at node 3.\n\nH3_sym = U_sym[v3]/U_sym[v1]\nH3_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{2} L R_{2} V_{1} s^{3} + C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{2} R_{2} V_{1} s + C_{3} R_{2} V_{1} s}{V_{1} \\left(C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1\\right)}\\)\n\n\nCollecting the s terms:\n\ncancel(H3_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right)}{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{1} C_{3} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right) + 1}\\)\n\n\nMy answer for the node 3 transfer function does not agree with the 1st answer’s node 3 transfer function. SE answer: numerator\n\ns*((C3+C2)*R2+(C1+C3)*L*R2*C2*s**2)\n\n\\(\\displaystyle s \\left(C_{2} L R_{2} s^{2} \\left(C_{1} + C_{3}\\right) + R_{2} \\left(C_{2} + C_{3}\\right)\\right)\\)\n\n\n\ncancel(s*((C3+C2)*R2+(C1+C3)*L*R2*C2*s**2),s)\n\n\\(\\displaystyle s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right)\\)\n\n\nnumerator agrees\ndenominator\n\n(1+(C1+C3)*L*s**2)*(1+R2*C2*s)\n\n\\(\\displaystyle \\left(C_{2} R_{2} s + 1\\right) \\left(L s^{2} \\left(C_{1} + C_{3}\\right) + 1\\right)\\)\n\n\n\ncancel((1+(C1+C3)*L*s**2)*(1+R2*C2*s),s)\n\n\\(\\displaystyle C_{2} R_{2} s + s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + 1\\)\n\n\nDenominator does not agree\n\nSE1 = (s*((C3+C2)*R2+(C1+C3)*L*R2*C2*s**2))/((1+(C1+C3)*L*s**2)*(1+R2*C2*s))\nSE1\n\n\\(\\displaystyle \\frac{s \\left(C_{2} L R_{2} s^{2} \\left(C_{1} + C_{3}\\right) + R_{2} \\left(C_{2} + C_{3}\\right)\\right)}{\\left(C_{2} R_{2} s + 1\\right) \\left(L s^{2} \\left(C_{1} + C_{3}\\right) + 1\\right)}\\)\n\n\n\ncancel(SE1,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s \\left(C_{2} R_{2} + C_{3} R_{2}\\right)}{C_{2} R_{2} s + s^{3} \\left(C_{1} C_{2} L R_{2} + C_{2} C_{3} L R_{2}\\right) + s^{2} \\left(C_{1} L + C_{3} L\\right) + 1}\\)\n\n\n\n\n17.3.3 Include the initial conditions\nSet initial conditions for C1, C2 and C3 by including independent voltage sources, V2, V3 and V4, and appling SymPy Heaveside function. The independent voltage source, V1 is a also a step function. Since V2, V3 and V4 are in series with capacitors, the steady state value of these sources is blocked and only the transient response is present. The netlist for Figure 17.2 is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nC2 4 1 1\nC3 5 2 1\nC1 6 2 1\nL 1 2 1\nR2 3 0 1\nV2 4 3 1\nV3 6 0 1\nV4 3 5 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_ic_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{2} s v_{1} - C_{2} s v_{4} + I_{L} + I_{V1} = 0\\)\\(- C_{1} s v_{6} - C_{3} s v_{5} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right) = 0\\)\\(- I_{V2} + I_{V4} + \\frac{v_{3}}{R_{2}} = 0\\)\\(- C_{2} s v_{1} + C_{2} s v_{4} + I_{V2} = 0\\)\\(- C_{3} s v_{2} + C_{3} s v_{5} - I_{V4} = 0\\)\\(- C_{1} s v_{2} + C_{1} s v_{6} + I_{V3} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} + v_{4} = V_{2}\\)\\(v_{6} = V_{3}\\)\\(v_{3} - v_{5} = V_{4}\\)\\(- I_{L} L s + v_{1} - v_{2} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_ic_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{2} s v_{1} - C_{2} s v_{4} + I_{L} + I_{V1}\\\\- C_{1} s v_{6} - C_{3} s v_{5} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right)\\\\- I_{V2} + I_{V4} + \\frac{v_{3}}{R_{2}}\\\\- C_{2} s v_{1} + C_{2} s v_{4} + I_{V2}\\\\- C_{3} s v_{2} + C_{3} s v_{5} - I_{V4}\\\\- C_{1} s v_{2} + C_{1} s v_{6} + I_{V3}\\\\v_{1}\\\\- v_{3} + v_{4}\\\\v_{6}\\\\v_{3} - v_{5}\\\\- I_{L} L s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\V_{2}\\\\V_{3}\\\\V_{4}\\\\0\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_ic_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  C_{3}, \\  R_{2}, \\  v_{5}, \\  v_{6}, \\  C_{2}, \\  v_{1}, \\  I_{V1}, \\  V_{4}, \\  V_{1}, \\  V_{3}, \\  I_{V2}, \\  s, \\  C_{1}, \\  L, \\  I_{L}, \\  v_{4}, \\  I_{V3}, \\  V_{2}, \\  I_{V4}, \\  v_{3}\\right)\\)\n\n\nThe SymPy Heaviside function is used to define the initial current and voltage on the inductor and capacitor. The equivalent circuit in s domain has a capacitor C with impedance 1/(sC) and a voltage source v(0)/s in series.\n\nNE_ic_sym = NE_ic_sym.subs({V1:laplace_transform(V1*Heaviside(t), t, s)[0], V2:laplace_transform(V2*Heaviside(t), t, s)[0], V3:laplace_transform(V3*Heaviside(t), t, s)[0], V4:laplace_transform(V4*Heaviside(t), t, s)[0]})\nNE_ic_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{2} s v_{1} - C_{2} s v_{4} + I_{L} + I_{V1}\\\\- C_{1} s v_{6} - C_{3} s v_{5} - I_{L} + v_{2} \\left(C_{1} s + C_{3} s\\right)\\\\- I_{V2} + I_{V4} + \\frac{v_{3}}{R_{2}}\\\\- C_{2} s v_{1} + C_{2} s v_{4} + I_{V2}\\\\- C_{3} s v_{2} + C_{3} s v_{5} - I_{V4}\\\\- C_{1} s v_{2} + C_{1} s v_{6} + I_{V3}\\\\v_{1}\\\\- v_{3} + v_{4}\\\\v_{6}\\\\v_{3} - v_{5}\\\\- I_{L} L s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{V_{1}}{s}\\\\\\frac{V_{2}}{s}\\\\\\frac{V_{3}}{s}\\\\\\frac{V_{4}}{s}\\\\0\\end{matrix}\\right]\\)\n\n\nGenerate and display the symbolic solution.\n\nU_ic_sym = solve(NE_ic_sym,X)\n\ntemp = ''\nfor i in U_ic_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{V_{1}}{s}\\)\\(v_{2} = \\frac{C_{1} C_{2} L R_{2} V_{3} s^{3} + C_{1} C_{3} L R_{2} V_{3} s^{3} + C_{1} L V_{3} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{2} R_{2} V_{1} s - C_{3} L V_{4} s^{2} + C_{3} R_{2} V_{1} s + V_{1}}{C_{1} C_{2} L R_{2} s^{4} + C_{1} C_{3} L R_{2} s^{4} + C_{1} L s^{3} + C_{2} C_{3} L R_{2} s^{4} + C_{2} R_{2} s^{2} + C_{3} L s^{3} + C_{3} R_{2} s^{2} + s}\\)\\(v_{3} = \\frac{C_{1} C_{2} L R_{2} V_{1} s^{2} - C_{1} C_{2} L R_{2} V_{2} s^{2} + C_{1} C_{3} L R_{2} V_{3} s^{2} + C_{1} C_{3} L R_{2} V_{4} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{2} - C_{2} C_{3} L R_{2} V_{2} s^{2} + C_{2} R_{2} V_{1} - C_{2} R_{2} V_{2} + C_{3} R_{2} V_{1} + C_{3} R_{2} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(v_{4} = \\frac{C_{1} C_{2} L R_{2} V_{1} s^{3} + C_{1} C_{3} L R_{2} V_{2} s^{3} + C_{1} C_{3} L R_{2} V_{3} s^{3} + C_{1} C_{3} L R_{2} V_{4} s^{3} + C_{1} L V_{2} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{2} R_{2} V_{1} s + C_{3} L V_{2} s^{2} + C_{3} R_{2} V_{1} s + C_{3} R_{2} V_{2} s + C_{3} R_{2} V_{4} s + V_{2}}{C_{1} C_{2} L R_{2} s^{4} + C_{1} C_{3} L R_{2} s^{4} + C_{1} L s^{3} + C_{2} C_{3} L R_{2} s^{4} + C_{2} R_{2} s^{2} + C_{3} L s^{3} + C_{3} R_{2} s^{2} + s}\\)\\(v_{5} = \\frac{C_{1} C_{2} L R_{2} V_{1} s^{3} - C_{1} C_{2} L R_{2} V_{2} s^{3} - C_{1} C_{2} L R_{2} V_{4} s^{3} + C_{1} C_{3} L R_{2} V_{3} s^{3} - C_{1} L V_{4} s^{2} + C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{2} R_{2} V_{1} s - C_{2} R_{2} V_{2} s - C_{2} R_{2} V_{4} s - C_{3} L V_{4} s^{2} + C_{3} R_{2} V_{1} s - V_{4}}{C_{1} C_{2} L R_{2} s^{4} + C_{1} C_{3} L R_{2} s^{4} + C_{1} L s^{3} + C_{2} C_{3} L R_{2} s^{4} + C_{2} R_{2} s^{2} + C_{3} L s^{3} + C_{3} R_{2} s^{2} + s}\\)\\(v_{6} = \\frac{V_{3}}{s}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} + C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} + C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} + C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} - C_{1} C_{2} L V_{1} s^{2} + C_{1} C_{2} L V_{2} s^{2} - C_{1} C_{2} R_{2} V_{1} s + C_{1} C_{2} R_{2} V_{3} s - C_{1} C_{3} R_{2} V_{1} s + C_{1} C_{3} R_{2} V_{3} s - C_{1} V_{1} + C_{1} V_{3} - C_{2} C_{3} L V_{1} s^{2} + C_{2} C_{3} L V_{2} s^{2} - C_{2} V_{1} + C_{2} V_{2} - C_{3} V_{1} - C_{3} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{V2} = \\frac{C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{1} C_{2} L V_{1} s^{2} - C_{1} C_{2} L V_{2} s^{2} + C_{2} C_{3} L V_{1} s^{2} - C_{2} C_{3} L V_{2} s^{2} - C_{2} C_{3} R_{2} V_{2} s - C_{2} C_{3} R_{2} V_{4} s + C_{2} V_{1} - C_{2} V_{2}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{V3} = \\frac{C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} + C_{1} C_{2} R_{2} V_{1} s - C_{1} C_{2} R_{2} V_{3} s - C_{1} C_{3} L V_{3} s^{2} - C_{1} C_{3} L V_{4} s^{2} + C_{1} C_{3} R_{2} V_{1} s - C_{1} C_{3} R_{2} V_{3} s + C_{1} V_{1} - C_{1} V_{3}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{V4} = \\frac{C_{1} C_{2} C_{3} L R_{2} V_{1} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{2} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{3} s^{3} - C_{1} C_{2} C_{3} L R_{2} V_{4} s^{3} - C_{1} C_{3} L V_{3} s^{2} - C_{1} C_{3} L V_{4} s^{2} - C_{2} C_{3} R_{2} V_{2} s - C_{2} C_{3} R_{2} V_{4} s - C_{3} V_{1} - C_{3} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\\(I_{L} = \\frac{C_{1} C_{2} R_{2} V_{1} s - C_{1} C_{2} R_{2} V_{3} s + C_{1} C_{3} R_{2} V_{1} s - C_{1} C_{3} R_{2} V_{3} s + C_{1} V_{1} - C_{1} V_{3} + C_{2} C_{3} R_{2} V_{2} s + C_{2} C_{3} R_{2} V_{4} s + C_{3} V_{1} + C_{3} V_{4}}{C_{1} C_{2} L R_{2} s^{3} + C_{1} C_{3} L R_{2} s^{3} + C_{1} L s^{2} + C_{2} C_{3} L R_{2} s^{3} + C_{2} R_{2} s + C_{3} L s^{2} + C_{3} R_{2} s + 1}\\)\n\n\nNetwork equations and solution in symbolic form are seaily obtained. These equations are in the frequency domain and if transformed back to the time domain, they would be differential equations. But not necessarily in the form of state equations. In this case the equations are a little too long to provide any insight into the operation of the circuit.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#initial-conditions-with-component-values",
    "href": "Bridge-T.html#initial-conditions-with-component-values",
    "title": "17  Bridge-T",
    "section": "17.4 Initial conditions with component values",
    "text": "17.4 Initial conditions with component values\nGet element values from network dataframe. As describe above, the orginal question didn’t have values associated with the components, so I’m using a value of one for all the values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  C_{3} : 1.0, \\  L : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0, \\  V_{2} : 1.0, \\  V_{3} : 1.0, \\  V_{4} : 1.0\\right\\}\\)\n\n\n\nNE_ic = NE_ic_sym.subs(element_values)\nNE_ic\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L} + I_{V1} + 1.0 s v_{1} - 1.0 s v_{4}\\\\- I_{L} + 2.0 s v_{2} - 1.0 s v_{5} - 1.0 s v_{6}\\\\- I_{V2} + I_{V4} + 1.0 v_{3}\\\\I_{V2} - 1.0 s v_{1} + 1.0 s v_{4}\\\\- I_{V4} - 1.0 s v_{2} + 1.0 s v_{5}\\\\I_{V3} - 1.0 s v_{2} + 1.0 s v_{6}\\\\v_{1}\\\\- v_{3} + v_{4}\\\\v_{6}\\\\v_{3} - v_{5}\\\\- 1.0 I_{L} s + v_{1} - v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1.0}{s}\\\\\\frac{1.0}{s}\\\\\\frac{1.0}{s}\\\\\\frac{1.0}{s}\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the network equations and display the results.\n\nU_ic = solve(NE_ic,X)\n\ntemp = ''\nfor i in U_ic.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_ic[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{s^{3} + 2.0 s + 1.0}{3.0 s^{4} + 2.0 s^{3} + 2.0 s^{2} + s}\\)\\(v_{3} = \\frac{2.0 s^{2} + 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(v_{4} = \\frac{5.0 s^{3} + 2.0 s^{2} + 4.0 s + 1.0}{3.0 s^{4} + 2.0 s^{3} + 2.0 s^{2} + s}\\)\\(v_{5} = \\frac{- s^{3} - 2.0 s^{2} - 1.0}{3.0 s^{4} + 2.0 s^{3} + 2.0 s^{2} + s}\\)\\(v_{6} = \\frac{1}{s}\\)\\(I_{V1} = \\frac{2.0 s^{3} - 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{V2} = \\frac{- 2.0 s^{3} - 2.0 s}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{V3} = \\frac{- 2.0 s^{3} - 2.0 s^{2}}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{V4} = \\frac{- 2.0 s^{3} - 2.0 s^{2} - 2.0 s - 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)\\(I_{L} = \\frac{2.0 s + 2.0}{3.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#node-2-voltage",
    "href": "Bridge-T.html#node-2-voltage",
    "title": "17  Bridge-T",
    "section": "17.5 Node 2 voltage",
    "text": "17.5 Node 2 voltage\n\nnode2 = U_ic[v2].nsimplify().simplify().expand().together()\nnode2\n\n\\(\\displaystyle \\frac{s^{3} + 2 s + 1}{s \\left(3 s^{3} + 2 s^{2} + 2 s + 1\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_2_voltage = inverse_laplace_transform(temp, s, t)\n#node_2_voltage\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(node2)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(s^{3} + 2 s + 1\\)denominator: \\(s \\left(3 s^{3} + 2 s^{2} + 2 s + 1\\right)\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{1}{s \\left(3 s^{3} + 2 s^{2} + 2 s + 1\\right)}, \\  \\frac{s^{2}}{3 s^{3} + 2 s^{2} + 2 s + 1}, \\  \\frac{2}{3 s^{3} + 2 s^{2} + 2 s + 1}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nthe SciPy function residue is used to get the residues and poles of the partial-fraction expansion\nbuild the partial expansion terms and find the inverse Laplace of each term and save\n\nReturns:\n\nr: Residues corresponding to the poles. For repeated poles, the residues are ordered to correspond to ascending by power fractions.\np: Poles ordered by magnitude in ascending order.\nk: Coefficients of the direct polynomial term.\n\nWhen computing the inverse Laplace transform, the Coefficients (k) are ignored since these transform to a Dirac delta function, \\(\\delta (t)\\) and don’t need to be plotted.\n\nN = []\n\nfor p in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node2 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node2 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(V_node2),label='v2(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#node-3-voltage",
    "href": "Bridge-T.html#node-3-voltage",
    "title": "17  Bridge-T",
    "section": "17.6 Node 3 voltage",
    "text": "17.6 Node 3 voltage\nThe voltage on node 3 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nnode3 = U_ic[v3].nsimplify().simplify().expand().together()\nnode3\n\n\\(\\displaystyle \\frac{2 \\left(s^{2} + 1\\right)}{3 s^{3} + 2 s^{2} + 2 s + 1}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_2_voltage = inverse_laplace_transform(temp, s, t)\n#node_2_voltage\n\nUsing NumPy\nExtract the numerator and denominator and display.\n\nn, d = fraction(node3)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(2 s^{2} + 2\\)denominator: \\(3 s^{3} + 2 s^{2} + 2 s + 1\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{2}{3 s^{3} + 2 s^{2} + 2 s + 1}, \\  \\frac{2 s^{2}}{3 s^{3} + 2 s^{2} + 2 s + 1}\\right]\\)\n\n\nProcess term as decribed above.\n\nN = []\n\nfor p in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nSum all the terms.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node3 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node3 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x, np.real(V_node3),label='v3(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#ltspice-solution",
    "href": "Bridge-T.html#ltspice-solution",
    "title": "17  Bridge-T",
    "section": "17.7 LTSpice Solution",
    "text": "17.7 LTSpice Solution\nTo chech the Python results the circuit was simulated in LTSpice. The following schematice was used and the LTSpice results are also shown below.\n\n\n\n\n\n\nFigure 17.3: Circuit used for LTSpice analysis\n\n\n\n\n\n\n\n\n\nFigure 17.4: Plot from LTSpice of node voltages\n\n\n\nLoad the csv file LTSpice results and plot along with the results obtained from Python.\n\nfn = 'Bridge-T-LTSpice.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\nCopy the data from the csv file into NumPy arrays.\n\n# initaliase some empty arrays\ntime = np.zeros(len(LTSpice_data))\nvoltage1 = np.zeros(len(LTSpice_data))\nvoltage2 = np.zeros(len(LTSpice_data))\nvoltage3 = np.zeros(len(LTSpice_data))\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    time[i] = LTSpice_data[i][0]\n    voltage1[i] = LTSpice_data[i][1]\n    voltage2[i] = LTSpice_data[i][2]\n    voltage3[i] = LTSpice_data[i][3]\n\nPlot the LTSpice data and the Python data to see if they agree.\n\nplt.title('LTSpice')\n\nplt.plot(time, voltage1,label='LTSpice v1(t)')\nplt.plot(time, voltage2,label='LTSpice v2(t)')\nplt.plot(time, voltage3,label='LTSpice v3(t)')\n\nplt.plot(x, np.real(V_node2),label='V node 2(t)')\nplt.plot(x, np.real(V_node3),label='V node 3(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plot above, the curves superimpose.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Bridge-T.html#summary",
    "href": "Bridge-T.html#summary",
    "title": "17  Bridge-T",
    "section": "17.8 Summary",
    "text": "17.8 Summary\nIn this notebook, newtork equations were solved which had initial conditions. The independent voltage source, V1 was modeled as a step function. The initial voltages on each of the capacitors were also modeled as step functions equal to the initial voltage. The network equations were generated with MNA and SymPy was used to solve the system of equations. The results were compared to results from LTSpice and the curves superimpose.\nThe MNA procedure and LTSpice didn’t have any issues with initial conditions. At t=0, all the voltages and currents in the circuit comply with Kirchhoff’s circuit laws (KCL) since the Heavyside function at t=0 is zero. At t=0+, where the + indicates the next infinitesimal instant in time, the voltages and currents would comply with KCL and result in large current flows to accomidate the solution for the voltages. Both Python and LTSpice step through time in discreate amounts, and at each step time KCL is satisified. I don’t think this was explained in any of the answers provided.\nThe answers provide by Franc (2023) are different from the results I obtained and he did not provide a time domain solution and plots of the node voltages.\n\n\n\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nLees, Andrew. 2023. “Solution of Electrical Network Where Arbitrary Initial Conditions Cannot Be Assigned.” 2023. https://electronics.stackexchange.com/questions/682634/solution-of-electrical-network-where-arbitrary-initial-conditions-cannot-be-assi.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bridge-T</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html",
    "href": "Pi-Filter.html",
    "title": "18  Pi Filter",
    "section": "",
    "text": "18.1 Introduction\nA question posted on Electronics Stackexchange by user15174 (2023) looked interesting, he asked:\nThe FACTS (Fast Analytical Circuits Techniques) method refers to a circuit analysis technique that enables engineers to obtain the transfer functions and input and output impedances of a circuit by inspection without resorting to too much algebra. The circuits offered as illustrations of the technique are small with one or two reactive elements. Middlebrook (1991) seems to have been the first proponent of the method and describes what he calls design oriented analysis. He talks about low entropy equations, in which the terms and elements are ordered or grouped in such a way that their physical origin, where they come from in the circuit, and what part of the circuit contributes to this part of the final expression becomes obvious. The method is also described in Middlebrook (1992).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#introduction",
    "href": "Pi-Filter.html#introduction",
    "title": "18  Pi Filter",
    "section": "",
    "text": "Am trying to apply the FACTS method to find out the transfer function for this circuit as shown below. This is a Pi-filter circuit with all its component parasitics and also including the source and load resistances. I would like to find out the transfer function of this circuit and match its plot from Mathcad with simulation.\n\n\nFirst, to find out the zeros of this transfer function by inspection, I placed all circuit elements in its high frequency state. I can observe the response Vout is still present. In that case, can I assume that this circuit has 6 zeros associated with it?\n\n\nBut as per the answer provided in this link, we have to place the other associated circuit element in its DC state and observe if the response is still present. Since this circuit has around 6 reactive elements, how do I decide which circuit element should be in DC State and which circuit element should be in high frequency state?\n\n\nI was able to follow some examples done based on 2nd and 3rd order circuits shared in the above links. But with this circuit configuration and so many reactive elements, frankly I am lost. It would be great if you could share some insight on how to derive the transfer function for this circuit including its poles and zeros.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#community-answers",
    "href": "Pi-Filter.html#community-answers",
    "title": "18  Pi Filter",
    "section": "18.2 Community answers",
    "text": "18.2 Community answers\nThere were two answers provided by the community. User Franc (2023) provided a detailed solution based on reducing the circuit to Z1, Z2 and Z3 as shown in Figure 18.2 and then substituting back into the transfer function the impedances for each of the Z’s. User Telsa23 provided a shorter answer, also based on reducing the circuit to Z1, Z2 and Z3, but where a different expression for the transfer function was obtained. Neither of these answers follow the FACTS method, since the Extra Element Theorem was not employed during the analysis.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#circuit-description",
    "href": "Pi-Filter.html#circuit-description",
    "title": "18  Pi Filter",
    "section": "18.3 Circuit description",
    "text": "18.3 Circuit description\nFigure 18.1 shows the schematic as I re-drew it in LTSpice with all the values set to one. I numbered each of the nodes and made some changes to the reference designators. In the original question, no component values were provided. user15174 (2023) stated that component parasitics are included, but he didn’t indicate which circuit elements he considered parasitic. I’m going to consider C1, L3 and C2 as the main components of the Pi-Filter. \\(R_{in}\\) and \\(R_{out}\\) are the source and load impedances. All other elements in the schematic are parasitic and the values will be assigned later in the analysis.\nWith C1, L3 and C2 being considered as the main components, the circuit is a three section low pass filter, sometimes called a Pi filter because the connection represents the greek letter \\(\\pi\\). The schematic in Figure 18.1 has 13 branches and 8 nodes.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#circuit-analysis",
    "href": "Pi-Filter.html#circuit-analysis",
    "title": "18  Pi Filter",
    "section": "18.4 Circuit analysis",
    "text": "18.4 Circuit analysis\nuser15174 (2023) asked for a FACTS analysis. However, I think the circuit has too many reactive components for a FACTS analysis since this is a 6th order circuit. Following my review of FACTS, I present a ‘brute force’ analysis followed by a rework of Franc (2023)’s solution. A MNA of the filter with the parasitic components removed is presented. This is a third order circuit and SymPy can obtain solutions for the poles of the transfer function.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#facts",
    "href": "Pi-Filter.html#facts",
    "title": "18  Pi Filter",
    "section": "18.5 FACTS",
    "text": "18.5 FACTS\nThe origin of the FACTS circuit analysis method, as stated above, is from Middlebrook (1991). IEEE technical papers and books by Basso (2016) and Vorpérian (2002) have been written on the subject, however these are not free or available to download for free. FACTS is a circuit analysis method where the transfer function is determined by applying the Extra Element Theorem. Christophe Basso, Vatché Vorpérian and others have open source content available:\n\nFast Analytical Techniques for Electrical and Electronic Circuits\nIntroduction to Fast Analytical Techniques: Application to Small-Signal Modeling\nA series of 21 YouTube videos starting with: Fast Analytical Techniques for Electrical and Electronic Circuits\nExtra Element Theorem: An Introduction (with Examples)\n\nAccording to the open source FACTS literature:\n\nThe well-known and widely used methods of nodal or loop analysis, while effective for obtaining numerical solutions, are largely ineffective for deriving analytical solutions in symbolic form, except for simple circuits. Attempting to invert a matrix with symbolic entries, even for low-order matrices, results in tedious algebra and complex, high-entropy expressions that provide little meaningful insight.\n\nThe FACTS procedure, as illustrated in the open source literature, employs example circuits that are usually of order 1 or 2. The procedure results in equations that keep circuit elements grouped together and thus the equations are more intuitive. For 3rd order and higher circuits, the procedure becomes rather involved and I didn’t see any circuit analysis examples beyond a 2nd order circuit.\nTraditional circuit analysis techniques usually don’t produce analytical answers, i.e. equations in terms of symbols. Both the FACTS procedure and the MNA Python code in this book yield analytical answers, with the FACTS results possibly being more intuitive and the MNA Python code providing an automated solution, which would then have to be algebraically manipulated to be put into a FACTS type solution. The circuit in question is a 6th order network and much too difficult to analyze by hand or with the FACTS method.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#brute-force-mna-procedure",
    "href": "Pi-Filter.html#brute-force-mna-procedure",
    "title": "18  Pi Filter",
    "section": "18.6 ‘Brute Force’ MNA procedure",
    "text": "18.6 ‘Brute Force’ MNA procedure\nDoing a so called brute force analysis. The goal is to get the transfer function, \\(H(s)=\\frac {V_2}{V_8}\\) and the poles and zeros of \\(H(s)\\). SymPy will be used to ‘brute force’ analyze the circuit and solve for the transfer function and find the poles and zeros.\nThe net list for the filter is:\nV1 8 0 1\nR_in 1 8 1\nR1 1 4 1\nRa 3 1 1\nR2 2 3 1\nR3 2 6 1\nR_out 2 0 1\nL1 4 5 1 Rser=0\nL2 3 2 1 Rser=0\nL3 6 7 1 Rser=0\nC1 5 0 1\nC2 2 3 1\nC3 7 0 1\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\nLoad the netlist generated from Figure 18.1.\n\nnet_list = '''\nV1 8 0 1\nR_in 1 8 1\nR1 1 4 1\nRa 3 1 1\nR2 2 3 1\nR3 2 6 1\nR_out 2 0 1\nL1 4 5 1 \nL2 3 2 1 \nL3 6 7 1\nC1 5 0 1\nC2 2 3 1\nC3 7 0 1\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nBuild the network equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = v_{1} \\cdot \\left(\\frac{1}{Ra} + \\frac{1}{R_{in}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{Ra} - \\frac{v_{8}}{R_{in}} - \\frac{v_{4}}{R_{1}}\\)\\(0 = - I_{L2} + v_{2} \\left(C_{2} s + \\frac{1}{R_{out}} + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) + v_{3} \\left(- C_{2} s - \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{3}}\\)\\(0 = I_{L2} + v_{2} \\left(- C_{2} s - \\frac{1}{R_{2}}\\right) + v_{3} \\left(C_{2} s + \\frac{1}{Ra} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{Ra}\\)\\(0 = I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}}\\)\\(0 = C_{1} s v_{5} - I_{L1}\\)\\(0 = I_{L3} - \\frac{v_{2}}{R_{3}} + \\frac{v_{6}}{R_{3}}\\)\\(0 = C_{3} s v_{7} - I_{L3}\\)\\(0 = I_{V1} - \\frac{v_{1}}{R_{in}} + \\frac{v_{8}}{R_{in}}\\)\\(V_{1} = v_{8}\\)\\(0 = - I_{L1} L_{1} s + v_{4} - v_{5}\\)\\(0 = - I_{L2} L_{2} s - v_{2} + v_{3}\\)\\(0 = - I_{L3} L_{3} s + v_{6} - v_{7}\\)\n\n\nAs shown above, MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time.\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{2}, \\  v_{1}, \\  I_{L2}, \\  I_{V1}, \\  I_{L3}, \\  v_{2}, \\  v_{4}, \\  R_{out}, \\  R_{2}, \\  C_{2}, \\  C_{3}, \\  v_{3}, \\  R_{1}, \\  v_{8}, \\  Ra, \\  R_{3}, \\  s, \\  v_{5}, \\  L_{1}, \\  L_{3}, \\  C_{1}, \\  I_{L1}, \\  v_{7}, \\  v_{6}, \\  V_{1}, \\  R_{in}\\right)\\)\n\n\nGenerate the symbolic solution, which takes a couple of minutes on my laptop (i3-8130U 2.20GHz).\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution. The espressions are long, so code to display is commented.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n# Markdown(temp)\n\nSolve for the transfer function \\(H(s)=\\frac {V_2}{V_8}\\) in symbolic form. As you can see the expression is long.\n\nH_sym = (U_sym[v2]/U_sym[v8]).simplify().collect(s)\nH_sym\n\n\\(\\displaystyle \\frac{R_{out} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} s^{6} + R_{2} + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3}\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{2} L_{1} L_{2} R_{2} + C_{1} C_{3} L_{1} L_{2} R_{3} + C_{1} C_{3} L_{1} L_{3} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} + C_{2} C_{3} L_{2} L_{3} R_{2}\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} + C_{1} C_{3} L_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{3} + C_{1} C_{3} L_{3} R_{1} R_{2} + C_{1} L_{1} L_{2} + C_{2} C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} L_{3}\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} + C_{1} L_{1} R_{2} + C_{1} L_{2} R_{1} + C_{2} L_{2} R_{2} + C_{3} L_{2} R_{3} + C_{3} L_{3} R_{2}\\right) + s \\left(C_{1} R_{1} R_{2} + C_{3} R_{2} R_{3} + L_{2}\\right)\\right)}{R_{2} R_{in} + R_{2} R_{out} + R_{2} Ra + s^{6} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} Ra\\right) + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} L_{2} L_{3} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} L_{3} Ra\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} Ra + C_{1} C_{2} L_{1} L_{2} R_{2} R_{in} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{2} L_{1} L_{2} R_{2} Ra + C_{1} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} Ra + C_{1} C_{3} L_{1} L_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{out} Ra + C_{1} C_{3} L_{1} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{3} R_{2} Ra + C_{1} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{1} Ra + C_{1} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{in} Ra + C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} + C_{2} C_{3} L_{2} L_{3} R_{2} Ra\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} R_{in} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{2} L_{2} R_{1} R_{2} Ra + C_{1} C_{2} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} L_{2} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{3} Ra + C_{1} C_{3} L_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{out} Ra + C_{1} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} Ra + C_{1} C_{3} L_{2} R_{1} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{out} Ra + C_{1} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} Ra + C_{1} C_{3} L_{2} R_{in} R_{out} Ra + C_{1} C_{3} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{3} R_{1} R_{2} Ra + C_{1} C_{3} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{3} R_{2} R_{in} Ra + C_{1} L_{1} L_{2} R_{2} + C_{1} L_{1} L_{2} R_{in} + C_{1} L_{1} L_{2} R_{out} + C_{1} L_{1} L_{2} Ra + C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{3} Ra + C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{out} Ra + C_{3} L_{2} L_{3} R_{2} + C_{3} L_{2} L_{3} R_{in} + C_{3} L_{2} L_{3} R_{out} + C_{3} L_{2} L_{3} Ra\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{3} Ra + C_{1} C_{3} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{out} Ra + C_{1} C_{3} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} R_{2} R_{3} R_{in} Ra + C_{1} C_{3} R_{2} R_{in} R_{out} Ra + C_{1} L_{1} R_{2} R_{in} + C_{1} L_{1} R_{2} R_{out} + C_{1} L_{1} R_{2} Ra + C_{1} L_{2} R_{1} R_{2} + C_{1} L_{2} R_{1} R_{in} + C_{1} L_{2} R_{1} R_{out} + C_{1} L_{2} R_{1} Ra + C_{1} L_{2} R_{2} R_{in} + C_{1} L_{2} R_{in} R_{out} + C_{1} L_{2} R_{in} Ra + C_{2} L_{2} R_{2} R_{in} + C_{2} L_{2} R_{2} R_{out} + C_{2} L_{2} R_{2} Ra + C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} R_{2} R_{out} + C_{3} L_{2} R_{3} R_{in} + C_{3} L_{2} R_{3} R_{out} + C_{3} L_{2} R_{3} Ra + C_{3} L_{2} R_{in} R_{out} + C_{3} L_{2} R_{out} Ra + C_{3} L_{3} R_{2} R_{in} + C_{3} L_{3} R_{2} R_{out} + C_{3} L_{3} R_{2} Ra\\right) + s \\left(C_{1} R_{1} R_{2} R_{in} + C_{1} R_{1} R_{2} R_{out} + C_{1} R_{1} R_{2} Ra + C_{1} R_{2} R_{in} R_{out} + C_{1} R_{2} R_{in} Ra + C_{3} R_{2} R_{3} R_{in} + C_{3} R_{2} R_{3} R_{out} + C_{3} R_{2} R_{3} Ra + C_{3} R_{2} R_{in} R_{out} + C_{3} R_{2} R_{out} Ra + L_{2} R_{2} + L_{2} R_{in} + L_{2} R_{out} + L_{2} Ra\\right)}\\)\n\n\nAs shown above the symbolic solution is long on not very insightful. The FACTS method is supposed to reveal aspects of the circuit’s operation that is hidden by the algebra. I think the Pi Filter with parasitic elements included is too complex.\nThe numerator and denominator of the transfer function can be extracted for analysis.\n\nn, d = fraction(H_sym)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle R_{out} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} s^{6} + R_{2} + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3}\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{2} L_{1} L_{2} R_{2} + C_{1} C_{3} L_{1} L_{2} R_{3} + C_{1} C_{3} L_{1} L_{3} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} + C_{2} C_{3} L_{2} L_{3} R_{2}\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} + C_{1} C_{3} L_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{3} + C_{1} C_{3} L_{3} R_{1} R_{2} + C_{1} L_{1} L_{2} + C_{2} C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} L_{3}\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} + C_{1} L_{1} R_{2} + C_{1} L_{2} R_{1} + C_{2} L_{2} R_{2} + C_{3} L_{2} R_{3} + C_{3} L_{3} R_{2}\\right) + s \\left(C_{1} R_{1} R_{2} + C_{3} R_{2} R_{3} + L_{2}\\right)\\right)\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle R_{2} R_{in} + R_{2} R_{out} + R_{2} Ra + s^{6} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} Ra\\right) + s^{5} \\left(C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} Ra + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} L_{2} L_{3} R_{2} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} L_{3} Ra\\right) + s^{4} \\left(C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} Ra + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{out} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} Ra + C_{1} C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} Ra + C_{1} C_{2} L_{1} L_{2} R_{2} R_{in} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{2} L_{1} L_{2} R_{2} Ra + C_{1} C_{3} L_{1} L_{2} R_{2} R_{3} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{3} Ra + C_{1} C_{3} L_{1} L_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} L_{2} R_{out} Ra + C_{1} C_{3} L_{1} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} + C_{1} C_{3} L_{1} L_{3} R_{2} Ra + C_{1} C_{3} L_{2} L_{3} R_{1} R_{2} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{1} Ra + C_{1} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{1} C_{3} L_{2} L_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} L_{3} R_{in} Ra + C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} + C_{2} C_{3} L_{2} L_{3} R_{2} Ra\\right) + s^{3} \\left(C_{1} C_{2} L_{2} R_{1} R_{2} R_{in} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{2} L_{2} R_{1} R_{2} Ra + C_{1} C_{2} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{2} L_{2} R_{2} R_{in} Ra + C_{1} C_{3} L_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{3} Ra + C_{1} C_{3} L_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{1} R_{2} R_{out} Ra + C_{1} C_{3} L_{2} R_{1} R_{2} R_{3} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{3} Ra + C_{1} C_{3} L_{2} R_{1} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{1} R_{out} Ra + C_{1} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{1} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} L_{2} R_{3} R_{in} Ra + C_{1} C_{3} L_{2} R_{in} R_{out} Ra + C_{1} C_{3} L_{3} R_{1} R_{2} R_{in} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} + C_{1} C_{3} L_{3} R_{1} R_{2} Ra + C_{1} C_{3} L_{3} R_{2} R_{in} R_{out} + C_{1} C_{3} L_{3} R_{2} R_{in} Ra + C_{1} L_{1} L_{2} R_{2} + C_{1} L_{1} L_{2} R_{in} + C_{1} L_{1} L_{2} R_{out} + C_{1} L_{1} L_{2} Ra + C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{3} Ra + C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} + C_{2} C_{3} L_{2} R_{2} R_{out} Ra + C_{3} L_{2} L_{3} R_{2} + C_{3} L_{2} L_{3} R_{in} + C_{3} L_{2} L_{3} R_{out} + C_{3} L_{2} L_{3} Ra\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{2} R_{3} R_{in} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{3} Ra + C_{1} C_{3} R_{1} R_{2} R_{in} R_{out} + C_{1} C_{3} R_{1} R_{2} R_{out} Ra + C_{1} C_{3} R_{2} R_{3} R_{in} R_{out} + C_{1} C_{3} R_{2} R_{3} R_{in} Ra + C_{1} C_{3} R_{2} R_{in} R_{out} Ra + C_{1} L_{1} R_{2} R_{in} + C_{1} L_{1} R_{2} R_{out} + C_{1} L_{1} R_{2} Ra + C_{1} L_{2} R_{1} R_{2} + C_{1} L_{2} R_{1} R_{in} + C_{1} L_{2} R_{1} R_{out} + C_{1} L_{2} R_{1} Ra + C_{1} L_{2} R_{2} R_{in} + C_{1} L_{2} R_{in} R_{out} + C_{1} L_{2} R_{in} Ra + C_{2} L_{2} R_{2} R_{in} + C_{2} L_{2} R_{2} R_{out} + C_{2} L_{2} R_{2} Ra + C_{3} L_{2} R_{2} R_{3} + C_{3} L_{2} R_{2} R_{out} + C_{3} L_{2} R_{3} R_{in} + C_{3} L_{2} R_{3} R_{out} + C_{3} L_{2} R_{3} Ra + C_{3} L_{2} R_{in} R_{out} + C_{3} L_{2} R_{out} Ra + C_{3} L_{3} R_{2} R_{in} + C_{3} L_{3} R_{2} R_{out} + C_{3} L_{3} R_{2} Ra\\right) + s \\left(C_{1} R_{1} R_{2} R_{in} + C_{1} R_{1} R_{2} R_{out} + C_{1} R_{1} R_{2} Ra + C_{1} R_{2} R_{in} R_{out} + C_{1} R_{2} R_{in} Ra + C_{3} R_{2} R_{3} R_{in} + C_{3} R_{2} R_{3} R_{out} + C_{3} R_{2} R_{3} Ra + C_{3} R_{2} R_{in} R_{out} + C_{3} R_{2} R_{out} Ra + L_{2} R_{2} + L_{2} R_{in} + L_{2} R_{out} + L_{2} Ra\\right)\\)\n\n\nSolve for the roots of the numerator.\n\nsolve(n,s)\n\n\\(\\displaystyle \\left[ \\frac{- C_{1} R_{1} - \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{1} R_{1} + \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{3} R_{3} - \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- C_{3} R_{3} + \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- L_{2} - \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}, \\  \\frac{- L_{2} + \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}\\right]\\)\n\n\nWe can see that there are six zeros in the transfer function. Here can see what components are influncing the zeros. One of the gaols of the FACTS method was to determine the zeros of the network and express them in terms of the components.\nSolve for the roots of the denominator\n\n#solve(d,s)\n\nSymPy could not find a solution for roots of denominator.\n\n18.6.1 Use numerical values for components\nBuilt a dictionary of element values. The LTSpice schematic had all the component values set to one.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  C_{3} : 1.0, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  L_{3} : 1.0, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{in} : 1.0, \\  R_{out} : 1.0, \\  Ra : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nIn this analysis, we are going to assum that the circuit is a low pass filter and the parasitics component values are scalled by 1000 from the value of the main components.\n\n# the values of the main components \nCa = 1 \nCb = 1\nLa = 2\nsf = 1e3 # parasitic scale factor\n\nelement_values[R1] = Ca/sf\nelement_values[Ra] = La/sf\nelement_values[R2] = La*sf\nelement_values[R3] = Cb/sf\n\nelement_values[L1] = Ca/sf\nelement_values[L2] = La\nelement_values[L3] = Cb/sf\nelement_values[C1] = Ca\nelement_values[C2] = La/sf\nelement_values[C3] = Cb\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1, \\  C_{2} : 0.002, \\  C_{3} : 1, \\  L_{1} : 0.001, \\  L_{2} : 2, \\  L_{3} : 0.001, \\  R_{1} : 0.001, \\  R_{2} : 2000.0, \\  R_{3} : 0.001, \\  R_{in} : 1.0, \\  R_{out} : 1.0, \\  Ra : 0.002, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\n\n18.6.2 Numerical solution\nDisplay the equations with component values.\n\nNE = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = 1501.0 v_{1} - 500.0 v_{3} - 1000.0 v_{4} - 1.0 v_{8}\\)\\(0 = - I_{L2} + v_{2} \\cdot \\left(0.002 s + 1001.0005\\right) + v_{3} \\left(- 0.002 s - 0.0005\\right) - 1000.0 v_{6}\\)\\(0 = I_{L2} - 500.0 v_{1} + v_{2} \\left(- 0.002 s - 0.0005\\right) + v_{3} \\cdot \\left(0.002 s + 500.0005\\right)\\)\\(0 = I_{L1} - 1000.0 v_{1} + 1000.0 v_{4}\\)\\(0 = - I_{L1} + s v_{5}\\)\\(0 = I_{L3} - 1000.0 v_{2} + 1000.0 v_{6}\\)\\(0 = - I_{L3} + s v_{7}\\)\\(0 = I_{V1} - 1.0 v_{1} + 1.0 v_{8}\\)\\(1.0 = v_{8}\\)\\(0 = - 0.001 I_{L1} s + v_{4} - v_{5}\\)\\(0 = - 2 I_{L2} s - v_{2} + v_{3}\\)\\(0 = - 0.001 I_{L3} s + v_{6} - v_{7}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{2004.0 s^{6} + 1008509.0 s^{5} + 1006517006.0 s^{4} + 3012013501.0 s^{3} + 1005009503000.0 s^{2} + 1002503000000.0 s + 501000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{2} = \\frac{2000.0 s^{6} + 4500.0 s^{5} + 4503000.0 s^{4} + 6000500.0 s^{3} + 3001500000.0 s^{2} + 1500000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{3} = \\frac{2000.0 s^{6} + 1004500.0 s^{5} + 1006503000.0 s^{4} + 3007000500.0 s^{3} + 1005001500000.0 s^{2} + 1001500000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{4} = \\frac{2004.0 s^{6} + 1006505.0 s^{5} + 1005510501.0 s^{4} + 2008507000.0 s^{3} + 1004007501000.0 s^{2} + 1002002000000.0 s + 501000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{5} = \\frac{2004000.0 s^{4} + 1006505000.0 s^{3} + 1003506501000.0 s^{2} + 1002002000000.0 s + 501000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{6} = \\frac{2000.0 s^{6} + 2500.0 s^{5} + 4500500.0 s^{4} + 3500000.0 s^{3} + 3000500000.0 s^{2} + 1000000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{7} = \\frac{2000000.0 s^{4} + 2500000.0 s^{3} + 2500500000.0 s^{2} + 1000000000.0 s + 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(v_{8} = 1.0\\)\\(I_{V1} = \\frac{- 2000.0 s^{6} - 4008500.0 s^{5} - 1013508000.0 s^{4} - 1006013001500.0 s^{3} - 1006003500000.0 s^{2} - 1002500000000.0 s - 500000000000.0}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(I_{L1} = \\frac{2004000.0 s^{5} + 1006505000.0 s^{4} + 1003506501000.0 s^{3} + 1002002000000.0 s^{2} + 501000000000.0 s}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\\(I_{L2} = \\frac{500000.0 s^{2} + 500000.0 s + 500000000.0}{4004.0 s^{4} + 1009005.0 s^{3} + 1006007001.0 s^{2} + 1003002000.0 s + 1001000000.0}\\)\\(I_{L3} = \\frac{2000000.0 s^{5} + 2500000.0 s^{4} + 2500500000.0 s^{3} + 1000000000.0 s^{2} + 500000000000.0 s}{4004.0 s^{6} + 5017009.0 s^{5} + 2020025006.0 s^{4} + 1009025015001.0 s^{3} + 2011013003000.0 s^{2} + 2005003000000.0 s + 1001000000000.0}\\)\n\n\n\nH = (U[v2]/U[v8]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{500 \\cdot \\left(4 s^{6} + 9 s^{5} + 9006 s^{4} + 12001 s^{3} + 6003000 s^{2} + 3000000 s + 1000000000\\right)}{4004 s^{6} + 5017009 s^{5} + 2020025006 s^{4} + 1009025015001 s^{3} + 2011013003000 s^{2} + 2005003000000 s + 1001000000000}\\)\n\n\nThe code below converst the SymPy equations into NumPy format. Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n18.6.3 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained and plotted with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n# plot the poles and zeros\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\n#plt.ylim((-2,2))\n#plt.xlim((-4,0))\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPrinting the value of the poles and zeros in radians per second.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of zeros: 6\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.125+15.811j rad/s\n-0.125-15.811j rad/s\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of poles: 6\n-1,000.000+0.000j rad/s\n-125.501+485.024j rad/s\n-125.501-485.024j rad/s\n-1.000+0.000j rad/s\n-0.499+0.865j rad/s\n-0.499-0.865j rad/s\n\n\n\n\n18.6.4 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(-2, 2, 1000, endpoint=False) #*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, radians')\n\nplt.semilogx(w, mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w, phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#re-work-of-user347817s-solution",
    "href": "Pi-Filter.html#re-work-of-user347817s-solution",
    "title": "18  Pi Filter",
    "section": "18.7 Re-work of Franc (2023)’s solution",
    "text": "18.7 Re-work of Franc (2023)’s solution\nThe solution provided by Franc (2023) is not a solution that following the FACTS method. He calculates the transfer function based on the ratio of the impedances of a voltage divider. Figure 18.2, shows the orginal circuit re-drawn with the branches replaced by their transformed impedances.\n\n\n\n\n\n\nFigure 18.2: Pi filter schematic with branch impedances replaced by Z1, Z2 and Z3\n\n\n\nThe components for the branches are replace by Z1, Z2 and Z3.\nZ1 = series connection of R1, L1 and C1\n\nZ2 = series connection of Ra and (L2 || C2 || R2)\n\nZ3 = series connection of R3, L3 and C3\n\nZ4 = Z3 || R_out\nThe following defines the SymPy symbols used in the calculations. The function symbols takes a string of variable names separated by spaces or commas, and creates Symbols out of them.\n\nL1, L2, L3, R1, R2, R3, Ra, R, R_out, R_in, C1, C2, C3, s, V1 = symbols('L1, L2, L3, R1, R2, R3, Ra, R, R_out, R_in, C1, C2, C3, s, V1')\n\n\n18.7.1 Branches of the circuit\nZ1 is the series connection of R1, C1 and L1.\n\nZ1_sym = R1+s*L1+1/(s*C1)\nZ1_sym\n\n\\(\\displaystyle L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\)\n\n\nZ2 is the series connection of Ra and the paralle connection of R2, L2 and C2\n\nZ2_sym = (Ra+1/(1/(1/(s*C2)) + 1/(s*L2) + 1/R2))\nZ2_sym\n\n\\(\\displaystyle Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\)\n\n\nZ3 is the series connection of R3, L3 and C3\n\nZ3_sym = R3+s*L3+1/(s*C3)\nZ3_sym\n\n\\(\\displaystyle L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\)\n\n\nZ4 is the parallel combination of R_out and Z3.\nZ4 = R_out || Z3\n\nZ4_sym = R_out*Z3_sym/(R_out+Z3_sym)\nZ4_sym\n\n\\(\\displaystyle \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}}\\)\n\n\nFranc (2023) provided a MatCAD like set of calculations. Using “||” to indicate a parallel combination of components and a “+” to indicate a series combination of componets, some of his calculations are shown here:\n\\(Z_1 = R_2 + sL_1 + \\frac {1}{sC_1}\\)\n\\(Z_2 = R_6 + R_3 || sL_2 || \\frac {1}{sC_2}\\)\n\\(Z_3 = R_4 + sL_3 + \\frac {1}{sC_3}\\)\n\\(Z_4 = Z_3 || R_2\\)\n\\(V_1 = \\frac {(Z_1 || (Z_2+Z_4))} {(R_1+Z_1 || (Z_2+Z_4))} V_i\\)\n\\(V_o = \\frac {Z_4} {(Z_4+Z_2)} V_1\\)\n\\(V_o = \\frac {Z_4} {(Z_4+Z_2)} \\frac {(Z_1 || (Z_2+Z_4))} {(R_1+Z_1 || (Z_2+Z_4))} V_i\\)\n\nZ1, Z2, Z3, Z4, R_in, R_out, V1 = symbols('Z1, Z2, Z3, Z4, R_in, R_out, V1')\n\nZx is the parallel combination of Z1, Z2 and Z4.\n\nZx = Z1*(Z2+Z4)/(Z1+Z2+Z4)\nZx\n\n\\(\\displaystyle \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\)\n\n\nThe voltage at node 1 is calculated by using the voltage divider formula for Zx and Rin.\n\nv_node1 = V1*Zx/(R_in+Zx)\nv_node1\n\n\\(\\displaystyle \\frac{V_{1} Z_{1} \\left(Z_{2} + Z_{4}\\right)}{\\left(R_{in} + \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\right) \\left(Z_{1} + Z_{2} + Z_{4}\\right)}\\)\n\n\nVout is the voltage divider of Z2 and Z4.\n\nV_out =  v_node1*Z4/(Z2+Z4)\nV_out\n\n\\(\\displaystyle \\frac{V_{1} Z_{1} Z_{4}}{\\left(R_{in} + \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\right) \\left(Z_{1} + Z_{2} + Z_{4}\\right)}\\)\n\n\nThe trasfer function is Vout/Vin. H_franc_sym\n\nH_franc_z = V_out/V1\nH_franc_z\n\n\\(\\displaystyle \\frac{Z_{1} Z_{4}}{\\left(R_{in} + \\frac{Z_{1} \\left(Z_{2} + Z_{4}\\right)}{Z_{1} + Z_{2} + Z_{4}}\\right) \\left(Z_{1} + Z_{2} + Z_{4}\\right)}\\)\n\n\n\nH_franc_z.simplify()\n\n\\(\\displaystyle \\frac{Z_{1} Z_{4}}{R_{in} \\left(Z_{1} + Z_{2} + Z_{4}\\right) + Z_{1} \\left(Z_{2} + Z_{4}\\right)}\\)\n\n\nRepeating the calculations from above, but using symbolic expressions for Z1, Z2, Z3 and Z4.\nZx is the combination of Z’s looking towards the output of the filter. Zx = Z1 || (Z2+Z4)\n\nZx_sym = Z1_sym*(Z2_sym+Z4_sym)/(Z1_sym+Z2_sym+Z4_sym)\nZx_sym\n\n\\(\\displaystyle \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\)\n\n\nThe voltage at node 1 is\nv_node1 = V1*Zx/(R_in+Zx)\n\nv_node1_sym = V1*Zx_sym/(R_in+Zx_sym)\nv_node1_sym\n\n\\(\\displaystyle \\frac{V_{1} \\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{\\left(R_{in} + \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\right) \\left(L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}\\right)}\\)\n\n\nV_out is the output of the voltage divider circuit formed by Z2 and Z4\n\nV_out_sym =  v_node1_sym*Z4_sym/(Z2_sym+Z4_sym)\nV_out_sym\n\n\\(\\displaystyle \\frac{R_{out} V_{1} \\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{\\left(R_{in} + \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\right) \\left(L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}\\right) \\left(L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}\\right)}\\)\n\n\n\n\n18.7.2 H_franc_sym\nThe transfer function as determined by taking the impedance of branches and combining by series and parallel combinations can be expressed below.\n\nH_franc_sym = V_out_sym/V1\nH_franc_sym\n\n\\(\\displaystyle \\frac{R_{out} \\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{\\left(R_{in} + \\frac{\\left(L_{1} s + R_{1} + \\frac{1}{C_{1} s}\\right) \\left(\\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}}\\right)}{L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}}\\right) \\left(L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}\\right) \\left(L_{1} s + R_{1} + \\frac{R_{out} \\left(L_{3} s + R_{3} + \\frac{1}{C_{3} s}\\right)}{L_{3} s + R_{3} + R_{out} + \\frac{1}{C_{3} s}} + Ra + \\frac{1}{C_{2} s + \\frac{1}{R_{2}} + \\frac{1}{L_{2} s}} + \\frac{1}{C_{1} s}\\right)}\\)\n\n\nThe expression above, probably comes closest to the reults that would be obtained from a FACTS analysis.\n\nH_franc_sym_1a = H_franc_sym.simplify()\nH_franc_sym_1a\n\n\\(\\displaystyle \\frac{R_{out} \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)}{R_{in} \\left(C_{1} L_{2} R_{2} s^{2} \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + C_{1} R_{out} s \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + C_{1} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(L_{1} s + R_{1} + Ra\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right) + \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(L_{2} R_{2} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + R_{out} \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + Ra \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right)}\\)\n\n\n\nn, d = fraction(H_franc_sym_1a)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle R_{out} \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle R_{in} \\left(C_{1} L_{2} R_{2} s^{2} \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + C_{1} R_{out} s \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + C_{1} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(L_{1} s + R_{1} + Ra\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right) + \\left(C_{1} s \\left(L_{1} s + R_{1}\\right) + 1\\right) \\left(L_{2} R_{2} s \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) + R_{out} \\left(C_{3} s \\left(L_{3} s + R_{3}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right) + Ra \\left(C_{3} s \\left(L_{3} s + R_{3} + R_{out}\\right) + 1\\right) \\left(C_{2} L_{2} R_{2} s^{2} + L_{2} s + R_{2}\\right)\\right)\\)\n\n\nSolve for the roots of the numberator.\n\nn.simplify().expand()\n\n\\(\\displaystyle C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} s^{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} s^{5} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} s^{4} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} s^{4} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} s^{2} + C_{1} L_{1} L_{2} R_{out} s^{3} + C_{1} L_{1} R_{2} R_{out} s^{2} + C_{1} L_{2} R_{1} R_{out} s^{2} + C_{1} R_{1} R_{2} R_{out} s + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} s^{4} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} s^{3} + C_{2} L_{2} R_{2} R_{out} s^{2} + C_{3} L_{2} L_{3} R_{out} s^{3} + C_{3} L_{2} R_{3} R_{out} s^{2} + C_{3} L_{3} R_{2} R_{out} s^{2} + C_{3} R_{2} R_{3} R_{out} s + L_{2} R_{out} s + R_{2} R_{out}\\)\n\n\n\nsolve(n.simplify().expand(),s)\n\n\\(\\displaystyle \\left[ \\frac{- C_{1} R_{1} - \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{1} R_{1} + \\sqrt{C_{1}^{2} R_{1}^{2} - 4 C_{1} L_{1}}}{2 C_{1} L_{1}}, \\  \\frac{- C_{3} R_{3} - \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- C_{3} R_{3} + \\sqrt{C_{3}^{2} R_{3}^{2} - 4 C_{3} L_{3}}}{2 C_{3} L_{3}}, \\  \\frac{- L_{2} - \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}, \\  \\frac{- L_{2} + \\sqrt{- 4 C_{2} L_{2} R_{2}^{2} + L_{2}^{2}}}{2 C_{2} L_{2} R_{2}}\\right]\\)\n\n\nWe can see that there are six zeros in the transfer function. Here can see what components are influncing the zeros. Once of the gaols of the FACTS method was to determine the zeros of the network.\nSolve for the roots of the denominator\n\nd.simplify().expand().together()\n\n\\(\\displaystyle C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{in} s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} R_{out} s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} L_{3} R_{2} Ra s^{6} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{in} s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{3} Ra s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{in} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{1} L_{2} R_{2} R_{out} Ra s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{in} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{1} R_{2} Ra s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} R_{out} s^{5} + C_{1} C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} Ra s^{5} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{in} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} R_{out} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{3} Ra s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{in} R_{out} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{1} R_{2} R_{out} Ra s^{4} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} R_{out} s^{4} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} Ra s^{4} + C_{1} C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} Ra s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{in} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} R_{out} s^{4} + C_{1} C_{2} L_{1} L_{2} R_{2} Ra s^{4} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{in} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{2} L_{2} R_{1} R_{2} Ra s^{3} + C_{1} C_{2} L_{2} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{2} L_{2} R_{2} R_{in} Ra s^{3} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{2} s^{5} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{in} s^{5} + C_{1} C_{3} L_{1} L_{2} L_{3} R_{out} s^{5} + C_{1} C_{3} L_{1} L_{2} L_{3} Ra s^{5} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{3} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{2} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{in} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{3} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{3} Ra s^{4} + C_{1} C_{3} L_{1} L_{2} R_{in} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{2} R_{out} Ra s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{in} s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} R_{out} s^{4} + C_{1} C_{3} L_{1} L_{3} R_{2} Ra s^{4} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{in} s^{3} + C_{1} C_{3} L_{1} R_{2} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{1} R_{2} R_{3} Ra s^{3} + C_{1} C_{3} L_{1} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{1} R_{2} R_{out} Ra s^{3} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{2} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{in} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{1} R_{out} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{1} Ra s^{4} + C_{1} C_{3} L_{2} L_{3} R_{2} R_{in} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{in} R_{out} s^{4} + C_{1} C_{3} L_{2} L_{3} R_{in} Ra s^{4} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{3} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{in} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{3} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{3} Ra s^{3} + C_{1} C_{3} L_{2} R_{1} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{1} R_{out} Ra s^{3} + C_{1} C_{3} L_{2} R_{2} R_{3} R_{in} s^{3} + C_{1} C_{3} L_{2} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{3} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{2} R_{3} R_{in} Ra s^{3} + C_{1} C_{3} L_{2} R_{in} R_{out} Ra s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{in} s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} R_{out} s^{3} + C_{1} C_{3} L_{3} R_{1} R_{2} Ra s^{3} + C_{1} C_{3} L_{3} R_{2} R_{in} R_{out} s^{3} + C_{1} C_{3} L_{3} R_{2} R_{in} Ra s^{3} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{in} s^{2} + C_{1} C_{3} R_{1} R_{2} R_{3} R_{out} s^{2} + C_{1} C_{3} R_{1} R_{2} R_{3} Ra s^{2} + C_{1} C_{3} R_{1} R_{2} R_{in} R_{out} s^{2} + C_{1} C_{3} R_{1} R_{2} R_{out} Ra s^{2} + C_{1} C_{3} R_{2} R_{3} R_{in} R_{out} s^{2} + C_{1} C_{3} R_{2} R_{3} R_{in} Ra s^{2} + C_{1} C_{3} R_{2} R_{in} R_{out} Ra s^{2} + C_{1} L_{1} L_{2} R_{2} s^{3} + C_{1} L_{1} L_{2} R_{in} s^{3} + C_{1} L_{1} L_{2} R_{out} s^{3} + C_{1} L_{1} L_{2} Ra s^{3} + C_{1} L_{1} R_{2} R_{in} s^{2} + C_{1} L_{1} R_{2} R_{out} s^{2} + C_{1} L_{1} R_{2} Ra s^{2} + C_{1} L_{2} R_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} R_{in} s^{2} + C_{1} L_{2} R_{1} R_{out} s^{2} + C_{1} L_{2} R_{1} Ra s^{2} + C_{1} L_{2} R_{2} R_{in} s^{2} + C_{1} L_{2} R_{in} R_{out} s^{2} + C_{1} L_{2} R_{in} Ra s^{2} + C_{1} R_{1} R_{2} R_{in} s + C_{1} R_{1} R_{2} R_{out} s + C_{1} R_{1} R_{2} Ra s + C_{1} R_{2} R_{in} R_{out} s + C_{1} R_{2} R_{in} Ra s + C_{2} C_{3} L_{2} L_{3} R_{2} R_{in} s^{4} + C_{2} C_{3} L_{2} L_{3} R_{2} R_{out} s^{4} + C_{2} C_{3} L_{2} L_{3} R_{2} Ra s^{4} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{in} s^{3} + C_{2} C_{3} L_{2} R_{2} R_{3} R_{out} s^{3} + C_{2} C_{3} L_{2} R_{2} R_{3} Ra s^{3} + C_{2} C_{3} L_{2} R_{2} R_{in} R_{out} s^{3} + C_{2} C_{3} L_{2} R_{2} R_{out} Ra s^{3} + C_{2} L_{2} R_{2} R_{in} s^{2} + C_{2} L_{2} R_{2} R_{out} s^{2} + C_{2} L_{2} R_{2} Ra s^{2} + C_{3} L_{2} L_{3} R_{2} s^{3} + C_{3} L_{2} L_{3} R_{in} s^{3} + C_{3} L_{2} L_{3} R_{out} s^{3} + C_{3} L_{2} L_{3} Ra s^{3} + C_{3} L_{2} R_{2} R_{3} s^{2} + C_{3} L_{2} R_{2} R_{out} s^{2} + C_{3} L_{2} R_{3} R_{in} s^{2} + C_{3} L_{2} R_{3} R_{out} s^{2} + C_{3} L_{2} R_{3} Ra s^{2} + C_{3} L_{2} R_{in} R_{out} s^{2} + C_{3} L_{2} R_{out} Ra s^{2} + C_{3} L_{3} R_{2} R_{in} s^{2} + C_{3} L_{3} R_{2} R_{out} s^{2} + C_{3} L_{3} R_{2} Ra s^{2} + C_{3} R_{2} R_{3} R_{in} s + C_{3} R_{2} R_{3} R_{out} s + C_{3} R_{2} R_{3} Ra s + C_{3} R_{2} R_{in} R_{out} s + C_{3} R_{2} R_{out} Ra s + L_{2} R_{2} s + L_{2} R_{in} s + L_{2} R_{out} s + L_{2} Ra s + R_{2} R_{in} + R_{2} R_{out} + R_{2} Ra\\)\n\n\n\n#solve(d,s)\n\nSymPy could not find a solution for roots of denominator.\n\n\n18.7.3 Use numerical values for components\nThe element vaules can be put into the equation.\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1, \\  C_{2} : 0.002, \\  C_{3} : 1, \\  L_{1} : 0.001, \\  L_{2} : 2, \\  L_{3} : 0.001, \\  R_{1} : 0.001, \\  R_{2} : 2000.0, \\  R_{3} : 0.001, \\  R_{in} : 1.0, \\  R_{out} : 1.0, \\  Ra : 0.002, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\nH_franc = H_franc_sym.subs(element_values)\nH_franc\n\n\\(\\displaystyle \\frac{1.0 \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)^{2}}{\\left(\\frac{\\left(0.001 s + 0.001 + \\frac{1}{s}\\right) \\left(\\frac{1.0 \\cdot \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)}{0.001 s + 1.001 + \\frac{1}{s}} + 0.002 + \\frac{1}{0.002 s + 0.0005 + \\frac{1}{2 s}}\\right)}{0.001 s + \\frac{1.0 \\cdot \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)}{0.001 s + 1.001 + \\frac{1}{s}} + 0.003 + \\frac{1}{0.002 s + 0.0005 + \\frac{1}{2 s}} + \\frac{1}{s}} + 1.0\\right) \\left(0.001 s + 1.001 + \\frac{1}{s}\\right) \\left(0.001 s + \\frac{1.0 \\cdot \\left(0.001 s + 0.001 + \\frac{1}{s}\\right)}{0.001 s + 1.001 + \\frac{1}{s}} + 0.003 + \\frac{1}{0.002 s + 0.0005 + \\frac{1}{2 s}} + \\frac{1}{s}\\right)}\\)\n\n\nSimplifying the expression.\n\nH_franc = H_franc.nsimplify().simplify().expand().together()\nH_franc\n\n\\(\\displaystyle \\frac{500 \\cdot \\left(4 s^{6} + 9 s^{5} + 9006 s^{4} + 12001 s^{3} + 6003000 s^{2} + 3000000 s + 1000000000\\right)}{4004 s^{6} + 5017009 s^{5} + 2020025006 s^{4} + 1009025015001 s^{3} + 2011013003000 s^{2} + 2005003000000 s + 1001000000000}\\)\n\n\n\n\n18.7.4 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_franc_num, H_franc_denom = fraction(H_franc) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_franc_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_franc_denom, s).all_coeffs(), dtype=float)\nfranc_sys = signal.TransferFunction(a,b)\n\n\nfranc_sys_zeros = np.roots(franc_sys.num)\nfranc_sys_poles = np.roots(franc_sys.den)\n\n\n\n18.7.5 Pole zero plot\nThe poles and zeros of the function are plotted on the complex plane.\n\nplt.plot(np.real(franc_sys_zeros), np.imag(franc_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(franc_sys_poles), np.imag(franc_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\n#plt.ylim((-2,2))\n#plt.xlim((-2,0))\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPrinting the value of the poles and zeros in radians per second.\n\nprint('number of zeros: {:d}'.format(len(franc_sys_zeros)))\nfor i in franc_sys_zeros:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of zeros: 6\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.500+31.619j rad/s\n-0.500-31.619j rad/s\n-0.125+15.811j rad/s\n-0.125-15.811j rad/s\n\n\n\nprint('number of poles: {:d}'.format(len(franc_sys_poles)))\nfor i in franc_sys_poles:\n    print('{:,.3f} rad/s'.format(i))\n\nnumber of poles: 6\n-1,000.000+0.000j rad/s\n-125.501+485.024j rad/s\n-125.501-485.024j rad/s\n-1.000+0.000j rad/s\n-0.499+0.865j rad/s\n-0.499-0.865j rad/s\n\n\n\n\n18.7.6 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(-2, 2, 1000, endpoint=False) #*2*np.pi\nw_franc, mag_franc, phase_franc = signal.bode(franc_sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, radians')\n\nplt.semilogx(w_franc, mag_franc,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_franc, phase_franc,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#comapring-solutions",
    "href": "Pi-Filter.html#comapring-solutions",
    "title": "18  Pi Filter",
    "section": "18.8 Comapring solutions",
    "text": "18.8 Comapring solutions\nLoad the csv file from LTSpice.\n\nfn = 'Pi-Filter-LTSpice.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # LTSpice magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # MNA magnitude plot\nplt.semilogx(w_franc/(2*np.pi), mag_franc,'-r')    # FACTS magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color='k',label='LTSpice')  # LTSpice phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='b',label='MNA')  # MNA phase plot\nplt.semilogx(w_franc/(2*np.pi), phase_franc,':',color='r',label='Franc')  # FACTS phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='LTSpice')\nax2.plot(np.NaN, np.NaN, color='b', label='MNA')\nax2.plot(np.NaN, np.NaN, color='r', label='Franc')\n\nplt.legend()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nLTSpice, SMNA and Franc results agree.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#community-answers-1",
    "href": "Pi-Filter.html#community-answers-1",
    "title": "18  Pi Filter",
    "section": "18.9 Community answers",
    "text": "18.9 Community answers\nBoth comunity answers did not provide a solution based on the FACTS method. Missing was the steps to extract the time constants of the circuit and from there find the zeros of the network.\nThe answer from Franc (2023) replaces each leg of the filter with Z’s and then uses series and parallel equalivent conbinations. As shown above this analysis provides only an approximate solution and probably would not cut the mustard in an acedemic or critical design reviwe.\nThe answer provided by Tesla23 is also suspect and seems wrong. The following calculations walk through some of his steps.\nR, Z1, Z2, Z3 = symbols(‘R Z1 Z2 Z3’)\n\nH_telsa23 = ((R*Z1*Z3)/(R*((Z2+2*Z1)*Z3 + Z1*Z2) + R**2*(Z3+Z2+Z1) + Z1*Z2*Z3)).subs({R:1})\nH_telsa23\n\n\\(\\displaystyle \\frac{Z_{1} Z_{3}}{Z_{1} Z_{2} Z_{3} + Z_{1} Z_{2} + Z_{1} + Z_{2} + Z_{3} \\cdot \\left(2 Z_{1} + Z_{2}\\right) + Z_{3}}\\)\n\n\n\nH_telsa23.simplify()\n\n\\(\\displaystyle \\frac{Z_{1} Z_{3}}{Z_{1} Z_{2} Z_{3} + Z_{1} Z_{2} + Z_{1} + Z_{2} + Z_{3} \\cdot \\left(2 Z_{1} + Z_{2}\\right) + Z_{3}}\\)\n\n\nComparing the results above to my rendition of FACTS, you can see that they are not the same.\n\nH_franc_z.simplify()\n\n\\(\\displaystyle \\frac{Z_{1} Z_{4}}{R_{in} \\left(Z_{1} + Z_{2} + Z_{4}\\right) + Z_{1} \\left(Z_{2} + Z_{4}\\right)}\\)\n\n\nIt’s not worth my time to analyze Tesla23’s answer to determine why there is a difference, especially since the thrust of these notebooks is MNA.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#reduced-complexity-circuit-with-source-and-load-impedance",
    "href": "Pi-Filter.html#reduced-complexity-circuit-with-source-and-load-impedance",
    "title": "18  Pi Filter",
    "section": "18.10 Reduced complexity circuit with source and load impedance",
    "text": "18.10 Reduced complexity circuit with source and load impedance\nThe following analysis finds the transfer function for the circuit below. The parasitic components have been removed from the schematic. The circuit is now a third order circuit. As shown below the poles of the transferfunction expressed symbolically are long and complex. It’s hard to see how a FACTS solution would yield design oriented results.\n\n\n\n\n\n\nFigure 18.3: Pi filter with out parasitics\n\n\n\n\nnet_list = '''\nV1 3 0 1\nR_in 1 3 1\nR_out 2 0 1\nC1 1 0 1\nC2 2 0 1\nL1 1 2 1\n'''\n\n\n18.10.1 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formulated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{L1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{in}}\\right) - \\frac{v_{3}}{R_{in}}\\)\\(0 = - I_{L1} + v_{2} \\left(C_{2} s + \\frac{1}{R_{out}}\\right)\\)\\(0 = I_{V1} - \\frac{v_{1}}{R_{in}} + \\frac{v_{3}}{R_{in}}\\)\\(V_{1} = v_{3}\\)\\(0 = - I_{L1} L_{1} s + v_{1} - v_{2}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  v_{1}, \\  I_{V1}, \\  L_{1}, \\  C_{1}, \\  I_{L1}, \\  v_{2}, \\  C_{2}, \\  R_{out}, \\  V_{1}, \\  v_{3}, \\  R_{in}\\right)\\)\n\n\n\n\n18.10.2 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{2} L_{1} R_{out} V_{1} s^{2} + L_{1} V_{1} s + R_{out} V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\\(v_{2} = \\frac{R_{out} V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\\(v_{3} = V_{1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} L_{1} R_{out} V_{1} s^{3} - C_{1} L_{1} V_{1} s^{2} - C_{1} R_{out} V_{1} s - C_{2} R_{out} V_{1} s - V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\\(I_{L1} = \\frac{C_{2} R_{out} V_{1} s + V_{1}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\n\n\n\n\n18.10.3 Transfer function\n\nH_sym_1  = (U_sym[v2]/U_sym[v3]).simplify()\nH_sym_1\n\n\\(\\displaystyle \\frac{R_{out}}{C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}}\\)\n\n\n\nn, d = fraction(H_sym_1)\ndisplay('numerator', n, 'denominator', d)\n\n'numerator'\n\n\n\\(\\displaystyle R_{out}\\)\n\n\n'denominator'\n\n\n\\(\\displaystyle C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}\\)\n\n\nSolve for the roots of the denominator\n\nd.simplify().expand().together()\n#d.simplify().expand()\n\n\\(\\displaystyle C_{1} C_{2} L_{1} R_{in} R_{out} s^{3} + C_{1} L_{1} R_{in} s^{2} + C_{1} R_{in} R_{out} s + C_{2} L_{1} R_{out} s^{2} + C_{2} R_{in} R_{out} s + L_{1} s + R_{in} + R_{out}\\)\n\n\n\nsolve(d,s)\n\n\\(\\displaystyle \\left[ - \\frac{- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}}{3} - \\frac{C_{1} R_{in} + C_{2} R_{out}}{3 C_{1} C_{2} R_{in} R_{out}}, \\  - \\frac{- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}}{3} - \\frac{C_{1} R_{in} + C_{2} R_{out}}{3 C_{1} C_{2} R_{in} R_{out}}, \\  - \\frac{- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{2}}{C_{1}^{2} C_{2}^{2} R_{in}^{2} R_{out}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{in} + R_{out}\\right)}{C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{2 \\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{in} + R_{out}\\right)}{2 C_{1} C_{2} L_{1} R_{in} R_{out}} - \\frac{9 \\left(C_{1} R_{in} + C_{2} R_{out}\\right) \\left(C_{1} R_{in} R_{out} + C_{2} R_{in} R_{out} + L_{1}\\right)}{2 C_{1}^{2} C_{2}^{2} L_{1} R_{in}^{2} R_{out}^{2}} + \\frac{\\left(C_{1} R_{in} + C_{2} R_{out}\\right)^{3}}{C_{1}^{3} C_{2}^{3} R_{in}^{3} R_{out}^{3}}}}{3} - \\frac{C_{1} R_{in} + C_{2} R_{out}}{3 C_{1} C_{2} R_{in} R_{out}}\\right]\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "Pi-Filter.html#summary",
    "href": "Pi-Filter.html#summary",
    "title": "18  Pi Filter",
    "section": "18.11 Summary",
    "text": "18.11 Summary\n\nFACTS method is applicable to low order circuits, since for higher order circuits, say N greater than 2 or 3, N-element Extra Element Theorem requires a lot of steps. The resultant analytical expression might be useful and insightful since series and parallel combinations of components and their grouping, or the circuit’s time constants, could be preserived in a relational way in the equation.\n\nIn Figure 18.1, a 6th order circuit, analytic expressions for the roots of the poles and zeros would be very long and of doubious utility.\nThe brute force solution for the transfer function of Figure 18.1, was a long expression. SymPy could solve for the roots of the numerator, but not for the denominator.\n\nThe assurtion that brute force is complicated and error prone is not true if computer algebra tools are used. Some of the same proported advantages of using FACTS, that is, less math, less algebra and some insight into the circuit operation are available with SMNA, since the computer does all the heavy lifting.\nPython based symbolic MNA code provides an easy and less error prone method of obtaining analytic solutions to circuit problems.\n\n\n\n\n\nBasso, Christophe. 2016. “Introduction to Fast Analytical Techniques: Application to Small-Signal Modeling.” 2016. https://www.powersimtof.com/Downloads/PPTs/Chris%20Basso%20APEC%20seminar%202016.pdf.\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nMiddlebrook, R. D. 1991. “Low-Entropy Expressions: The Key to Design-Oriented Analysis.” In Proceedings Frontiers in Education Twenty-First Annual Conference. Engineering Education in a New World Order, 399–403. https://doi.org/10.1109/FIE.1991.187513.\n\n\n———. 1992. “Methods of Design-Oriented Analysis: The Quadratic Equation Revisited.” In Proceedings. Twenty-Second Annual Conference Frontiers in Education, 95–102. https://doi.org/10.1109/FIE.1992.683365.\n\n\nuser15174. 2023. “How to Find Transfer Function for This Pi-Filter Using FACTS Method with 6 Reactive Elements?” https://electronics.stackexchange.com/questions/681002/how-to-find-transfer-function-for-this-pi-filter-using-facts-method-with-6-react/681087#681087.\n\n\nVorpérian, Vatché. 2002. Fast Analytical Techniques for Electrical and Electronic Circuits. Cambridge University Press. https://www.cambridge.org/core/books/fast-analytical-techniques-for-electrical-and-electronic-circuits/17845BA88A05A1645A8409D6739A475A#fndtn-information.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Pi Filter</span>"
    ]
  },
  {
    "objectID": "SIDO-low-pass-filter.html",
    "href": "SIDO-low-pass-filter.html",
    "title": "19  SIDO Low Pass Filter",
    "section": "",
    "text": "19.1 Introduction\nThe circuit shown in Figure 19.1, is from an electronics stackexchange question, where user349644 (2023) asks for help in determining the transfer function of the circuit. The circuit appears to be a low pass filter for the differential input to a following stage. I’m calling this circuit a Single-In-Dual-Out (SIDO) filter, where the output is the voltage across C3. An interesting response to the question was provided by Franc (2023), who has provided some interesting solutions to other circuit analysis questions. Usually his solutions are in the from of an image captured from a MathCAD type program consisting of equations, diagrams and plots.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>SIDO Low Pass Filter</span>"
    ]
  },
  {
    "objectID": "SIDO-low-pass-filter.html#circuit-description",
    "href": "SIDO-low-pass-filter.html#circuit-description",
    "title": "19  SIDO Low Pass Filter",
    "section": "19.2 Circuit description",
    "text": "19.2 Circuit description\nThe circuit has nine branches, five nodes and was interned into LTSpice in order to capture the schematic and generate the netlist.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>SIDO Low Pass Filter</span>"
    ]
  },
  {
    "objectID": "SIDO-low-pass-filter.html#circuit-analysis",
    "href": "SIDO-low-pass-filter.html#circuit-analysis",
    "title": "19  SIDO Low Pass Filter",
    "section": "19.3 Circuit analysis",
    "text": "19.3 Circuit analysis\nThe following analysis was performed.\n\nsolve network equations for the transfer function\npole, zero plot\nfrequency response plot\nstep and impusle response\ngroup delay\n\nThe net list for the filter is:\nV1 1 0 1\nC1 1 0 2.2n\nC2 4 5 330p\nC3 2 3 100p\nR1 1 0 100k\nR2 4 1 4.7k\nR3 5 0 4.7k\nR4 2 4 10k\nR5 3 5 10k\nThe following Python modules are used.\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\n19.3.1 Load the netlist\nThe netlist generated by LTSpice is pasted into the cell below and some edits were made to remove the inductor series resistance and the independent sources are set to their DC values.\n\nnet_list = '''\nV1 1 0 1\nC1 1 0 2.2e-9\nC2 4 5 330e-12\nC3 2 3 100e-12\nR1 1 0 100e3\nR2 4 1 4.7e3\nR3 5 0 4.7e3\nR4 2 4 10e3\nR5 3 5 10e3\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(- C_{3} s v_{3} + v_{2} \\left(C_{3} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(- C_{3} s v_{2} + v_{3} \\left(C_{3} s + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{R_{5}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand and a symbolic soultion would take a lot of computing time. The equations are displace in matrix notation.\n\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}}\\\\- C_{3} s v_{3} + v_{2} \\left(C_{3} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}}\\\\- C_{3} s v_{2} + v_{3} \\left(C_{3} s + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{R_{5}}\\\\- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{4}} - \\frac{v_{1}}{R_{2}}\\\\- C_{2} s v_{4} + v_{5} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{5}}\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\end{matrix}\\right]\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{5}, \\  R_{2}, \\  v_{4}, \\  v_{3}, \\  I_{V1}, \\  s, \\  V_{1}, \\  v_{2}, \\  C_{1}, \\  v_{5}, \\  C_{2}, \\  R_{4}, \\  C_{3}, \\  R_{3}, \\  v_{1}, \\  R_{1}\\right)\\)\n\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.2 \\cdot 10^{-9}, \\  C_{2} : 3.3 \\cdot 10^{-10}, \\  C_{3} : 1.0 \\cdot 10^{-10}, \\  R_{1} : 100000.0, \\  R_{2} : 4700.0, \\  R_{3} : 4700.0, \\  R_{4} : 10000.0, \\  R_{5} : 10000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nGenerate the symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s + C_{3} R_{5} V_{1} s + V_{1}}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(v_{3} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s + C_{3} R_{5} V_{1} s}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(v_{4} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s + C_{3} R_{4} V_{1} s + C_{3} R_{5} V_{1} s + V_{1}}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(v_{5} = \\frac{C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} + C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} + C_{2} R_{3} V_{1} s + C_{3} R_{3} V_{1} s}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} C_{3} R_{1} R_{2} R_{4} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{2} R_{5} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} R_{4} V_{1} s^{3} - C_{1} C_{2} C_{3} R_{1} R_{3} R_{5} V_{1} s^{3} - C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} - C_{1} C_{2} R_{1} R_{3} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{2} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{3} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{4} V_{1} s^{2} - C_{1} C_{3} R_{1} R_{5} V_{1} s^{2} - C_{1} R_{1} V_{1} s - C_{2} C_{3} R_{1} R_{4} V_{1} s^{2} - C_{2} C_{3} R_{1} R_{5} V_{1} s^{2} - C_{2} C_{3} R_{2} R_{4} V_{1} s^{2} - C_{2} C_{3} R_{2} R_{5} V_{1} s^{2} - C_{2} C_{3} R_{3} R_{4} V_{1} s^{2} - C_{2} C_{3} R_{3} R_{5} V_{1} s^{2} - C_{2} R_{1} V_{1} s - C_{2} R_{2} V_{1} s - C_{2} R_{3} V_{1} s - C_{3} R_{1} V_{1} s - C_{3} R_{2} V_{1} s - C_{3} R_{3} V_{1} s - C_{3} R_{4} V_{1} s - C_{3} R_{5} V_{1} s - V_{1}}{C_{2} C_{3} R_{1} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{1} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{1} R_{3} R_{5} s^{2} + C_{2} R_{1} R_{2} s + C_{2} R_{1} R_{3} s + C_{3} R_{1} R_{2} s + C_{3} R_{1} R_{3} s + C_{3} R_{1} R_{4} s + C_{3} R_{1} R_{5} s + R_{1}}\\)\n\n\nTransfer function\n\nH_sym = ((U_sym[v2]-U_sym[v3])/U_sym[v1]).nsimplify().simplify().expand().together()\nH_sym\n\n\\(\\displaystyle \\frac{1}{C_{2} C_{3} R_{2} R_{4} s^{2} + C_{2} C_{3} R_{2} R_{5} s^{2} + C_{2} C_{3} R_{3} R_{4} s^{2} + C_{2} C_{3} R_{3} R_{5} s^{2} + C_{2} R_{2} s + C_{2} R_{3} s + C_{3} R_{2} s + C_{3} R_{3} s + C_{3} R_{4} s + C_{3} R_{5} s + 1}\\)\n\n\n\ncancel(H_sym,s)\n\n\\(\\displaystyle \\frac{1}{s^{2} \\left(C_{2} C_{3} R_{2} R_{4} + C_{2} C_{3} R_{2} R_{5} + C_{2} C_{3} R_{3} R_{4} + C_{2} C_{3} R_{3} R_{5}\\right) + s \\left(C_{2} R_{2} + C_{2} R_{3} + C_{3} R_{2} + C_{3} R_{3} + C_{3} R_{4} + C_{3} R_{5}\\right) + 1}\\)\n\n\n\nH_sym_num, H_sym_denom = fraction(H_sym) #returns numerator and denominator\n\n\nsolve(H_sym_denom,s)\n\n\\(\\displaystyle \\left[ \\frac{- C_{2} R_{2} - C_{2} R_{3} - C_{3} R_{2} - C_{3} R_{3} - C_{3} R_{4} - C_{3} R_{5} - \\sqrt{C_{2}^{2} R_{2}^{2} + 2 C_{2}^{2} R_{2} R_{3} + C_{2}^{2} R_{3}^{2} + 2 C_{2} C_{3} R_{2}^{2} + 4 C_{2} C_{3} R_{2} R_{3} - 2 C_{2} C_{3} R_{2} R_{4} - 2 C_{2} C_{3} R_{2} R_{5} + 2 C_{2} C_{3} R_{3}^{2} - 2 C_{2} C_{3} R_{3} R_{4} - 2 C_{2} C_{3} R_{3} R_{5} + C_{3}^{2} R_{2}^{2} + 2 C_{3}^{2} R_{2} R_{3} + 2 C_{3}^{2} R_{2} R_{4} + 2 C_{3}^{2} R_{2} R_{5} + C_{3}^{2} R_{3}^{2} + 2 C_{3}^{2} R_{3} R_{4} + 2 C_{3}^{2} R_{3} R_{5} + C_{3}^{2} R_{4}^{2} + 2 C_{3}^{2} R_{4} R_{5} + C_{3}^{2} R_{5}^{2}}}{2 C_{2} C_{3} \\left(R_{2} R_{4} + R_{2} R_{5} + R_{3} R_{4} + R_{3} R_{5}\\right)}, \\  \\frac{- C_{2} R_{2} - C_{2} R_{3} - C_{3} R_{2} - C_{3} R_{3} - C_{3} R_{4} - C_{3} R_{5} + \\sqrt{C_{2}^{2} R_{2}^{2} + 2 C_{2}^{2} R_{2} R_{3} + C_{2}^{2} R_{3}^{2} + 2 C_{2} C_{3} R_{2}^{2} + 4 C_{2} C_{3} R_{2} R_{3} - 2 C_{2} C_{3} R_{2} R_{4} - 2 C_{2} C_{3} R_{2} R_{5} + 2 C_{2} C_{3} R_{3}^{2} - 2 C_{2} C_{3} R_{3} R_{4} - 2 C_{2} C_{3} R_{3} R_{5} + C_{3}^{2} R_{2}^{2} + 2 C_{3}^{2} R_{2} R_{3} + 2 C_{3}^{2} R_{2} R_{4} + 2 C_{3}^{2} R_{2} R_{5} + C_{3}^{2} R_{3}^{2} + 2 C_{3}^{2} R_{3} R_{4} + 2 C_{3}^{2} R_{3} R_{5} + C_{3}^{2} R_{4}^{2} + 2 C_{3}^{2} R_{4} R_{5} + C_{3}^{2} R_{5}^{2}}}{2 C_{2} C_{3} \\left(R_{2} R_{4} + R_{2} R_{5} + R_{3} R_{4} + R_{3} R_{5}\\right)}\\right]\\)\n\n\n\n\n19.3.2 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(2.2 \\cdot 10^{-9} s + 0.000222765957446809\\right) - 0.000212765957446809 v_{4}\\\\- 1.0 \\cdot 10^{-10} s v_{3} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-10} s + 0.0001\\right) - 0.0001 v_{4}\\\\- 1.0 \\cdot 10^{-10} s v_{2} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-10} s + 0.0001\\right) - 0.0001 v_{5}\\\\- 3.3 \\cdot 10^{-10} s v_{5} - 0.000212765957446809 v_{1} - 0.0001 v_{2} + v_{4} \\cdot \\left(3.3 \\cdot 10^{-10} s + 0.000312765957446809\\right)\\\\- 3.3 \\cdot 10^{-10} s v_{4} - 0.0001 v_{3} + v_{5} \\cdot \\left(3.3 \\cdot 10^{-10} s + 0.000312765957446809\\right)\\\\v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\nU\n\n\\(\\displaystyle \\left\\{ I_{V1} : \\frac{- 1.452 \\cdot 10^{18} s^{3} - 1.49089787234043 \\cdot 10^{24} s^{2} - 2.86214893617021 \\cdot 10^{29} s - 1.06382978723394 \\cdot 10^{33}}{6.6 \\cdot 10^{26} s^{2} + 6.42765957446809 \\cdot 10^{32} s + 1.06382978723404 \\cdot 10^{38}}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{660000000.0 s^{2} + 642765957446809.0 s + 2.12765957446809 \\cdot 10^{20}}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}, \\  v_{3} : \\frac{660000000.0 s^{2} + 642765957446809.0 s}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}, \\  v_{4} : \\frac{330000000.0 s^{2} + 427765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}, \\  v_{5} : \\frac{330000000.0 s^{2} + 215000000000000.0 s}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}\\right\\}\\)\n\n\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{660000000.0 s^{2} + 642765957446809.0 s + 2.12765957446809 \\cdot 10^{20}}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}\\)\\(v_{3} = \\frac{660000000.0 s^{2} + 642765957446809.0 s}{1320000000.0 s^{2} + 1.28553191489362 \\cdot 10^{15} s + 2.12765957446809 \\cdot 10^{20}}\\)\\(v_{4} = \\frac{330000000.0 s^{2} + 427765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}\\)\\(v_{5} = \\frac{330000000.0 s^{2} + 215000000000000.0 s}{660000000.0 s^{2} + 642765957446809.0 s + 1.06382978723404 \\cdot 10^{20}}\\)\\(I_{V1} = \\frac{- 1.452 \\cdot 10^{18} s^{3} - 1.49089787234043 \\cdot 10^{24} s^{2} - 2.86214893617021 \\cdot 10^{29} s - 1.06382978723394 \\cdot 10^{33}}{6.6 \\cdot 10^{26} s^{2} + 6.42765957446809 \\cdot 10^{32} s + 1.06382978723404 \\cdot 10^{38}}\\)\n\n\n\nH = ((U[v2]-U[v3])/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{10638297872340450000}{66000000 s^{2} + 64276595744681 s + 10638297872340450000}\\)\n\n\n\n19.3.2.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\n\n\n19.3.3 Poles and zeros of the low pass transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n19.3.3.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-121,354.74 Hz\n-33,644.32 Hz\n\n\n\n\n\n19.3.4 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nx = np.logspace(3, 8, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n19.3.5 Filter impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n19.3.6 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nuser349644. 2023. “Transfer Function of the Below Circuit.” https://electronics.stackexchange.com/questions/682389/transfer-function-of-the-below-circuit.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>SIDO Low Pass Filter</span>"
    ]
  },
  {
    "objectID": "Super-node.html",
    "href": "Super-node.html",
    "title": "20  Super Node",
    "section": "",
    "text": "20.1 Load the net list\nA question posted on Electronics Stackexchange by Malek (2020) asked:\nThe MNA solution provided below can work directly with the circuit netlist and the concept of a super node is not required.\nThe net list for Figure 31.1 was generated by LTSpice and show below:\nThe following Python modules are used in this notebook.\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\nnet_list = '''\nV1 1 3 36\nI1 0 1 12\nI2 2 0 18\nI3 0 3 24\nR1 1 0 4\nR4 3 0 6\nR2 2 1 12\nR3 3 2 15\n'''",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Super Node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "Super-node.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "20  Super Node",
    "section": "20.2 Call the symbolic modified nodal analysis function",
    "text": "20.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the smna function. The A, X and Z are formuloated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = I_{1}\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = - I_{2}\\)\\(- I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = I_{3}\\)\\(v_{1} - v_{3} = V_{1}\\)\n\n\n\n20.2.1 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\nNE_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}}\\\\v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}}\\\\- I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}}\\\\v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}I_{1}\\\\- I_{2}\\\\I_{3}\\\\V_{1}\\end{matrix}\\right]\\)\n\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{3}, \\  v_{2}, \\  I_{2}, \\  I_{1}, \\  R_{2}, \\  R_{4}, \\  V_{1}, \\  I_{3}, \\  v_{3}, \\  v_{1}, \\  R_{1}\\right)\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Super Node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#symbolic-solution",
    "href": "Super-node.html#symbolic-solution",
    "title": "20  Super Node",
    "section": "20.3 Symbolic solution",
    "text": "20.3 Symbolic solution\nThe newtork equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{I_{1} R_{1} R_{4} - I_{2} R_{1} R_{4} + I_{3} R_{1} R_{4} + R_{1} V_{1}}{R_{1} + R_{4}}\\)\\(v_{2} = \\frac{I_{1} R_{1} R_{2} R_{4} + I_{1} R_{1} R_{3} R_{4} - I_{2} R_{1} R_{2} R_{3} - I_{2} R_{1} R_{2} R_{4} - I_{2} R_{1} R_{3} R_{4} - I_{2} R_{2} R_{3} R_{4} + I_{3} R_{1} R_{2} R_{4} + I_{3} R_{1} R_{3} R_{4} + R_{1} R_{3} V_{1} - R_{2} R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(v_{3} = \\frac{I_{1} R_{1} R_{4} - I_{2} R_{1} R_{4} + I_{3} R_{1} R_{4} - R_{4} V_{1}}{R_{1} + R_{4}}\\)\\(I_{V1} = \\frac{I_{1} R_{1} R_{2} + I_{1} R_{1} R_{3} - I_{2} R_{1} R_{3} + I_{2} R_{2} R_{4} - I_{3} R_{2} R_{4} - I_{3} R_{3} R_{4} - R_{1} V_{1} - R_{2} V_{1} - R_{3} V_{1} - R_{4} V_{1}}{R_{1} R_{2} + R_{1} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Super Node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#construct-a-dictionary-of-element-values",
    "href": "Super-node.html#construct-a-dictionary-of-element-values",
    "title": "20  Super Node",
    "section": "20.4 Construct a dictionary of element values",
    "text": "20.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 12.0, \\  I_{2} : 18.0, \\  I_{3} : 24.0, \\  R_{1} : 4.0, \\  R_{2} : 12.0, \\  R_{3} : 15.0, \\  R_{4} : 6.0, \\  V_{1} : 36.0\\right\\}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Super Node</span>"
    ]
  },
  {
    "objectID": "Super-node.html#numerical-solution",
    "href": "Super-node.html#numerical-solution",
    "title": "20  Super Node",
    "section": "20.5 Numerical solution",
    "text": "20.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.333333333333333 v_{1} - 0.0833333333333333 v_{2}\\\\- 0.0833333333333333 v_{1} + 0.15 v_{2} - 0.0666666666666667 v_{3}\\\\- I_{V1} - 0.0666666666666667 v_{2} + 0.233333333333333 v_{3}\\\\v_{1} - v_{3}\\end{matrix}\\right] = \\left[\\begin{matrix}12.0\\\\-18.0\\\\24.0\\\\36.0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\nDisplay the numerical solution. Six significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          57.600000\nv2         -78.400000\nv3          21.600000\nI_V1       -13.733333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\n\n\n\n\nMalek, Ihdene. 2020. “Eliminating Ideal Voltage Source for Node Analysis.” Electrical Engineering Stack Exchange. https://electronics.stackexchange.com/q/479528.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Super Node</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html",
    "href": "Modeling Op Amps.html",
    "title": "21  Modeling Op Amps",
    "section": "",
    "text": "21.1 Introduction\nThe Operational Amplifier or Op Amp, is type of electronic amplifier that has two input terminals, amplifies the voltage difference between the two input terminals while suppresses any voltage common to the two inputs and is usually operated with negative feedback to control the gain of the amplifier. The amplifier typically has a very high differential mode gain, high input impedance and low output impedance. Today Op Amps are commonly impemnted in an intergrated circuit that can contain hundreds of transistors. The Op Amp is included in my sysmbolic MNA code as one of the element types along with resistors, capacitors, inductors, dependent sources and independednt sources.\nThe schematic symbol for an Op Amp is shown in Figure 21.1. The two input terminals are labled \\(V-\\) and \\(V+\\). The \\(V-\\) terminal is called the inverting input and \\(V+\\) is called the non-inverting input. \\(V_{out}\\) is the output terminal of the amplifier. An input on the \\(V+\\) terminal causes an in phase output and an input on the \\(V-\\) terminal causes an out of phase output. Not shown, but implied, are power supply and or ground connections. The datasheet for the particular model of Op Amp will show other connections.\nOp Amps are very versitile and are used in many types of circuits. A web search will uncover many examples and a few are listed below:\nThe first mass-produced Op Amp, in 1953, was the vacuum tube-based K2-W from GAP/R. The first widely available integrated circuit Op Amp was the Fairchild μA709 operational amplifier, designed by Bob Widlar in 1965. In 1968, the μA709 was replaced by the μA741, which offered better performance while being more stable and easier to setup. A modern version of the μA741 is produced by Texas Instruments, with the part number LM741.\nThere are more than 30 semiconductor manufactures making general purpose Op Amps priced as low as $0.30 each in small quantities. Under the general purpose catagory, there are thousands of part numbers avaliable from distributers such as Digikey. The world wide market for Op Amps is about $6 billion dollars.\nOp Amps can be configured to operate in circuits without feedback, which is how a comparitor works. Some applications configure the Op Amp to have positive feedback and Schmitt trigger is an example of this type of configureation. When the Op Amp is used without feedback or with positive feedback, the amplifier is operating as a non-linear device and non-linear circuits cannot be analyized with the Python MNA code presented in this book.\nOnly negative feedback Op Amp circuits are supported by the Python MNA code. These circuit configurations typically use resistors to connect the output terminal of the Op Amp to the inverting terminal of the Op Amp. When Op Amps are included in circuits to be analyzed using MNA, the Op Amp model used has negative feed back implied, reguardless of whether such feedback is actually present in the circuit. This is discussed below.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#introduction",
    "href": "Modeling Op Amps.html#introduction",
    "title": "21  Modeling Op Amps",
    "section": "",
    "text": "Operational Amplifier Applications\nAmplifier Circuit Collection\nCollection of Amp Applications\nHandbook of Operational Amplifier Applications\nOp Amps for Everyone, Ron Mancini",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#the-ideal-op-amp",
    "href": "Modeling Op Amps.html#the-ideal-op-amp",
    "title": "21  Modeling Op Amps",
    "section": "21.2 The ideal Op Amp",
    "text": "21.2 The ideal Op Amp\nThe concept of an ideal Op Amp is used when performance limitations of real Op Amps are ignored in order to symplify the circuit analysis. Often the performance limitions of real Op Amps have only minor effects on the operation of the circuit and the engineer will use their judgment to decide if the second order effects of these limitions need to be considered. The ideal Op Amp is described by Equation 21.1. The Op Amp’s inputs consist of a non-inverting input \\(V+\\) and an inverting input \\(V-\\), as shown in Figure 21.1. The Op Amp amplifies only the difference in voltage between the two inputs, which is called the differential input voltage. The power supply terminals of a real Op Amp are not included in the model of an ideal Op Amp.\nThe output voltage of the Op Amp \\(V_{out}\\) is given by the equation:\n\\[V_{out} = A_{OL}(V_+ - V_-) \\tag{21.1}\\]\nWhere \\(A_{OL}\\) is the open-loop gain of the amplifier. The value of the open loop gain in real Op Amps is very large, sometimes on the order of 100 dB. The value of \\(A_{OL}\\) in ideal Op Amps is not needed when the Op Amp is configured with negative feedback. The components in the feedback path determine the gain of the Op Amp circuit independednt of \\(A_{OL}\\).\nThe ideal Op Amp has other charasterics such as:\n\nInfinite gain and bandwidth\nZero output impedance\nInfinite input impedance\nZero volts between the two inputs\nInfinite output voltage range\nInfinite bandwidth with zero phase shift and infinite slew rate\nZero noise\nInfinite common-mode rejection ratio",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#mna-op-amp-stamp",
    "href": "Modeling Op Amps.html#mna-op-amp-stamp",
    "title": "21  Modeling Op Amps",
    "section": "21.3 MNA Op Amp stamp",
    "text": "21.3 MNA Op Amp stamp\nMNA is an algorithic procedure for generating network equations. When there is an element type ‘O’, in the netlist, three connection nodes are required. The first node is the inverting input, the second node is the non inverting input and the third node is the output node. The Python code, then makes entries into the B and C matricies based simply on the node numbers of the Op Amp terminals. This is called stamping the matrix, because for each component type a specific template is used.\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The Op Amp model has one unknown current for the output current. In the code that builds the B matrix, a value of 1 is included in the matrix at the index position given by the Op Amp output node number. The snippit of code that performes this operation is shown below.\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    :\n    :\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    :\n    :\nEach Op Amp the entry in the B matrix lines up with an unknown current in the X vector.\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements. The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and for Op Amps, a 1 is inserted for the non-inverting node and a -1 for the inverting node, unless the terminal is connected to ground. The code snippit is shown below.\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    :\n    :\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n    :\n    :\nThe above code mathematically equates the voltages at the input input terminals equal to each other, \\(v_n = v_m\\), where n and m are the node numbers. By default, the MNA Op Amp model is operating as if negative feedback is present in the circuit, reguardless of whether such feedback is actually present in the surrounding network. The Python MNA code does not verify that the Op Amp has negative feedback applied by the surrounding network. Consequencely, the Python MNA code is agnostic with reguard to feedback and which input terminal is used. The Python MNA code Op Amp model should be used with some care and the results need to be checked.\nThe Nullor is a two port device which can be used to model ideal Op Amps. The Python NMA Op Amp and the Nullor have the same NMA stamp and are equalivent.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#op-amp-feedback-test-circuit",
    "href": "Modeling Op Amps.html#op-amp-feedback-test-circuit",
    "title": "21  Modeling Op Amps",
    "section": "21.4 Op Amp feedback test circuit",
    "text": "21.4 Op Amp feedback test circuit\nThe circuit in Figure 21.2 is used to examine various Op Amp feedback connections. The following Op Amp circuits with various elements in the feedback path are examined below.\n\nNo feedback\nR in the feed back path\nSwap Op Amp input connections\nC in feedback path\nC and R in parallel in feedback path\n5a. C and R in series in feedback path\nL in feedback path\nL and R in series in the feedback path\nL and R in parallel in the feedback path\n\nThe following Python modules are used in this notebook.\n\n\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#op-amp-test-circuit",
    "href": "Modeling Op Amps.html#op-amp-test-circuit",
    "title": "21  Modeling Op Amps",
    "section": "21.5 Op Amp test circuit",
    "text": "21.5 Op Amp test circuit\nAn Op Amp test circuit, shown below, is used to explore various feedback configurations. A resistor is used to terminate each Op Amp terminal. A DC voltage source, V1, is used as the stimulus to the circuit and all the resistor values are set to one.\n\n\n\n\n\n\nFigure 21.2: Op Amp test circuit",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-1-no-feedback",
    "href": "Modeling Op Amps.html#case-1-no-feedback",
    "title": "21  Modeling Op Amps",
    "section": "21.6 Case 1: No feedback",
    "text": "21.6 Case 1: No feedback\nThe net list for Figure 21.2 was obtained from LTSpice.\n\nnet_list1 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A1, X1, Z1 = SymMNA.smna(net_list1)\n\n# Put matricies into SymPy \nX1 = Matrix(X1)\nZ1 = Matrix(Z1)\n\nNE1_sym = Eq(A1*X1,Z1)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X1)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A1*X1)[i:i+1][0],Z1[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(- \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nShown above are the six equations generatated by NMA. The last three equations are rather simple.\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE1_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  v_{1}, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nAttemp to solve the equations.\n\nU1_sym = solve(NE1_sym,X1)\nU1_sym\n\n\\(\\displaystyle \\left[ \\right]\\)\n\n\nNo solution is found. By inspection we can see that there are three equations:\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(- \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\nand four knowns: \\(v_2\\), \\(v_3\\), \\(I_{V1}\\) and \\(I_{O1}\\).\nSo without a connection from node 2 to the rest of the network, the voltage and current at node 2 cannot be solved for.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-2-r-in-the-feed-back-path",
    "href": "Modeling Op Amps.html#case-2-r-in-the-feed-back-path",
    "title": "21  Modeling Op Amps",
    "section": "21.7 Case 2: R in the feed back path",
    "text": "21.7 Case 2: R in the feed back path\nR added to network between nodes 2 and 3, by manually editing the netlist below.\n\nnet_list2 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A2, X2, Z2 = SymMNA.smna(net_list2)\n\n# Put matricies into SymPy \nX2 = Matrix(X2)\nZ2 = Matrix(Z2)\n\nNE2_sym = Eq(A2*X2,Z2)\n\nBoth case 1 and case 2 have a 6 by 6 A matrix, but R shows up in the off diagonal in case 2.\n\nA2\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0\\\\0 & \\frac{1}{R_{3}} + \\frac{1}{R} & - \\frac{1}{R} & 0 & 0 & 1\\\\- \\frac{1}{R_{1}} & - \\frac{1}{R} & \\frac{1}{R_{1}} + \\frac{1}{R} & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{2}} & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 1 & -1 & 0 & 0\\end{matrix}\\right]\\)\n\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X2)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A2*X2)[i:i+1][0],Z2[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE2_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU2_sym = solve(NE2_sym,X2)\n\ntemp = ''\nfor i in U2_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U2_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{R V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{R V_{1} + R_{3} V_{1}}{R_{1} R_{3}}\\)\n\n\nNotice that \\(v_3\\) and \\(v_4\\) are both zero volts. There is no current flowing into the Op Amp input terminals.\nSolving for the transfer function at node 2.\n\nH2_sym = U2_sym[v2]/U2_sym[v1]\nH2_sym #.simplify()\n\n\\(\\displaystyle - \\frac{R}{R_{1}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-3-swap-op-amp-input-connections",
    "href": "Modeling Op Amps.html#case-3-swap-op-amp-input-connections",
    "title": "21  Modeling Op Amps",
    "section": "21.8 Case 3: Swap Op Amp input connections",
    "text": "21.8 Case 3: Swap Op Amp input connections\nAs discussed above, the MNA code equates the voltages at the Op Amps input terminals. This implies that there is negative feedback present in the circuit. Because the voltage at thes terminal are equal, there is no distinction between the two as far as a mathematical solution to the network equations is concerned. This is illustrated below.\n\nnet_list3 = '''\nV1 1 0 1\n*O1 3 4 2\nO1 4 3 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A3, X3, Z3 = SymMNA.smna(net_list3)\n\n# Put matricies into SymPy \nX3 = Matrix(X3)\nZ3 = Matrix(Z3)\n\nNE3_sym = Eq(A3*X3,Z3)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X3)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A3*X3)[i:i+1][0],Z3[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} + v_{4} = 0\\)\n\n\nLast equation,\n\\(- v_{3} + v_{4} = 0\\)\nis identical anlgebracily to the equation generated in Case 1 above, which is:\n\\(v_{3} - v_{4} = 0\\)\nThis shows that because the Op Amp model defines \\(V+\\) and \\(V-\\) to be equal, the terminals of the NMA Op Amp model can be swapped.\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE3_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU3_sym = solve(NE3_sym,X3)\n\ntemp = ''\nfor i in U3_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U3_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{R V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{R V_{1} + R_{3} V_{1}}{R_{1} R_{3}}\\)\n\n\nNotice that \\(v_3\\) and \\(v_4\\) are both zero volts. There is no current flowing into the Op Amp input terminals.\nSolving for the transfer function at node 2.\n\nH3_sym = U3_sym[v2]/U3_sym[v1]\nH3_sym #.simplify()\n\n\\(\\displaystyle - \\frac{R}{R_{1}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-4-c-in-feedback-path",
    "href": "Modeling Op Amps.html#case-4-c-in-feedback-path",
    "title": "21  Modeling Op Amps",
    "section": "21.9 Case 4: C in feedback path",
    "text": "21.9 Case 4: C in feedback path\n\nnet_list4 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nC 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A4, X4, Z4 = SymMNA.smna(net_list4)\n\n# Put matricies into SymPy \nX4 = Matrix(X4)\nZ4 = Matrix(Z4)\n\nNE4_sym = Eq(A4*X4,Z4)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X4)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A4*X4)[i:i+1][0],Z4[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C s v_{3} + I_{O1} + v_{2} \\left(C s + \\frac{1}{R_{3}}\\right) = 0\\)\\(- C s v_{2} + v_{3} \\left(C s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE4_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  C, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU4_sym = solve(NE4_sym,X4)\n\ntemp = ''\nfor i in U4_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U4_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{V_{1}}{C R_{1} s}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{C R_{3} V_{1} s + V_{1}}{C R_{1} R_{3} s}\\)\n\n\nSolving for the transfer function at node 2.\n\nU4_sym[v2]/U4_sym[v1]\n\n\\(\\displaystyle - \\frac{1}{C R_{1} s}\\)\n\n\nSeems correct.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-5-c-and-r-in-parallel-in-feedback-path",
    "href": "Modeling Op Amps.html#case-5-c-and-r-in-parallel-in-feedback-path",
    "title": "21  Modeling Op Amps",
    "section": "21.10 Case 5: C and R in parallel in feedback path",
    "text": "21.10 Case 5: C and R in parallel in feedback path\n\nnet_list5 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nC 2 3 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A5, X5, Z5 = SymMNA.smna(net_list5)\n\n# Put matricies into SymPy \nX5 = Matrix(X5)\nZ5 = Matrix(Z5)\n\nNE5_sym = Eq(A5*X5,Z5)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X5)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A5*X5)[i:i+1][0],Z5[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\left(C s + \\frac{1}{R_{3}} + \\frac{1}{R}\\right) + v_{3} \\left(- C s - \\frac{1}{R}\\right) = 0\\)\\(v_{2} \\left(- C s - \\frac{1}{R}\\right) + v_{3} \\left(C s + \\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE5_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  C, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU5_sym = solve(NE5_sym,X5)\n\ntemp = ''\nfor i in U5_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U5_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{R V_{1}}{C R R_{1} s + R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{C R R_{3} V_{1} s + R V_{1} + R_{3} V_{1}}{C R R_{1} R_{3} s + R_{1} R_{3}}\\)\n\n\nSolving for the transfer function at node 2.\n\nU5_sym[v2]/U5_sym[v1]\n\n\\(\\displaystyle - \\frac{R}{C R R_{1} s + R_{1}}\\)\n\n\nAt \\(s=0\\) the transfer function reduces correctly to the DC case. For \\(s=\\infty\\), the capacitor is a short and equation is not correct, but then the circuit now has a short accross R and this is not reflected in the netlist. So at \\(s=\\infty\\), the solution needs some interperation and maybe the netlist needs to edited to correctly reflect the value of \\(Z_c\\) at \\(\\infty\\).\nThe result seems correct for \\(s \\ne \\infty\\).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-5a-c-and-r-in-series-in-feedback-path",
    "href": "Modeling Op Amps.html#case-5a-c-and-r-in-series-in-feedback-path",
    "title": "21  Modeling Op Amps",
    "section": "21.11 Case 5a: C and R in series in feedback path",
    "text": "21.11 Case 5a: C and R in series in feedback path\n\nnet_list5a = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nC 2 5 1\nR 3 5 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A5a, X5a, Z5a = SymMNA.smna(net_list5a)\n\n# Put matricies into SymPy \nX5a = Matrix(X5a)\nZ5a = Matrix(Z5a)\n\nNE5a_sym = Eq(A5a*X5a,Z5a)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X5a)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A5a*X5a)[i:i+1][0],Z5a[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C s v_{5} + I_{O1} + v_{2} \\left(C s + \\frac{1}{R_{3}}\\right) = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{5}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(- C s v_{2} + v_{5} \\left(C s + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE5a_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  v_{4}, \\  V_{1}, \\  C, \\  R_{1}, \\  v_{5}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU5a_sym = solve(NE5a_sym,X5a)\n\ntemp = ''\nfor i in U5a_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U5a_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C R V_{1} s - V_{1}}{C R_{1} s}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(v_{5} = - \\frac{R V_{1}}{R_{1}}\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{C R V_{1} s + C R_{3} V_{1} s + V_{1}}{C R_{1} R_{3} s}\\)\n\n\nSolving for the transfer function at node 2.\n\n(U5a_sym[v2]/U5a_sym[v1]).simplify()\n\n\\(\\displaystyle - \\frac{R}{R_{1}} - \\frac{1}{C R_{1} s}\\)\n\n\nThe result seems correct.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-6-l-in-feedback-path",
    "href": "Modeling Op Amps.html#case-6-l-in-feedback-path",
    "title": "21  Modeling Op Amps",
    "section": "21.12 Case 6: L in feedback path",
    "text": "21.12 Case 6: L in feedback path\n\nnet_list6 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nL 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A6, X6, Z6 = SymMNA.smna(net_list6)\n\n# Put matricies into SymPy \nX6 = Matrix(X6)\nZ6 = Matrix(Z6)\n\nNE6_sym = Eq(A6*X6,Z6)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X6)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A6*X6)[i:i+1][0],Z6[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L} + I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(- I_{L} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\\(- I_{L} L s + v_{2} - v_{3} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE6_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R_{2}, \\  L, \\  I_{L}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU6_sym = solve(NE6_sym,X6)\n\ntemp = ''\nfor i in U6_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U6_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{L V_{1} s}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{L V_{1} s + R_{3} V_{1}}{R_{1} R_{3}}\\)\\(I_{L} = - \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\nU6_sym[v2]/U6_sym[v1]\n\n\\(\\displaystyle - \\frac{L s}{R_{1}}\\)\n\n\nAt \\(s=0\\) the transfer function does not reduce correctly to the DC case. For \\(s=\\infty\\), the inductor is an open and equation is correct.\nThe result seems correct for \\(s \\ne 0\\).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-7-l-and-r-in-series-in-the-feedback-path",
    "href": "Modeling Op Amps.html#case-7-l-and-r-in-series-in-the-feedback-path",
    "title": "21  Modeling Op Amps",
    "section": "21.13 Case 7: L and R in series in the feedback path",
    "text": "21.13 Case 7: L and R in series in the feedback path\n\nnet_list7 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nL 2 5 1\nR 3 5 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A7, X7, Z7 = SymMNA.smna(net_list7)\n\n# Put matricies into SymPy \nX7 = Matrix(X7)\nZ7 = Matrix(Z7)\n\nNE7_sym = Eq(A7*X7,Z7)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X7)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A7*X7)[i:i+1][0],Z7[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L} + I_{O1} + \\frac{v_{2}}{R_{3}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{5}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(- I_{L} - \\frac{v_{3}}{R} + \\frac{v_{5}}{R} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\\(- I_{L} L s + v_{2} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE7_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  L, \\  I_{L}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  v_{4}, \\  V_{1}, \\  R_{1}, \\  v_{5}, \\  I_{O1}\\right)\\)\n\n\nSolve and display the solution.\n\nU7_sym = solve(NE7_sym,X7)\n\ntemp = ''\nfor i in U7_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U7_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- L V_{1} s - R V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(v_{5} = - \\frac{R V_{1}}{R_{1}}\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{L V_{1} s + R V_{1} + R_{3} V_{1}}{R_{1} R_{3}}\\)\\(I_{L} = - \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\n(U7_sym[v2]/U7_sym[v1]).simplify()\n\n\\(\\displaystyle \\frac{- L s - R}{R_{1}}\\)\n\n\nThe result seems correct for \\(s \\ne \\infty\\).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#case-8-l-and-r-in-parallel-in-the-feedback-path",
    "href": "Modeling Op Amps.html#case-8-l-and-r-in-parallel-in-the-feedback-path",
    "title": "21  Modeling Op Amps",
    "section": "21.14 Case 8: L and R in parallel in the feedback path",
    "text": "21.14 Case 8: L and R in parallel in the feedback path\n\nnet_list8 = '''\nV1 1 0 1\nO1 3 4 2\nR1 3 1 1\nR3 2 0 1\nR2 4 0 1\nL 2 3 1\nR 2 3 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A8, X8, Z8 = SymMNA.smna(net_list8)\n\n# Put matricies into SymPy \nX8 = Matrix(X8)\nZ8 = Matrix(Z8)\n\nNE8_sym = Eq(A8*X8,Z8)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X8)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A8*X8)[i:i+1][0],Z8[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L} + I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R}\\right) - \\frac{v_{3}}{R} = 0\\)\\(- I_{L} + v_{3} \\cdot \\left(\\frac{1}{R_{1}} + \\frac{1}{R}\\right) - \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R} = 0\\)\\(\\frac{v_{4}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\\(- I_{L} L s + v_{2} - v_{3} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE8_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( s, \\  R_{3}, \\  v_{1}, \\  R, \\  R_{2}, \\  L, \\  I_{L}, \\  v_{3}, \\  v_{2}, \\  I_{V1}, \\  V_{1}, \\  R_{1}, \\  v_{4}, \\  I_{O1}\\right)\\)\n\n\nSolve the equations.\n\nU8_sym = solve(NE8_sym,X8)\n\ntemp = ''\nfor i in U8_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U8_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{L R V_{1} s}{L R_{1} s + R R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{L R V_{1} s + L R_{3} V_{1} s + R R_{3} V_{1}}{L R_{1} R_{3} s + R R_{1} R_{3}}\\)\\(I_{L} = - \\frac{R V_{1}}{L R_{1} s + R R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\n(U8_sym[v2]/U8_sym[v1]).simplify()\n\n\\(\\displaystyle - \\frac{L R s}{R_{1} \\left(L s + R\\right)}\\)\n\n\nThe result seems correct for \\(s \\ne \\infty\\) or \\(s \\ne 0\\).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Modeling Op Amps.html#summary",
    "href": "Modeling Op Amps.html#summary",
    "title": "21  Modeling Op Amps",
    "section": "21.15 Summary",
    "text": "21.15 Summary\n\nResistors in the feedback path seem to give the correct results\nInductors and capacitors in the feedback path seem to work as long as \\(s \\ne \\infty \\space \\text {or} \\space \\ne 0\\).\nIf a solution is only desired for non-zero or non-infinit requencies, then the results seem correct.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modeling Op Amps</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html",
    "href": "Op Amp circuits.html",
    "title": "22  Op Amp Circuits",
    "section": "",
    "text": "22.1 Voltage follower\nSome typical Op Amp circuits are presented to explore the use of the Op Amp element type using symbolic MNA. These examples represent some very common applications of Op Amps ranging from a buffer amplifier to a dual Op Amp active band pass filter. The following Op Amp circuits are analyzed below.\nTwo good Op Amp references are Stout (1976) and Franco (2002).\nThe following Python libraries are used:\nThe Op Amp configured as a voltage follower is shown above. In this configuration, the output of the output Op Amp is connected to the negative input of the Op Amp. This causes the output voltage to be equal to the input voltage and this arrangement is called a voltage follower because the output voltage follows the input voltage. In this configuration, the Op Amp is used to as buffer amplifier or isolation amplifier since the amplifier provids a high input impedance and a low out put impedance. The gain of the amplifier is one. The circuit contains just one component, the Op Amp.\nIn a real Op Amp, the input terminals are a differential inputs, and a signal fed to the inverting input will cause the output signal to swing in the oposit direction. When the output is connected to the inverting input by a direct connection (a wire), the voltage at the inverting input is equal to the voltage at the out put. Since a change in voltage at the inverting input will casue the output to move in the opposit direction, the contribution of the inverting input signal to the output of the Op Amp is cancelled. A signal on the non-inverting input will cause the output signal to move in the same direction. Since the Op Amp amplifies the difference between the input terminals, an Op Amp connected as shown in Figure 22.1, will produce an output that is equal to the signal at the non-inverting input.\nThe Op Amp model used in the MNA network equations, is defined to equate the inverting and non-inverting termainals to each other. This equality is defined in the network equations reguardless of anyother connections in the circuit. This implies that the Op Amp is only operating in a negative feedback mode. The output therminal of the Op Amp is assigned in the network equations as an unknown current. Since the Op Amp’s input terminals are equal (by definition) and the output is connected to the inverting input, the output voltage is the same as the voltage at the non-inverting input. In the Op Amp model used in the MNA network equations, there is no distintion between the non-inverting and inverting inputs, other than node number and an arbitrary convention of treating the first node in the Op Amp netlist line as the positive node. This means that as described by the MNA network equations, the Op Amp’s inputs can be swapped without affecting the solution. This is not the case with real Op Amps, so good practice is draw the circuit schematic with the Op Amp’s input terminals going to the intended nodes.\nThe netlist for Figure 22.1 was obtained from LTSpice:\nThe reference designaltor for the Op Amp was changed from XU1 to O1 and the text was assinged to the net_list variable.\nnet_list = '''\nV1 1 0 1\nO1 2 1 2 \n'''\nGenerate and display the network equations.\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} = 0\\)\\(I_{O1} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{2} = 0\\)\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  V_{1}, \\  v_{1}\\right)\\)\nSolve the equations and display the results.\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(I_{V1} = 0\\)\\(I_{O1} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{2} = V_{1}\\)\nThe voltage at node 2 is simply equal to the input voltage, \\(v_2 = V_1\\).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#voltage-follower",
    "href": "Op Amp circuits.html#voltage-follower",
    "title": "22  Op Amp Circuits",
    "section": "",
    "text": "Figure 22.1: Op Amp voltage follower\n\n\n\n\n\n\n\nV1 1 0 1\nXU1 2 1 2",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#non-inverting-amplifier",
    "href": "Op Amp circuits.html#non-inverting-amplifier",
    "title": "22  Op Amp Circuits",
    "section": "22.2 Non-inverting amplifier",
    "text": "22.2 Non-inverting amplifier\n\n\n\n\n\n\nFigure 22.2: Non-inverting amplifier configuration.\n\n\n\nThe schematic for a non-inverting Op Amp configuration is shown above. Resistors Rf and R1 form a voltage divider circuit from the Op Amp out put terminal to the inverting input termial at node 4. Resistor Rp is some times included in Op Amp circuits as an impedance maching element that matches the source impedance from the driving circuit, Rs. Rp and Rs are usually equal in value and serve to balance the impedance seen at each of the input terminals. In a real Op Amp a very small amount of leakage current and a very small offest voltage is present at the input pins.\nThe schematic for the circuit was entered into LTSpice and the netlist was generated.\nV1 1 0 1\nXU1 4 3 2 opamp Aol=100K GBW=10Meg\nRs 3 1 100\nR1 0 5 2k\nRf 2 5 2k\nRp 4 5 100\nAs shown below, some edits were made to the netlist.\n\nnet_list = '''\nV1 1 0 1\nO1 4 3 2 \nRs 3 1 100\nR1 0 5 2e3\nRf 2 5 2e3\nRp 4 5 100\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{Rs} - \\frac{v_{3}}{Rs} = 0\\)\\(I_{O1} + \\frac{v_{2}}{Rf} - \\frac{v_{5}}{Rf} = 0\\)\\(- \\frac{v_{1}}{Rs} + \\frac{v_{3}}{Rs} = 0\\)\\(\\frac{v_{4}}{Rp} - \\frac{v_{5}}{Rp} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{Rp} + \\frac{1}{Rf} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Rp} - \\frac{v_{2}}{Rf} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{3} + v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  Rs, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  Rf, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  Rp, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{1} V_{1} + Rf V_{1}}{R_{1}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = V_{1}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = 0\\)\\(I_{O1} = - \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.expand()\n\n\\(\\displaystyle 1 + \\frac{Rf}{R_{1}}\\)\n\n\nFrom the transfer function we can see that the voltage gain of non-inverting Op Amp configuration is always greater than one.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#inverting-amplifier",
    "href": "Op Amp circuits.html#inverting-amplifier",
    "title": "22  Op Amp Circuits",
    "section": "22.3 Inverting amplifier",
    "text": "22.3 Inverting amplifier\n\n\n\n\n\n\nFigure 22.3: Inverting amplifier configuration.\n\n\n\nThe schematic above shows a the typical connection for an inverting amplifier. This configuratin is called an inverting amplifier since the output signal is inverted with respect to the input signal. Resistors Rf and R1 set the gain of the amplifier. Resistor Rp is sometime used to balance the impedance as seen from the Op Amps two inputs. Usually the value of Rp is chosen to be equal to the paralled combination of R1 and Rf.\nThe schematic for the circuit was entered into LTSpice and the following netlist was generated.\nV1 1 0 1\nXU1 3 4 2 opamp Aol=100K GBW=10Meg\nR1 3 1 2k\nRp 0 4 1k\nRf 3 2 2k\nA few edits were made to the netlist.\n\nnet_list = '''\nV1 1 0 1\nO1 3 4 2 \nR1 3 1 2e3\nRp 0 4 1e3\nRf 3 2 2e3\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{Rf} - \\frac{v_{3}}{Rf} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{Rf} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{Rf} - \\frac{v_{1}}{R_{1}} = 0\\)\\(\\frac{v_{4}}{Rp} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} - v_{4} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  Rf, \\  R_{1}, \\  v_{4}, \\  v_{3}, \\  Rp, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{Rf V_{1}}{R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{O1} = \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.simplify()\n\n\\(\\displaystyle - \\frac{Rf}{R_{1}}\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#differential-amplifier",
    "href": "Op Amp circuits.html#differential-amplifier",
    "title": "22  Op Amp Circuits",
    "section": "22.4 Differential amplifier",
    "text": "22.4 Differential amplifier\n\n\n\n\n\n\nFigure 22.4: Differential amplifier configuration.\n\n\n\nThe circuit shown above is a differential amplifier, where the circuit outputs the difference between V1 and V2, while rejecting any voltage from V3. All the resistors in Figure 22.4 have been set a value of 1k, whcih makes the gain applied to V1 and V2 equal to one, but the values of the reistors don’t have to be equal, which would make the gains something else.\nThe schematic for the circuit was entered into LTSpice and the following netlist was exported:\nXU1 4 5 2 opamp Aol=100K GBW=10Meg\nV1 1 6 1\nR1 4 1 1k\nR3 2 4 1k\nR4 0 5 1k\nR2 5 3 1k\nV2 3 6 3\nV3 6 0 10\nA few edits to the netlist were made to change the Op Amp designation and the values of the resistors to scientific notation.\n\nnet_list = '''\nO1 4 5 2\nV1 1 6 1\nR1 4 1 1e3\nR3 2 4 1e3\nR4 0 5 1e3\nR2 5 3 1e3\nV2 3 6 3\nV3 6 0 100\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(I_{V2} + \\frac{v_{3}}{R_{2}} - \\frac{v_{5}}{R_{2}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{3}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- I_{V1} - I_{V2} + I_{V3} = 0\\)\\(v_{1} - v_{6} = V_{1}\\)\\(v_{3} - v_{6} = V_{2}\\)\\(v_{6} = V_{3}\\)\\(v_{4} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{3}, \\  R_{2}, \\  I_{V2}, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  V_{3}, \\  v_{6}, \\  I_{V3}, \\  R_{4}, \\  v_{4}, \\  R_{1}, \\  R_{3}, \\  V_{1}, \\  v_{1}, \\  V_{2}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1} + V_{3}\\)\\(v_{2} = \\frac{R_{1} R_{4} V_{2} + R_{1} R_{4} V_{3} - R_{2} R_{3} V_{1} - R_{2} R_{3} V_{3} - R_{3} R_{4} V_{1} + R_{3} R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\\(v_{3} = V_{2} + V_{3}\\)\\(v_{4} = \\frac{R_{4} V_{2} + R_{4} V_{3}}{R_{2} + R_{4}}\\)\\(v_{5} = \\frac{R_{4} V_{2} + R_{4} V_{3}}{R_{2} + R_{4}}\\)\\(v_{6} = V_{3}\\)\\(I_{V1} = \\frac{- R_{2} V_{1} - R_{2} V_{3} - R_{4} V_{1} + R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\\(I_{V2} = \\frac{- V_{2} - V_{3}}{R_{2} + R_{4}}\\)\\(I_{V3} = \\frac{- R_{1} V_{2} - R_{1} V_{3} - R_{2} V_{1} - R_{2} V_{3} - R_{4} V_{1} + R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\\(I_{O1} = \\frac{R_{2} V_{1} + R_{2} V_{3} + R_{4} V_{1} - R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\n\n\n\nU_sym[v2]\n\n\\(\\displaystyle \\frac{R_{1} R_{4} V_{2} + R_{1} R_{4} V_{3} - R_{2} R_{3} V_{1} - R_{2} R_{3} V_{3} - R_{3} R_{4} V_{1} + R_{3} R_{4} V_{2}}{R_{1} R_{2} + R_{1} R_{4}}\\)\n\n\n\nU_sym[v2].subs({R1:1e3,R2:1e3,R3:1e3,R4:1e3})\n\n\\(\\displaystyle - 1.0 V_{1} + 1.0 V_{2}\\)\n\n\nWhen equal values are put in for the resistors, the output voltage reduces to the difference between the input voltages.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#summing-amplifier",
    "href": "Op Amp circuits.html#summing-amplifier",
    "title": "22  Op Amp Circuits",
    "section": "22.5 Summing amplifier",
    "text": "22.5 Summing amplifier\n\n\n\n\n\n\nFigure 22.5: summing amplifier circuit\n\n\n\nA summing amplifier outputs a voltage that is the sum of the input voltages. The schematic shown in Figure 22.5 has two input voltages, V1 and V2. Feedback provide by Rf along with R1 sets the gain of the amplifier. An abritray number of input can be configuted by duplicating V1 and R2 and connecting to node number 5.\nThere are other Op Amp summing configurations that have an inverting configuration.\nXU1 4 5 2 opamp Aol=100K GBW=10Meg\nV1 1 0 1\nR1 4 0 1k\nRf 2 4 2k\nR4 0 5 1k\nR3 5 3 1k\nV2 3 0 3\nR2 5 1 1k\n\nnet_list = '''\nO1 4 5 2\nV1 1 0 1\nR1 4 0 1e3\nRf 2 4 2e3\nR4 0 5 1e3\nR3 5 3 1e3\nV2 3 0 3\nR2 5 1 1e3\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{2}} - \\frac{v_{5}}{R_{2}} = 0\\)\\(I_{O1} + \\frac{v_{2}}{Rf} - \\frac{v_{4}}{Rf} = 0\\)\\(I_{V2} + \\frac{v_{3}}{R_{3}} - \\frac{v_{5}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{Rf} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{Rf} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{3} = V_{2}\\)\\(v_{4} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  I_{V2}, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  Rf, \\  R_{4}, \\  v_{4}, \\  R_{3}, \\  v_{3}, \\  R_{1}, \\  V_{1}, \\  v_{1}, \\  V_{2}\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{1} R_{2} R_{4} V_{2} + R_{1} R_{3} R_{4} V_{1} + R_{2} R_{4} Rf V_{2} + R_{3} R_{4} Rf V_{1}}{R_{1} R_{2} R_{3} + R_{1} R_{2} R_{4} + R_{1} R_{3} R_{4}}\\)\\(v_{3} = V_{2}\\)\\(v_{4} = \\frac{R_{2} R_{4} V_{2} + R_{3} R_{4} V_{1}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(v_{5} = \\frac{R_{2} R_{4} V_{2} + R_{3} R_{4} V_{1}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(I_{V1} = \\frac{- R_{3} V_{1} - R_{4} V_{1} + R_{4} V_{2}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(I_{V2} = \\frac{- R_{2} V_{2} + R_{4} V_{1} - R_{4} V_{2}}{R_{2} R_{3} + R_{2} R_{4} + R_{3} R_{4}}\\)\\(I_{O1} = \\frac{- R_{2} R_{4} V_{2} - R_{3} R_{4} V_{1}}{R_{1} R_{2} R_{3} + R_{1} R_{2} R_{4} + R_{1} R_{3} R_{4}}\\)\n\n\n\nU_sym[v2]\n\n\\(\\displaystyle \\frac{R_{1} R_{2} R_{4} V_{2} + R_{1} R_{3} R_{4} V_{1} + R_{2} R_{4} Rf V_{2} + R_{3} R_{4} Rf V_{1}}{R_{1} R_{2} R_{3} + R_{1} R_{2} R_{4} + R_{1} R_{3} R_{4}}\\)\n\n\n\nU_sym[v2].subs({R1:1e3,R2:1e3,R3:1e3,R4:1e3,Rf:2e3})\n\n\\(\\displaystyle 1.0 V_{1} + 1.0 V_{2}\\)\n\n\nWhen all the resistor values are equal, except for \\(R_f\\) which is set to twice the value, the gain of the circuit is unity and the output voltage is the sum of \\(V_1\\) and \\(V_2\\), as shown above.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#integrator",
    "href": "Op Amp circuits.html#integrator",
    "title": "22  Op Amp Circuits",
    "section": "22.6 Integrator",
    "text": "22.6 Integrator\n\n\n\n\n\n\nFigure 22.6: Integrator circuit\n\n\n\nThe schematic of the circuit shown above is an example of an Op Amp integrator and produces an output voltage which is proportional to the negative of the integral of the input voltage. The circuit is from Stout (1976), Chapter 15, Figure 15.3, with the switches omited, which are used to reset the integrator. The current through R1 and Cf is almost the same, since the current in Rf is small. Rf sets the low frequency gain of the circuit and prevents saturation of the Op Amp. The resistors R2 and Rp balance any offset voltages and currents at the input terminals of the Op Amp. The capacitor Cp is used to by pass any thermal noise from Rp.\nThe intergrator circuit is essentially a low pass filter and acts as an integrator for most of the frequency range up to the pole set by the values of R1 and Cf. The rule of thumb is to choose a time constant, \\(\\tau = R_1 C_f\\), such that \\(\\tau\\) is larger than the period of the input signal, but much smaller than the duration of interest for integration.\nThe schematic for the integrator was entered into LTSpice and the netlist was was obtained. In the LTSpice simulation, the voltage source, V1, was configured as pulse voltage source inorder to test the circuit. For the symbolic analysis, V1 is defined as a voltage source.\nV1 1 0 PULSE(0 1 1m 2m 0 0 5m) AC 1\nXU1 4 5 2 opamp Aol=100K GBW=10Meg\nR1 3 1 1k\nR2 4 3 100\nRp 0 5 100\nRf 3 2 100k\nCf 2 3 1µ\nCp 5 0 0.1µ\nA few edits were made and the netlist is assigned to the net_list variable.\n\nnet_list = '''\nV1 1 0 1\nOU1 4 5 2\nR1 3 1 1e3\nR2 4 3 100\nRp 0 5 100\nRf 3 2 100e3\nCf 2 3 1e-6\nCp 5 0 0.1e-6\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{Ou1} + v_{2} \\left(Cf s + \\frac{1}{Rf}\\right) + v_{3} \\left(- Cf s - \\frac{1}{Rf}\\right) = 0\\)\\(v_{2} \\left(- Cf s - \\frac{1}{Rf}\\right) + v_{3} \\left(Cf s + \\frac{1}{Rf} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- \\frac{v_{3}}{R_{2}} + \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{5} \\left(Cp s + \\frac{1}{Rp}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(v_{4} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  s, \\  Cp, \\  I_{Ou1}, \\  v_{2}, \\  v_{5}, \\  Rf, \\  R_{1}, \\  v_{4}, \\  v_{3}, \\  Cf, \\  V_{1}, \\  v_{1}, \\  Rp\\right)\\)\n\n\nSolve and display the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{Rf V_{1}}{Cf R_{1} Rf s + R_{1}}\\)\\(v_{3} = 0\\)\\(v_{4} = 0\\)\\(v_{5} = 0\\)\\(I_{V1} = - \\frac{V_{1}}{R_{1}}\\)\\(I_{Ou1} = \\frac{V_{1}}{R_{1}}\\)\n\n\nSolving for the transfer function at node 2. Transfer functions are normally presented in the frequency domain and are steady state responses.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.simplify()\n\n\\(\\displaystyle - \\frac{Rf}{R_{1} \\left(Cf Rf s + 1\\right)}\\)\n\n\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ Cf : 1.0 \\cdot 10^{-6}, \\  Cp : 1.0 \\cdot 10^{-7}, \\  Ou_{1} : \\text{NaN}, \\  R_{1} : 1000.0, \\  R_{2} : 100.0, \\  Rf : 100000.0, \\  Rp : 100.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nIn the circuit, the values of R1 and Cf produce a time constant calculated below.\n\nprint('integrator time constant: {:.1f}ms'.format(element_values[R1]*element_values[Cf]*1e3))\n\nintegrator time constant: 1.0ms\n\n\nThis means the integrator circuit will produce reasonable results for input signals having frequencies of less than 5 Hz over an integration period of less than 10 ms.\nSubstiuting the element values into the network equations gives the following equations.\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\I_{Ou1} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-6} s + 1.0 \\cdot 10^{-5}\\right) + v_{3} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right)\\\\- 0.001 v_{1} + v_{2} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right) + v_{3} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.01101\\right) - 0.01 v_{4}\\\\- 0.01 v_{3} + 0.01 v_{4}\\\\v_{5} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.01\\right)\\\\v_{1}\\\\v_{4} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\nSolving for the unknow node voltages and source currents.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = - \\frac{1000.0}{s + 10.0}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = -0.001\\)\\(I_{Ou1} = 0.001\\)\n\n\nThe voltage transferfunction of the integrator is shown below.\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle - \\frac{1000}{s + 10}\\)\n\n\nConvert transfer function to SciPy system. Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-1.59 Hz\n\n\nUse the SciPy function bode to plot the magnitude and phase of the intrgrator circuit.\n\nx = np.logspace(0, 5, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step responce for the integrator circuit is an exponential function, but over the initial time segment of zero to about 10ms, the response is approximately a straight line and value at point is equal to the area under the step at each point in time.\n** Ramp input to integrator**\nThe following cells step through the calcuations to solve for the voltage at node 2. The following cells analyze the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\nelement_values[V1] = 500/(s**2)\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.001 v_{1} - 0.001 v_{3}\\\\I_{Ou1} + v_{2} \\cdot \\left(1.0 \\cdot 10^{-6} s + 1.0 \\cdot 10^{-5}\\right) + v_{3} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right)\\\\- 0.001 v_{1} + v_{2} \\left(- 1.0 \\cdot 10^{-6} s - 1.0 \\cdot 10^{-5}\\right) + v_{3} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.01101\\right) - 0.01 v_{4}\\\\- 0.01 v_{3} + 0.01 v_{4}\\\\v_{5} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.01\\right)\\\\v_{1}\\\\v_{4} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{500}{s^{2}}\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{500.0}{s^{2}}\\)\\(v_{2} = - \\frac{500000.0}{s^{3} + 10.0 s^{2}}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = - \\frac{0.5}{s^{2}}\\)\\(I_{Ou1} = \\frac{0.5}{s^{2}}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 500.0 t\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle - \\frac{500000.0}{s^{3} + 10.0 s^{2}}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\nnode_v2 = inverse_laplace_transform(node_v2_s, s, t)\nnode_v2\n\n\\(\\displaystyle - 50000.0 t + 5000.0 - 5000.0 e^{- 10.0 t}\\)\n\n\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.002, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, node_v2)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\nPlot the final combined result.\n\nplt.title('Integrator output voltage vs time')\n\nplt.plot(x*1e3, np.real(V_node2),label='v2(t)')\nplt.plot(x*1e3, np.real(V_node1),label='v1(t)')\n#plt.plot(x*1e3, np.real(V_node2)+V_node1*x/2/(element_values[R1]*element_values[Cf]),label='error')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that the output of the Op Amp integrator, v2, is an exponential function in response to a voltage ramp scaled by the values of \\(R_1\\) and \\(C_f\\). The value of v2 is the area under the ramp at each x.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#differentiator",
    "href": "Op Amp circuits.html#differentiator",
    "title": "22  Op Amp Circuits",
    "section": "22.7 Differentiator",
    "text": "22.7 Differentiator\n\n\n\n\n\n\nFigure 22.7: Differentiator circuit.\n\n\n\nFigure 22.7 implements a circuit which produces an output proporational to the derivative of the input voltage. The circuit is from Stout (1976), chapter 15, Fig 15.1. C1, Rf and the Op Amp implement the differentiator function. R1 and Cf help stabalized the feedback loop. Rp helps balance the Op Amps offset currents and Cp is used to bypass the thermal noise of Rp to ground. A more compresive description of the circuit can be found in the referenced hadbook.\nThe schamitic for the circuit was entered into LTSpice and the netlist was exported.\nXU1 5 4 2 opamp Aol=100K GBW=10Meg\nV1 1 0 PULSE(0 1 1m 1m 0.5m 1m 5m) AC 1\nR1 3 1 100\nRf 2 5 200k\nRp 0 4 200k\nC1 5 3 0.01µ\nCf 2 5 70p\nCp 0 4 0.1µ\nThe netlist was editited as shown below.\n\nnet_list = '''\nO1 5 4 2\nV1 1 0 1\nR1 3 1 100\nRf 2 5 200e3\nRp 0 4 200e3\nC1 5 3 0.01e-6\nCf 2 5 50e-12\nCp 0 4 0.1e-6\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\left(Cf s + \\frac{1}{Rf}\\right) + v_{5} \\left(- Cf s - \\frac{1}{Rf}\\right) = 0\\)\\(- C_{1} s v_{5} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{4} \\left(Cp s + \\frac{1}{Rp}\\right) = 0\\)\\(- C_{1} s v_{3} + v_{2} \\left(- Cf s - \\frac{1}{Rf}\\right) + v_{5} \\left(C_{1} s + Cf s + \\frac{1}{Rf}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  s, \\  Cp, \\  v_{2}, \\  I_{O1}, \\  C_{1}, \\  v_{5}, \\  Rf, \\  v_{1}, \\  R_{1}, \\  v_{4}, \\  v_{3}, \\  Cf, \\  V_{1}, \\  Rp\\right)\\)\n\n\nSolve the equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - \\frac{C_{1} Rf V_{1} s}{C_{1} Cf R_{1} Rf s^{2} + C_{1} R_{1} s + Cf Rf s + 1}\\)\\(v_{3} = \\frac{V_{1}}{C_{1} R_{1} s + 1}\\)\\(v_{4} = 0\\)\\(v_{5} = 0\\)\\(I_{V1} = - \\frac{C_{1} V_{1} s}{C_{1} R_{1} s + 1}\\)\\(I_{O1} = \\frac{C_{1} V_{1} s}{C_{1} R_{1} s + 1}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.simplify()\n\n\\(\\displaystyle - \\frac{C_{1} Rf s}{C_{1} Cf R_{1} Rf s^{2} + C_{1} R_{1} s + Cf Rf s + 1}\\)\n\n\nSubstituting values for the component reference designators.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  Cf : 5.0 \\cdot 10^{-11}, \\  Cp : 1.0 \\cdot 10^{-7}, \\  O_{1} : \\text{NaN}, \\  R_{1} : 100.0, \\  Rf : 200000.0, \\  Rp : 200000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.01 v_{1} - 0.01 v_{3}\\\\I_{O1} + v_{2} \\cdot \\left(5.0 \\cdot 10^{-11} s + 5.0 \\cdot 10^{-6}\\right) + v_{5} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 0.01 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 0.01\\right)\\\\v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{3} + v_{2} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right) + v_{5} \\cdot \\left(1.005 \\cdot 10^{-8} s + 5.0 \\cdot 10^{-6}\\right)\\\\v_{1}\\\\- v_{4} + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = - \\frac{200000000.0 s}{s^{2} + 1100000.0 s + 100000000000.0}\\)\\(v_{3} = \\frac{1000000.0}{s + 1000000.0}\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = - \\frac{s}{100.0 s + 100000000.0}\\)\\(I_{O1} = \\frac{s}{100.0 s + 100000000.0}\\)\n\n\nTransfer function:\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle - \\frac{200000000 s}{s^{2} + 1100000 s + 100000000000}\\)\n\n\nConvert transfer function to SciPy system. Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 1\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-159,154.94 Hz\n-15,915.49 Hz\n\n\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(0, 5, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe impulse and step response maximum values are for an ideal Op Amp. A real Op Amp’s maximum output voltage would be limited to the supply rails.\nThe following cells analyize the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\nelement_values[V1] = 1e3/(s**2)   # ramp of 1 volt per 1 ms \nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 0.01 v_{1} - 0.01 v_{3}\\\\I_{O1} + v_{2} \\cdot \\left(5.0 \\cdot 10^{-11} s + 5.0 \\cdot 10^{-6}\\right) + v_{5} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 0.01 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 0.01\\right)\\\\v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 5.0 \\cdot 10^{-6}\\right)\\\\- 1.0 \\cdot 10^{-8} s v_{3} + v_{2} \\left(- 5.0 \\cdot 10^{-11} s - 5.0 \\cdot 10^{-6}\\right) + v_{5} \\cdot \\left(1.005 \\cdot 10^{-8} s + 5.0 \\cdot 10^{-6}\\right)\\\\v_{1}\\\\- v_{4} + v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1000.0}{s^{2}}\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1000.0}{s^{2}}\\)\\(v_{2} = - \\frac{200000000000.0}{s^{3} + 1100000.0 s^{2} + 100000000000.0 s}\\)\\(v_{3} = \\frac{1000000000.0}{s^{3} + 1000000.0 s^{2}}\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(I_{V1} = - \\frac{10.0}{s^{2} + 1000000.0 s}\\)\\(I_{O1} = \\frac{10.0}{s^{2} + 1000000.0 s}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 1000.0 t\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle - \\frac{200000000000.0}{s^{3} + 1100000.0 s^{2} + 100000000000.0 s}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\nnode_v2 = inverse_laplace_transform(node_v2_s, s, t)\nnode_v2\n\n\\(\\displaystyle -2.0 - 0.222222222222222 e^{- 1000000.0 t} + 2.22222222222222 e^{- 100000.0 t}\\)\n\n\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.001, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, node_v2)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\n\nplt.title('Differentiator output voltage vs time')\n\nplt.plot(x, np.real(V_node2),label='v2(t)')\nplt.plot(x, np.real(V_node1),label='v1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that the output of the Op Amp differentiator, v2, is a constant value in response to a voltage ramp scaled by the values of \\(R_1\\) and \\(C_f\\). The value of v2 is the slope of the ramp at each x.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#generalized-impedance-converter-gic-circuit",
    "href": "Op Amp circuits.html#generalized-impedance-converter-gic-circuit",
    "title": "22  Op Amp Circuits",
    "section": "22.8 Generalized Impedance Converter (GIC) circuit",
    "text": "22.8 Generalized Impedance Converter (GIC) circuit\n\n\n\n\n\n\nFigure 22.8: Schematic for a Generalized Impedance Converter circuit.\n\n\n\nThe schematic shown above is from Williams and Taylor (1995), Figure 3-31, and is known as a generalized impedance converter (GIC). The circuit is attributed to Antoniou (1969) and used by Bruton (1978) to realize active filters from ladder topologies as describe in Section 22.9.\nThe schematic for the circuit shown above was entered into LTSpice and the following net list was generated.\nXU2 3 1 4 opamp Aol=100K GBW=10Meg\nV1 1 0 1\nXU1 3 5 2 opamp Aol=100K GBW=10Meg\nR2 2 3 1\nR4 4 5 1\nR5 5 0 1\nR1 1 2 1\nR3 3 4 1\n\n22.8.1 Basic GIC\nThe circuit for the basic GIC is analyzed below using resistors in all the elements.\n\nnet_list = '''\nO2 3 1 4 \nV1 1 0 1\nO1 3 5 2\nR1 1 2 1\nR2 2 3 1\nR3 3 4 1\nR4 4 5 1\nR5 5 0 1\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{O2} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{3}}{R_{3}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{3} = 0\\)\\(v_{3} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{1}, \\  R_{3}, \\  v_{3}, \\  v_{4}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{2} R_{4} V_{1} + R_{3} R_{5} V_{1}}{R_{3} R_{5}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{R_{4} V_{1} + R_{5} V_{1}}{R_{5}}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{R_{2} R_{4} V_{1}}{R_{1} R_{3} R_{5}}\\)\\(I_{O2} = \\frac{- R_{3} V_{1} - R_{4} V_{1}}{R_{3} R_{5}}\\)\\(I_{O1} = \\frac{R_{1} R_{4} V_{1} + R_{2} R_{4} V_{1}}{R_{1} R_{3} R_{5}}\\)\n\n\nSolving for the impedance at node 1.\n\nZ_sym = U_sym[v1]/(U_sym[I_V1])\nZ_sym\n\n\\(\\displaystyle - \\frac{R_{1} R_{3} R_{5}}{R_{2} R_{4}}\\)\n\n\nIf you replace any of the R’s with \\(Ls\\) or \\(\\frac {1}{Cs}\\), then you can see that a new complex impedance is obtained. This is illustrated in the two examples below.\n\n\n22.8.2 Inductor\nBy substituting a capacitor for R4, the impedance of a grounded inductor can be synthesized.\n\n# inductor\nnet_list = '''\nO2 3 1 4 \nV1 1 0 1\nO1 3 5 2\nR1 1 2 1\nR2 2 3 1\nR3 3 4 1\n*R4 4 5 1\nC 4 5 1\nR5 5 0 1\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(v_{3} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{3}} - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C s v_{5} + I_{O2} + v_{4} \\left(C s + \\frac{1}{R_{3}}\\right) - \\frac{v_{3}}{R_{3}} = 0\\)\\(- C s v_{4} + v_{5} \\left(C s + \\frac{1}{R_{5}}\\right) = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{3} = 0\\)\\(v_{3} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  s, \\  v_{2}, \\  I_{O1}, \\  v_{5}, \\  I_{O2}, \\  R_{5}, \\  C, \\  R_{1}, \\  R_{3}, \\  v_{3}, \\  v_{4}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C R_{3} R_{5} V_{1} s - R_{2} V_{1}}{C R_{3} R_{5} s}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{C R_{5} V_{1} s + V_{1}}{C R_{5} s}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{R_{2} V_{1}}{C R_{1} R_{3} R_{5} s}\\)\\(I_{O2} = \\frac{- C R_{3} V_{1} s - V_{1}}{C R_{3} R_{5} s}\\)\\(I_{O1} = \\frac{R_{1} V_{1} + R_{2} V_{1}}{C R_{1} R_{3} R_{5} s}\\)\n\n\nSolving for the impedance at node 1.\n\nZ_sym = U_sym[v1]/(U_sym[I_V1])\nZ_sym #.simplify()\n\n\\(\\displaystyle - \\frac{C R_{1} R_{3} R_{5} s}{R_{2}}\\)\n\n\nThe sign of the impedance is negative which accounts for the direction of the current flowing in V1.\nThe value of the synthesized inductor is:\n\\(\\frac {C R_1 R_3 R_5}{R_2}\\)\n\n\n22.8.3 D element - frequency dependent negative resistor\nBy substituting a capacitor for R1 and R3, a frequency-dependent negative resistor impedances can be synthenzisied.\n\n# D element - frequency dependent negative resistor\nnet_list = '''\nO2 3 1 4 \nV1 1 0 1\nO1 3 5 2\n*R1 1 2 1\nC1 1 2 1\nR2 2 3 1\n*R3 3 4 1\nC3 3 4 1\nR4 4 5 1\nR5 5 0 1\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{V1} = 0\\)\\(- C_{1} s v_{1} + I_{O1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(- C_{3} s v_{4} + v_{3} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}} = 0\\)\\(- C_{3} s v_{3} + I_{O2} + v_{4} \\left(C_{3} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{1} + v_{3} = 0\\)\\(v_{3} - v_{5} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{2}, \\  s, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  v_{4}, \\  v_{3}, \\  V_{1}, \\  v_{1}\\right)\\)\n\n\nSolve the equations and display the results.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{3} R_{2} R_{4} V_{1} s + R_{5} V_{1}}{R_{5}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{R_{4} V_{1} + R_{5} V_{1}}{R_{5}}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{C_{1} C_{3} R_{2} R_{4} V_{1} s^{2}}{R_{5}}\\)\\(I_{O2} = \\frac{- C_{3} R_{4} V_{1} s - V_{1}}{R_{5}}\\)\\(I_{O1} = \\frac{C_{1} C_{3} R_{2} R_{4} V_{1} s^{2} + C_{3} R_{4} V_{1} s}{R_{5}}\\)\n\n\nSolving for the impedance, \\(\\frac {v_1}{I_{V1}}\\), at node 1.\n\nZ_sym = U_sym[v1]/(U_sym[I_V1])\nZ_sym #.simplify()\n\n\\(\\displaystyle - \\frac{R_{5}}{C_{1} C_{3} R_{2} R_{4} s^{2}}\\)\n\n\nThe frequency dependent negative resistor can be used to convert ladder filters into active filters as desribed below.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#sec-GIC-LP-filter",
    "href": "Op Amp circuits.html#sec-GIC-LP-filter",
    "title": "22  Op Amp Circuits",
    "section": "22.9 Generalized Impedance Converter Filter",
    "text": "22.9 Generalized Impedance Converter Filter\n\n\n\n\n\n\nFigure 22.9: GIC-LP-filter\n\n\n\nThe filter shown above is from Williams and Taylor (1995), Figure 3-33. The filter is an active low-pass filter with a 3 dB cut off at 400 Hz, with at least 20 dB attenuation at 1200 Hz. Resistors Ra and Rb are included in the schematic to provide a DC path to ground since real Op Amps have some leakage current from the input terminals and this would cause a build up voltage on C2 if not for a DC ground path provided by Ra or Rb. Refere to Williams and Taylor (1995) for a more detailed description of the filter design procedure.\nThe net list for the filter was obtained from LTSpice.\nXU2 6 4 7 opamp Aol=100K GBW=10Meg\nV1 1 0 AC 1\nXU1 6 8 5 opamp Aol=100K GBW=10Meg\nC1 3 1 0.01µ\nC2 5 4 0.01µ\nC3 7 6 0.01µ\nC4 0 2 0.01µ\nR2 5 6 40.2k\nR3 7 8 41.2k\nR4 8 0 40.2k\nR1 4 3 22.1k\nR5 2 4 97.6k\nRb 2 0 1Meg\nThe netlist was editied to fix Op Amp designators and to comment out Rb, which not needed for a symbolic solution.\n\nnet_list = '''\nO2 6 4 7\nV1 1 0 1\nO1 6 8 5\nC1 3 1 0.01e-6\nC2 5 4 0.01e-6\nC3 7 6 0.01e-6\nC4 0 2 0.01e-6\nR2 5 6 40.2e3\nR3 7 8 41.2e3\nR4 8 0 40.2e3\nR1 4 3 22.1e3\nR5 2 4 97.6e3\n*Rb 2 0 1e6\n'''\n\nGenerate markdown text to display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{3} + I_{V1} = 0\\)\\(v_{2} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) - \\frac{v_{4}}{R_{5}} = 0\\)\\(- C_{1} s v_{1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C_{2} s v_{4} + I_{O1} + v_{5} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{2}} = 0\\)\\(- C_{3} s v_{7} + v_{6} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{3} s v_{6} + I_{O2} + v_{7} \\left(C_{3} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{8}}{R_{3}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{3}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{6} = 0\\)\\(v_{6} - v_{8} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  C_{4}, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  v_{8}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  v_{7}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nSolving for the transfer function at node 2.\n\nU_sym = solve(NE_sym,X)\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym\n\n\\(\\displaystyle \\frac{C_{1} R_{4}}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5} s^{3} + C_{1} C_{2} C_{3} R_{1} R_{2} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{4} s + C_{1} C_{4} R_{4} R_{5} s + C_{1} R_{4} + C_{2} C_{3} C_{4} R_{2} R_{3} R_{5} s^{2} + C_{2} C_{3} R_{2} R_{3} s + C_{4} R_{4}}\\)\n\n\nThe roots of the denominator can be obtained symbolically. Since the degree of the polynominal is a third order, SymPy can solve for the roots and obtain a solution very quickly. The roots expressed in symbolic form are not very useful, but are easily obtained, something that would be almost impossible to do by hand with pencil and paper.\n\nnum, den = fraction(H_sym)\np = solve(den,s)\np[0]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}}{3} - \\frac{C_{1} R_{1} + C_{4} R_{5}}{3 C_{1} C_{4} R_{1} R_{5}}\\)\n\n\n\np[1]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}}{3} - \\frac{C_{1} R_{1} + C_{4} R_{5}}{3 C_{1} C_{4} R_{1} R_{5}}\\)\n\n\n\np[2]\n\n\\(\\displaystyle - \\frac{- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{2}}{C_{1}^{2} C_{4}^{2} R_{1}^{2} R_{5}^{2}}\\right)^{3} + \\left(\\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{2 \\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(C_{1} R_{4} + C_{4} R_{4}\\right)}{2 C_{1} C_{2} C_{3} C_{4} R_{1} R_{2} R_{3} R_{5}} - \\frac{9 \\left(C_{1} R_{1} + C_{4} R_{5}\\right) \\left(C_{1} C_{4} R_{1} R_{4} + C_{1} C_{4} R_{4} R_{5} + C_{2} C_{3} R_{2} R_{3}\\right)}{2 C_{1}^{2} C_{2} C_{3} C_{4}^{2} R_{1}^{2} R_{2} R_{3} R_{5}^{2}} + \\frac{\\left(C_{1} R_{1} + C_{4} R_{5}\\right)^{3}}{C_{1}^{3} C_{4}^{3} R_{1}^{3} R_{5}^{3}}}}{3} - \\frac{C_{1} R_{1} + C_{4} R_{5}}{3 C_{1} C_{4} R_{1} R_{5}}\\)\n\n\nIncluding Rb in the circuit and changing the value to 1M.\n\nnet_list = '''\nO2 6 4 7\nV1 1 0 1\nO1 6 8 5\nC1 3 1 0.01e-6\nC2 5 4 0.01e-6\nC3 7 6 0.01e-6\nC4 0 2 0.01e-6\nR2 5 6 40.2e3\nR3 7 8 41.2e3\nR4 8 0 40.2e3\nR1 4 3 22.1e3\nR5 2 4 97.6e3\nRb 2 0 1e6\n'''\n\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{3} + I_{V1} = 0\\)\\(v_{2} \\left(C_{4} s + \\frac{1}{Rb} + \\frac{1}{R_{5}}\\right) - \\frac{v_{4}}{R_{5}} = 0\\)\\(- C_{1} s v_{1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C_{2} s v_{4} + I_{O1} + v_{5} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{2}} = 0\\)\\(- C_{3} s v_{7} + v_{6} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{3} s v_{6} + I_{O2} + v_{7} \\left(C_{3} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{8}}{R_{3}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{3}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{6} = 0\\)\\(v_{6} - v_{8} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  C_{4}, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  v_{8}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  v_{7}, \\  Rb, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-8}, \\  C_{4} : 1.0 \\cdot 10^{-8}, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 22100.0, \\  R_{2} : 40200.0, \\  R_{3} : 41200.0, \\  R_{4} : 40200.0, \\  R_{5} : 97600.0, \\  Rb : 1000000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 \\cdot 10^{-8} s v_{1} - 1.0 \\cdot 10^{-8} s v_{3}\\\\v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 1.12459016393443 \\cdot 10^{-5}\\right) - 1.02459016393443 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 4.52488687782805 \\cdot 10^{-5}\\right) - 4.52488687782805 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 1.02459016393443 \\cdot 10^{-5} v_{2} - 4.52488687782805 \\cdot 10^{-5} v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-8} s + 5.54947704176248 \\cdot 10^{-5}\\right)\\\\I_{O1} - 1.0 \\cdot 10^{-8} s v_{4} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right) - 2.48756218905473 \\cdot 10^{-5} v_{6}\\\\- 1.0 \\cdot 10^{-8} s v_{7} - 2.48756218905473 \\cdot 10^{-5} v_{5} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-8} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.42718446601942 \\cdot 10^{-5}\\right) - 2.42718446601942 \\cdot 10^{-5} v_{8}\\\\- 2.42718446601942 \\cdot 10^{-5} v_{7} + 4.91474665507414 \\cdot 10^{-5} v_{8}\\\\v_{1}\\\\- v_{4} + v_{6}\\\\v_{6} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{2.79920457659434 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{3} = \\frac{2.48756218905472 \\cdot 10^{46} s^{4} + 2.79748796998614 \\cdot 10^{49} s^{3} + 3.35064787818341 \\cdot 10^{53} s^{2} + 3.13426936441268 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{4} = \\frac{2.73202366675606 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{5} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{3} + 1.46619200612885 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{6} = \\frac{2.73202366675606 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{7} = \\frac{5.53200812124237 \\cdot 10^{53} s^{2} + 6.22124191995455 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{8} = \\frac{2.73202366675606 \\cdot 10^{53} s^{2} + 3.07240694326994 \\cdot 10^{56} s}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(I_{V1} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{4} - 1.26583166062721 \\cdot 10^{53} s^{3} - 2.79920457659434 \\cdot 10^{56} s^{2} - 2.79920457659434 \\cdot 10^{58} s}{2.48756218905472 \\cdot 10^{54} s^{4} + 1.40534254770211 \\cdot 10^{58} s^{3} + 4.61647953881062 \\cdot 10^{61} s^{2} + 5.93347394100702 \\cdot 10^{64} s + 2.79920457659434 \\cdot 10^{66}}\\)\\(I_{O2} = \\frac{- 2.18748785506742 \\cdot 10^{62} s^{3} - 7.76946386696064 \\cdot 10^{65} s^{2} - 5.97094011052149 \\cdot 10^{68} s}{1.943407960199 \\cdot 10^{63} s^{4} + 1.09792386539227 \\cdot 10^{67} s^{3} + 3.6066246396958 \\cdot 10^{70} s^{2} + 4.63552651641173 \\cdot 10^{73} s + 2.18687857546433 \\cdot 10^{75}}\\)\\(I_{O1} = \\frac{1.75874023547421 \\cdot 10^{48} s^{4} + 6.35283767986486 \\cdot 10^{51} s^{3} + 4.9200546510697 \\cdot 10^{54} s^{2}}{3.886815920398 \\cdot 10^{52} s^{4} + 2.19584773078454 \\cdot 10^{56} s^{3} + 7.2132492793916 \\cdot 10^{59} s^{2} + 9.27105303282346 \\cdot 10^{62} s + 4.37375715092865 \\cdot 10^{64}}\\)\n\n\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{174950286037146250000000 s}{15547263681592 s^{4} + 87833909231381875 s^{3} + 288529971175663750000 s^{2} + 370842121312938125000000 s + 17495028603714625000000000}\\)\n\n\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 1\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-278.58+446.47j Hz\n-278.58-446.47j Hz\n-334.18+0.00j Hz\n-7.80+0.00j Hz\n\n\nThe SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(1, 5, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nStep response as a check of the network equations\n\nnet_list = '''\nO2 6 4 7\nV1 1 0 1\nO1 6 8 5\nC1 3 1 0.01e-6\nC2 5 4 0.01e-6\nC3 7 6 0.01e-6\nC4 0 2 0.01e-6\nR2 5 6 40.2e3\nR3 7 8 41.2e3\nR4 8 0 40.2e3\nR1 4 3 22.1e3\nR5 2 4 97.6e3\nRb 2 0 1e6\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{3} + I_{V1} = 0\\)\\(v_{2} \\left(C_{4} s + \\frac{1}{Rb} + \\frac{1}{R_{5}}\\right) - \\frac{v_{4}}{R_{5}} = 0\\)\\(- C_{1} s v_{1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{2} s v_{5} + v_{4} \\left(C_{2} s + \\frac{1}{R_{5}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- C_{2} s v_{4} + I_{O1} + v_{5} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{2}} = 0\\)\\(- C_{3} s v_{7} + v_{6} \\left(C_{3} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(- C_{3} s v_{6} + I_{O2} + v_{7} \\left(C_{3} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{8}}{R_{3}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{3}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{6} = 0\\)\\(v_{6} - v_{8} = 0\\)\n\n\nget the element values from thge netlist.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0 \\cdot 10^{-8}, \\  C_{2} : 1.0 \\cdot 10^{-8}, \\  C_{3} : 1.0 \\cdot 10^{-8}, \\  C_{4} : 1.0 \\cdot 10^{-8}, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 22100.0, \\  R_{2} : 40200.0, \\  R_{3} : 41200.0, \\  R_{4} : 40200.0, \\  R_{5} : 97600.0, \\  Rb : 1000000.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  C_{4}, \\  v_{2}, \\  C_{1}, \\  I_{O1}, \\  v_{5}, \\  C_{3}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  v_{8}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  v_{7}, \\  Rb, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nThe following cells analyize the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\n#element_values[V1] = 1/(s**2)   # ramp of 1 volt per 1 s\nelement_values[V1] = 1/(s)   # step function\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 1.0 \\cdot 10^{-8} s v_{1} - 1.0 \\cdot 10^{-8} s v_{3}\\\\v_{2} \\cdot \\left(1.0 \\cdot 10^{-8} s + 1.12459016393443 \\cdot 10^{-5}\\right) - 1.02459016393443 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-8} s + 4.52488687782805 \\cdot 10^{-5}\\right) - 4.52488687782805 \\cdot 10^{-5} v_{4}\\\\- 1.0 \\cdot 10^{-8} s v_{5} - 1.02459016393443 \\cdot 10^{-5} v_{2} - 4.52488687782805 \\cdot 10^{-5} v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-8} s + 5.54947704176248 \\cdot 10^{-5}\\right)\\\\I_{O1} - 1.0 \\cdot 10^{-8} s v_{4} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right) - 2.48756218905473 \\cdot 10^{-5} v_{6}\\\\- 1.0 \\cdot 10^{-8} s v_{7} - 2.48756218905473 \\cdot 10^{-5} v_{5} + v_{6} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.48756218905473 \\cdot 10^{-5}\\right)\\\\I_{O2} - 1.0 \\cdot 10^{-8} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-8} s + 2.42718446601942 \\cdot 10^{-5}\\right) - 2.42718446601942 \\cdot 10^{-5} v_{8}\\\\- 2.42718446601942 \\cdot 10^{-5} v_{7} + 4.91474665507414 \\cdot 10^{-5} v_{8}\\\\v_{1}\\\\- v_{4} + v_{6}\\\\v_{6} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{2.79920457659434 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{3} = \\frac{2.48756218905472 \\cdot 10^{46} s^{3} + 2.79748796998614 \\cdot 10^{49} s^{2} + 3.35064787818341 \\cdot 10^{53} s + 3.13426936441268 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{4} = \\frac{2.73202366675606 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{5} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{2} + 1.46619200612885 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{6} = \\frac{2.73202366675606 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{7} = \\frac{5.53200812124237 \\cdot 10^{53} s + 6.22124191995455 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(v_{8} = \\frac{2.73202366675606 \\cdot 10^{53} s + 3.07240694326994 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\\(I_{V1} = \\frac{- 1.12559375070349 \\cdot 10^{50} s^{3} - 1.26583166062721 \\cdot 10^{53} s^{2} - 2.79920457659434 \\cdot 10^{56} s - 2.79920457659434 \\cdot 10^{58}}{2.48756218905472 \\cdot 10^{54} s^{4} + 1.40534254770211 \\cdot 10^{58} s^{3} + 4.61647953881062 \\cdot 10^{61} s^{2} + 5.93347394100702 \\cdot 10^{64} s + 2.79920457659434 \\cdot 10^{66}}\\)\\(I_{O2} = \\frac{- 2.18748785506742 \\cdot 10^{62} s^{2} - 7.76946386696064 \\cdot 10^{65} s - 5.97094011052149 \\cdot 10^{68}}{1.943407960199 \\cdot 10^{63} s^{4} + 1.09792386539227 \\cdot 10^{67} s^{3} + 3.6066246396958 \\cdot 10^{70} s^{2} + 4.63552651641173 \\cdot 10^{73} s + 2.18687857546433 \\cdot 10^{75}}\\)\\(I_{O1} = \\frac{1.75874023547421 \\cdot 10^{48} s^{3} + 6.35283767986486 \\cdot 10^{51} s^{2} + 4.9200546510697 \\cdot 10^{54} s}{3.886815920398 \\cdot 10^{52} s^{4} + 2.19584773078454 \\cdot 10^{56} s^{3} + 7.2132492793916 \\cdot 10^{59} s^{2} + 9.27105303282346 \\cdot 10^{62} s + 4.37375715092865 \\cdot 10^{64}}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 1\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle \\frac{2.79920457659434 \\cdot 10^{56}}{2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_v2 = inverse_laplace_transform(node_v2_s, s, t)\n#node_v2\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\n\nn, d = fraction(node_v2_s)\nn = n.expand()\nd = d.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(2.79920457659434 \\cdot 10^{56}\\)denominator: \\(2.48756218905472 \\cdot 10^{46} s^{4} + 1.40534254770211 \\cdot 10^{50} s^{3} + 4.61647953881062 \\cdot 10^{53} s^{2} + 5.93347394100702 \\cdot 10^{56} s + 2.79920457659434 \\cdot 10^{58}\\)\n\n\nUse the SciPy residue function to do the inverse Laplace transform.\n\ncn = Poly(n, s).all_coeffs()\ncd = Poly(d, s).all_coeffs()\nr, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n# build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\nz = 0\nfor i in range(len(r)):\n    m = (r[i]/(s-p[i]))\n    z += inverse_laplace_transform(m, s, t)\n\nEach of the terms came be converted to a function using SymPy’s lambdify function. Define the values for the x-axis of the plot and put each one into an array for plotting.\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.2, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, z)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x*1e3, np.real(V_node2),label='v2(t)')\n#plt.plot(x, np.real(V_node1),label='v1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Op Amp circuits.html#dual-amplifier-band-pass-filter",
    "href": "Op Amp circuits.html#dual-amplifier-band-pass-filter",
    "title": "22  Op Amp Circuits",
    "section": "22.10 Dual amplifier band pass filter",
    "text": "22.10 Dual amplifier band pass filter\n\n\n\n\n\n\nFigure 22.10: Dual amplifier band pass filter with compoenet values set to 1\n\n\n\nThe Dual Amplifier Bandpass (DABP) filter shown above is from Williams and Taylor (1995), Figure 5-27. The filter was first described by Sedra and Espinoza (1975). The filter uses two Op Amps and has eight branches and 6 nodes. The DABP configuration has been found very useful for designs covering a wide range of Qs and frequencies. Component sensitivity is small, resonant frequency and Q are easily adjustable, and the element spread is low.\nThe schematic was entered into LTSpice and the netlist was exported as shown below.\nXU1 5 4 2 opamp Aol=100K GBW=10Meg\nXU2 5 6 3 opamp Aol=100K GBW=10Meg\nR1 4 1 10\nR2 4 3 1\nR3 5 2 1\nR5 6 2 1\nR4 6 0 1\nC2 5 3 1\nC1 0 4 1\nV1 1 0 AC 1\nThe netlist was modified and equated to the net list variable shown below.\n\nnet_list = '''\nO1 5 4 2\nO2 5 6 3\nR1 4 1 1\nR2 4 3 1\nR3 5 2 1\nR5 6 2 1\nR4 6 0 1\nC2 5 3 1\nC1 0 4 1\nV1 1 0 1\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{5}}{R_{3}} = 0\\)\\(- C_{2} s v_{5} + I_{O2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{5} = 0\\)\\(v_{5} - v_{6} = 0\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  C_{1}, \\  v_{5}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nSolve the network equations for the unknown node voltages and currents.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s + C_{2} R_{2} R_{3} R_{5} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{3} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s - R_{2} R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{4} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{5} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(v_{6} = \\frac{C_{2} R_{2} R_{3} R_{4} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} R_{2} R_{3} R_{4} V_{1} s^{2} - R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(I_{O1} = \\frac{- C_{2} R_{2} R_{3} V_{1} s - C_{2} R_{2} R_{5} V_{1} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\\(I_{O2} = \\frac{C_{2} R_{2} R_{5} V_{1} s + R_{5} V_{1}}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\n\n\nSolving for the transfer function at node 2.\n\nH_sym = U_sym[v2]/U_sym[v1]\nH_sym.cancel()\n\n\\(\\displaystyle \\frac{C_{2} R_{2} R_{3} R_{4} s + C_{2} R_{2} R_{3} R_{5} s}{C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}}\\)\n\n\nUsing the function fraction() extract the numerator and denomiator of the transferfunction.\n\nnum, den = fraction(H_sym.cancel())\n\nThe denominator is a second order function of the Laplace variable s shown below.\n\nden\n\n\\(\\displaystyle C_{1} C_{2} R_{1} R_{2} R_{3} R_{4} s^{2} + C_{2} R_{2} R_{3} R_{4} s + R_{1} R_{5}\\)\n\n\nThe following code extracts the coefficients of s and these are assigned to variables, a, b and c.\n\np = Poly(den, s)\na, b, c, = p.coeffs()\n\nOmega, \\(\\omega\\), is the natural freguency of system and is determined by the following expression:\n\nomega = sqrt(c/a)\nomega\n\n\\(\\displaystyle \\sqrt{\\frac{R_{5}}{C_{1} C_{2} R_{2} R_{3} R_{4}}}\\)\n\n\nQ is a parameter that relates the damping ratio to the natural frequency.\n\nQ = omega/(b/a)\nQ\n\n\\(\\displaystyle C_{1} R_{1} \\sqrt{\\frac{R_{5}}{C_{1} C_{2} R_{2} R_{3} R_{4}}}\\)\n\n\nThe design of a band pass filter can be accomplished by letting \\(C1 = C2 = Cn = 0.1\\mu\\)F, \\(R4 = R5 = Rp = 10\\)k and \\(R2 = R3 = R\\). We can then solve for R at the desired \\(\\omega\\) and \\(\\zeta\\). For example, if we desire a band pass filter with a center frequency of 10 Hz, \\(\\omega = 2 \\pi 10\\) and a damping ratio of \\(\\zeta = 0.5\\), we can solve for the value of R that gives an \\(\\omega = 2 \\pi 10\\)\n\nR = Symbol('R')\nfreq = 10 #Hz\nCn = 0.1e-6\nRp = 10e3\nomega_n = omega.subs({R2:R,R3:R,C1:Cn,C2:Cn,R5:Rp,R4:Rp})\nomega_n\n\n\\(\\displaystyle 10000000.0 \\sqrt{\\frac{1}{R^{2}}}\\)\n\n\nSolve for R with \\(\\omega = 10\\)Hz.\n\nRn = solve(omega_n-freq*2*pi,R)\nRn = float(Rn[1])\nRn\n\n\\(\\displaystyle 159154.943091895\\)\n\n\nSolve for R with \\(R2=R3=Rn\\),\n\nQ_n = Q.subs({R2:Rn,R3:Rn,C1:Cn,C2:Cn,R5:Rp,R4:Rp})\nQ_n\n\n\\(\\displaystyle 6.28318530717959 \\cdot 10^{-6} R_{1}\\)\n\n\nThe damping ratio is a system parameter, denoted by \\(\\zeta\\)\n\nunderdamped: \\(\\zeta \\gt 1\\), roots of the demoninator are real\ncritically damped: \\(\\zeta = 1\\)\noverdamped: \\(\\zeta \\lt 1\\), roots of the demoninator are complex\n\nQ factor is another non-dimensional characterization of the amount of damping; high Q indicates slow damping relative to the oscillation.\n\\(Q = \\frac {1}{2 \\zeta}\\)\n\nzeta = 0.5\nq_factor = 1/(2*zeta)\nR1n = solve(Q_n - q_factor,R1)\nR1n = float(R1n[0])\nR1n\n\n\\(\\displaystyle 159154.943091895\\)\n\n\nUsing the component values calculated above, these are substituted into the network equations.\n\nNE = NE_sym.subs({V1:1.0, R1:R1n, R2:Rn, R3:Rn, R5:Rp, R4:Rp, C2:Cn, C1:Cn})\n\nThe equations are quickly solved by SymPy and the solution is displayed.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{1.25663706143592 \\cdot 10^{28} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{3} = \\frac{6.28318530717959 \\cdot 10^{27} s - 3.94784176043575 \\cdot 10^{29}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{4} = \\frac{6.28318530717959 \\cdot 10^{27} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{5} = \\frac{6.28318530717959 \\cdot 10^{27} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{6} = \\frac{6.28318530717959 \\cdot 10^{27} s}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(I_{V1} = \\frac{- 6.28318530717959 \\cdot 10^{40} s^{2} - 1.25663706143592 \\cdot 10^{28} s - 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{2} + 6.28318530717961 \\cdot 10^{47} s + 3.94784176043575 \\cdot 10^{49}}\\)\\(I_{O1} = - \\frac{6.67796948322322 \\cdot 10^{30} s}{1.0 \\cdot 10^{33} s^{2} + 6.28318530717961 \\cdot 10^{34} s + 3.94784176043575 \\cdot 10^{36}}\\)\\(I_{O2} = \\frac{3.94784176043575 \\cdot 10^{42} s + 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{2} + 6.28318530717961 \\cdot 10^{47} s + 3.94784176043575 \\cdot 10^{49}}\\)\n\n\nThe transfer function is v2/v1 and some simplication is performed by the operations of nsimplify().simplify().expand().together().\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{1256637061435920 s}{10000000000000 s^{2} + 628318530717961 s + 39478417604357500}\\)\n\n\n\n22.10.0.1 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values units in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 1\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 2\n-5.00+8.66j Hz\n-5.00-8.66j Hz\n\n\nThe SciPy function bode to plot the magnitude and phase of the filter.\n\nx = np.logspace(-2, 4, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SciPy functions impulse and step to plot the impulse and step response of the system.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nStep response as a check of the network equations\n\nnet_list = '''\nO1 5 4 2\nO2 5 6 3\nR1 4 1 1\nR2 4 3 1\nR3 5 2 1\nR5 6 2 1\nR4 6 0 1\nC2 5 3 1\nC1 0 4 1\nV1 1 0 1\n'''\n\nGenerate the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nGenerate markdown text to display the network equations.\n\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{O1} + v_{2} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{5}}{R_{3}} = 0\\)\\(- C_{2} s v_{5} + I_{O2} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{4}}{R_{2}} = 0\\)\\(v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}} = 0\\)\\(- C_{2} s v_{3} + v_{5} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{4} + v_{5} = 0\\)\\(v_{5} - v_{6} = 0\\)\n\n\nget the element values from thge netlist.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  O_{1} : \\text{NaN}, \\  O_{2} : \\text{NaN}, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{4} : 1.0, \\  R_{5} : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nThe symbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  v_{2}, \\  I_{O1}, \\  C_{1}, \\  v_{5}, \\  v_{4}, \\  R_{1}, \\  v_{3}, \\  v_{6}, \\  V_{1}, \\  v_{1}, \\  R_{2}, \\  s, \\  C_{2}, \\  I_{O2}, \\  R_{5}, \\  R_{4}, \\  R_{3}\\right)\\)\n\n\nThe following cells analyize the circuit with a voltage ramp as the input. The Laplace transform of a ramp is \\(\\frac {a}{s^2}\\), where a is the slope of the ramp.\n\n#element_values[V1] = 1/(s**2)   # ramp of 1 volt per 1 s\n#element_values[V1] = 1/(s)   # step function\nNE = NE_sym.subs({V1:1/(s), R1:R1n, R2:Rn, R3:Rn, R5:Rp, R4:Rp, C2:Cn, C1:Cn})\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + 6.28318530717959 \\cdot 10^{-6} v_{1} - 6.28318530717959 \\cdot 10^{-6} v_{4}\\\\I_{O1} + 0.00010628318530718 v_{2} - 6.28318530717959 \\cdot 10^{-6} v_{5} - 0.0001 v_{6}\\\\I_{O2} - 1.0 \\cdot 10^{-7} s v_{5} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 6.28318530717959 \\cdot 10^{-6}\\right) - 6.28318530717959 \\cdot 10^{-6} v_{4}\\\\- 6.28318530717959 \\cdot 10^{-6} v_{1} - 6.28318530717959 \\cdot 10^{-6} v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 1.25663706143592 \\cdot 10^{-5}\\right)\\\\- 1.0 \\cdot 10^{-7} s v_{3} - 6.28318530717959 \\cdot 10^{-6} v_{2} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-7} s + 6.28318530717959 \\cdot 10^{-6}\\right)\\\\- 0.0001 v_{2} + 0.0002 v_{6}\\\\v_{1}\\\\- v_{4} + v_{5}\\\\v_{5} - v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{1.25663706143592 \\cdot 10^{28}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{3} = \\frac{6.28318530717959 \\cdot 10^{27} s - 3.94784176043575 \\cdot 10^{29}}{1.0 \\cdot 10^{26} s^{3} + 6.28318530717961 \\cdot 10^{27} s^{2} + 3.94784176043575 \\cdot 10^{29} s}\\)\\(v_{4} = \\frac{6.28318530717959 \\cdot 10^{27}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{5} = \\frac{6.28318530717959 \\cdot 10^{27}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(v_{6} = \\frac{6.28318530717959 \\cdot 10^{27}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\\(I_{V1} = \\frac{- 6.28318530717959 \\cdot 10^{40} s^{2} - 1.25663706143592 \\cdot 10^{28} s - 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{3} + 6.28318530717961 \\cdot 10^{47} s^{2} + 3.94784176043575 \\cdot 10^{49} s}\\)\\(I_{O1} = - \\frac{6.67796948322322 \\cdot 10^{30}}{1.0 \\cdot 10^{33} s^{2} + 6.28318530717961 \\cdot 10^{34} s + 3.94784176043575 \\cdot 10^{36}}\\)\\(I_{O2} = \\frac{3.94784176043575 \\cdot 10^{42} s + 2.48050213442399 \\cdot 10^{44}}{1.0 \\cdot 10^{46} s^{3} + 6.28318530717961 \\cdot 10^{47} s^{2} + 3.94784176043575 \\cdot 10^{49} s}\\)\n\n\nDeclare the variable t for time.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe voltage at node 1 is a ramp and the inverse Laplace transform of the ramp is calculated below.\n\nV1_volts = inverse_laplace_transform(U[v1], s, t)\nV1_volts\n\n\\(\\displaystyle 1\\)\n\n\nThe voltage at node 2 is:\n\nnode_v2_s = U[v2] #.nsimplify().simplify().expand().together()\nnode_v2_s\n\n\\(\\displaystyle \\frac{1.25663706143592 \\cdot 10^{28}}{1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node_v2 = inverse_laplace_transform(node_v2_s, s, t)\n#node_v2\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\n\nn, d = fraction(node_v2_s)\nn = n.expand()\nd = d.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(1.25663706143592 \\cdot 10^{28}\\)denominator: \\(1.0 \\cdot 10^{26} s^{2} + 6.28318530717961 \\cdot 10^{27} s + 3.94784176043575 \\cdot 10^{29}\\)\n\n\nUse the SciPy residue function to do the inverse Laplace transform.\n\ncn = Poly(n, s).all_coeffs()\ncd = Poly(d, s).all_coeffs()\nr, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n# build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\nz = 0\nfor i in range(len(r)):\n    m = (r[i]/(s-p[i]))\n    z += inverse_laplace_transform(m, s, t)\n\nEach of the terms came be converted to a function using SymPy’s lambdify function. Define the values for the x-axis of the plot and put each one into an array for plotting.\n\n# the x-axis is time and voltages are plotted from 0 to 0.001 seconds over 200 points \nx = np.linspace(0, 0.2, 200, endpoint=True)\n\n# the voltage at note 2 is evaluated at each point in the array x\nV_node2 = lambdify(t, z)(x)\n\n# the voltage at note 1 is evaluated at each point in the array x\nV_node1 = lambdify(t, V1_volts)(x)\n\nPlot the final combined result.\n\nplt.title('Filter output voltage vs time')\n\nplt.plot(x*1e3, np.real(V_node2),label='v2(t)')\n#plt.plot(x, np.real(V_node1),label='v1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, msec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nAntoniou, Andreas. 1969. “Realization of Gyrators Using Operational Amplifiers and Their Use in RC-Active-Network Synthesis.” In. https://api.semanticscholar.org/CorpusID:64381922.\n\n\nBruton, L. 1978. “Multiple-Amplifier RC-Active Filter Design with Emphasis on GIC Realizations (Invited Paper).” IEEE Transactions on Circuits and Systems.\n\n\nFranco, Sergio. 2002. Design with Operational Amplifiers and Analog Integrated Circuits, 3rd Edition. McGraw-Hill.\n\n\nSedra, A., and J. Espinoza. 1975. “Sensitivity and Frequency Limitations of Biquadratic Active Filters.” IEEE Transactions on Circuits and Systems.\n\n\nStout, D. 1976. Handbook of Operational Amplifier Circuit Design. McGraw-Hill.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design Handbook, Third Edition. McGraw-Hill Education.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Op Amp Circuits</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html",
    "href": "Two amplifier RIAA Phono Preamp.html",
    "title": "23  Two Amplifier RIAA Phono Preamp",
    "section": "",
    "text": "Abstract\nThis paper analyzes the circuit for the RIAA preamp given in the Texas Instruments application note AN346, High-Performance Audio Applications of the LM833, shown in the app note as Figure 3. The schematic for the phono preamplifier was entered into LTSpice and the circuit netlist was generated. A circuit analysis method called the Modified Nodal Analysis was used to derive the symbolic circuit equations and Python libraries were used to solve the equations. The preamplifier transfer function was used to calculate the Bode, impulse and step response plots. The Python results were compared to those from LTSpice. Deviation from the RIAA response curve was also examined. The sensitivity, Monte Carlo and worst case analysis for the preamplifier circuit was performed. The JupyterLab notebook showcases the use of Python in electrical engineering and circuit analysis.\nContents\n1. Introduction\n2. RIAA pre-emphasis curve\n3. AN346 RIAA Phono Preamplifier Design Procedure\n4. Analysis of the phono preamplifier circuit\n5. Summary",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Two Amplifier RIAA Phono Preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#introduction",
    "href": "Two amplifier RIAA Phono Preamp.html#introduction",
    "title": "23  Two Amplifier RIAA Phono Preamp",
    "section": "23.1 Introduction",
    "text": "23.1 Introduction\nThis JupyterLab notebook uses the SymPy, NumPy,SciPy and the Python programming language libraries to analyze a phono preamplifier circuit from the Texas Instruments application note, AN346, High-Performance Audio Applications of the LM833. The purpose of this analysis is to demonstrate the capability of using the Python libraries in electrical engineering circuit analysis. The circuit chosen for this analysis is a two stage RIAA Phono Preamplifier described in the application note. The preamplifier is designed to accurately reproduce the RIAA equalization curve required for playback of Vinyl LP records. The preamplifier provides about 35 dB of gain at 1kHz along with the proper gain profile and phase response. The schematic of the circuit is shown below with each node explicitly annotated.\n\n\n\nSchematic\n\n\nThere has been a resurgence in the popularity of Vinyl LP records over the last few years. So the use of a RIAA Phono Preamplifier is still relevant in this age where most music is delivered by streaming. Two internet news stories describe the current market for Vinyl LP records:\nThey Said the Album Was Dying. They Were Wrong\n\nVinyl sales have grown steadily for 17 years, but jumped by a stunning 46% in 2020 and 51% in 2021 …\n\nWhy Vinyl Records Are Making a Comeback in 2022\n\nThis year, 2020, marks the first year in more than a generation since record sales — that is to say physical vinyl records — have surpassed CD sales. The reasons for this are twofold: CD sales have dropped dramatically in recent years, while sales of vinyl records are actually up this year. And while you might think it’s nostalgic Boomers or Gen Xers behind the renaissance of records, in fact surveys show it’s millennial consumers driving the rising trend in vinyl sales.\n\n\nSo vinyl is here to stay, it seems, despite all technological advances that would have seemed to threaten it. The same RIAA study that found records surpassing CDs also revealed that streaming music now account for more than 85% of all music enjoyed. Only 6% of music is now downloaded, even less than is physically purchased in the form of records, CDs, or the last tapes.\n\nToday there are hundreds of phono products sold on Amazon. Phono preamps range in price from $10 to $1,000 dollars.\nThe Phono Preamplifier also known as a phono stage, is an audio component that amplifies the signal from your turntable to a level that allows you to connect it to your sound system the same way you would with any other audio source. In addition to boosting the signal from the phono cartridge, the preamp applies the RIAA equalization curve to the signal, reverting it back to the shape it was on the original recording. Phono cartridge output varies depending on the type of phono cartridge. Moving Magnet (MM) or Moving Iron (MI) cartridges typically produce a maximum output of 5mV. Moving Coil (MC) cartridges produce a much lower output, typically around 0.5mV maximum. Most phono preamps have switches that allow users to select the type of coil they have installed on their turntable arm.\nTexas Instruments provided the schematic of the preamplifier in their application note to highlight the types of applications their LM833 operational amplifier can support. Application notes are sometimes part of the marketing literature provided along with component data sheets by semiconductor manufacturers.\nRIAA equalization is a specification for the recording and playback of phonograph records, established by the Recording Industry Association of America (RIAA). RIAA was formed in 1952. Its original mission was to administer recording copyright fees and problems, work with trade unions, and do research relating to the record industry and government regulations. Early RIAA standards included the RIAA equalization curve, the format of the stereophonic record groove and the dimensions of 33 1/3, 45, and 78 rpm records.\nThe purposes of the equalization are to permit greater recording times (by decreasing the mean width of each groove), to improve sound quality and to reduce the groove damage that would otherwise arise during playback. RIAA equalization is a form of pre-emphasis on recording and de-emphasis on playback. A recording is made with the low frequencies reduced and the high frequencies boosted, and on playback, the opposite occurs. The net result is a flat frequency response, but with attenuation of high-frequency noise such as hiss and clicks that arise from the recording medium. Reducing the low frequencies also limits the excursions the cutter needs to make when cutting a groove. Groove width is thus reduced, allowing more grooves to fit into a given surface area, permitting longer recording times. This also reduces physical stresses on the stylus, which might otherwise cause distortion or groove damage during playback.\n\n23.1.1 Scope\nThe analysis presented in this notebook is intended to illustrate the use of Python for circuit analysis. This is not a tutorial on how to design a better phono preamp. The circuit taken from the Texas Instruments application note is examined for what it is, which is a suggested application for the use of their audio grade op amp. However, in this analysis I don’t address the performance of the op amp relative to the implementation of the RIAA equalization curve. I’m more concerned with examining the circuit’s ability to reproduce the proper gain and phase over the audio band. The performance LM833 op amp is assumed to be sufficient for this application and in my analysis of the circuit, I’ve replaced the LM833 with an ideal op amp model. Also, it is assumed that the reader is familiar with electronic components such as resistors, capacitors and operational amplifiers also known as op amps or opamps.\n\n\n23.1.2 Methodology\nThe analysis presented in this notebook will cover topics that are often presented during a design review. Usually during a design review conformance to requirements is presented. For the phono preamp circuit, the main performance requirement is minimum deviation from the RIAA curve. The application note from TI stated that the deviation is less than 0.1 dB over the audio band when using 1% resistors.\nIn this notebook the analysis is divided into sections.\n\nThe analysis will start with a description of the circuit operation and some basic calculations.\nThere are many symbols used in the equations and these are listed in a table for reference. I also tried to be constant with variable names.\nThe RIAA pre-emphasis curve is discussed and the transfer function, pole/zero plot and amplitude and phase response is plotted.\nCalculations for the phono preamplifier design procedure as covered in the application note are presented. The element values obtained with this procedure are the ones used in the analysis.\nThe equations for the transfer function of the preamp are derived by using a technique known as modified nodal analysis.\nThe preamp poles and zeros are plotted and some comments about stability are provided.\nThe amplitude and phase response of the preamp transfer function is plotted.\nThe impulse, step and group delay are plotted\nThe amplitude and phase response of the preamp transfer function is plotted against results taken from LTSpice as a check and comparison.\nThe deviation of the amplitude and phase response from the RIAA curve is plotted.\nSensitivity analysis, component selection, Monte Carlo analysis and worst case analysis are presented.\n\n\nimport os\nimport sys\nimport random\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\n\n\nDefine a function to return the system gain at a frequency: get_gain()\n\ndef get_gain(freq_Hz, sys):\n    '''\n    freq_Hz: the frequency in Hz for which the system gain is desired\n    sys: a SciPy instance of the LTI class or a tuple describing the system\n    '''\n    f1 = freq_Hz - freq_Hz*0.1 # lower limit of the frequency range\n    f1a = freq_Hz - freq_Hz*0.01 # lower interpolation point\n    f2 = freq_Hz + freq_Hz*0.1 # upper limit of the frequency range\n    f2a = freq_Hz + freq_Hz*0.01  # upper interpolation point\n\n    x_axis_range = np.linspace(f1*2*np.pi, f2*2*np.pi, 1000, endpoint=True) # define the range frequency range\n    w, mag, phase = sys.bode(w=x_axis_range)\n\n    index_for_f1a = np.where(w &gt; f1a*2*np.pi)[0][0]\n    index_for_f2a = np.where(w &gt; f2a*2*np.pi)[0][0]\n\n    return np.interp(freq_Hz, [w[index_for_f1a]/(2*np.pi),w[index_for_f2a]/(2*np.pi)], [mag[index_for_f1a],mag[index_for_f2a]])\n\n\n\n23.1.3 Schematic and circuit description\nThe circuit from Figure 3 of AN346 was entered into LTSpice and the circuit nodes were numbered as shown above. Any schematic capture program could be used for this as long as a SPICE netlist can be generated. In the schematic, the voltage source V1, is set to 5 mV to represent the output of a Moving Magnet (MM) or Moving Iron (MI) cartridge. The input to the preamp is shunted by a capacitance, which is equal to the sum of the input cable capacitance and the cartridge. This capacitance resonates with the inductance of the moving magnet cartridge to determine the frequency response of the transducer, so when a moving magnet pickup is used, Cp should be carefully chosen so that the total capacitance is equal to the recommended load capacitance for that particular cartridge. 100 pF is used in this analysis. Rp is the recommended resistive load for the phono cartridge. In some commercial preamp designs, the value of Rp is user selectable with switches. As shown in the calculations, Cp and Rp have a resonant frequency of 33.86kHz.\n\nCp = 100e-12\nRp = 47e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Rp*Cp)))\n\nresonant frequency: 33,862.8 Hz\n\n\n33,862 Hz is well above the audio range.\nThe first operational amplifier, U1, takes care of the 50 Hz and 500 Hz breakpoints. For the analysis with Python, the Op Amp is modeled as an ideal Op Amp. There is expected to be some differences between the LTSpice results and the Python analysis. Using two amplifiers results in accurate conformance to the RIAA curve without reverting to the noisy inverting topology, as well as lower distortion due to the fact that each amplifier is operating at a lower gain than would be the case in a single-amplifier design.\nThe resistor, R1, which has a value of 80.6k\\(\\Omega\\) and the capacitor C1, which has a value of 0.039 \\(\\mu\\)Farads, form a resonant pair with frequency of 50.6 Hz.\n\nR1 = 80.6e3\nC1 = 0.039e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R1*C1)))\n\nresonant frequency: 50.6 Hz\n\n\n50 Hz is one of the RIAA time constants required by the RIAA specification.\nFrom here on, I’ll refer to resistors that have values in 1000’s of Ohms by using k for thousands of Ohms or just the numerical value if it’s less than 1000. Capacitors will have values indicated in \\(\\mu\\) for micro Farads and p for pico Farads, designated as \\(\\mu\\) or p. \n\nR2 = 8.45e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R2*C1)))\n\nresonant frequency: 482.9 Hz\n\n\nC1 and R2 have a resonant frequency of 482.94 Hz. As described later, these frequencies correspond to the time constants required by the RIAA specification.\nCo provides an AC ground for the non-inverting configuration of U1. Ro along with R1 and R2 set the low frequency gain of U1.\n\nRo = 499\nCo = 200e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Ro*Co)))\n\nresonant frequency: 1.6 Hz\n\n\nRo=499 and Co=200\\(\\mu\\) have a resonant frequency of 1.6 Hz.\n\nRf=R1+R2\nprint('low frequency voltage gain of U1: {:,.2f} or {:,.1f}dB'.format(1+Rf/Ro, 20*np.log10(1+Rf/Ro)))\n\nlow frequency voltage gain of U1: 179.46 or 45.1dB\n\n\nRo along with R1 and R2 set the low frequency gain of U1 at 45 dB.\n\nR3 = 2.37e3\nC3 = 0.033e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R3*C3)))\n\nresonant frequency: 2,035.0 Hz\n\n\nR3=2.37k and C3=0.033\\(\\mu\\) have a resonant frequency of 2034.96 Hz and corresponds to the the third time constant specified by RIAA.\nC4=2\\(\\mu\\) and R6=54.9k form a high pass filter with a corner frequency of 1.45Hz.\n\nR6 = 54.9e3\nC4 = 2e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R6*C4)))\n\nresonant frequency: 1.4 Hz\n\n\nU2, R4 and R5 form a non-inverting configuration with a voltage gain of 3.15 or 9.98 dB.\n\nR4 = 2e3\nR5 = 4.3e3\nprint('voltage gain of U2: {:,.2f} or {:,.1f}dB'.format(1+R5/R4, 20*np.log10(1+R5/R4)))\n\nvoltage gain of U2: 3.15 or 10.0dB\n\n\n\n\n23.1.4 Symbols\nIn addition to the variables listed in Table G.2, Table 23.1 lists the variable names used in this notebook.\n\n\n\nTable 23.1: Variable names used in this notebook\n\n\n\n\n\n\n\n\n\nVariable name\ndefinition\n\n\n\n\ns\nwhen used in a polynomial: the Laplace variable equal to \\(j\\omega\\), where \\(j=\\sqrt{-1}\\)\n\n\n\\(\\mu\\)\n\\(1 \\times 10^{-6}\\) multiplier, either: \\(1 \\times 10^{-6}\\) seconds or \\(1 \\times 10^{-6}\\) Farads\n\n\nT\ntime constant: T1, T2, T3\n\n\n\\(\\omega\\)\nangular frequency, radians per second, \\(\\omega = 1/T\\)\n\n\nRIAA_num\nnumerator of the RIAA pre-emphasis transfer function\n\n\nRIAA_den\ndenominator of the RIAA pre-emphasis transfer function\n\n\nw_RIAA\nradian frequency of the RIAA pre-emphasis transfer function\n\n\nmag_RIAA\nmagnitude of the RIAA pre-emphasis transfer function\n\n\nphase_RIAA\nphase of the RIAA pre-emphasis transfer function\n\n\nRIAA_gain_1kHz\ngain of the RIAA pre-emphasis transfer function at 1kHz\n\n\npreamp_equ_sym\npreamp circuit equations with symbolic values\n\n\nU_sym\nsymbolic solution to network equations, node voltages and unknown currents\n\n\nH_sym\ntransfer function with symbolic coefficients\n\n\npreamp_equ\ncircuit equations with numeric element values\n\n\nH_preamp_num\nnumerator of the transfer function\n\n\nH_preamp_denom\ndenominator of the transfer function\n\n\npreamp_sys\nSciPy representation of the preamp system\n\n\npreamp_gain_1kHz\ngain of the preamp transfer function at 1kHz\n\n\nw_preamp\nradian frequency of the preamp transfer function\n\n\nmag_preamp\nmagnitude of the preamp transfer function\n\n\nphase_preamp\nphase of the preamp transfer function",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Two Amplifier RIAA Phono Preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "href": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "title": "23  Two Amplifier RIAA Phono Preamp",
    "section": "23.2 RIAA pre-emphasis curve",
    "text": "23.2 RIAA pre-emphasis curve\nThe RIAA equalization curve was established in 1954. The equalization is defined by time constants, T1, T2 and T3. During the Phonograph record manufacturing process, a pre-emphasis is applied to the signal, which allows for longer playback times on phonograph records by decreasing the average width of the groove cut into vinyl phonograph disks. The curve attenuates low frequencies and amplifies high frequencies, relative to 1 kHz. Since low frequencies cause wide undulations in the record groove, they must be attenuated to keep the grove within its bounds. Above 1 kHz, the frequencies are amplified which helps overcome the inherent noise produced by the phonograph needle during play-back.\nThe RIAA disc recording/reproduction standard specifies the time constants of, \\(T1 = 75 \\mu s\\), \\(T2 = 318 \\mu s\\) and \\(T3 = 3180 \\mu s\\) and the pre-emphasis transfer function:\n\\(RIAA(s)=\\frac {(sT_{1}+1)(sT_{3}+1)}{(sT_{2}+1)}\\)\nThe three time constants correspond to the frequencies calculated below.\n\nT1 = 75e-6\nT2 = 318e-6\nT3 = 3180e-6\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T1*1e6,1/(T1*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T2*1e6,1/(T2*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T3*1e6,1/(T3*2*np.pi)))\n\n75 μs corresponds to 2,122.1 Hz\n318 μs corresponds to 500.5 Hz\n3180 μs corresponds to 50.0 Hz\n\n\nThe time constants are put in polynomial form using s as the Laplace variable. The numerator and denominator of the pre-emphasis transfer function is defined below.\n\ns = symbols('s')\nRIAA_num = Eq(((s*T3+1)*(s*T1+1)),0)\nRIAA_denom = Eq(s*T2+1,0)\n\nSolve for the poles and zeros of the pre-emphasis transfer function and plot the locations on the complex s-plane. The zeros of the transfer function are the roots of the numerator polynomial. The poles of the transfer function are the roots of the denominator polynomial.\n\nRIAA_zeros = solve(RIAA_num,s)\nRIAA_poles = solve(RIAA_denom,s)\n\n\nplt.plot(np.real(RIAA_zeros), np.imag(RIAA_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(RIAA_poles), np.imag(RIAA_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(RIAA_zeros)))\nfor i in RIAA_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n-2,122.07 Hz\n-50.05 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(RIAA_poles)))\nfor i in RIAA_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-500.49 Hz\n\n\nAs shown in the plot above, the poles and zeros lay on the negative real axis. The de-emphasis transfer function of the phono pre-amplifier should have poles at the zero locations and a zero in the pole location in the plot above.\nThe code below is used to convert SymPy symbolic equations to a NumPy polynomial representation. The SciPy function, TransferFunction, represents the system as the continuous-time transfer function. The NumPy function, logspace, is used to generate data points on a log scale for plotting. The SciPy function, bode, is used to generate the magnitude and phase data of a continuous-time system.\n\na = np.array(Poly(RIAA_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(RIAA_denom, s).all_coeffs(), dtype=float)\nRIAA_sys = signal.TransferFunction(a,b)\n\nx_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\nw_RIAA, mag_RIAA, phase_RIAA = RIAA_sys.bode(w=x_axis_range) # returns: rad/s, mag in dB, phase in deg\n\nFind the gain at 1kHz so the plots can be normalized for 0 dB at 1 kHz.\n\nRIAA_gain_1kHz = get_gain(1000,RIAA_sys)\n\n\nprint('The RIAA gain at 1kHz: {:.3f} dB'.format(RIAA_gain_1kHz))\n\nThe RIAA gain at 1kHz: 19.911 dB\n\n\nPlot the magnitude and phase of the RIAA curve.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_RIAA/(2*np.pi), mag_RIAA-RIAA_gain_1kHz,'-k')    # Bode magnitude plot, normalized to 0 at 1kHz\n\n# mark individual points\np3 = np.where(w_RIAA &gt; 49.9*(2*np.pi))[0][0]\np2 = np.where(w_RIAA &gt; 499.9*(2*np.pi))[0][0]\np1 = np.where(w_RIAA &gt; 2122*(2*np.pi))[0][0]\n\nplt.semilogx(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-RIAA_gain_1kHz,'^k')\n\nplt.text(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-25,'T1')\nplt.text(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-25,'T2')\nplt.text(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-25,'T3')\n\n# highlight the audio band, 20 to 20kHz\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w_RIAA/(2*np.pi), phase_RIAA,':',color='b',label='phase')  # Bode phase plot\n\n# mark individual points\nplt.semilogx(w_RIAA[p1]/(2*np.pi), phase_RIAA[p1],'xb')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), phase_RIAA[p2],'xb')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), phase_RIAA[p3],'xb')\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\nax2.set_ylim((0,100))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('RIAA pre-emphasis magnitude and frequency plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the frequency response of the RIAA curve. The frequencies corresponding to the time constants T1, T2 and T3 are plotted on the magnitude and phase curves. The audio band of 20Hz to 20kHz is highlighted. One thing to notice about this curve is that the amplitude is increasing as the frequency increases. This is not a realistic function, real circuits do not have an infinite gain as the frequency goes to infinity. Also, there is no zero at \\(j\\omega=0\\), so the pre-emphasis transfer function does not block DC.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Two Amplifier RIAA Phono Preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "href": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "title": "23  Two Amplifier RIAA Phono Preamp",
    "section": "23.3 Phono Preamplifier Design Procedure",
    "text": "23.3 Phono Preamplifier Design Procedure\nThe following notebook cells walk through the design procedure given in the application note, starting on page 5.\nA design procedure is shown below with an illustrative example using 1% tolerance E96 components for close conformance to the ideal RIAA curve. Since 1% tolerance capacitors are often difficult to find except in 5% or 10% standard values, the design procedure calls for re-calculation of a few component values so that standard capacitor values can be used.\n\nChoose \\(R_o\\). \\(R_o\\) should be small for minimum noise contribution, but not so small that the feedback network excessively loads the amplifier. Example: Choose \\(R_o = 500\\)\nChoose 1 kHz gain, A1 of the first amplifier. This will typically be around 20 dB to 30 dB. Example: Choose A1 = 26 dB = 20\nCalculate \\(R_11 = 8.058 \\times R_o \\times A_1\\)\n\n\nA1 = 20\nRo = 500\nR1 = 8.058 * Ro * A1\nprint('R1={:,.0f}'.format(R1))\n\nR1=80,580\n\n\n\nCalculate C1\n\n\\(C_1 = \\frac {3.18 \\times 10^{-3}}{R_1}\\)\n\nC1 = 3.18e-3/R1\nprint('C1={:.4e}'.format(C1))\n\nC1=3.9464e-08\n\n\nThe calculated value for capacitor C1 is not a standard value, so step 5 takes care of this.\n\nIf C1 is not a convenient value, choose the nearest convenient value and calculate a new R1 from:\n\n\\(R_1 = \\frac {3.18 \\times 10^{-3}}{3.9 \\times 10^{-8}}\\)\nChoose C1 to be 0.039\\(\\mu\\), which is a standard capacitor value.\n\nC1 = 0.039e-6\nR1 = 3.18e-3/C1\nprint('R1={:,.0f}'.format(R1))\n\nR1=81,538\n\n\nNow choose a standard resistor value close to the calculated value, which is 80.6k.\nE96 resistor values are a set of preferred values for 1% resistors. When doing the calculations to determine the resistor values, the closest standard value is chosen from the E96 series. The E series of preferred numbers derived for use in electronic components. It consists of the E3, E6, E12, E24, E48, E96 and E192 series, where the number after the ‘E’ designates the quantity of logarithmic value “steps” per decade.\n\nR1 = 80.6e3\n\nCalculate a new value for Ro.\n\\(R_o=\\frac {R_1}{8.058A_1}\\)\n\nRo = R1/(8.058*A1)\nprint('R1={:,.0f}'.format(Ro))\n\nR1=500\n\n\nChoose a standard value close to this value, which is 499.\n\nRo = 499\n\n\nCalculate R2\n\\(R_2=\\frac {R_1}{9} - R_o\\)\n\n\nR2 = R1/9-Ro\nprint('R1={:,.0f}'.format(R2))\n\nR1=8,457\n\n\nChoose a standard value close to this value, which is 8.45k.\n\nR2 = 8.45e3\n\n\nChoose a convenient value for C3 in the range from 0.01 \\(\\mu\\)F to 0.05 \\(\\mu\\)F.\nExample: C3 = 0.033 \\(\\mu\\)F\n\n\nC3 = 0.033e-6\nprint('C3={:,.3f}\\u03BC'.format(C3*1e6))\n\nC3=0.033μ\n\n\n\nCalculate Rp\n\\(R_p=\\frac {75 \\mu s }{C_3}\\)\n\n\\(75 \\mu s\\) is one of the RIAA time constants.\n\nRp = 75e-6/C3\nprint('Rp={:,.0f}'.format(Rp))\n\nRp=2,273\n\n\n\nChoose a standard value for R3 that is slightly larger than Rp.\nExample: R3 = 2.37k, which is a standard resistor value.\n\n\nR3 = 2.37e3\n\n\nCalculate R6 from \\(1/R_6 = 1/R_P − 1/R_3\\)\n\n\nR6 = 1/(1/Rp-1/R3)\nprint('R6={:,.0f}'.format(R6))\n\nR6=55,374\n\n\n54.9k is the closest standard value.\n\nR6 = 54.9e3\n\n\nCalculate \\(C_4\\) for low-frequency roll off below 1 Hz from design Equation 5.\n\n\\(C_4=\\frac{1}{2\\pi f_L(R_3+R_6)}\\)\nWhere \\(f_L\\) is the low frequency -3dB corner of the second stage.\nIn the application note, there is a comment on page 4:\n&gt; If the preamplifier is to follow the IEC recommendation (IEC Publication 98, Amendment #4), fL should equal 20.2 Hz.\nThe calculations in the app note use 1 Hz.\n\nf_L = 1.0 # Hz\nC4 = 1/(2*np.pi*f_L*(R3+R6))\nprint('C4={:,.3f}\\u03BC'.format(C4*1e6))\n\nC4=2.779μ\n\n\n2\\(\\mu\\)F is a standard value close to the calculated value.\nExample: C4 = 2 \\(\\mu\\)F.\n\nChoose the gain of the second amplifier.\nExample: The 1 kHz gain up to the input of the second amplifier is about 26 dB for this example. For an overall 1 kHz gain equal to about 36 dB we choose:\n\\(A_2 = 10 dB = 3.16\\)\nChoose value for R4.\nExample: R4 = 2k\n\n\nR4 = 2e3\n\n\nCalculate \\(R_5 = (A_2 − 1) R_4\\)\n\n\nA2 = 3.16\nR5 = (A2-1)*R4\nprint('R5={:,.0f}'.format(R5))\n\nR5=4,320\n\n\n4.3k is a standard value close to the calculated value.\n\nR5 = 4.3e3\n\n\nCalculate Co for low-frequency roll off below 1 Hz from design Equation 7.\n\n\\(C_o=\\frac {1}{2\\pi f_o R_o}\\)\nwhere fo is the low-frequency −3 dB corner of the first amplifier. fo is chosen to be 1Hz for the calculations since this frequency is well below the audible frequency range.\n\nfo = 1 # 1 Hz\nCo = 1/(2*np.pi*fo*Ro)\nprint('Co={:,.3f}\\u03BC'.format(Co*1e6))\n\nCo=318.948μ\n\n\nThe value chosen in the app note for this component is 200\\(\\mu\\)F.\n\nCo = 200e-6\n\n\nprint('resonant frequency of Ro and Co: {:.2f}Hz'.format(1/(Co*Ro*2*np.pi)))\n\nresonant frequency of Ro and Co: 1.59Hz",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Two Amplifier RIAA Phono Preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "href": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "title": "23  Two Amplifier RIAA Phono Preamp",
    "section": "23.4 Analysis of AN-346 phono preamplifier circuit",
    "text": "23.4 Analysis of AN-346 phono preamplifier circuit\nThe schematic of the preamp was entered into LTSpice and the netlist was generated. Starting with a schematic and then using LTSpice to generate the net list eliminates errors that would occur if these circuits were analyzed by hand. For small circuits with a handful of components, symbolic solutions of the node equations can be of interest, but for larger circuits, not so much. This is because the number of symbols and equations is too large to offer in insight without some simplification.\nIn this section the modified nodal analysis method will be used to generate the circuit equations. The modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. The Python code that generates the circuit’s equations is located here.\n\n23.4.1 Modified nodal analysis\nThe preamp circuit has 15 branches, 9 nodes, 3 unknown currents, 14 passive components and 2 op amps. The net list generated by LTSpice and some edits were made to put the component values into scientific notation with units of Ohms, Farads and Henerys and the Op Amp statements were fixed. The edited netlist is:\nV1 1 0 5e-3\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\n\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\n\nnet_list = '''\nV1 1 0 5e-3\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the SMNA function. The A, X and Z are formulated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(Cp s + \\frac{1}{Rp}\\right)\\)\\(0 = I_{O2} + \\frac{v_{2}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\)\\(0 = v_{3} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Ro}\\)\\(0 = v_{4} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{3}}{Ro}\\)\\(0 = v_{3} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{5} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{6}}{R_{2}}\\)\\(0 = I_{O1} + v_{6} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{7}}{R_{3}} - \\frac{v_{5}}{R_{2}}\\)\\(0 = - C_{4} s v_{8} + v_{7} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{3}}\\)\\(0 = - C_{4} s v_{7} + v_{8} \\left(C_{4} s + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}}\\)\\(V_{1} = v_{1}\\)\\(0 = - v_{1} + v_{3}\\)\\(0 = - v_{8} + v_{9}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{5}, \\  R_{4}, \\  v_{6}, \\  v_{7}, \\  v_{2}, \\  Ro, \\  I_{V1}, \\  I_{O1}, \\  C_{4}, \\  v_{8}, \\  v_{4}, \\  v_{1}, \\  Rp, \\  s, \\  I_{O2}, \\  Cp, \\  v_{9}, \\  C_{3}, \\  R_{5}, \\  C_{1}, \\  R_{2}, \\  R_{6}, \\  R_{3}, \\  v_{3}, \\  R_{1}, \\  V_{1}, \\  Co\\right)\\)\n\n\nThese equations can be solved in their symbolic form using the solve function from SymPy. The solution time takes about 3 seconds on my i3 laptop.\n\nU_preamp_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution to the newtork equations.\n\ntemp = ''\nfor i in U_preamp_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_preamp_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{V_{1}}{Co Ro s + 1}\\)\\(v_{5} = \\frac{C_{1} Co R_{1} Ro V_{1} s^{2} + C_{1} R_{1} V_{1} s + Co R_{1} V_{1} s + Co Ro V_{1} s + V_{1}}{C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co Ro s + 1}\\)\\(v_{6} = \\frac{C_{1} Co R_{1} R_{2} V_{1} s^{2} + C_{1} Co R_{1} Ro V_{1} s^{2} + C_{1} R_{1} V_{1} s + Co R_{1} V_{1} s + Co R_{2} V_{1} s + Co Ro V_{1} s + V_{1}}{C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co Ro s + 1}\\)\\(v_{7} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} + C_{1} Co R_{1} R_{2} V_{1} s^{2} + C_{1} Co R_{1} Ro V_{1} s^{2} + C_{1} R_{1} V_{1} s + C_{4} Co R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{6} V_{1} s^{2} + C_{4} Co R_{6} Ro V_{1} s^{2} + C_{4} R_{6} V_{1} s + Co R_{1} V_{1} s + Co R_{2} V_{1} s + Co Ro V_{1} s + V_{1}}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(v_{8} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{6} V_{1} s^{2} + C_{4} Co R_{6} Ro V_{1} s^{2} + C_{4} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(v_{9} = \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{6} V_{1} s^{2} + C_{4} Co R_{6} Ro V_{1} s^{2} + C_{4} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(I_{V1} = \\frac{- Cp Rp V_{1} s - V_{1}}{Rp}\\)\\(I_{O1} = \\frac{- C_{1} C_{3} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{4} - C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} V_{1} s^{4} - C_{1} C_{3} C_{4} Co R_{1} R_{6} Ro V_{1} s^{4} - C_{1} C_{3} C_{4} R_{1} R_{6} V_{1} s^{3} - C_{1} C_{3} Co R_{1} R_{2} V_{1} s^{3} - C_{1} C_{3} Co R_{1} R_{3} V_{1} s^{3} - C_{1} C_{3} Co R_{1} Ro V_{1} s^{3} - C_{1} C_{3} R_{1} V_{1} s^{2} - C_{1} C_{4} Co R_{1} R_{2} V_{1} s^{3} - C_{1} C_{4} Co R_{1} R_{3} V_{1} s^{3} - C_{1} C_{4} Co R_{1} R_{6} V_{1} s^{3} - C_{1} C_{4} Co R_{1} Ro V_{1} s^{3} - C_{1} C_{4} R_{1} V_{1} s^{2} - C_{1} Co R_{1} V_{1} s^{2} - C_{3} C_{4} Co R_{1} R_{6} V_{1} s^{3} - C_{3} C_{4} Co R_{2} R_{6} V_{1} s^{3} - C_{3} C_{4} Co R_{3} R_{6} V_{1} s^{3} - C_{3} C_{4} Co R_{6} Ro V_{1} s^{3} - C_{3} C_{4} R_{6} V_{1} s^{2} - C_{3} Co R_{1} V_{1} s^{2} - C_{3} Co R_{2} V_{1} s^{2} - C_{3} Co R_{3} V_{1} s^{2} - C_{3} Co Ro V_{1} s^{2} - C_{3} V_{1} s - C_{4} Co R_{1} V_{1} s^{2} - C_{4} Co R_{2} V_{1} s^{2} - C_{4} Co R_{3} V_{1} s^{2} - C_{4} Co R_{6} V_{1} s^{2} - C_{4} Co Ro V_{1} s^{2} - C_{4} V_{1} s - Co V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} s^{2} + C_{1} C_{4} Co R_{1} R_{3} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} s^{2} + C_{1} C_{4} R_{1} R_{6} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + C_{3} C_{4} Co R_{3} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} Co R_{3} Ro s^{2} + C_{3} R_{3} s + C_{4} Co R_{3} Ro s^{2} + C_{4} Co R_{6} Ro s^{2} + C_{4} R_{3} s + C_{4} R_{6} s + Co Ro s + 1}\\)\\(I_{O2} = \\frac{- C_{1} C_{4} Co R_{1} R_{2} R_{6} V_{1} s^{3} - C_{1} C_{4} Co R_{1} R_{6} Ro V_{1} s^{3} - C_{1} C_{4} R_{1} R_{6} V_{1} s^{2} - C_{4} Co R_{1} R_{6} V_{1} s^{2} - C_{4} Co R_{2} R_{6} V_{1} s^{2} - C_{4} Co R_{6} Ro V_{1} s^{2} - C_{4} R_{6} V_{1} s}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}}\\)\n\n\n\nThe transfer function for the preamp is the equation for the output node, 2, divided by the equation for the input node 1.\n\nH_preamp_sym = U_preamp_sym[v2]/U_preamp_sym[v1]\n\nThe symbolic solution obtained by SymPy, while not being very interesting since they are unwieldy, illustrate the power of SymPy to easily obtain symbolic solutions that would be very difficult to obtain by hand.\n\nH_preamp_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{V_{1} \\left(C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}\\right)}\\)\n\n\nThe SymPy function, cancel(), can be used to put the preamp transfer function in to standard canonical form, where the polynomials are expanded with no common factors and the leading coefficients do not have denominators (i.e., are integers).\n\ncancel(H_preamp_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} C_{4} R_{1} R_{5} R_{6} + C_{4} Co R_{1} R_{4} R_{6} + C_{4} Co R_{1} R_{5} R_{6} + C_{4} Co R_{2} R_{4} R_{6} + C_{4} Co R_{2} R_{5} R_{6} + C_{4} Co R_{4} R_{6} Ro + C_{4} Co R_{5} R_{6} Ro\\right) + s \\left(C_{4} R_{4} R_{6} + C_{4} R_{5} R_{6}\\right)}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + R_{4} + s^{3} \\left(C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} Co R_{1} R_{4} Ro + C_{3} C_{4} R_{3} R_{4} R_{6} + C_{3} Co R_{3} R_{4} Ro + C_{4} Co R_{3} R_{4} Ro + C_{4} Co R_{4} R_{6} Ro\\right) + s \\left(C_{1} R_{1} R_{4} + C_{3} R_{3} R_{4} + C_{4} R_{3} R_{4} + C_{4} R_{4} R_{6} + Co R_{4} Ro\\right)}\\)\n\n\nThe Sympy function, factor(), can be used to factor the polynomials into irreducible factors over the rational numbers.\n\nH_preamp_sym.factor()\n\n\\(\\displaystyle \\frac{C_{4} R_{6} s \\left(R_{4} + R_{5}\\right) \\left(C_{1} Co R_{1} R_{2} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co R_{1} s + Co R_{2} s + Co Ro s + 1\\right)}{R_{4} \\left(C_{1} R_{1} s + 1\\right) \\left(Co Ro s + 1\\right) \\left(C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} R_{3} s + C_{4} R_{3} s + C_{4} R_{6} s + 1\\right)}\\)\n\n\nThe symbolic solutions obtained above will be used later when the sensitivity analysis of the preamp is performed. Otherwise the roots in symbolic form don’t seem to be particularly insightful, but are easily obtained by SymPy.\n\n23.4.1.1 Numerical solution\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {V1:5.0000e-03, C1:3.9000e-08, Co:2.0000e-04, Ro:4.9900e+02, R3:2.3700e+03, R1:8.0600e+04, \n    R2:8.4500e+03, Cp:1.0000e-10, Rp:4.7000e+04, C3:3.3000e-08, C4:2.0000e-06, R6:5.4900e+04, R4:2.0000e+03, R5:4.3000e+03}\n\n# put the element values into the equations\npreamp_equ = NE_sym.subs(nominal_component_value)\n\nNow we can display the network equations with values for the components instead of symbols.\n\ntemp = ''\nfor i in range(shape(preamp_equ.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(preamp_equ.rhs[i]),latex(preamp_equ.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-10} s + 2.12765957446809 \\cdot 10^{-5}\\right)\\)\\(0 = I_{O2} + 0.000232558139534884 v_{2} - 0.000232558139534884 v_{9}\\)\\(0 = v_{3} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.00201641496392288\\right) - 0.00200400801603206 v_{4} + v_{5} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right)\\)\\(0 = - 0.00200400801603206 v_{3} + v_{4} \\cdot \\left(0.0002 s + 0.00200400801603206\\right)\\)\\(0 = v_{3} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right) + v_{5} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.000130750143157091\\right) - 0.000118343195266272 v_{6}\\)\\(0 = I_{O1} - 0.000118343195266272 v_{5} + 0.000540284123536314 v_{6} - 0.000421940928270042 v_{7}\\)\\(0 = - 2.0 \\cdot 10^{-6} s v_{8} - 0.000421940928270042 v_{6} + v_{7} \\cdot \\left(2.033 \\cdot 10^{-6} s + 0.000421940928270042\\right)\\)\\(0 = - 2.0 \\cdot 10^{-6} s v_{7} + v_{8} \\cdot \\left(2.0 \\cdot 10^{-6} s + 1.82149362477231 \\cdot 10^{-5}\\right)\\)\\(0 = - 0.000232558139534884 v_{2} + 0.000732558139534884 v_{9}\\)\\(0.005 = v_{1}\\)\\(0 = - v_{1} + v_{3}\\)\\(0 = - v_{8} + v_{9}\\)\n\n\nSolve for voltages and currents.\nUsing the SymPy solve function we can solve the system of equations.\n\nU_preamp = solve(preamp_equ,X)\n\nThe values of the exponents are very large in the solution. The numerator and denominator for v2 could be normalized. Another option for avoiding large exponents is to 1st normalize the component values by frequency scaling. I suppose that large exponents don’t become a problem as long as they remain under two digits.\n\nLetting SciPy do the math and not worrying about the size of the exponents. The transfer function can be obtained by dividing the equation for node 2 by the equation for node 1. The system transfer function, is \\(H(s) = \\frac {v2}{V1}\\)\n\nH_preamp = U_preamp[v2]/U_preamp[v1]\nH_preamp\n\n\\(\\displaystyle \\frac{200.0 \\cdot \\left(2.76499422921242 \\cdot 10^{69} s^{3} + 8.80353368479522 \\cdot 10^{72} s^{2} + 4.91462150480132 \\cdot 10^{71} s\\right)}{7.65600122987477 \\cdot 10^{65} s^{4} + 1.0469819689888 \\cdot 10^{70} s^{3} + 3.44479259637884 \\cdot 10^{72} s^{2} + 6.18286042227129 \\cdot 10^{73} s + 2.84188944100537 \\cdot 10^{74}}\\)\n\n\nfactor() takes a polynomial and factors it into irreducible factors over the rational numbers. For example:\n\nH_preamp.factor()\n\n\\(\\displaystyle \\frac{6.19554973375798 s \\left(0.000314077770155853 s^{2} + 1.0 s + 0.0558255546098434\\right)}{2.69398278462456 \\cdot 10^{-9} s^{4} + 3.68410520790143 \\cdot 10^{-5} s^{3} + 0.012121487017314 s^{2} + 0.21756161 s + 1.0}\\)\n\n\n\n\n23.4.1.2 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into NumPy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_preamp_num, H_preamp_denom = fraction(H_preamp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction(), represents the system as the continuous-time transfer function and takes as inputs the coefficients of the numerator and denominator polynomials.\n\n# convert symbolic to numpy polynomial\na2 = np.array(Poly(H_preamp_num, s).all_coeffs(), dtype=float)\nb2 = np.array(Poly(H_preamp_denom, s).all_coeffs(), dtype=float)\npreamp_sys = signal.TransferFunction(a2,b2)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\npreamp_sys_zeros = np.roots(preamp_sys.num)\npreamp_sys_poles = np.roots(preamp_sys.den)\n\n\n\n\n23.4.2 Pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(preamp_sys_zeros), np.imag(preamp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(preamp_sys_poles), np.imag(preamp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(preamp_sys_zeros)))\nfor i in preamp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-506.73 Hz\n-0.01 Hz\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(preamp_sys_poles)))\nfor i in preamp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-2,122.88 Hz\n-50.63 Hz\n-1.59 Hz\n-1.39 Hz\n\n\nWe can see that the RIAA time constants, displayed in terms of frequency are present, although the values differ by a few Hz. There are two zeros and two poles at nearly zero Hz and these cancel each other.\n\n\n23.4.3 Stability\nBy inspecting the plot above, we can tell the preamplifier is stable since the phase shift at 0 dB of gain is less than 180 degrees. Additionally, all the poles of the transfer function are in the left hand plane.\nNow we can find the preamp gain at 1 kHz, so that the bode plots can be normalized.\n\npreamp_gain_1kHz = get_gain(1000, preamp_sys)\nprint('preamp gain at 1kHz: {:f} dB'.format(preamp_gain_1kHz))\n\npreamp gain at 1kHz: 34.783614 dB\n\n\n\n\n23.4.4 Bode plot, Frequency and phase response\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nextended_x_axis_range = np.logspace(-2, 8, 5000, endpoint=True)*2*np.pi\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=extended_x_axis_range)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b' #'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color=color,label='phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude')\n\nplt.legend(loc=0)\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe magnitude and phase plot for the preamplifier is plotted from 0.01 Hz to 100 MHz. The preamplifier circuit blocks DC because C4 is in series with the audio path.\n\n\n23.4.5 Impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n23.4.6 Group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=x_axis_range)\n\nplt.title('AN-346 phono preamplifier group delay')\nplt.semilogx(w_preamp/(2*np.pi), -np.gradient(phase_preamp*np.pi/180)/np.gradient(w_preamp),'-',label='group delay')\n\n#plt.semilogx(w_c1/(2*np.pi), -np.gradient(phase_c1)/w_c1/1e-3,'-',label='phase delay')\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies below 100 Hz, the group delay is as much as 4 ms in the audio band. According to paper, Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe preamp group delay in the low end of the audio band is of concern and some re-design should be implemented if this preamp was to be implemented. The group delay plotted above agrees with the group delay results obtained from LTSpice simulation of the preamp circuit.\n\n\n\n23.4.7 Preamplifier deviation from RIAA response\nThe plot below shows the deviation of the preamplifier from the RIAA response. The TI app note says conformance to the RIAA curve is within 0.1 dB from 20 Hz to 20 kHz. The series response of the RIAA curve with that of the preamp response curve can be obtained by adding the magnitude quantities. If the preamp response is the exact inverse of the RIAA curve, the result will be a flat line.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.2,0.1))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_RIAA+phase_preamp,':',color=color,label='phase of S2')  # Bode phase plot\n\nax2.set_ylabel('phase difference preamplifier, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude of S1')\nplt.legend(loc=0)\n\nplt.title('Preamp deviation from RIAA response')\nplt.show()\n\n\n\n\n\n\n\n\nThe calculations below will find the minimum and maximun deviation of the amplitude response from the RIAA curve.\n\nidx_low = np.where(w_preamp/(2*np.pi) &gt; 20)[0][0]\nidx_high = np.where(w_preamp/(2*np.pi) &gt; 20e3)[0][0]\nprint('preamp deviation from RIAA curve: {:.3f} to {:.3f} dB'.format(((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].min(),((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].max()))\n\npreamp deviation from RIAA curve: -0.045 to 0.066 dB\n\n\nThe calculations above show that within the audio range the deviation of the preamp amplitude response from the RIAA curve varies from -0.044 to 0.066 dB when the nominal component values are used.\n\n\n23.4.8 Sensitivity analysis\nAll circuits have characteristics that depend on the values of the component. The sensitivity of a circuit’s performance is a measure of how much a particular circuit characteristic changes as a particular component value varies. In this analysis I’ll look at the changes of each pole or zero relative to the component’s value.\nThe root sensitivity function \\(S_x^y\\) gives the change occurring in filter characteristic per \\(\\delta y/ \\delta x\\).\n\\(S_x^y\\) is read as the sensitivity of the characteristic (i.e. y = \\(\\omega_n,\\) or Q or some other characteristic) with respect to the element x.\n\\(S_x^y = \\frac {x}{y} \\frac{\\delta y}{\\delta x}\\)\nWhere x is the filter component that is varied and y is the filter characteristic (\\(\\omega_n,\\) or Q etc.) that we wish to evaluate as x is varied.\nThe preamp transfer function in symbolic form is, H_preamp_sym, and we can get the numerator and denominator with the SymPy fraction function.\n\nH_sym_num, H_sym_denom = fraction(H_preamp_sym)\n\nThe SymPy solve function is used to find the root of the numerator and denominator polynomials.\n\nH_sym_zeros = solve(H_sym_num,s)\nH_sym_poles = solve(H_sym_denom,s)\n\n\n23.4.8.1 Zeros\nHow many roots are there for the numerator polynomial?\n\nprint('there are {:d} zeros'.format(len(H_sym_zeros)))\n\nthere are 3 zeros\n\n\n\n\n23.4.8.2 Z0\nThe first zero is at DC.\n\nH_sym_Z0 = H_sym_zeros[0]\nH_sym_Z0\n\n\\(\\displaystyle 0\\)\n\n\n\n\n23.4.8.3 Z1\nThe second zero is given symbolically by the expression:\n\nH_sym_Z1 = H_sym_zeros[1]\nH_sym_Z1\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\nWhat are the components that determine Z1?\n\nprint('the components that determine Z1 are: {:s} '.format(str(H_sym_Z1.free_symbols)))\n\nthe components that determine Z1 are: {Ro, C1, R2, R1, Co} \n\n\nWhat is the locations of Z1?\n\nprint('location of zero: {:.2f} Hz'.format(N(H_sym_Z1.subs(nominal_component_value))/(2*np.pi)))\n\nlocation of zero: -506.73 Hz\n\n\nZ1 is the zero at 500 Hz and is one of the RIAA time constants.\nWe can find the sensitivity of Z1 to C1 with the following operation.\n\nS_C1_H_sym_Z1 = (C1/H_sym_Z1)*(H_sym_Z1.diff(C1))\nS_C1_H_sym_Z1\n\n\\(\\displaystyle \\frac{C_{1} \\left(- \\frac{1}{2 C_{1} Co \\left(R_{2} + Ro\\right)} - \\frac{C_{1} R_{1}^{2} + Co R_{1}^{2} - Co R_{1} R_{2} - Co R_{1} Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right) \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}} + \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)}\\right)}{- \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}}\\)\n\n\nEvaluating this numerically with the component values, we get the sensitivity of Z1 to C1.\n\nprint('the sensitivity of Z1 to C1 is: {:.2f}'.format(N(S_C1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to C1 is: -1.00\n\n\nDoing the math with SymPy, we can get the sensitivity of Z1 to the other components.\n\nS_R1_H_sym_Z1 = (R1/H_sym_Z1)*(H_sym_Z1.diff(R1))\nprint('the sensitivity of Z1 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R1 is: -0.10\n\n\n\nS_R2_H_sym_Z1 = (R2/H_sym_Z1)*(H_sym_Z1.diff(R2))\nprint('the sensitivity of Z1 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R2 is: -0.85\n\n\n\nS_Co_H_sym_Z1 = (Co/H_sym_Z1)*(H_sym_Z1.diff(Co))\nprint('the sensitivity of Z1 to Co is: {:.4f}'.format(N(S_Co_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Co is: -0.0002\n\n\n\nS_Ro_H_sym_Z1 = (Ro/H_sym_Z1)*(H_sym_Z1.diff(Ro))\nprint('the sensitivity of Z1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Ro is: -0.05\n\n\nLater, we are doing the worst case analysis, we can ignore Co. \n\n\n23.4.8.4 Z2\nThe third zero of the transfer function is Z2.\n\nH_sym_Z2 = H_sym_zeros[2]\nH_sym_Z2\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\n\nprint('the components that determine Z2 are: {:s} '.format(str(H_sym_Z2.free_symbols)))\n\nthe components that determine Z2 are: {Ro, C1, R2, R1, Co} \n\n\n\nprint('Z2: {:.3e} Hz'.format(N(H_sym_Z2.subs(nominal_component_value))/(2*np.pi)))\n\nZ2: -8.885e-3 Hz\n\n\nThe zero Z2, evaluates to a system zero at DC and is not one of the RIAA time constants.\n\nS_C1_H_sym_Z2 = (C1/H_sym_Z2)*(H_sym_Z2.diff(C1))\nprint('the sensitivity of Z2 to C1 is: {:.3e}'.format(N(S_C1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to C1 is: -1.580e-4\n\n\n\nS_Co_H_sym_Z2 = (Co/H_sym_Z2)*(H_sym_Z2.diff(Co))\nprint('the sensitivity of Z2 to Co is: {:.2f}'.format(N(S_Co_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Co is: -1.00\n\n\n\nS_R1_H_sym_Z2 = (R1/H_sym_Z2)*(H_sym_Z2.diff(R1))\nprint('the sensitivity of Z2 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R1 is: -0.90\n\n\n\nS_R2_H_sym_Z2 = (R2/H_sym_Z2)*(H_sym_Z2.diff(R2))\nprint('the sensitivity of Z2 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R2 is: -0.09\n\n\n\nS_Ro_H_sym_Z2 = (Ro/H_sym_Z2)*(H_sym_Z2.diff(Ro))\nprint('the sensitivity of Z2 to Ro is: {:.3f}'.format(N(S_Ro_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Ro is: -0.006\n\n\n\n\n23.4.8.5 Poles\nHow many poles are there in the preamp transfer function?\n\nprint('there are {:d} poles in the transfer function'.format(len(H_sym_poles)))\n\nthere are 4 poles in the transfer function\n\n\n\n\n23.4.8.6 P0\nThe first pole is:\n\nH_sym_P0 = H_sym_poles[0]\nH_sym_P0\n\n\\(\\displaystyle - \\frac{1}{C_{1} R_{1}}\\)\n\n\nThe pole P0 evaluates to one of the RIAA time constants.\n\nprint('P0: {:.2f}Hz'.format(N(H_sym_P0.subs(nominal_component_value))/(2*np.pi)))\n\nP0: -50.63Hz\n\n\n\nS_C1_H_sym_P0 = (C1/H_sym_P0)*(H_sym_P0.diff(C1))\nprint('the sensitivity of P0 to C1 is: {:.2f}'.format(N(S_C1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to C1 is: -1.00\n\n\n\nS_R1_H_sym_P0 = (R1/H_sym_P0)*(H_sym_P0.diff(R1))\nprint('the sensitivity of P0 to R1 is: {:.2f}'.format(N(S_R1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to R1 is: -1.00\n\n\n\n\n23.4.8.7 P1\nThe second pole is:\n\nH_sym_P1 = H_sym_poles[1]\nH_sym_P1\n\n\\(\\displaystyle - \\frac{1}{Co Ro}\\)\n\n\nThe pole P1 evaluates to a frequency near DC.\n\nprint('P1: {:.2f}Hz'.format(N(H_sym_P1.subs(nominal_component_value))/(2*np.pi)))\n\nP1: -1.59Hz\n\n\n\nS_Co_H_sym_P1 = (Co/H_sym_P1)*(H_sym_P1.diff(Co))\nprint('the sensitivity of P1 to Co is: {:.2f}'.format(N(S_Co_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Co is: -1.00\n\n\n\nS_Ro_H_sym_P1 = (Ro/H_sym_P1)*(H_sym_P1.diff(Ro))\nprint('the sensitivity of P1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Ro is: -1.00\n\n\n\n\n23.4.8.8 P2\nThe 3rd pole is:\n\nH_sym_P2 = H_sym_poles[2]\nH_sym_P2\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} - \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the components that determine P2 are: {:s} '.format(str(H_sym_P2.free_symbols)))\n\nthe components that determine P2 are: {C3, C4, R6, R3} \n\n\n\nprint('P2: {:.2f}Hz'.format(N(H_sym_P2.subs(nominal_component_value))/(2*np.pi)))\n\nP2: -2122.88Hz\n\n\n\nS_C3_H_sym_P2 = (C3/H_sym_P2)*(H_sym_P2.diff(C3))\nprint('the sensitivity of P2 to C3 is: {:.2f}'.format(N(S_C3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C3 is: -1.00\n\n\n\nS_C4_H_sym_P2 = (C4/H_sym_P2)*(H_sym_P2.diff(C4))\nprint('the sensitivity of P2 to C4 is: {:.3e}'.format(N(S_C4_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C4 is: -2.829e-5\n\n\n\nS_R3_H_sym_P2 = (R3/H_sym_P2)*(H_sym_P2.diff(R3))\nprint('the sensitivity of P2 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R3 is: -0.96\n\n\n\nS_R6_H_sym_P2 = (R6/H_sym_P2)*(H_sym_P2.diff(R6))\nprint('the sensitivity of P2 to R6 is: {:.3f}'.format(N(S_R6_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R6 is: -0.041\n\n\n\n\n23.4.8.9 P3\nThe 4th pole is:\n\nH_sym_P3 = H_sym_poles[3]\nH_sym_P3\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} + \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the components that determine P3 are: {:s} '.format(str(H_sym_P3.free_symbols)))\n\nthe components that determine P3 are: {C3, C4, R6, R3} \n\n\n\nprint('P3: {:.2f}Hz'.format(N(H_sym_P3.subs(nominal_component_value))/(2*np.pi)))\n\nP3: -1.39Hz\n\n\n\nS_C3_H_sym_P3 = (C3/H_sym_P3)*(H_sym_P3.diff(C3))\nprint('the sensitivity of P3 to C3 is: {:.2e}'.format(N(S_C3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C3 is: -2.83e-5\n\n\n\nS_C4_H_sym_P3 = (C4/H_sym_P3)*(H_sym_P3.diff(C4))\nprint('the sensitivity of P3 to C5 is: {:.2f}'.format(N(S_C4_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C5 is: -1.00\n\n\n\nS_R3_H_sym_P3 = (R3/H_sym_P3)*(H_sym_P3.diff(R3))\nprint('the sensitivity of P3 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R3 is: -0.04\n\n\n\nS_R6_H_sym_P3 = (R6/H_sym_P3)*(H_sym_P3.diff(R6))\nprint('the sensitivity of P3 to R6 is: {:.2f}'.format(N(S_R6_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R6 is: -0.96\n\n\nIn the worst case analysis below, the components that have sensitivities greater than 0.05 are the ones that factor into the worst case analysis.\n\n\n\n23.4.9 Component selection\nThe table below lists each of the components used in the preamp along with a link to the Digikey pages for each of the components in the preamp. Digikey is a larger distributor of electronic components in the US. All the components have operating temperature ranges that exceed the normal household environment.\nThe resistors chosen are all 1% Metal film type resistors. Metal film resistors possess good noise characteristics and low nonlinearity due to a low voltage coefficient. They are also beneficial due to long-term stability.\nThe capacitors are all polypropylene Film capacitor types. Polystyrene or polypropylene are considered the best for audio applications.\nThe Op Amp, LM833N, is a dual bipolar low noise (\\(\\frac {4.5nV}{\\sqrt{Hz}}\\)), wide bandwidth (16 MHz) audio operational amplifier from Texas Instrments.\n\n\n\nRef\nValue\nDescription\nDigikey PN\n\n\n\n\nRo\n499\n±1% 1/4W Metal Film\nRNF14FTD499RCT-ND\n\n\nRp\n47k\n±1% 1/4W Metal Film\n13-MFR-25FTE52-47KTB-ND\n\n\nR1\n80.6k\n±1% 1/4W Metal Film\n80.6KXBK-ND\n\n\nR2\n58.45k\n±1% 1/4W Metal Film\nRNF14FTD8K45CT-ND\n\n\nR3\n2.37k\n±1% 1/4W Metal Film\n13-MFR-25FBF52-2K37-ND\n\n\nR4\n2k\n±1% 1/4W Metal Film\n13-MFR-25FRF52-2KCT-ND\n\n\nR5\n4.3k\n±1% 1/4W Metal Film\nS4.3KCACT-ND\n\n\nR6\n54.9k\n±1% 1/4W Metal Film\nRNF14FTD54K9CT-ND\n\n\nCo\n200\\(\\mu\\)\n10% Film Capacitor 450V Polypropylene\n283-EFDKS45K207F064DH-ND\n\n\nCp\n100p\n10% Film Capacitor 250V Polypropylene\n399-RSBEC0100ZA00M-ND\n\n\nC1\n0.039\\(\\mu\\)\n2% Film Capacitor 25V 63V Polypropylene\nBC2066-ND\n\n\nC3\n0.033\\(\\mu\\)\n1% Film Capacitor 63V 100V Polypropylene\n399-PHE426DJ5330FR17T0CT-ND\n\n\nC4\n2\\(\\mu\\)\n10% Film Capacitor 305V 630V Polypropylene\n495-B32923P3205K000-ND\n\n\nU1, U2\nLM833N\nAudio op amp\n296-44419-5-ND\n\n\n\nThe parts in this list are considered good choices for a first pass at the bill of materials. The size of the production run and the piece part cost are also factors which must be considered if the preamp is going to be built. One thing to notice is that Co, the 200 \\(\\mu\\) F capacitor is expensive. The use of a polypropylene film capacitor for this component is consistent with the advice of keeping all capacitors in the audio path polystyrene or polypropylene.\n\n\n23.4.10 Monte Carlo simulation\nIn this analysis the circuit equations are solved after assigning random element values from within the tolerance band to the components. This simulates building a large number of circuits with components chosen at random from bins or reals of components during the board stuffing process. All the components are required to meet their specifications, but are allowed to have some variation according to their tolerance. For example a 1% 2k resistor can range from 1980 to 2020 \\(\\Omega\\). In addition to the components initial tolerance, the temperature coefficient and aging of parameters can also be included.\nIn this simulation, I’m only including the initial tolerances of parameters and I’m assuming the distribution is uniform. The NumPy function random.uniform is used to generate the random values within the tolerance range, however, for this function, the high end-point value may or may not be included in the range depending on floating-point rounding, so if this is important, some adjustments to the code are required. The NumPy function random.seed is used to re-seed the random number generator.\n\nnum = 20 # number of simulations to run\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to the hold the results of each run\nmag_ans = np.zeros(shape=(num,len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(num,len(new_x_axis_range)))\n\ncomponent_values_tol = nominal_component_value.copy() # make a copy\n\nrandom.seed(a=None, version=2) # re-seed the random number generator\n\nThe following takes about 15 seconds to run on for num=20 on an i3 machine.\n\nfor i in range(0,num):\n\n    component_values_tol[Ro] = random.uniform(nominal_component_value[Ro]-nominal_component_value[Ro]*0.01,nominal_component_value[Ro]+nominal_component_value[Ro]*0.01)\n    component_values_tol[Rp] = random.uniform(nominal_component_value[Rp]-nominal_component_value[Rp]*0.01,nominal_component_value[Rp]+nominal_component_value[Ro]*0.01)\n\n    component_values_tol[R1] = random.uniform(nominal_component_value[R1]-nominal_component_value[R1]*0.01,nominal_component_value[R1]+nominal_component_value[R1]*0.01)\n    component_values_tol[R2] = random.uniform(nominal_component_value[R2]-nominal_component_value[R2]*0.01,nominal_component_value[R2]+nominal_component_value[R2]*0.01)    \n    component_values_tol[R3] = random.uniform(nominal_component_value[R3]-nominal_component_value[R3]*0.01,nominal_component_value[R3]+nominal_component_value[R3]*0.01)\n    component_values_tol[R4] = random.uniform(nominal_component_value[R4]-nominal_component_value[R4]*0.01,nominal_component_value[R4]+nominal_component_value[R4]*0.01)    \n    component_values_tol[R5] = random.uniform(nominal_component_value[R5]-nominal_component_value[R5]*0.01,nominal_component_value[R5]+nominal_component_value[R5]*0.01)\n    component_values_tol[R6] = random.uniform(nominal_component_value[R6]-nominal_component_value[R6]*0.01,nominal_component_value[R6]+nominal_component_value[R6]*0.01)    \n\n    component_values_tol[Co] = random.uniform(nominal_component_value[Co]-nominal_component_value[Co]*0.1,nominal_component_value[Co]+nominal_component_value[Co]*0.1)\n    component_values_tol[Cp] = random.uniform(nominal_component_value[Cp]-nominal_component_value[Cp]*0.1,nominal_component_value[Cp]+nominal_component_value[Cp]*0.1)\n    component_values_tol[C1] = random.uniform(nominal_component_value[C1]-nominal_component_value[C1]*0.02,nominal_component_value[C1]+nominal_component_value[C1]*0.02)\n    component_values_tol[C3] = random.uniform(nominal_component_value[C3]-nominal_component_value[C3]*0.01,nominal_component_value[C3]+nominal_component_value[C3]*0.01)\n    component_values_tol[C4] = random.uniform(nominal_component_value[C4]-nominal_component_value[C4]*0.1,nominal_component_value[C4]+nominal_component_value[C4]*0.1)\n\n    # enter the element values\n    preamp_equ_tol = NE_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    \n    # save the results from each run\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\n\n23.4.11 Preamplifier deviation from RIAA response\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.3))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Monte Carlo runs showing deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe Monte Carlo simulation shows that the preamp amplitude response deviation from the RIAA curve can very from -0.2 to 0.3 dB over the audio band. If the performance requirement for this preamp was to be within \\(\\pm\\) 0.1 dB of the RIAA curve, then some redesign or tighter component tolerancing is required.\n\n\n23.4.12 Worst case analysis\nIn a worst case analysis, we would look at:\n\nminimum and maximum values of the initial component tolerance\n\nmaximum or minimum temperature coefficients of the parameters\n\nmaximum aging or drift of parameter values\n\nSince we usually can’t tell by inspection which combination of minimum and maximum values will give the worst case, we can run a number of simulations in which all combinations of minimum and maximum variations are included. From the family of results we can look for the worst case.\n\nprint('number of components: {:d}'.format(len(nominal_component_value)))\n\nnumber of components: 14\n\n\nHow many min and max combinations?\n\nprint('number of min and max combinations: {:,d}'.format(2**14))\n\nnumber of min and max combinations: 16,384\n\n\n16 thousand simulation runs too many. From the sensitivity analysis above, only R1, R2, R3, R6, Ro, C1 and C3 are sensitive. Running all combinations of the min and max tolerance for this set is reasonable and is \\(2^7=128\\) combinations.\nThe tolerances for each of the components is defined below:\n\nTol = {Ro:0.01,R1:0.01,R2:0.01,R3:0.01,R6:0.01,C1:0.02,C3:0.01}\n\nOnly C1 has a tolerance other than 1%.\nThe array ‘run’ is created that consists of a binary count, with leading zeros from 0 to 127. Then the zero values are replaced with -1.\n\nrun = []\nfor i in range(0,2**(len(Tol))):\n    temp = list('{:07b}'.format(i)) # include leading zeros\n    for j in range(len(temp)):\n        temp[j] = int(temp[j])\n    run.append(temp)\n\nrun = np.asarray(run)\nrun = np.where(run == 0, -1, run)\n\nThe first row of run is:\n\nrun[0]\n\narray([-1, -1, -1, -1, -1, -1, -1])\n\n\nIn the for loop below, at i = 0, run[0] would be all -1’s and this could apply the low tolerance range to the nominal component values.\n\nrun[-1]\n\narray([1, 1, 1, 1, 1, 1, 1])\n\n\nThe last time through the for loop, where i = 127, run[-1] is all 1’s and this would apply the high tolerance range to the nominal component values. Between i = 0 and i = 127, all combinations of minimum and maximum tolerance are applied.\n\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to hold the results\nmag_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\n\nThe following cell takes about 90 seconds to run on my i3-8130U 2.20GHz laptop.\n\nfor i in range(len(run)):\n    component_values_tol[Ro] = nominal_component_value[Ro]*(1+run[i][0]*Tol[Ro])\n    component_values_tol[Rp] = nominal_component_value[Rp]\n\n    component_values_tol[R1] = nominal_component_value[R1]*(1+run[i][1]*Tol[R1])\n    component_values_tol[R2] = nominal_component_value[R2]*(1+run[i][2]*Tol[R2]) \n    component_values_tol[R3] = nominal_component_value[R3]*(1+run[i][3]*Tol[R3])\n\n    component_values_tol[R4] = nominal_component_value[R4] \n    component_values_tol[R5] = nominal_component_value[R5]\n    component_values_tol[R6] = nominal_component_value[R6]*(1+run[i][4]*Tol[R6])\n\n    component_values_tol[Co] = nominal_component_value[Co]\n    component_values_tol[Cp] = nominal_component_value[Cp]\n    component_values_tol[C1] = nominal_component_value[C1]*(1+run[i][5]*Tol[C1])\n    component_values_tol[C3] = nominal_component_value[C3]*(1+run[i][6]*Tol[C3])\n    component_values_tol[C4] = nominal_component_value[C4]\n    \n    # enter the element values\n    preamp_equ_tol = NE_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.4))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Worst Case deviation from RIAA curve')\nplt.show()\n\n\n\n\n\n\n\n\nThe results above show that the worst case tolerance conditions yield deviations of -0.19 to 0.3 dB from the RIAA curve.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Two Amplifier RIAA Phono Preamp</span>"
    ]
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#summary",
    "href": "Two amplifier RIAA Phono Preamp.html#summary",
    "title": "23  Two Amplifier RIAA Phono Preamp",
    "section": "23.5 Summary",
    "text": "23.5 Summary\nThe circuit presented in this analysis is just one example of many circuits that can be found online. For each design to be evaluated, some type of side by side analysis should be used to down select. This notebook can be used as a template for any comparative analysis.\nThe circuit in the app note appears to have low frequency group delay that might be an issue. Also the deviation from the RIAA curve using normal component tolerances does not meet the 0.1 dB requirement. The worst case analysis also confirms this. The circuit employs an expensive 200\\(\\mu\\) Farad film capacitor. The circuit is missing a subsonic filter.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Two Amplifier RIAA Phono Preamp</span>"
    ]
  },
  {
    "objectID": "mech-sys.html",
    "href": "mech-sys.html",
    "title": "24  Mechanical Systems",
    "section": "",
    "text": "24.1 Translational mechanical system\nThis notebook explores what is called mechanical–electrical analogies and is an example of how MNA methods can be used to analyze non-circuit problems. In Akbaba et al. (2022), two examples of mechanical systems are analyized. The first is a translational mechanical system and the second is a rotational mechanical system. The code presented here will analyze the equalivent electrical circuits and not cover the derivation of the electrical circuits.\nThe first example in Akbaba et al. (2022), is a translational mechanical system shown in Figure 24.1. The mechaninical system consists of masses, springs, damping elements and sliding friction.\nThe system parameters for mechanical system given in Figure 1 are:\nThe equalivent electrical circuit was entered into LTSpice so that a net list could be generated. The circuit has 16 branches and 11 nodes. The capacitor values in Figure 24.2 have entered as equations. For example, the value for \\(C_1\\) is {1/500}, for which LTSpice will calculate a value of 0.002.\nThe net list for the circuit is listed below.\nTransient analysis is somewhat more involved than the other types of circuit analysis, primarily because SymPy’s inverse Laplace transform is not very robust and can’t handle complicated expressions. The output equation needs to be simplified by writing some code to put the equation into forms that SymPy can deal with.\nLoad the following Python modules.\nfrom sympy import *\nimport numpy as np\nfrom tabulate import tabulate\nimport pandas as pd\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()\nLoad the netlist generated by LTSpice.\nThe element values in the net list have been set to one. In the code cells below, the correct values will be substituted into the network equations.\nnet_list = '''\nV1 1 0 1\nC1 1 2 1\nCeq 3 4 1\nC4 4 5 1\nC5 7 8 1\nC6 9 10 1\nR1 2 0 1\nR2 5 0 1\nR3 3 4 1\nR4 7 4 1\nR5 8 6 1\nR7 11 8 1\nR6 11 10 1\nL1 1 3 1\nL3 3 9 1\nL2 6 5 1\n'''\nGenerate and display the network equations.\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(C_{1} s v_{1} - C_{1} s v_{2} + I_{L1} + I_{V1} = 0\\)\\(- C_{1} s v_{1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) = 0\\)\\(- I_{L1} + I_{L3} + v_{3} \\left(Ceq s + \\frac{1}{R_{3}}\\right) + v_{4} \\left(- Ceq s - \\frac{1}{R_{3}}\\right) = 0\\)\\(- C_{4} s v_{5} + v_{3} \\left(- Ceq s - \\frac{1}{R_{3}}\\right) + v_{4} \\left(C_{4} s + Ceq s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{4}} = 0\\)\\(- C_{4} s v_{4} - I_{L2} + v_{5} \\left(C_{4} s + \\frac{1}{R_{2}}\\right) = 0\\)\\(I_{L2} + \\frac{v_{6}}{R_{5}} - \\frac{v_{8}}{R_{5}} = 0\\)\\(- C_{5} s v_{8} + v_{7} \\left(C_{5} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}} = 0\\)\\(- C_{5} s v_{7} + v_{8} \\left(C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{11}}{R_{7}} - \\frac{v_{6}}{R_{5}} = 0\\)\\(- C_{6} s v_{10} + C_{6} s v_{9} - I_{L3} = 0\\)\\(- C_{6} s v_{9} + v_{10} \\left(C_{6} s + \\frac{1}{R_{6}}\\right) - \\frac{v_{11}}{R_{6}} = 0\\)\\(v_{11} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{10}}{R_{6}} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{1} - v_{3} = 0\\)\\(- I_{L3} L_{3} s + v_{3} - v_{9} = 0\\)\\(- I_{L2} L_{2} s - v_{5} + v_{6} = 0\\)\nAs shown above MNA generated many equations and these would be difficult to solve by hand.\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  I_{L1}, \\  v_{11}, \\  L_{1}, \\  v_{6}, \\  R_{3}, \\  v_{10}, \\  v_{5}, \\  C_{6}, \\  v_{7}, \\  I_{L2}, \\  L_{2}, \\  I_{L3}, \\  v_{2}, \\  R_{1}, \\  Ceq, \\  v_{4}, \\  R_{6}, \\  v_{3}, \\  v_{9}, \\  V_{1}, \\  C_{4}, \\  R_{2}, \\  v_{8}, \\  s, \\  R_{5}, \\  R_{7}, \\  C_{5}, \\  L_{3}, \\  v_{1}, \\  C_{1}, \\  R_{4}\\right)\\)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mechanical Systems</span>"
    ]
  },
  {
    "objectID": "mech-sys.html#translational-mechanical-system",
    "href": "mech-sys.html#translational-mechanical-system",
    "title": "24  Mechanical Systems",
    "section": "",
    "text": "Figure 24.1: The mechanical and electrical schematic for the mechanical system under consideration is shown. The Figure is from Akbaba et al. (2022), licensed under Creative Commons Attribution-Non Commercial-No Derivatives 4.0 License.\n\n\n\n\n\n\nMechanical Load Masses: M1 = 100 kg, M2 = 40 kg, M3 = 80 kg\nStiffness Elements: K1 = 500 N/m, K2 = 250 N/m, K3 = 150 N/m, K4 = 300 N/m, K5 = 200 N/m, K6 = 180 N/m, Keq = k1 + k2\nViscous Friction elements: B1 = 80 N.s/m, B2 = 30 N.s/m, B3 = 50 N.s/m, B4 = 40 N.s/m, B5 = 10 N.s/m, B6 = 30 N.s/m, B7 = 20 N.s/m\nThe applied force: \\(F(t) = 400sin(4t)e^{-0.1 t}\\) is changed to a unit step function, \\(\\frac {1}{s}\\).\n\n\n\n\n\n\n\n\nFigure 24.2: Schematic\n\n\n\n\nV1 1 0 PULSE(0 1 1 1e-10 0 20 100 2)\nC1 1 2 {1/500}\nCeq 3 4 {1/(500+250)}\nC4 4 5 {1/300}\nC5 7 8 {1/200}\nC6 9 10 {1/180}\nR1 2 0 80\nR2 5 0 30\nR3 3 4 50\nR4 7 4 40\nR5 8 6 10\nR7 11 8 20\nR6 11 10 30\nL1 1 3 100\nL3 3 9 80\nL2 6 5 40\n\n\n\n\n\n\n\n\n\n\n\n\n24.1.1 Symbolic solution\nSince the circuit is large, a symbolic solution takes a long time, so code is commented out.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)\n\n\n\n24.1.2 Numerical solution\nBuilt a dictionary of element values.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{4} : 1.0, \\  C_{5} : 1.0, \\  C_{6} : 1.0, \\  Ceq : 1.0, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  L_{3} : 1.0, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  R_{3} : 1.0, \\  R_{4} : 1.0, \\  R_{5} : 1.0, \\  R_{6} : 1.0, \\  R_{7} : 1.0, \\  V_{1} : 1.0\\right\\}\\)\n\n\nR’s\n(B1 = 80 N.s/m, B2 = 30 N.s/m, B3 = 50 N.s/m, B4 = 40 N.s/m, B5 = 10 N.s/m, B6 = 30 N.s/m, B7 = 20 N.s/m)\n(R1 = 80, R2 = 30, R3 = 50, R4 = 40, R5 = 10, R6 = 30, R7 = 20)\n\nB1 = 80\nB2 = 30\nB3 = 50\nB4 = 40\nB5 = 10\nB6 = 30\nB7 = 20\nelement_values[R1] = B1\nelement_values[R2] = B2\nelement_values[R3] = B3\nelement_values[R4] = B4\nelement_values[R5] = B5\nelement_values[R6] = B6\nelement_values[R7] = B7\n\nL’s\n(M1 = 100 kg, M2 = 40 kg, M3 = 80 kg)\n(L1 = 100, L2 = 40, L3 = 80)\n\nM1 = 100\nM2 = 40\nM3 = 80\nelement_values[L1] = M1\nelement_values[L2] = M2\nelement_values[L3] = M3\n\nUsing C = 1/K\n1/K = C\n(K1 = 500 N/m, K2 = 250 N/m, K3 = 150 N/m, K4 = 300 N/m, K5 = 200 N/m, K6 = 180 N/m, Keq = k1 + k2 )\n(C1 = 500, C2 = 250, C3 = 150, C4 = 300, C5 = 200, C6 = 180, Ceq = k1 + k2 )\n\nK1 = 500\nK2 = 250\nK3 = 150\nK4 = 300\nK5 = 200\nK6 = 180\nKeq = K1 + K2 \n\nelement_values[C1] = 1/K1\nelement_values[C4] = 1/K4\nelement_values[C5] = 1/K5\nelement_values[C6] = 1/K6\nelement_values[Ceq] = 1/Keq\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 0.002, \\  C_{4} : 0.00333333333333333, \\  C_{5} : 0.005, \\  C_{6} : 0.00555555555555556, \\  Ceq : 0.00133333333333333, \\  L_{1} : 100, \\  L_{2} : 40, \\  L_{3} : 80, \\  R_{1} : 80, \\  R_{2} : 30, \\  R_{3} : 50, \\  R_{4} : 40, \\  R_{5} : 10, \\  R_{6} : 30, \\  R_{7} : 20, \\  V_{1} : 1.0\\right\\}\\)\n\n\n\n\n24.1.3 Mechanical Analogies\nAkbaba et al. (2022) stated that the inductor current is equalivent to the velocity of the mass in a translational mechanical system. Displacement is equalivent to the charge in a capacitor. In the mechanical system shown in Figure 24.1, we will look at the velocity of mass, M3, and its displacement in response to a step function. In the example, Akbaba et al. (2022), uses a dampled sinusoidal function as the driving force, here I’m going to drive the system with a step function. In the cell below, the dampled sinusoidal function is has been commented out and V1 is a unit step function.\n\n#element_values[V1] = laplace_transform(400*exp(-0.1*t)*sin(4*t), t, s)[0] # driving function in example\nelement_values[V1] = laplace_transform(1*Heaviside(t), t, s)[0] # step function as a test\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V1} + 0.002 s v_{1} - 0.002 s v_{2}\\\\- 0.002 s v_{1} + v_{2} \\cdot \\left(0.002 s + \\frac{1}{80}\\right)\\\\- I_{L1} + I_{L3} + v_{3} \\cdot \\left(0.00133333333333333 s + \\frac{1}{50}\\right) + v_{4} \\left(- 0.00133333333333333 s - \\frac{1}{50}\\right)\\\\- 0.00333333333333333 s v_{5} + v_{3} \\left(- 0.00133333333333333 s - \\frac{1}{50}\\right) + v_{4} \\cdot \\left(0.00466666666666667 s + \\frac{9}{200}\\right) - \\frac{v_{7}}{40}\\\\- I_{L2} - 0.00333333333333333 s v_{4} + v_{5} \\cdot \\left(0.00333333333333333 s + \\frac{1}{30}\\right)\\\\I_{L2} + \\frac{v_{6}}{10} - \\frac{v_{8}}{10}\\\\- 0.005 s v_{8} - \\frac{v_{4}}{40} + v_{7} \\cdot \\left(0.005 s + \\frac{1}{40}\\right)\\\\- 0.005 s v_{7} - \\frac{v_{11}}{20} - \\frac{v_{6}}{10} + v_{8} \\cdot \\left(0.005 s + \\frac{3}{20}\\right)\\\\- I_{L3} - 0.00555555555555556 s v_{10} + 0.00555555555555556 s v_{9}\\\\- 0.00555555555555556 s v_{9} + v_{10} \\cdot \\left(0.00555555555555556 s + \\frac{1}{30}\\right) - \\frac{v_{11}}{30}\\\\- \\frac{v_{10}}{30} + \\frac{v_{11}}{12} - \\frac{v_{8}}{20}\\\\v_{1}\\\\- 100 I_{L1} s + v_{1} - v_{3}\\\\- 80 I_{L3} s + v_{3} - v_{9}\\\\- 40 I_{L2} s - v_{5} + v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{4.0}{4.0 s + 25.0}\\)\\(v_{3} = \\frac{96.0 s^{6} + 5028.0 s^{5} + 28443.0 s^{4} + 125715.0 s^{3} + 226350.0 s^{2} + 240300.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{4} = \\frac{96.0 s^{6} + 2628.0 s^{5} + 22743.0 s^{4} + 82140.0 s^{3} + 199350.0 s^{2} + 172800.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{5} = \\frac{96.0 s^{5} + 1668.0 s^{4} + 6063.0 s^{3} + 28710.0 s^{2} + 37350.0 s + 67500.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{6} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 22743.0 s^{3} + 64470.0 s^{2} + 105750.0 s + 67500.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{7} = \\frac{96.0 s^{6} + 2628.0 s^{5} + 22983.0 s^{4} + 67440.0 s^{3} + 188190.0 s^{2} + 140400.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{8} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 22983.0 s^{3} + 68640.0 s^{2} + 114690.0 s + 84600.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{9} = \\frac{96.0 s^{6} + 2628.0 s^{5} + 24483.0 s^{4} + 76515.0 s^{3} + 154350.0 s^{2} + 240300.0 s + 162000.0}{320.0 s^{8} + 5656.0 s^{7} + 25238.0 s^{6} + 124143.0 s^{5} + 250215.0 s^{4} + 451350.0 s^{3} + 240300.0 s^{2} + 162000.0 s}\\)\\(v_{10} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 24483.0 s^{3} + 71115.0 s^{2} + 145440.0 s + 129600.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(v_{11} = \\frac{96.0 s^{5} + 2628.0 s^{4} + 23583.0 s^{3} + 69630.0 s^{2} + 126990.0 s + 102600.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\\(I_{V1} = \\frac{- 320.0 s^{7} - 5912.0 s^{6} - 31286.0 s^{5} - 168111.0 s^{4} - 427825.0 s^{3} - 1029450.0 s^{2} - 1042800.0 s - 1287000.0}{25600.0 s^{8} + 612480.0 s^{7} + 4847040.0 s^{6} + 22550440.0 s^{5} + 82088700.0 s^{4} + 161215500.0 s^{3} + 244899000.0 s^{2} + 133110000.0 s + 81000000.0}\\)\\(I_{L1} = \\frac{32.0 s^{5} + 556.0 s^{4} + 2021.0 s^{3} + 9570.0 s^{2} + 12450.0 s + 22500.0}{3200.0 s^{7} + 56560.0 s^{6} + 252380.0 s^{5} + 1241430.0 s^{4} + 2502150.0 s^{3} + 4513500.0 s^{2} + 2403000.0 s + 1620000.0}\\)\\(I_{L3} = \\frac{60.0 s^{3} + 99.0 s^{2} + 1230.0 s + 1800.0}{640.0 s^{7} + 11312.0 s^{6} + 50476.0 s^{5} + 248286.0 s^{4} + 500430.0 s^{3} + 902700.0 s^{2} + 480600.0 s + 324000.0}\\)\\(I_{L2} = \\frac{24.0 s^{3} + 417.0 s^{2} + 894.0 s + 1710.0}{320.0 s^{7} + 5656.0 s^{6} + 25238.0 s^{5} + 124143.0 s^{4} + 250215.0 s^{3} + 451350.0 s^{2} + 240300.0 s + 162000.0}\\)\n\n\n\n\n24.1.4 Velocity of \\(M_3\\)\nThe current in L3 is equalivent to the velocity of \\(M_3\\) and the following cells compute the current in the inductor. The current through L3 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nL3_current_s = U[I_L3].nsimplify().simplify().expand().together()\nL3_current_s\n\n\\(\\displaystyle \\frac{3 \\cdot \\left(20 s^{3} + 33 s^{2} + 410 s + 600\\right)}{2 \\cdot \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#L3_current = inverse_laplace_transform(L3_current_s, s, t)\n#L3_current\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(L3_current_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(60 s^{3} + 99 s^{2} + 1230 s + 1800\\)denominator: \\(640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{1800}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}, \\  \\frac{60 s^{3}}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}, \\  \\frac{99 s^{2}}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}, \\  \\frac{1230 s}{640 s^{7} + 11312 s^{6} + 50476 s^{5} + 248286 s^{4} + 500430 s^{3} + 902700 s^{2} + 480600 s + 324000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nthe SciPy function residue is used to get the residues and poles of the partial-fraction expansion\nbuild the partial expansion terms and find the inverse Laplace of each term and save\n\nReturns:\n\nr: Residues corresponding to the poles. For repeated poles, the residues are ordered to correspond to ascending by power fractions.\np: Poles ordered by magnitude in ascending order.\nk: Coefficients of the direct polynomial term.\n\nWhen computing the inverse Laplace transform, the Coefficients (k) are ignored since these transform to a Dirac delta function, \\(\\delta (t)\\) and don’t need to be plotted.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node2 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node2 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Inductor current vs time')\n\nplt.plot(x, np.real(V_node2),label='i(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n24.1.5 Displacement of \\(M_3\\)\nThe displacement of \\(M_3\\) is equalavent to the charge on C6 which is proportional to the voltage difference between nodes 9 and 10.\n\nC6_voltage_s = (U[v9] - U[v10]).nsimplify().simplify().expand().together()\nC6_voltage_s\n\n\\(\\displaystyle \\frac{270 \\cdot \\left(20 s^{3} + 33 s^{2} + 410 s + 600\\right)}{s \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#C6_voltage = inverse_laplace_transform(C6_voltage_s, s, t)\n#C6_voltage\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(C6_voltage_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(5400 s^{3} + 8910 s^{2} + 110700 s + 162000\\)denominator: \\(s \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{162000}{s \\left(320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000\\right)}, \\  \\frac{5400 s^{2}}{320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000}, \\  \\frac{8910 s}{320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000}, \\  \\frac{110700}{320 s^{7} + 5656 s^{6} + 25238 s^{5} + 124143 s^{4} + 250215 s^{3} + 451350 s^{2} + 240300 s + 162000}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node2 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node2 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Voltage vs time')\n\nplt.plot(x, np.real(V_node2),label='v(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mechanical Systems</span>"
    ]
  },
  {
    "objectID": "mech-sys.html#rotational-mechanical-system",
    "href": "mech-sys.html#rotational-mechanical-system",
    "title": "24  Mechanical Systems",
    "section": "24.2 Rotational mechanical system",
    "text": "24.2 Rotational mechanical system\n\n\n\n\n\n\nFigure 24.3: The mechanical and electrical schematic for the mechanical system under consideration is shown. The Figure is from Akbaba et al. (2022), licensed under Creative Commons Attribution-Non Commercial-No Derivatives 4.0 License.\n\n\n\nThe second example in Akbaba et al. (2022), is a rotational mechanical system shown in Figure 24.3. The conversion of the mechanical parameters:\n\nthe moment of inertia\nrotational stiffness or rotational spring element\nrotational viscous friction or rotational damper element\n\nto electrical elements in the equalivent circuit is not include in my calculations. All the electrical elment values are set to one. The reason for this is the converseion is not straight forward and somewhat outside the scope of circuit analysis.\nThe circuit was drawn in LTSpice so that the netlist could be obtained.\n\n\n\n\n\n\nFigure 24.4: Schematic\n\n\n\nLoad the netlist. The value of \\(V_L\\) is set to zero.\n\nnet_list = '''\nVa 1 0 1\nVL 14 0 0\nLa 1 2 1\nLm 5 6 1\nL1 7 8 1\nL2 9 10 1\nL5 0 10 1\nL6 11 0 1\nL3 11 12 1\nL4 13 14 1\nRa 3 0 1\nRmb 5 4 1\nR1 7 6 1\nR4 13 12 1\nC1 9 0 1\nC2 12 0 1\nHa 2 3 V1 1\nHm 4 0 Va 1\nV1 9 8 0\nK1 L5 L6 0.5\n'''\n\nGenerate and display the network equations.\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\n# Put matricies into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# generate markdown text to display the network equations.\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*X)[i:i+1][0],Z[i])))\n\nMarkdown(temp)\n\n\\(I_{La} + I_{Va} = 0\\)\\(I_{Ha} - I_{La} = 0\\)\\(- I_{Ha} + \\frac{v_{3}}{Ra} = 0\\)\\(I_{Hm} + \\frac{v_{4}}{Rmb} - \\frac{v_{5}}{Rmb} = 0\\)\\(I_{Lm} - \\frac{v_{4}}{Rmb} + \\frac{v_{5}}{Rmb} = 0\\)\\(- I_{Lm} + \\frac{v_{6}}{R_{1}} - \\frac{v_{7}}{R_{1}} = 0\\)\\(I_{L1} - \\frac{v_{6}}{R_{1}} + \\frac{v_{7}}{R_{1}} = 0\\)\\(- I_{L1} - I_{V1} = 0\\)\\(C_{1} s v_{9} + I_{L2} + I_{V1} = 0\\)\\(- I_{L2} - I_{L5} = 0\\)\\(I_{L3} + I_{L6} = 0\\)\\(- I_{L3} + v_{12} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{13}}{R_{4}} = 0\\)\\(I_{L4} - \\frac{v_{12}}{R_{4}} + \\frac{v_{13}}{R_{4}} = 0\\)\\(- I_{L4} + I_{Vl} = 0\\)\\(v_{1} = Va\\)\\(v_{14} = Vl\\)\\(- v_{8} + v_{9} = V_{1}\\)\\(- I_{La} La s + v_{1} - v_{2} = 0\\)\\(- I_{Lm} Lm s + v_{5} - v_{6} = 0\\)\\(- I_{L1} L_{1} s + v_{7} - v_{8} = 0\\)\\(- I_{L2} L_{2} s - v_{10} + v_{9} = 0\\)\\(- I_{L5} L_{5} s - I_{L6} M_{1} s - v_{10} = 0\\)\\(- I_{L5} M_{1} s - I_{L6} L_{6} s + v_{11} = 0\\)\\(- I_{L3} L_{3} s + v_{11} - v_{12} = 0\\)\\(- I_{L4} L_{4} s + v_{13} - v_{14} = 0\\)\\(- I_{V1} ha + v_{2} - v_{3} = 0\\)\\(- I_{Va} hm + v_{4} = 0\\)\n\n\nAs shown above MNA generated many equations and these would be difficult to solve by hand.\nThe sysmbols generated by the Python code are extraced by the SymPy function free_symbols and then declared as SymPy variables.\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L4}, \\  ha, \\  I_{L1}, \\  L_{1}, \\  v_{14}, \\  v_{6}, \\  Rmb, \\  L_{4}, \\  v_{10}, \\  hm, \\  L_{5}, \\  v_{2}, \\  I_{Vl}, \\  R_{1}, \\  v_{12}, \\  I_{Lm}, \\  v_{8}, \\  La, \\  L_{6}, \\  I_{Va}, \\  I_{V1}, \\  Ra, \\  v_{13}, \\  v_{11}, \\  Vl, \\  I_{Hm}, \\  v_{5}, \\  v_{7}, \\  I_{L2}, \\  L_{2}, \\  I_{L5}, \\  I_{L3}, \\  I_{L6}, \\  v_{4}, \\  I_{La}, \\  C_{2}, \\  Lm, \\  v_{3}, \\  v_{9}, \\  V_{1}, \\  s, \\  M_{1}, \\  L_{3}, \\  Va, \\  v_{1}, \\  C_{1}, \\  R_{4}, \\  I_{Ha}\\right)\\)\n\n\nSince the circuit is large, a symbolic solution takes a long time, so code is commented out.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)\n\nBuilt a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.0, \\  C_{2} : 1.0, \\  K_{1} : 0.5, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  L_{3} : 1.0, \\  L_{4} : 1.0, \\  L_{5} : 1.0, \\  L_{6} : 1.0, \\  La : 1.0, \\  Lm : 1.0, \\  R_{1} : 1.0, \\  R_{4} : 1.0, \\  Ra : 1.0, \\  Rmb : 1.0, \\  V_{1} : 0.0, \\  Va : 1.0, \\  Vl : 0.0, \\  ha : 1.0, \\  hm : 1.0\\right\\}\\)\n\n\nThe mutual inductance between L1 and L2 is calculated from the coupling coeeficient.\n\\(M = k\\sqrt{L_1L_2}\\)\n\nK1 = symbols('K1')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L5] * element_values[L6])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 0.500000000\n\n\nRe-define the symbol \\(t\\) for time and define \\(V_a\\) to be a voltage step.\n\nt = symbols('t',positive=True)  # t &gt; 0\n\n\nelement_values[Va] = laplace_transform(1*Heaviside(t), t, s)[0]\nNE = NE_sym.subs(element_values)\nNE\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{La} + I_{Va}\\\\I_{Ha} - I_{La}\\\\- I_{Ha} + 1.0 v_{3}\\\\I_{Hm} + 1.0 v_{4} - 1.0 v_{5}\\\\I_{Lm} - 1.0 v_{4} + 1.0 v_{5}\\\\- I_{Lm} + 1.0 v_{6} - 1.0 v_{7}\\\\I_{L1} - 1.0 v_{6} + 1.0 v_{7}\\\\- I_{L1} - I_{V1}\\\\I_{L2} + I_{V1} + 1.0 s v_{9}\\\\- I_{L2} - I_{L5}\\\\I_{L3} + I_{L6}\\\\- I_{L3} + v_{12} \\cdot \\left(1.0 s + 1.0\\right) - 1.0 v_{13}\\\\I_{L4} - 1.0 v_{12} + 1.0 v_{13}\\\\- I_{L4} + I_{Vl}\\\\v_{1}\\\\v_{14}\\\\- v_{8} + v_{9}\\\\- 1.0 I_{La} s + v_{1} - v_{2}\\\\- 1.0 I_{Lm} s + v_{5} - v_{6}\\\\- 1.0 I_{L1} s + v_{7} - v_{8}\\\\- 1.0 I_{L2} s - v_{10} + v_{9}\\\\- 1.0 I_{L5} s - 0.5 I_{L6} s - v_{10}\\\\- 0.5 I_{L5} s - 1.0 I_{L6} s + v_{11}\\\\- 1.0 I_{L3} s + v_{11} - v_{12}\\\\- 1.0 I_{L4} s + v_{13} - v_{14}\\\\- 1.0 I_{V1} + v_{2} - v_{3}\\\\- 1.0 I_{Va} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\\\frac{1}{s}\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{1}{s}\\)\\(v_{2} = \\frac{30.0 s^{6} + 75.0 s^{5} + 122.0 s^{4} + 140.0 s^{3} + 95.0 s^{2} + 52.0 s + 12.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{3} = \\frac{30.0 s^{6} + 60.0 s^{5} + 107.0 s^{4} + 109.0 s^{3} + 79.0 s^{2} + 40.0 s + 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{4} = \\frac{- 30.0 s^{6} - 60.0 s^{5} - 107.0 s^{4} - 109.0 s^{3} - 79.0 s^{2} - 40.0 s - 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{5} = \\frac{- 30.0 s^{6} - 45.0 s^{5} - 92.0 s^{4} - 78.0 s^{3} - 63.0 s^{2} - 28.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{6} = \\frac{- 15.0 s^{6} - 30.0 s^{5} - 61.0 s^{4} - 62.0 s^{3} - 51.0 s^{2} - 24.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(v_{7} = \\frac{- 15.0 s^{5} - 15.0 s^{4} - 46.0 s^{3} - 31.0 s^{2} - 35.0 s - 12.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{8} = \\frac{- 15.0 s^{3} - 15.0 s^{2} - 23.0 s - 8.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{9} = \\frac{- 15.0 s^{3} - 15.0 s^{2} - 23.0 s - 8.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{10} = \\frac{- 7.0 s^{3} - 7.0 s^{2} - 11.0 s - 4.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{11} = \\frac{2.0 s^{3} + 2.0 s^{2} + 4.0 s + 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{12} = \\frac{2.0 s + 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{13} = \\frac{2.0 s}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(v_{14} = 0.0\\)\\(I_{Va} = \\frac{- 30.0 s^{6} - 60.0 s^{5} - 107.0 s^{4} - 109.0 s^{3} - 79.0 s^{2} - 40.0 s - 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{Vl} = \\frac{2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{V1} = \\frac{15.0 s^{5} + 15.0 s^{4} + 31.0 s^{3} + 16.0 s^{2} + 12.0 s + 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{La} = \\frac{30.0 s^{6} + 60.0 s^{5} + 107.0 s^{4} + 109.0 s^{3} + 79.0 s^{2} + 40.0 s + 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{Lm} = \\frac{- 15.0 s^{5} - 15.0 s^{4} - 31.0 s^{3} - 16.0 s^{2} - 12.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L1} = \\frac{- 15.0 s^{5} - 15.0 s^{4} - 31.0 s^{3} - 16.0 s^{2} - 12.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L2} = \\frac{- 8.0 s^{3} - 8.0 s^{2} - 12.0 s - 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L5} = \\frac{8.0 s^{3} + 8.0 s^{2} + 12.0 s + 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{L6} = \\frac{- 2.0 s^{2} - 2.0 s - 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{L3} = \\frac{2.0 s^{2} + 2.0 s + 2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{L4} = \\frac{2.0}{30.0 s^{7} + 90.0 s^{6} + 182.0 s^{5} + 231.0 s^{4} + 219.0 s^{3} + 135.0 s^{2} + 60.0 s + 12.0}\\)\\(I_{Ha} = \\frac{30.0 s^{6} + 60.0 s^{5} + 107.0 s^{4} + 109.0 s^{3} + 79.0 s^{2} + 40.0 s + 8.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\\(I_{Hm} = \\frac{15.0 s^{5} + 15.0 s^{4} + 31.0 s^{3} + 16.0 s^{2} + 12.0 s + 4.0}{30.0 s^{8} + 90.0 s^{7} + 182.0 s^{6} + 231.0 s^{5} + 219.0 s^{4} + 135.0 s^{3} + 60.0 s^{2} + 12.0 s}\\)\n\n\n\n24.2.1 Va current\nThe current from Va is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nVa_current_s = U[I_Va].nsimplify().simplify().expand().together()\nVa_current_s\n\n\\(\\displaystyle \\frac{- 30 s^{6} - 60 s^{5} - 107 s^{4} - 109 s^{3} - 79 s^{2} - 40 s - 8}{s \\left(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\right)}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#Va_current = inverse_laplace_transform(Va_current_s, s, t)\n#Va_current\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(Va_current_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(- 30 s^{6} - 60 s^{5} - 107 s^{4} - 109 s^{3} - 79 s^{2} - 40 s - 8\\)denominator: \\(s \\left(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\right)\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ - \\frac{8}{s \\left(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\right)}, \\  - \\frac{109 s^{2}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{107 s^{3}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{79 s}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{60 s^{4}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{40}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  - \\frac{30 s^{5}}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nVa_current = np.zeros(len(x),dtype = complex)\nfor p in N:\n    Va_current += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Current vs time')\n\nplt.plot(x, np.real(Va_current),label='I_Va(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n24.2.2 Node 12 voltage\nThe voltage at node 12 is symplified with the chain of operators applied to the expression; nsimplify(), simplify(), expand() and together(). This helps SymPy solve the inverse Laplace transform.\n\nnode12_voltage_s = U[v12].nsimplify().simplify().expand().together()\nnode12_voltage_s\n\n\\(\\displaystyle \\frac{2 \\left(s + 1\\right)}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}\\)\n\n\nThe inverse Laplace was taking too long, so the lines of code were commented out\n\n#node12_voltage = inverse_laplace_transform(node12_voltage_s, s, t)\n#node12_voltage\n\nUsing NumPy to obtain the partial fraction expansion, convert back to the s domain and then take the inverse Laplace transform on each term.\nExtract the numerator and denominator and display.\n\nn, d = fraction(node12_voltage_s)\nn = n.expand()\nMarkdown('numerator: ${:s}$&lt;br&gt;denominator: ${:s}$'.format(latex(n),latex(d)))\n\nnumerator: \\(2 s + 2\\)denominator: \\(30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12\\)\n\n\nEach of the numerator terms can be put over the common denominator.\n\nterms = [a / d for a in n.args]\ndisplay(terms)\n\n\\(\\displaystyle \\left[ \\frac{2}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}, \\  \\frac{2 s}{30 s^{7} + 90 s^{6} + 182 s^{5} + 231 s^{4} + 219 s^{3} + 135 s^{2} + 60 s + 12}\\right]\\)\n\n\nThe following code processes each of the terms obtained above.\n\nN = []\n\nfor p1 in terms:\n\n    # use the SciPy residue function to get the partial-fraction expansion residues and poles\n    n, d = fraction(p1)\n    cn = Poly(n, s).all_coeffs()\n    cd = Poly(d, s).all_coeffs()\n    r, p, k = signal.residue(cn, cd, tol=0.001, rtype='avg')\n\n    # build a symbolic expression for each of the residues and find the inverse Laplace of each one and save\n    z = 0\n    for i in range(len(r)):\n        m = (r[i]/(s-p[i]))\n        z += inverse_laplace_transform(m, s, t)\n\n    N.append(z)\n\nEach of these terms came be converted to a function using SymPy’s lambdify function.\nDefine the values for the x-axis of the plot and put each one into an array for plotting.\n\nx = np.linspace(0, 50, 2000, endpoint=True)\nV_node12 = np.zeros(len(x),dtype = complex)\nfor p in N:\n    V_node12 += lambdify(t, p)(x)\n\nPlot the final combined result.\n\nplt.title('Voltage vs time')\n\nplt.plot(x, np.real(V_node12),label='v12(t)')\n#plt.plot(x, np.real(func_V1_t(x)),label='V1(t)')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mechanical Systems</span>"
    ]
  },
  {
    "objectID": "mech-sys.html#summary",
    "href": "mech-sys.html#summary",
    "title": "24  Mechanical Systems",
    "section": "24.3 Summary",
    "text": "24.3 Summary\nAs show above, when a mechanical system is drawn as an electrical schematic, MNA can be applied to obtain a solution. The procedure to express a mechanical system as an equalivent circuit is outside the scope of this book.\nHere are a few links to an interesting related video and papers:\n\nThe Genius Device That Rocked F1 | An Interview With Its Inventor\nSynthesis of Mechanical Networks: The Inerter\nThe Inerter: A Retrospective\n\n\n\n\n\nAkbaba, Mehmet, Omar Dakkak, Byung-Seo Kim, Adnan Cora, and Shahrudin Awang Nor. 2022. “Electric Circuit-Based Modeling and Analysis of the Translational, Rotational Mechanical and Electromechanical Systems Dynamics.” IEEE Access. https://doi.org/10.1109/ACCESS.2022.3185422.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mechanical Systems</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html",
    "href": "Klon Centaur part 1.html",
    "title": "25  Klon Centaur, Part 1",
    "section": "",
    "text": "25.1 Electric guitar characteristics\nThis chapter will illustrate the application of MNA, Python programming and LTSpice to an interesting circuit called the Klon Centaur. The schematics shown in this notebook were drawn using LTSpice and from those schematics, LTSpice was used to generate the netlists. Python and the MNA code was used to generate network equations from the netlists and obtain solutions for unknown voltages and currents. Transient analysis of the circuit was performed using LTSpice using device models for the diodes and Op Amps. This notebook will attempt to analyze and describe the operation of the various parts of the circuit, with the exception of the power supply.\nAs an electrical engineer, I’ve been curious about the workings of the electric guitar and the operation of the effects boxes. My motivation in writing this paper was to learn a little about the topic. I don’t play the guitar and I’m not a musician, so I’ll be looking at this topic from the point of view of signals and circuits.\nFollowing the introduction section about the characteristics of the electric guitar and associated equipment, a description of the electrical schematic and the interfaces to the circuit (knobs and jacks) is provided. There are some on-line sources that are referenced which provide an analysis of the circuit, primarily utilizing LTSpice. These analyses are interesting since the perspective is somewhat different from what is provided in this notebook. A few words are provided about current price and availability of the pedal, the Klon KTR and Klon Centaur clones.\nThe analysis provided in this notebook is a deep dive into the operation of the circuit from the perspective of traditional linear circuit analysis taught in electrical engineering schools. The focus is on circuit analysis and not circuit design. This means looking at how the circuit works, since this is what circuit analysis is all about. The designers of the Klon Centaur were looking for a particular sound or tone profile and in some places I’ll comment on reasons why the designers might have developed these circuits; but for the most part I’ll not be looking at why the circuit works in a particular way, but how it works.\nThe Klon Centaur is an overdrive pedal and the top of the pedal is shown in Figure 25.1. The Klon Centaur is widely used in many genres of music, including blues, rock and country. An overdrive pedal is a piece of electronic equipment used by guitarists to alter the sound of the guitar. It’s essentially a box containing a circuit that is connected between the guitar and the amplifier, often with other pedals in series, and these pedals control the amount of gain, distortion, tone and output level delivered to the amplifier.\nBill Finnegan, owner of Klon LLC, and the Klon Centaur creator, wanted to make a pedal that would recreate the sound of a guitar amplifier’s distortion at high volume. Finnegan wasn’t a fan of the sound of the popular Ibanez Tube Screamer, which many guitarists use for overdrive. He felt it sounded too artificial and buzzy. So he set out to create a pedal that would deliver a more natural, tube-like overdrive sound with rich harmonics. The pedal was designed to have a “big, open” sound with “a hint of tube clipping” that wouldn’t sound like it was made by a pedal. Just to clarify, Klon is the company name and Centuar is the name of the pedal and since the Klon only had one product, the product became known as the Klon Centaur. Over the production life of the Centaur, the color of the case and the centaur logo has changed.\nFinnegan worked with MIT graduate Fred Fenning and other electrical engineer friends for four and a half years to create prototype pedals. A Germanium diode was chosen by Finnegan for the circuit and he bought as many as he could, since these were a special type that he determined sounded more musical than others he tested. These diodes are no longer in production. The components of the circuit were coated in epoxy resin to make reverse engineering of the circuit more difficult. The Klon Centaur was first sold in late 1994. Finnegan personally built, tested and shipped the pedals from his house, where he was inundated with orders. Many of the components, including the cast enclosure and knobs were custom manufactured. Over the course of 15 years, Finnegan sold about 8,000 pedals. See The Klon Centaur Guide for a thorough and informative history of the Klon.\nAn electric guitar is a type of guitar that relies on electrical amplification to produce sound. Electric guitars are known for the wide variety of tones they can produce. By using effects pedals and manipulating the knobs on the guitar and amplifier, musicians can create sounds ranging from clean and bright to distorted and heavy. This versatility has made the electric guitar a popular instrument in many genres of music, including rock, blues, country and jazz.\nAn electric guitar isn’t just the guitar. While the wooden body, neck and strings are essential components, they only produce a very faint sound on their own. The essential parts for the electric guitar are:\nIn essence, the electric guitar, amplifier and speaker work together as a system to produce the rich, varied and powerful sounds that define this instrument. Each component plays a crucial role in shaping the final sound. The combination of these elements is what makes the electric guitar such a versatile and expressive instrument.\nJim Lill, a Nashville musician, has an informative series of videos exploring this topic, starting with Tested: Where Does The Tone Come From In An Electric Guitar?. The components of an electric guitar, all of which contribute to the tone are described below in more detail:",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#electric-guitar-characteristics",
    "href": "Klon Centaur part 1.html#electric-guitar-characteristics",
    "title": "25  Klon Centaur, Part 1",
    "section": "",
    "text": "The Guitar: This is where the musical performance originates. The player’s technique, the strings’ vibration and the guitar’s construction all contribute to the initial sound. However, the sound produced by the guitar alone is very quiet and lacks the power and character we associate with electric guitars.\nThe Amplifier: This electronic device takes the tiny electrical signals from the guitar’s pickups and boosts them to a much higher volume level. It also shapes the sound, adding characteristics like warmth, brightness, or distortion.\nThe Speaker: This is the final link in the chain, converting the amplified electrical signal into sound waves that we can hear. Different speakers produce different tones and the size and design of the speaker cabinet significantly impacts the overall sound.\n\n\n\n\n25.1.1 Body\nThe electric guitar body is the foundation of the instrument, providing a sturdy platform for attaching the neck, strings, pickups, electronics and bridge. Electric guitar bodies come in a wide variety of shapes, each with its own distinct look and tonal characteristics. Some of the most popular and iconic shapes include:\n\nStratocaster: Contoured double-cutaway body with three pickups. Known for its bright, twangy sound and versatility across various genres.\nTelecaster: Solid body with a single-cutaway design and typically two pickups. Known for its twangy, bright tone and bite.\nLes Paul: Solid body with a carved top, typically two humbucker pickups. Known for its warm, thick and sustain-rich tone.\nGibson SG: Solid body with a “horns” design and typically two humbucker pickups. Known for its comfortable, lightweight design and bright, punchy tone.\n\nThe type of wood used for the guitar body plays a significant role in its tone. Some of the most common body woods include:\n\nMahogany: A popular choice for both solid and semi-hollow bodies, known for its warm, woody tone with good sustain.\nAlder: A popular choice for Stratocasters and Telecasters, known for its bright, balanced tone.\nAsh: Lighter than mahogany with a brighter, more scooped tone. Often used on Fender guitars.\nBasswood: A lightweight wood often used on budget guitars, with a neutral tone that can take EQ well.\nPoplar: Another affordable wood with a neutral tone, commonly used on budget guitars.\n\nElectric guitar bodies can be constructed in two main ways:\n\nSolid body: The most common type, made from a single piece of wood or laminated pieces of wood. Offers good sustain and resonance.\nSemi-hollow body: Has a hollow core with solid wood tops and backs. Offers a warmer, more resonant tone than solid bodies, but with less sustain.\n\n\n\n25.1.2 Strings\nThe electric guitar uses pickups to convert the vibrations of the steel strings into electrical signals. There are many different types of electric guitar strings available, each with its own unique sound. Some of the most common types of strings include:\n\nRound wound strings: These are the most popular type of electric guitar string. They have a bright, clear sound and are very versatile.\nFlat wound strings: These strings have a smooth, mellow sound. They are often used by jazz guitarists.\nNickel-plated steel strings: These strings are bright and warm-sounding. They are a popular choice for many different genres of music.\nStainless steel strings: These strings are bright and have a long lifespan. They are often used by rock and metal guitarists.\n\nWhen a string is strummed or plucked, it vibrates and interactacts with the magnetic field of the pickup. The vibrations and movement of the steel string in close proximity to the ends of the magnets in the pickup cause the vibrations to be impressed on the magnetic field which causes a voltage to be induced in the wire wound around the magnets. The strings vibrate at different frequencies depending on their thickness, length and tension. The thicker the string, the lower the pitch and frequency. An electric guitar typically has six strings. The thickest string is the low E string and the thinnest string is the high E string. The fundamental of the low E string is about 80 Hz. The frequency range of interest would start at 80 Hz and go up to the sixth harmonic of the highest note on the high E string, or about 7.8kHz. Guitar Frequency Range Chart talks about using an equalized frequency range of 150 Hz up to 5 to 8 kHz. In the analysis that follows an audio range of 80 to 8kHz will be highlighted as the electric guitar audio band.\n\n\n25.1.3 Pickups\nThere are different types of pickups, each with its own sound. There are two main types of electric guitar pickups: single-coil and Humbucker.\n\nSingle-coil pickups are known for their bright, clear and often crisp sound. However, they are also susceptible to electrical hum, which is a low-level buzzing sound that can be caused by electromagnetic interference.\nHumbucker pickups are made with two coils that are wired out of phase with each other. This helps to cancel out the hum that is common with single-coil pickups. Humbuckers tend to have a thicker, fuller sound than single-coils.\n\nThe position of a pickup in the guitar also affects its sound. Pickups that are closer to the bridge tend to have a brighter sound, while pickups that are closer to the neck tend to have a warmer, fuller sound. Electric guitar pickups come in a wide variety of styles and designs, each with its own unique sound. Some of the most popular brands of electric guitar pickups include Seymour Duncan, DiMarzio, EMG and Fender.\nElectric guitar pickups typically have a high impedance, around 10kΩ, which can make them susceptible to noise pickup over long cables. Most electric guitars use passive pickups, which rely on the vibration of the strings to induce a current in the pickup coil. This results in a relatively weak signal with low output voltage.\n\n\n25.1.4 Controls\nElectric guitars typically have pickup selector switches and tone/volume knobs.\n\nPickup selector switch: This switch allows you to select which pickups will be active and sent to the amplifier. The most common types of pickup selector switches are 3-way and 5-way switches.\n\n3-way switch: This is commonly found on Gibson Les Paul guitars. It typically has positions for the bridge pickup only, neck pickup only and both pickups combined.\n5-way switch: This is commonly found on Fender Stratocaster guitars. It typically has positions for the bridge pickup only, bridge and middle pickups combined, middle pickup only, neck and middle pickups combined and neck pickup only.\n\nTone/Volume knobs: These are knobs that allow you to control the volume and tone of the signal sent from the pickups to the amplifier.\n\nVolume knob: This knob controls the overall output level of the guitar. Turning it up increases the volume and turning it down decreases the volume.\nTone knob: This knob controls the treble (high frequencies) of the signal. Turning it up allows more treble to pass through, resulting in a brighter sound. Turning it down cuts the treble, resulting in a warmer sound. Some guitars may have multiple tone knobs, allowing for independent control over the treble of different pickups.\n\n\nThese switches and knobs are crucial for shaping the electric guitar’s sound. By manipulating the pickup selection and tone/volume controls, guitarists can create a wide variety of tones, from bright and twangy to warm and thick.\n\n\n25.1.5 Amplifier\nAn electric guitar amplifier, often simply called an amp, is an electronic device that takes the weak electrical signal produced by an electric guitar’s pickups and amplifies the signal such that it can be heard through a speaker. There are two main types of electric guitar amplifiers:\n\nTube amplifiers: These classic amps use vacuum tubes to pre-amplify and power the signal. Tube amps are prized for their warm, rich sound and responsiveness to playing dynamics. However, they tend to be more expensive, heavier and more delicate than solid-state amps.\nSolid-state amplifiers: These amps use transistors to amplify the signal. Solid-state amps are generally more affordable, lighter and more durable than tube amps. They can also produce a wide variety of tones, making them versatile for many genres of music.\nModeling amps: These amps use digital technology to model the sound of classic tube amps and other effects pedals. Modeling amps are very versatile and can be a great way to get a wide variety of tones without having to buy a lot of equipment.\nCombo amps: These amps combine the amplifier and speaker in a single unit. They are typically more portable and affordable than stacks, making them a good choice for beginners and practice.\n\n\n\n25.1.6 Cabinet\nAn electric guitar cabinet, also known as a speaker cabinet or simply a cab, is an enclosure that houses one or more loudspeakers. It is an essential component of an electric guitar amplifier setup. The Cabinet is the housing that encloses the speakers. The cabinet is typically made of wood, such as plywood or MDF (medium-density fiberboard) and is designed to resonate at certain frequencies to color the sound of the speakers. There are Open-back and Closed-back cabinets. Open-back cabinets tend to produce a brighter, more airy sound, while closed-back cabinets produce a tighter, more focused sound with more bass. The number of speakers in a cabinet affects its overall volume and tone. A 4x12 cabinet with four 12-inch speakers is a popular choice for rock and metal guitarists who need a lot of volume and bottom end. A 1x12 cabinet with a single 12-inch speaker is a more portable option that is still loud enough for practice and small gigs.\n\n\n25.1.7 Tone\nThe electric guitar tone is the overall sound produced by the instrument, influenced by a combination of factors including:\n\nElectric guitar components:\n\nPickups: These magnetic devices convert the vibrations of the strings into an electrical signal.\nEffects: Electric guitar effects are electronic devices that modify the sound of an electric guitar. They can be used to create a wide variety of tones, from subtle to extreme. Effects pedals are typically individual units that are controlled by foot switches. They can be chained together to create complex effects. Multi-effects processors combine the functionality of many different pedals into a single unit.\nAmp: Tube amps are known for their warm, rich sound and responsiveness to playing dynamics, while solid-state amps are more versatile and can produce a wider variety of tones. The settings on the amplifier, such as gain, EQ and reverb, will significantly impact the overall tone.\nCabinet: An electric guitar cabinet, also known as a speaker cabinet or simply a cab, is a wooden enclosure that houses one or more loudspeakers. It is designed to project the amplified sound of an electric guitar. Guitar cabinets are passive devices, meaning that they don’t require their own power source to function. Instead, they rely on the power from an electric guitar amplifier.\n\nPlaying technique:\n\nPicking technique: How you pick the strings (pickups closer to the bridge or neck, pick attack strength) can affect the brightness, attack and overall character of the tone.\nString bending: Bending strings adds pitch variations and vibrato to your sound.\nEffects pedals: These electronic devices can add a wide variety of effects to your tone, such as distortion, overdrive, chorus, delay and reverb.\n\nMicrophone: Miking an electric guitar cab involves placing a microphone in front of the speaker cabinet to capture the sound of the amplified guitar. This technique is commonly used in live performances and studio recordings to capture the full body and character of the electric guitar tone.\nMixing console: Live performance mixing consoles, also known as live sound mixers, are electronic devices used to control and manipulate the sounds of multiple microphones and instruments during a live performance. They are the central hub of a sound system for concerts, public speeches, theatrical productions and other live events.\n\nHere are some common electric guitar tones and how they are achieved:\n\nClean tone: A bright, clear tone with minimal distortion or amplification. Achieved with low gain settings on the amp and single-coil pickups.\nOverdrive: A warmer, more saturated tone than clean, with a slight amount of grit and breakup. Achieved with higher gain settings on the amp or with overdrive pedals.\nDistortion: A heavily amplified and distorted sound, often used for rock and metal music. Achieved with high gain settings on the amp or with distortion pedals.\nBlues tone: Often characterized by a clean or slightly overdriven tone with a warm midrange emphasis. Achieved with single-coil pickups and tube amps with moderate gain settings.\n\n\n\n25.1.8 Effects\nElectric guitar effects pedals are electronic devices that alter the electrical signal of the guitar to create new and unique sounds. They are inserted between the guitar and your amplifier, allowing modification of the basic sound of the instrument in a variety of ways. There are a vast number of different effects pedals available, but some of the most common and popular types include:\n\nDistortion and overdrive pedals: These pedals add grit, saturation and sustain to the guitar sound. Distortion is generally heavier than overdrive, but both can be used to create a wide range of rock and metal tones.\nFuzz pedals: These pedals create a thick, fuzzy distortion sound that is often associated with psychedelic rock and garage rock.\nWah-wah pedals: These pedals create a vocal-like “wah-wah” sound by sweeping a band of frequencies up and down as the pedal is rocked. They are often used in funk, blues and rock music.\nDelay pedals: These pedals create echo effects by recording a short sample of the signal and then playing it back a few milliseconds later. Delay pedals can be used to add depth, space and atmosphere to the sound.\nReverb pedals: These pedals simulate the natural reverberation of sound in a room or hall. Reverb can add depth, ambience and atmosphere to the sound.\nChorus pedals: These pedals create a lush, shimmering sound by duplicating the signal and slightly detuning it. Chorus is often used to add thickness and body to clean tones.\nFlanger pedals: These pedals create a swirling, jet-like sound by splitting your signal and delaying one side slightly. Flangers are often used to add texture and movement to the sound.\nPhaser pedals: These pedals create a phasing effect by splitting the signal and feeding it through two slightly out-of-phase filters. Phasers can create a subtle warbling or pulsating sound.\nEqualizer (EQ) pedals: These pedals allow you to boost or cut specific frequencies in your signal. EQ pedals can be used to shape the tone and correct for tonal imbalances.\n\nThe Klon Centaur is a type of distortion pedal. Distortion is usually achieved by some type of nonlinear signal processing such as clipping or limiting the amplitude of the guitar signal, which creates harmonic overtones. The amount of distortion that a pedal creates puts it into a typical category or type. An overdrive pedal creates a relatively moderate amount of distortion. A pedal producing a bit more distortion is called a distortion pedal and a pedal producing an extreme amount of distortion is called a fuzz pedal.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#klon-centaur-schematic",
    "href": "Klon Centaur part 1.html#klon-centaur-schematic",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.2 Klon Centaur schematic",
    "text": "25.2 Klon Centaur schematic\nThe Klon Centaur circuit board was originally covered with a black epoxy resin to prevent people from replicating it. The community at freestompboxes.org bought a Centaur and sent it to Martin Chittum to analyze. Martin was able to remove the black epoxy resin, trace the circuit and identify all of the components. The schematic was publicly released online in April 2008. Several modifications needed to be made to the schematic, with a final corrected version released in May 2009. Martin Chittum’s Klon Centaur schematic is regarded as accurate. Production of the Klon Centaur stopped soon after Martin Chittum’s schematic was published and clones became available.\n\n\n\n\n\n\nFigure 25.2: Martin Chittum’s Klon Centaur schematic\n\n\n\nThe Op Amp U2A is configured as a summing amplifier that combines the signal from two clean paths and the path containing the diodes, D2 and D3. The paths have reactive components that are shaping the frequency response of the signal and it is not obvious how these circuits are shaping the tone. This is one reason why this pedal has a mystic surrounding it and almost a cult following.\n\n25.2.1 Klon Centaur interface\nThe Klon Centaur has a simple yet effective control layout.\n\nKnobs, these correspond to P1, P2 and P3 in the schematic, Figure 25.2.\n\nGAIN: This control significantly influences the pedal’s tone and character. At low gain settings it provides clean boost. At medium Gain Settings the overdrive is increased. At high gain setting the overdrive is more aggressive.\nTREBLE: The treble control boosts or cuts frequencies above 200Hz.\nOUTPUT: The output control on a Klon Centaur is primarily used to adjust the overall volume level of the pedal.\n\nSwitch S1 is the bypass ON or effects ON switch.\nRed LED, D1 in the schematic: illuminated when the effect is on.\n\nThe Klon Centaur uses a standard 9-volt battery as the internal power source, but also has a jack for external 9 volt power. This is indicated as BAT1 in the schematic.\nThere are three jacks on the Klon Centaur chassis, these are:\n\nIN (J1 in the schematic): The signal input. This is a standard 1/4-inch guitar input jack.\nOUT (J2 in the schematic): This is also a standard 1/4-inch output jack, used to connect the pedal to the amplifier or other effects.\n9V (The DC jack in the schematic): The Klon Centaur uses a unique 1/8” (3.5mm) mini jack power connector for external power (if a battery is not used). This is different from the standard center-negative 2.1mm barrel jack found on most pedals.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#sec-web_circuit_analysis",
    "href": "Klon Centaur part 1.html#sec-web_circuit_analysis",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.3 Klon Centaur Circuit analysis, blog/forum pages",
    "text": "25.3 Klon Centaur Circuit analysis, blog/forum pages\nThere are a variety of online sites that explain how the circuit operates, among these are:\n\nElectroSmash: This website provides a detailed breakdown of the Klon Centaur circuit, highlighting unique features and explaining how different sections contribute to the overall sound.\nKlon Centaur circuit analysis: Circuit description.\nDIYstompboxes forum: While discussions here acknowledge the complexity of the circuit and the lack of a purely mathematical approach, some users delve into specific aspects and component functions.\nBuilder Profile: Klon’s Bill Finnegan: Interview and design history.\n\nThe Klon Centaur’s design is thought to be a mixture of basic circuit design known for its blend of theoretical understandingand “ear-based” adjustments. So, while the resources above offer valuable insights, the complete picture might involve a combination of electrical theory and the designer’s experimentation. I could not find a good description of the signal path for what I’m calling the clean tone path 2, see Section 25.10.2.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#klon-centaur-price-and-availability",
    "href": "Klon Centaur part 1.html#klon-centaur-price-and-availability",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.4 Klon Centaur price and availability",
    "text": "25.4 Klon Centaur price and availability\nThe initial price of a Klon Centaur in 1994 was 225 dollars. The price increased over time and by 2007 a Klon Centaur cost 329 dollars. The price of used Klon Centaur pedals began to increase because people did not want to wait for a new one. Currently used Klon Centaurs are selling for thousands of dollars on eBay.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#the-klon-ktr-a-pedalboard-friendly-redesign",
    "href": "Klon Centaur part 1.html#the-klon-ktr-a-pedalboard-friendly-redesign",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.5 The Klon KTR: A Pedalboard-Friendly Redesign",
    "text": "25.5 The Klon KTR: A Pedalboard-Friendly Redesign\nThe Klon KTR is a redesigned version of the Klon Centaur overdrive pedal, released in 2014 by Bill Finnegan. Finnegan’s aim with the KTR was to create a pedal that retained the sound of the original Centaur while addressing some of the production and practicality issues of the original design. One of his main goals was to make the KTR easier to manufacture, so he opted for a design that could be built by a contracted manufacturing firm. This involved using surface-mount components for most of the parts, with the exception of the germanium clipping diodes. He also wanted to make the KTR more pedalboard-friendly, so he chose a smaller enclosure than the original Centaur. The KTR features a standard DC jack and a switchable buffer bypass. Importantly, Finnegan maintained the use of the original Klon Centaur germanium clipping diodes in the KTR. The KTR initially sold for $269. Finnegan included the text “Kindly remember: The ridiculous hype that offends so many is not of my making” on the pedal. The Klon KTR is no longer in production.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#klon-centaur-clones",
    "href": "Klon Centaur part 1.html#klon-centaur-clones",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.6 Klon Centaur clones",
    "text": "25.6 Klon Centaur clones\nThe Klon Centaur is a legendary overdrive pedal widely regarded as the “holy grail” of overdrive by many guitarists. There are many Klon Centaur clones available on the market that try to capture the sound of the original. Here are some of the popular Klon Centaur clones:\n\nMosky Silver Horse Overdrive Boost-Function: This is a budget-friendly option that captures the Klon Centaur’s warm overdrive sound. It has gain and sustain, making it great for solos. Prices are typically $48.\nWarm Audio Centavo Overdrive Pedal: This clone is known for its high quality and accurate reproduction of the Klon Centaur sound. It also includes a mod switch for extending the low-end response. It currently costs $179.\nTone City Bad Horse Overdrive: This is another well-regarded Klon clone that is known for its accurate sound and small size. It has a rating of 4.80 out of 5 based on 51 user reviews and currently costs $54.\nStewMac Ghost Drive Pedal Kit: This is a great option for those who want to build their own Klon clone. It has a rating of 4.91 out of 5 based on 210 user reviews and costs $125.\nMosky Golden Horse: This is a popular Klon clone that is known for its transparent overdrive sound and ease of use. It is also very compact. Prices typically are around $39.\nClown Centurion: A DIY implementation with some circuit simplification.\nNOTAKLÖN: A kit for a no-solder clone for $99.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#analysis-methodology",
    "href": "Klon Centaur part 1.html#analysis-methodology",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.7 Analysis methodology",
    "text": "25.7 Analysis methodology\n\n\n\n\n\n\nFigure 25.3: Schematic used for the Python analysis\n\n\n\nThe analysis of the circuit in Figure 25.3 will use some symbolic analysis and primarily numerical methods to solve a system of equations to obtain solutions of the node voltages. The circuit analysis relies on using Laplace transformed circuit elements. This means that the analysis is performed in the frequency domain where linear algebra and matrix inversions are used to solve for the unknown voltages and currents. This method avoids having to deal with differential equations.\nLTSpice was used to draw the schematics of the circuits and generate the netlist. This helps to ensure that the netlist is correct. The component values in the netlist were manually edited to use scientific notation and the Op Amp entries were fixed to use the Op Amp component type.\nThe analysis begins with generating the network equations from the circuit’s netlist by calling:\n\nreport, network_df, df2, A, X, Z = SymMNA.smna(net_list)\n\nThe function SymMNA.smna() is described in Chapter 4 and the source listing is shown in Appendix A.\nKey techniques used in the analysis are described in the following sections:\n\n\n25.7.1 Frequency Response Plot\nA frequency response plot is a graphical representation of how a system responds to different input frequencies. It’s a valuable tool in various fields, including engineering, audio, and signal processing. Typically, a frequency response plot shows two key characteristics of a system:\n\nMagnitude Response: This indicates how much the system amplifies or attenuates different frequencies. It’s often plotted in decibels (dB) on a logarithmic scale.\nPhase Response: This shows the phase shift introduced by the system at different frequencies. It’s usually plotted in degrees or radians.\n\nBy analyzing a frequency response plot, you can determine:\n\nBandwidth: The range of frequencies a system can process effectively.\nGain: The amount of amplification or attenuation at specific frequencies.\nPhase shift: The delay introduced by the system at different frequencies.\nResonance: Peaks in the magnitude response indicating frequencies where the system amplifies strongly.\nStability: Whether a system is stable or unstable based on the phase margin.\n\n\n\n25.7.2 The Complex Frequency Plane\nThe complex frequency plane is a two-dimensional space where complex numbers represent frequency. Unlike the real-world concept of frequency, which is a scalar value representing the rate of oscillation, complex frequency adds a dimension of complexity. It’s represented by the symbol \\(s\\) and is defined as:\n\\(s=\\sigma+j\\omega\\)\nWhere:\n\n\\(\\sigma\\) is the real part, representing exponential growth or decay.\n\\(j\\) is the imaginary unit \\(\\sqrt{-1}\\).\n\\(\\omega\\) is the imaginary part, representing the angular frequency (related to the frequency in Hertz).\n\nThe complex frequency plane is divided into four quadrants:\n\nRight half-plane (RHP): \\(\\sigma \\gt 0\\), representing exponentially growing signals.\nLeft half-plane (LHP): \\(\\sigma \\lt 0\\), representing exponentially decaying signals.\nImaginary axis: \\(\\sigma = 0\\), representing sinusoidal signals with constant amplitude.\n\nThe complex frequency plane is crucial in various fields, including:\n\nControl systems: Analyzing system stability, designing controllers.\nSignal processing: Representing signals and systems in the frequency domain.\nElectrical engineering: Analyzing circuits and systems.\nPhysics: Describing damped oscillations and resonances.\n\nBy plotting poles and zeros of a system on this plane, you can gain insights into its behavior, stability, and frequency response.\n\n\n25.7.3 Pole-Zero Diagram\nA pole–zero plot is a graphical representation of a system’s transfer function in the complex plane. It provides valuable insights into the system’s behavior, stability, and frequency response. The diagram is plotted on the complex plane, with the real part on the horizontal axis (\\(\\sigma\\)) and the imaginary part on the vertical axis (\\(j\\omega\\)).\n\nPoles: These are the values of the complex variable ‘s’ that make the transfer function infinite. They are represented by ‘x’ on the diagram.\nZeros: These are the values of ‘s’ that make the transfer function zero. They are represented by ‘o’ on the diagram.\n\n\n25.7.3.1 Relative Count of Zeros vs. Poles\nThe relative count of zeros and poles in a transfer function significantly impacts the shape of the frequency response.\n\nPoles:\n\nEach pole introduces a downward slope of -20 dB/decade. Multiple poles at the same frequency amplify this effect.\nEach pole contributes a phase shift of -90 degrees. Multiple poles at the same frequency amplify this effect.\n\n\nZeros:\n\nEach zero introduces an upward slope of +20 dB/decade. Multiple zeros at the same frequency amplify this effect.\nEach zero contributes a phase shift of +90 degrees. Multiple zeros at the same frequency amplify this effect.\n\nOverall Slope:\n\nIf the number of zeros exceeds the number of poles, the magnitude plot will have a net upward slope.\nIf the number of poles exceeds the number of zeros, the magnitude plot will have a net downward slope.\nA balanced number of zeros and poles can lead to a flat magnitude plot over certain frequency ranges.\n\nHigh-Frequency Asymptote:\n\nThe high-frequency asymptote of the magnitude plot is determined by the difference between the number of zeros and poles.\nA larger number of zeros compared to poles will result in a steeper upward slope at high frequencies.\nA larger number of poles compared to zeros will result in a steeper downward slope at high frequencies.\n\nPhase Shift:\n\nThe total phase shift at any frequency is the sum of the phase shifts contributed by each pole and zero.\nA larger number of zeros compared to poles will result in a larger positive phase shift.\nA larger number of poles compared to zeros will result in a larger negative phase shift.\n\n\nThe location of poles and zeros on the complex plane provides information about:\n\nStability: If all poles are in the left half of the plane (LHP), the system is stable. If any pole is in the right half of the plane (RHP), the system is unstable.\nFrequency response: The distance of poles and zeros from the imaginary axis affects the system’s gain and phase response at different frequencies.\nTime-domain behavior: The location of poles and zeros can influence the system’s transient response and steady-state behavior.\n\n\n\n\n25.7.4 Impulse Response\nThe impulse response of a system is its output when presented with a brief input signal called an impulse. An impulse is an idealized signal that has infinite amplitude and infinitely short duration, but with a total area of one. The impulse response can be obtained from the transfer function by using the SciPy function impulse. However, for the analysis of the Klon Centaur, I don’t find the impulse response of the transfer functions to be that informative. Using SciPy, the impulse response is easy to calculate and plot, but I couldn’t relate the shape of the impulse response back to the circuit in an intuitive way. All the impulse responses looked very similar and they were not insightful. Additionally, using the impulse response along with the convolution function did not produce correct results since the SciPy convolve and Numpy convolve functions seemed to treat the signal and circuit as a discrete time system. For this reason, the impulse of the transfer functions are not included in the analysis.\n\n\n\n25.7.5 Step response\nThe step response of a system is its output when the input is a sudden change from zero to a constant value. This constant value is often referred to as a “step” input. The system’s behavior as it transitions from its initial state to a new steady-state condition is captured by the step response.\nSeveral parameters are used to characterize a step response:\n\nRise time: The time it takes for the output to go from 10% to 90% of its final value.\nOvershoot: The maximum amount by which the output exceeds the final value.\nSettling time: The time it takes for the output to settle within a specified percentage (e.g., 2%) of the final value.\nSteady-state error: The difference between the final value of the output and the desired output.\n\nThe step response provides valuable insights into a system’s behavior:\n\nStability: A stable system will eventually reach a steady-state value.\nSpeed of response: The rise time indicates how quickly the system reacts to changes.\nDamping: Overshoot and settling time reveal information about the system’s damping characteristics.\n\nThe step response is calculated by using the SciPy function lsim, which can be used to simulate output of a continuous-time linear system from the continuous-time linear time invariant system base class. The function lsim allows us to evaluate the performance characteristics of the circuit to square wave or arbitrary input signal input.\n\n\n25.7.6 Group Delay\nGroup delay is a measure of the time delay experienced by a group of frequencies as they pass through a system. It’s essentially the rate of change of the phase response with respect to frequency. Group Delay is important for the following reasons:\n\nSignal distortion: Variations in group delay across different frequencies can cause signal distortion, affecting the quality of audio, video, and data transmission.\nSystem design: Understanding group delay is crucial for designing systems with linear phase characteristics, which minimize distortion.\nPulse propagation: In fields like optics and telecommunications, group delay affects the shape and timing of pulses.\n\nGroup delay (\\(\\tau_g\\)) is calculated as the negative derivative of the phase response (\\(\\phi\\)) with respect to angular frequency (\\(\\omega\\)):\n\\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega)}{d\\omega}\\)\nA system with a constant group delay is called a linear phase system. These systems introduce a pure time delay to all frequency components without altering their relative phase relationships, preserving the original waveform shape. According to Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe following Python modules are used in this notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\ninit_printing()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#sec-Bypass_path",
    "href": "Klon Centaur part 1.html#sec-Bypass_path",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.8 Bypass path",
    "text": "25.8 Bypass path\nThe bypass path is controlled by the effect on/off switch S1A and S1B. The effect on/off switch is a DPDT (double pole, double throw, On-On, type, which are two switches operated by the same actuator). Figure 25.4 shows the bypass signal path highlighted. When switch S1A is in the effect-on position, R27 is shorted and the wiper contact of P3 is directly connected to the output jack J2. Switch S1B controls the current in D1, a red LED (Light Emitting Diode) that indicates the position of S1A. S1B also grounds the distortion diodes D2 and D3 when the switch is in the effects off (bypass) position. However, the effects signal can still travel to the output via the connections to U2A, see Section 25.10.1 and Section 25.10.2. When S1A is in the bypass position, R26 is shorted and the bypass signal is directly connected to the output jack.\nThis is not a true bypass, since the signal is buffered by Op Amp U1A and AC coupled by C1 and C2. The bypass signal is resistively summed with the signal from the wiper terminal of P3, the output level potentiometer. S1A either shorts R26 or R27. In either case, the bypass signal or the effects signal is attenuated by 20dB or more depending on the rotational position of P3.\nThe analysis below will look at:\n\nbypass path frequency response\neffect signal leakage into bypass path\neffects path frequency response from U2B to the output\nbypass signal leakage into effects path\n\n\n\n\n\n\n\n\nFigure 25.4: Klon Centaur schematic with bypass circuit highlighted.\n\n\n\n\n25.8.1 Bypass path frequency response\nThe schematic below, Figure 25.5 shows the essential parts of the bypass circuit. We can look at this path independently of the rest of the circuit because the Op Amps, U1A and U2B, control the voltage at circuit nodes connected to their output terminals. The circuit branches that start with components C3 and R5 || C4 can be ignored when analyzing the bypass path since the voltage at this node is controlled by the output of U1A. The current from the output of U1A is the sum of currents in the branch connected to the node. Superposition allows us to analyze these other currents independently. Since we are only interested in the bypass path we can ignore the other paths while keeping in mind that when we do this the current from U1A is missing the current from the other paths, but the voltage at this node is correct. Op Amp U2B can be replaced with the voltage source, V2.\nThe signal path, either the bypass signal or the effects signal, is a high pass filter with a very low corner frequency, which essentially blocks DC and passes audio frequencies higher than about 3 Hz.\nThe operation of S1A is accounted for by changing the values of R26 and R27. Depending on the position of S1A, the value of R26 and R27 are alternatively either 0.01 or 68K \\(\\Omega\\). V1 is the bypass signal and V2 is the effects signal. From the way the schematic has been redrawn, it should be clear that both the bypass and the effects signal are always connected to the output, by either 68k or the on position switch resistance, modeled here as a 0.01 \\(\\Omega\\) resistor.\nR1 is a 10K \\(\\Omega\\) resistor and in some builds of the Klon Centaur, R1 is a wire jumper, and R2 is a 1000K \\(\\Omega\\) and connects the non-inverting input of Op Amp U1A to the virtual ground \\(V_g=4.5 V_{dc}\\) and biases the input signal to the midpoint of U1A’s power supply rails. C1 is a 100n Farad capacitor who’s function in the circuit is to block bias voltage from the virtual ground or any residual DC voltage present at the input jack, J1. R1, C1 and R2 form a high pass filter. C1 will prevent the bias voltage, \\(V_g\\), from getting to J1 and adversely affecting any equipment that plugs into J1. The Centaur schematic indicates the value of R1 as 10k \\(\\Omega\\), but the value of 10k or sometimes zero if it is a jumper, is small when compared to the value of R2, which is 1000K \\(\\Omega\\), and the high pass corner frequency controlled by the value of R1, R2 and C1 is not influenced significantly by the value of R1.\nV1 is a voltage source that represents the input signal from the guitar or another pedal. The amplitude of this signal from the guitar pickups can range from almost zero to 0.5 Volts peak to peak depending on how the guitar’s strings are strummed or plucked. The frequency range is from 80 Hz to 8 kHz.\nU1A is a TL072 Op Amp described in Section 26.1 and modeled in this section as an ideal Op Amp. The output of U1A is connected to C2, which continues the bypass path. C2 is a 4.7\\(\\mu\\) Farad capacitor together with R3, a 100k \\(\\Omega\\) resistor, forms a high pass filter who’s corner frequency is \\(\\omega=\\frac{1}{R_3C_3}\\).\nThe output of Op Amp U1A is also connected to the circuit branches of C3 and R5||C4 (|| is used to denote the parallel connection of the components) as well as C2. Since the Op Amp output is modeled as a voltage source, each of the connecting branches sees the same node voltage, labeled as node 5 below. We can employ the principle of superposition and ignore the branch currents in C3 and R5||C4. While U1A will source current equal to the sum of the connecting branch currents, the current in branches of C3 and R5||C4 doesn’t affect the node voltages along the path starting with the C2 branch. The principle of superposition is described in more detail in Section 25.10.\nThe output control, P3, is modeled as a voltage divider consisting of resistors with reference designators of Rp3a and Rp3b. The value of Rp3a is controlled by the equation \\(Rp3a=100k-R_{output}\\) and the value of Rp3b is controlled by the equation \\(Rp3b=R_{output}\\), with the variable \\(R_{output}\\) indicating the value of the potentiometer set by the rotational position of the knob.\nR4 is a 560 \\(\\Omega\\) resistor that isolates the output of U1A from any short circuits to ground that might inadvertently be connected to the output jack, J2. R28 is a 100k \\(\\Omega\\) resistor used to provide a DC path to ground to discharge any stray voltage that might be present on the output jack from external equipment. It also prevents transients from occurring when S1A is toggled. R26 and R27 are 68k \\(\\Omega\\) resistors that are alternately shorted by S1A. When the pedal is bypass mode, R26 is shorted and in the equations below, the value of R26 is set to 0.01 \\(\\Omega\\), which is the value being used in this analysis for the On resistance of S1A. In the bypass mode, R27 isolates the effects signal present at the wiper contact of P3. As described below, there is a small amount of signal leakage from the effects path into the bypass path.\nThe Output level is controlled by P3, a 100k \\(\\Omega\\) potentiometer. In the circuit analysis presented below, I’m assuming that P3 has an audio taper, also described below. This makes the output level somewhat linear to the ear as P3 is rotated. R25 is a 560 \\(\\Omega\\) resistor that isolates the output of U2B from any short circuits to ground that might inadvertently be connected to the output jack, J2. C15 is a 4.7\\(\\mu\\) Farad capacitor together with R25 and P3, form a high pass filter who’s corner frequency is \\(\\omega=\\frac{1}{R_{25} P_3 C_3}\\). V2 is a voltage source that represents the effects signal from the pedal.\nThe output of Op Amp U2B is the final amplifier in the effects signal path. In Figure 25.5, the output of U2B is replaced by V2 for analysis. The output of U2B is a voltage source and controls the voltage at node 11. When analyzing the bypass path, V2 is set to zero. Later I’ll look at the leakage of the effects signal into the bypass path by setting V1 to zero and examining the transfer function from V2 to node 2, the output.\n\n\n\n\n\n\nFigure 25.5: The LTSpice schematic of the bypass path which generated the netlist.\n\n\n\n\n25.8.1.1 Symbolic solution\nThe following section of this notebook presents calculations that are used to find the poles and zeros of the system using symbolic calculations. This allows us to determine which components influence the values of the poles and zeros. The netlist for the schematic in Figure 25.5 was generated by LTSpice and shown below. Notice that the value of the Level control potentiometer is set in a position where the values of Rp3a and Rp3b are equal and have a value of 5k. As described later, I will assume that P3 has a logarithmic taper and this type of pot is usually called an audio pot. Notice that in the netlist, V2 is assigned a value of zero.\n\nbypass_v1_net_list = '''\n* Klon-Centaur_bypass_v1.asc\nV1 1 0 1\nR1 3 1 10e3\nR2 0 4 1000e3\nC1 4 3 100e-9\nO1a 5 4 5\nR3 6 0 100e3\nR4 7 6 560\nR28 0 2 100e3\nC2 5 6 4.7e-6\nR27 2 9 68e3\nRp3b 9 0 5e3\nRp3a 8 9 5e3\nR25 8 10 560\nC15 11 10 4.7e-6\nV2 11 0 0\nR26 2 7 0.01\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(bypass_v1_net_list)\n\nThe element values can be loaded into a Python dictionary variable.\n\nelement_values = SymMNA.get_part_values(network_df)\n\nBuild and display the network equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = v_{2} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{9}}{R_{27}} - \\frac{v_{7}}{R_{26}}\\)\\(0 = - C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}}\\)\\(0 = - C_{1} s v_{3} + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}}\\right)\\)\\(0 = C_{2} s v_{5} - C_{2} s v_{6} + I_{O1a}\\)\\(0 = - C_{2} s v_{5} + v_{6} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{7}}{R_{4}}\\)\\(0 = v_{7} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{6}}{R_{4}} - \\frac{v_{2}}{R_{26}}\\)\\(0 = v_{8} \\cdot \\left(\\frac{1}{Rp3a} + \\frac{1}{R_{25}}\\right) - \\frac{v_{9}}{Rp3a} - \\frac{v_{10}}{R_{25}}\\)\\(0 = v_{9} \\cdot \\left(\\frac{1}{Rp3b} + \\frac{1}{Rp3a} + \\frac{1}{R_{27}}\\right) - \\frac{v_{8}}{Rp3a} - \\frac{v_{2}}{R_{27}}\\)\\(0 = - C_{15} s v_{11} + v_{10} \\left(C_{15} s + \\frac{1}{R_{25}}\\right) - \\frac{v_{8}}{R_{25}}\\)\\(0 = - C_{15} s v_{10} + C_{15} s v_{11} + I_{V2}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{11}\\)\\(0 = - v_{4} + v_{5}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{5}, \\  Rp3a, \\  V_{1}, \\  R_{1}, \\  v_{2}, \\  v_{3}, \\  I_{O1a}, \\  Rp3b, \\  C_{15}, \\  R_{28}, \\  v_{7}, \\  C_{2}, \\  R_{27}, \\  R_{3}, \\  V_{2}, \\  v_{6}, \\  v_{4}, \\  v_{10}, \\  I_{V1}, \\  R_{25}, \\  v_{1}, \\  R_{26}, \\  I_{V2}, \\  C_{1}, \\  R_{4}, \\  v_{11}, \\  v_{9}, \\  R_{2}, \\  s, \\  v_{8}\\right)\\)\n\n\nThe network equations can be solved symbolically using the SymPy function, solve. The solution takes about one minute on my i3 laptop.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution.\n\n\"\"\"\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\"\"\"\n\"\"\"output too long, uncomment to display the equations\"\"\"\n\n'output too long, uncomment to display the equations'\n\n\nThe equations generated for the solution of the node voltages and unknown currents are long and not very insightful, so the code to display the equations has been commented out.\nThe voltage transfer function from the input (V1) to the output, node 2, which is the voltage across R28 is \\(H_{sym}=\\frac{v2}{v1}\\). \\(H_{sym}\\) is computed below and is used to examine the poles and zeros of a system and describe the operation of the circuit in the frequency domain.\n\nH_sym = U_sym[v2]/U_sym[v1]\n#H_sym\n\"\"\"output too long, uncomment to display the equations\"\"\"\n\n'output too long, uncomment to display the equations'\n\n\nThe numerator and denominator of \\(H_{sym}\\) are assigned to the variables sym_num and sym_denom.\n\nsym_num, sym_denom = fraction(H_sym) #returns numerator and denominator\n\nSymPy can solve for the roots of the numerator. The roots of the numerator are called the zeros of the transfer function. These correspond to the capacitors, C1, C2 and C3 which are in series along the signal paths and block the flow of DC current.\nSymPy can determine the degree of the numerator and denominator polynomials.\n\nprint('degree of numerator polynomial: {:d}'.format(int(degree(sym_num,gen=s))))\nprint('degree of denominator polynomial: {:d}'.format(int(degree(sym_denom,gen=s))))\n\ndegree of numerator polynomial: 3\ndegree of denominator polynomial: 3\n\n\n\n\n\n25.8.1.2 Numerical solution\nThe following section of this notebook presents calculations that are used to find the frequency, impulse and step response, and the poles and zeros of the bypass circuit using numerical methods.\n\n25.8.1.2.1 Output control\nThe output control is the potentiometer, P3 in Figure 25.3, and modeled as resistors, Rp3a and Rp3b in Figure 25.5. I’m going to assume that this component has an audio taper similar to PTV09, which can be found at Digikey. I don’t know the actual Klon part number used for P3 and online references are not clear about the type, so the PTV09 is being used as a stand-in.\nA potentiometer is essentially a variable resistor and is usually a three-terminal component with a sliding or rotating contact that allows the resistance to be adjusted. Two terminals are fixed at the ends of a resistive element, and the third terminal is connected to a movable wiper. As the wiper is moved, the resistance between the wiper and each end terminal changes. Let’s say the pins are numbered 1, 2, and 3. Pins 1 and 3 are connected to the end points of the resistive element and pin 2 is connected to the wiper. Full CW rotation of the shaft sets the resistance between pins 1 and 3 to the value of potentiometer.\nThe following function describes the taper from the figure in the datasheet for A series tapers. Data point values for the taper were eyeballed and the curve shown below approximates the curve shown in the datasheet. The equation used for modeling the taper was obtained from the following references, Formula for Logarithmic (audio taper) pot and Modeling logarithmic potentiometer laws.\n\ndef audio_pot_10k(rotation):\n    '''\n    defines the resistance of an audio taper potentiometer as a function of rotation.\n    The value for the rotation should be a number between 0 and 100, which corresponds to 0 to 100 percent.\n    ref: 1) https://electronics.stackexchange.com/questions/304692/formula-for-logarithmic-audio-taper-pot, \n    2) https://benholmes.co.uk/posts/2017/11/logarithmic-potentiometer-laws\n    '''\n    mid = 0.2 # define the factor of resistance at the middle pot position, at the mid postion\n    # of the pot's rotation, the resistance value of the wiper will be 0.2 * 10k = 2k  \n    b = (1/mid - 1)**2 # b is the base of the exponential equation\n    a = 1/(b-1) # a is the multiple and also the offset\n    return 10e3*(a*b**(rotation/100) - a)\n\nThe plot below shows the value of resistance between pins 1 and 3 as a function of wiper position.\n\np3_value = 10e3 # full scale value of potentiometer\npotentiometer_rotation = np.linspace(0,1,51)*100\n\nplt.plot(potentiometer_rotation,audio_pot_10k(potentiometer_rotation)/1e3,'-')\n\nplt.ylabel('resistance between pins 1 and 3, k\\u03A9')\nplt.xlabel('rotational travel, %')\nplt.grid()\nplt.title('Output potentiometer taper')\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the resistance value between pins 1 and 2 is an exponential function of pot rotation. If a linear Pot was used, the spacing of the output level in some of the frequency response plots below would be compressed in a narrow dB range that didn’t look correct.\nPlot the frequency response of the bypass circuit, \\(H(s)=\\frac {v_2} {V_1}\\), for various settings of P3.\n\noutput_setting = np.array([1,25,50,75,99])\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\nfor i in range (len(output_setting)):\n    \n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i])\n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n\n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n    \n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n    \n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.set_ylim((-0.5,0))\nax1.grid()\nplt.title('Magnitude and phase response at various rotational positions')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.6: Bypass path magnitude and phase response\n\n\n\n\n\nThe plot above shows the frequency response for the bypass circuit. The highlighted frequency range of 80 to 8,000 Hz is the audio range of a typical electric guitar. The gain is flat across this range and there is a small amount of insertion loss of about 0.2 dB across the guitar audio band. P3 has only a very small effect on the gain. The annotation for the plot shows the position of P3 at various rotation displacements from 1 to 99 percent.\n\n\n\n25.8.1.3 Pole / zero plot\nThe following calculations solve for the pole and zero locations for the bypass circuit with the wiper position on P3 set to \\(5k\\Omega\\).\n\n# output_setting = 50%, knob position as a percent of full rotation\nelement_values[Rp3a] = 5e3\nelement_values[Rp3b] = 5e3\n\nThe element values are substituted into the equations, solutions are obtained and the ratio \\(H = \\frac {v_2}{v_1}\\) is formulated. Then the coefficients of the numerator and denominator polynomials are saved to variables a and b.\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nUse the SciPy function TransferFunction to represent the system as the continuous-time transfer function.\n\nsys_tf = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above and printed below, there are three zeros and three poles in the transfer function. The plotted position of the poles and zeros are in units of radian frequency. There are two zeros at 0 Hz and one at 3.3 Hz. The position of zeros at 0 Hz indicates that the transfer function is a high pass filter and the equal count of poles and zeros indicate the system has a flat frequency response over some frequencies. The pole zero pair near 3.3 Hz tend to cancel since they are very close in frequency. The system zeros stem from C1 and C2, which block the direct current path. One of the system poles stems from C1 , R1 and R2. The other system pole stems from C2 and primarily R3.\nThe following cells print the zero and pole values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 3\nz0: -3.31 Hz\nz1: 0.00 Hz\nz2: 0.00 Hz\nnumber of poles: 3\np0: -3.34 Hz\np1: -1.58 Hz\np2: -1.12 Hz\n\n\n\n\n25.8.1.4 Step response\nThe step response of the is calculated using the SciPy function lsim, which can be used to simulate output of a continuous-time linear system from the continuous-time linear time invariant system base class. The function lsim allows us to evaluate the performance characteristics of the circuit to square wave input. A square wave with a frequency of 500 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\nIf we didn’t already know from the schematic that the bypass path is AC coupled, the step response would show us that for large values of time, the response is zero, therefore DC is being blocked. The input signal for the step response is 0.1 volt step. The circuit responds to the rising edge of the square wave and tracks the leading edge of the input. This is because at time zero, the capacitors in the circuit are at their initial condition which is zero volts. At this instant, the output voltage is almost 0.1 volts, since the value of the resistors along the path don’t present much of a voltage divider. As time increases, the voltage on the capacitors will approach their final values according to Kirchhoff’s Current Law, which results in a final output voltage of zero for time greater than about one second.\n\n# define the time interval and create a square wave step waveform.\nt = np.linspace(0, 5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*0.5*t, duty=0.5)/20+1/20\n\n# call lsim to generate the response signal\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth = 1.0, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe square wave response shows about 10% overshoot and a settling time of about 1 second with no ringing. This is a result of series connection of C1 and C2 in the path which equate to a zero at DC and two low frequency poles at 1.1 and 1.6 Hz. The location of these poles result from the relatively large time constants produced by C2 and R3 as well as from C15 and R28.\nYou would expect the transient step response to be an exponential decay function, asymptotically approaching zero volts. The bypass network has three capacitors, C1, C2 and C15. This makes the circuit a third order system. From the plot above, we can see that there is some overshoot, but no ringing in the step response. This implies that the damping ratio is between 0.7 and 1. We can approximate the damping ratio by considering the two dominant poles of the system and ignoring the highest frequency pole.\nAs calculated above, the transfer function of the bypass circuit for P3 at 50% is \\(H(s)\\).\n\nH\n\n\\(\\displaystyle \\frac{1.0 \\cdot \\left(2.31889927274817 \\cdot 10^{77} s^{3} + 4.82878561580902 \\cdot 10^{78} s^{2}\\right)}{2.37377342819845 \\cdot 10^{77} s^{3} + 9.00095037426057 \\cdot 10^{78} s^{2} + 1.00954261077259 \\cdot 10^{80} s + 3.47583640381444 \\cdot 10^{80}}\\)\n\n\nAs calculated above, the system poles are:\n\nprint(sys_poles)\n\n[-20.9622128   -9.9009901   -7.05511848]\n\n\nWe can have NumPy to generate the system polynomial.\n\nsys_poly = np.poly(sys_poles)\nprint(sys_poly)\n\n[1.00000000e+00 3.79183214e+01 4.25290215e+02 1.46426629e+03]\n\n\nNormalize the system polynomial on the second order term by dividing the polynomial coefficients by the second order coefficient.\n\nnorm_sys_poly = sys_poly/sys_poly[1]\nprint(norm_sys_poly)\n\n[2.63724755e-02 1.00000000e+00 1.12159557e+01 3.86163267e+01]\n\n\nThis puts the pronominal into the form:\n\\(as^3 + s^{2}+\\frac {\\omega _N}{Q}s + \\omega _N^2\\)\nWe are going to ignore the \\(as^3\\) term and only consider the other terms:\n\\(s^{2}+\\frac {\\omega _N}{Q}s + \\omega _N^2\\)\nThe natural frequency can be found from the last term in the normalized system polynomial.\n\nw_n = np.sqrt(norm_sys_poly[3])\nw_n\n\n\\(\\displaystyle 6.21420362662557\\)\n\n\nThe damping ratio can be found solving for the damping ratio, \\(\\delta\\), in the equation:\n\\(\\frac {\\omega _N}{Q} = 2 \\delta \\omega _N\\)\n\ndamp_ratio = norm_sys_poly[2]/(2*w_n)\nprint('damping ratio = {:.2f}'.format(damp_ratio))\n\ndamping ratio = 0.90\n\n\nThe damping ratio is less than between 0.7 and 1, leading to the behavior shown in the step response.\nThe transient behavior of the circuit in Figure 25.5 with a square wave input was simulated in LTSpice and the results are a close match with the Python results as shown in the plot below.\n\nfn = 'Klon-Centaur_bypass_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\nCopy the data from the csv file into NumPy arrays.\n\n# initialize some empty arrays\ntime = np.zeros(len(LTSpice_data))\nvoltage1 = np.zeros(len(LTSpice_data))\nvoltage2 = np.zeros(len(LTSpice_data))\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    time[i] = LTSpice_data[i][0]\n    voltage1[i] = LTSpice_data[i][1]\n    voltage2[i] = LTSpice_data[i][2]\n\nPlot the LTSpice data and the Python data to see if they agree.\n\nplt.title('LTSpice')\n\n#plt.plot(time, voltage1, 'g', alpha = 1.0, linewidth=1, label='LTSpice v1(t)')\nplt.plot(time, voltage2, '-.r', alpha = 1.0, linewidth=2, label='LTSpice v2(t)')\n\n#plt.plot(t_step, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', alpha = 1.0, linewidth = 1.0, label='Python result')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, there is a one to one correspondence.\n\n\n25.8.1.5 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,2))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.\n\n\n25.8.1.6 Effect signal leakage into bypass path\nThe frequency response plot below shows the signal gain from the effects path into the output when the switch is in the bypass position. The transfer function, \\(H(s)=\\frac {v_2} {v_{11}}\\), is plotted for various settings of P3, with \\(V_1=0\\), \\(R_{26}=68k\\Omega\\) and \\(R_{27}=0.01\\Omega\\). Since the bypass switch doesn’t break the connection between the bypass and effects path, it is informative to look at the leakage of one path into the other.\n\nelement_values[V1] = 0\nelement_values[V2] = 1\nelement_values[R26] = 0.01\nelement_values[R27] = 68e3\n\noutput_setting = np.array([1,25,50,75,99])\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\nfor i in range(len(output_setting)):\n    \n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i])\n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v11]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.7: Effect signal leakage into bypass path magnitude and phase response\n\n\n\n\n\nThe plot above shows that the effects signal is isolated from the bypass signal by more than 40 dB over the audio band of the guitar.\n\n\n\n25.8.2 Effects path output frequency response\nThe signal through the effects path is analyzed from C15 to the output at J2. In Figure 25.5, the output of U2A is replaced by \\(V_2\\) at node 11. The frequency response for the transfer function, \\(H(s)=\\frac{v_2}{v_{11}}\\) is plotted below. \\(V_1\\) has been set to zero, \\(R_{26}=68k\\Omega\\) and \\(R_{27}=0.01\\Omega\\)\n\nelement_values[V1] = 0\nelement_values[V2] = 1\nelement_values[R26] = 68e3\nelement_values[R27] = 0.01\n\noutput_setting = np.array([1,25,50,75,99])\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\nfor i in range(len(output_setting)):\n\n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i])\n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v11]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.8: Effect output path magnitude and phase response\n\n\n\n\n\nThe gain of the output circuit for the effects path can be adjusted by P3 to have a gain of a bit less than 0 dB to about -55 dB.\n\n25.8.2.1 Poles and zeros\nSetting the wiper position of P3 to a position that puts \\(5k\\Omega\\) on each side of the wiper, the poles and zeros for the output circuit are calculated.\n\n# output_setting = 50%, knob position as a percent of full rotation\nelement_values[Rp3a] = 5e3\nelement_values[Rp3b] = 5e3\n\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v11]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted below. As indicated in the legend, the location of the zeros are marked with blue circles and the location of the poles are marked with red x’s.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nIn the plot above, the units of frequency are in radians, cycles per 1 radian, or \\(2\\pi\\) degrees. There is a zero at 0 Hz, which is from C15. The second zero is from C2. The two poles are also from C15 and C2 combined with various resistors in the network.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 2\nz0: -0.83 Hz\nz1: 0.00 Hz\nnumber of poles: 2\np0: -3.40 Hz\np1: -0.80 Hz\n\n\n\n\n25.8.2.2 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 500 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*0.5*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero. There is a relatively small spike in the output at each square wave edge. The step response of this path could be explored in more detail during prototype testing.\n\n\n25.8.2.3 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,2))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.\n\n\n25.8.2.4 Bypass signal leakage into effects path\nThe frequency response of the bypass signal leakage into the effects path is shown below. The bypass switch is simulated by setting the values of \\(R_{26}\\) and \\(R_{27}\\)\n\nelement_values[V1] = 1\nelement_values[V2] = 0\nelement_values[R26] = 68e3\nelement_values[R27] = 0.01\n\noutput_setting = np.array([1,25,50,75,99])\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(output_setting)):\n\n    element_values[Rp3a] = p3_value - audio_pot_10k(output_setting[i]) \n    element_values[Rp3b] = audio_pot_10k(output_setting[i])\n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude, P3 at {:.0f}%'.format(output_setting[i]))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P3 at {:.0f}%'.format(output_setting[i]))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.9: Bypass signal leakage into effects path magnitude and phase response\n\n\n\n\n\nThe gain of the output circuit for the bypass path to the output with the bypass switch off varies as a function of P3 position. As shown above the maximum leakage for the values plotted is at a rotational position of 75%.\nThe signal leakage into the other path, while not zero, is very small and not a concern.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#treble-control",
    "href": "Klon Centaur part 1.html#treble-control",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.9 Treble control",
    "text": "25.9 Treble control\nThe treble control circuit is highlighted in the schematic below and can be analyzed independently from the rest of the Klon Centaur circuit if we consider the sub circuit from the output of U2A to the output of U2B. The isolation and buffering provided by the Op Amp allows us to analyze this part of the pedal without having to consider other parts of the circuit.\n\n\n\n\n\n\nFigure 25.10: Schematic of Klon Centaur treble circuit highlighted.\n\n\n\nThe circuit for the treble control was drawn using LTSpice and shown below. The treble control allows the frequency response of the pedal to be adjusted. The treble circuit resembles the treble portion of the classic Baxandall tone control circuit. As shown in the circuit analysis below, the circuit can cut or boost the treble frequencies with a single potentiometer control. The capacitor, C14, is connected from the inverting terminal of U2B to the wiper contact of potentiometer P2. This places a frequency dependent negative feedback network around the Op Amp.\nThere are several interesting online references for audio tone control circuits:\n\ntone circuit calculator\nAmplifier Controls\nAudio Tone Control Using The TLC074 Operational Amplifier\nJames tone stack\nJames Tone Stack - Analysis\n\n\n\n\n\n\n\nFigure 25.11: LTSpice schematic of the treble circuit.\n\n\n\nV1 is the input signal for circuit and for frequency analysis the value is 1.\nTwo resistors, R21, a 1.8K \\(\\Omega\\) resistor and R23, a 4.7K \\(\\Omega\\) resistor, sit on either side of the treble potentiometer and skew the treble control towards treble boost at the control mid point of rotation, since R21 is a lower value. R21 and R23 also limit the amount of boost and cut provided by the treble circuit.\nR22 is a 100K \\(\\Omega\\) resistor and with R241 sets the DC gain of the Op Amp circuit.\nThe treble control, potentiometer P2, is modeled as a voltage divider consisting of resistors with reference designators of Rp2a and Rp2b. The value of Rp2a is controlled by the equation \\(Rp2a=10k-R_{treble}\\) and the value of Rp2b is controlled by the equation \\(Rp2b=R_{treble}\\), with the variable \\(R_{treble}\\) indicating the value of the potentiometer set by the rotational position of the knob.\nC14 is a 3.9n Farad capacitor and one end is connected to the inverting input of the Op Amp, which is a virtual ground. The other end is connected to the wiper terminal of P2.\nR21, Rp2a and C14 form a low pass network, since C14 is shunting the input signal to the virtual ground. This puts a zero in the voltage transfer function. The output signal from the Op Amp is fed back to the inverting input through the network of R23, Rp2b and C14 and because these components put a pole in the voltage transfer function. The relative pole and zero location in the complex frequency plane determine if the circuit will provide boost or cut to the treble frequencies.\nR241 is a 100K \\(\\Omega\\) resistor in the negative feedback path of the Op Amp along with the components R23, Rp2b and C14. R241 along with R22, P2, R21 and R23 set the DC gain for the circuit.\nU2B is an ideal Op Amp in this analysis.\nLoad the net list for the treble control circuit.\n\ntreble_v2_net_list = '''\nV1 1 0 1\nR21 1 4 1.8e3\nR22 3 1 100e3\nRp2a 4 5 5e3\nRp2b 5 6 5e3\nC14 3 5 3.9e-9\nR241 2 3 100e3\nR23 2 6 4.7e3\nO2b 3 0 2\n'''\n\nCall the symbolic modified nodal analysis function to generate the network matrices and databases.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(treble_v2_net_list)\n\nBuild the network equations and display the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{22}} + \\frac{1}{R_{21}}\\right) - \\frac{v_{3}}{R_{22}} - \\frac{v_{4}}{R_{21}}\\)\\(0 = I_{O2b} + v_{2} \\cdot \\left(\\frac{1}{R_{241}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{241}} - \\frac{v_{6}}{R_{23}}\\)\\(0 = - C_{14} s v_{5} + v_{3} \\left(C_{14} s + \\frac{1}{R_{241}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{2}}{R_{241}} - \\frac{v_{1}}{R_{22}}\\)\\(0 = v_{4} \\cdot \\left(\\frac{1}{Rp2a} + \\frac{1}{R_{21}}\\right) - \\frac{v_{5}}{Rp2a} - \\frac{v_{1}}{R_{21}}\\)\\(0 = - C_{14} s v_{3} + v_{5} \\left(C_{14} s + \\frac{1}{Rp2b} + \\frac{1}{Rp2a}\\right) - \\frac{v_{6}}{Rp2b} - \\frac{v_{4}}{Rp2a}\\)\\(0 = v_{6} \\cdot \\left(\\frac{1}{Rp2b} + \\frac{1}{R_{23}}\\right) - \\frac{v_{5}}{Rp2b} - \\frac{v_{2}}{R_{23}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{3}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( Rp2b, \\  R_{22}, \\  v_{5}, \\  R_{241}, \\  V_{1}, \\  v_{2}, \\  v_{3}, \\  Rp2a, \\  I_{O2b}, \\  v_{6}, \\  v_{4}, \\  I_{V1}, \\  v_{1}, \\  R_{21}, \\  C_{14}, \\  R_{23}, \\  s\\right)\\)\n\n\nGet the element values from the network database.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n\n25.9.1 Symbolic solution\nThe network equations can be solved symbolically and the solution to the node voltages and unknown currents is displayed.\n\nU_sym = solve(NE_sym,X)\n\n# display the symbolic solution\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{14} R_{21} R_{23} R_{241} V_{1} s - C_{14} R_{21} R_{241} Rp2b V_{1} s - C_{14} R_{22} R_{23} R_{241} V_{1} s - C_{14} R_{22} R_{241} Rp2b V_{1} s - C_{14} R_{23} R_{241} Rp2a V_{1} s - C_{14} R_{241} Rp2a Rp2b V_{1} s - R_{21} R_{241} V_{1} - R_{23} R_{241} V_{1} - R_{241} Rp2a V_{1} - R_{241} Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(v_{3} = 0\\)\\(v_{4} = \\frac{C_{14} R_{22} R_{23} Rp2a V_{1} s + C_{14} R_{22} R_{241} Rp2a V_{1} s + C_{14} R_{22} Rp2a Rp2b V_{1} s - R_{21} R_{241} V_{1} + R_{22} R_{23} V_{1} + R_{22} Rp2a V_{1} + R_{22} Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(v_{5} = \\frac{- R_{21} R_{241} V_{1} + R_{22} R_{23} V_{1} + R_{22} Rp2b V_{1} - R_{241} Rp2a V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(v_{6} = \\frac{- C_{14} R_{21} R_{241} Rp2b V_{1} s - C_{14} R_{22} R_{241} Rp2b V_{1} s - C_{14} R_{241} Rp2a Rp2b V_{1} s - R_{21} R_{241} V_{1} + R_{22} R_{23} V_{1} - R_{241} Rp2a V_{1} - R_{241} Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(I_{V1} = \\frac{- C_{14} R_{21} R_{23} V_{1} s - C_{14} R_{21} R_{241} V_{1} s - C_{14} R_{21} Rp2b V_{1} s - C_{14} R_{22} R_{23} V_{1} s - C_{14} R_{22} R_{241} V_{1} s - C_{14} R_{22} Rp2b V_{1} s - C_{14} R_{23} Rp2a V_{1} s - C_{14} R_{241} Rp2a V_{1} s - C_{14} Rp2a Rp2b V_{1} s - R_{21} V_{1} - R_{22} V_{1} - R_{23} V_{1} - R_{241} V_{1} - Rp2a V_{1} - Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\\(I_{O2b} = \\frac{C_{14} R_{21} R_{23} V_{1} s + C_{14} R_{21} R_{241} V_{1} s + C_{14} R_{21} Rp2b V_{1} s + C_{14} R_{22} R_{23} V_{1} s + C_{14} R_{22} R_{241} V_{1} s + C_{14} R_{22} Rp2b V_{1} s + C_{14} R_{23} Rp2a V_{1} s + C_{14} R_{241} Rp2a V_{1} s + C_{14} Rp2a Rp2b V_{1} s + R_{21} V_{1} + R_{22} V_{1} + R_{23} V_{1} + R_{241} V_{1} + Rp2a V_{1} + Rp2b V_{1}}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\n\n\n\n\n25.9.2 Transfer function\nThe transfer function, \\(H(s)=\\frac{v_2}{v_1}\\), can be expressed in symbolic form and is displayed below.\n\nH_sym = cancel(U_sym[v2]/U_sym[v1])\nH_sym\n\n\\(\\displaystyle \\frac{- C_{14} R_{21} R_{23} R_{241} s - C_{14} R_{21} R_{241} Rp2b s - C_{14} R_{22} R_{23} R_{241} s - C_{14} R_{22} R_{241} Rp2b s - C_{14} R_{23} R_{241} Rp2a s - C_{14} R_{241} Rp2a Rp2b s - R_{21} R_{241} - R_{23} R_{241} - R_{241} Rp2a - R_{241} Rp2b}{C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + C_{14} R_{21} R_{22} Rp2b s + C_{14} R_{22} R_{23} Rp2a s + C_{14} R_{22} R_{241} Rp2a s + C_{14} R_{22} Rp2a Rp2b s + R_{21} R_{22} + R_{22} R_{23} + R_{22} Rp2a + R_{22} Rp2b}\\)\n\n\n\n\n25.9.3 DC gain\nThe gain of the treble circuit at zero frequency can be calculated by putting the component values into \\(H(s)\\) and setting \\(s=0\\) as shown below.\n\nH_sym.subs({s:0}).subs(element_values)\n\n\\(\\displaystyle -1.0\\)\n\n\nThe DC gain of the treble circuit is -1.\n\n\n25.9.4 Solve P2 position for flat treble response\nThe position of P2 that gives a flat treble response can be calculated. A flat frequency response occurs when the numerator of \\(H(s)\\) equal to the denominator. Another way of saying this is, the frequency response is flat when the system pole and zero are at the same frequency. Since \\(R_{21}\\) and \\(R_{23}\\) have different values, a flat frequency response will not occur at the rotational mid point of P2.\nIn the cells that follow, the SymPy symbols \\(P2a\\) and \\(P2b\\) are defined and are substituted into the system transfer function. This is done for two reasons, first to make it clear that we are solving for the value of P2 sections ‘a’ and ‘b’. Second, we want to substitute numerical values for the symbols and we don’t want to overwrite the values of Rp2a and Rp2b. The modified \\(H_{sym}\\) is displayed below.\n\nP2a, P2b = symbols('P2a P2b')\n\nH_sym1 = H_sym.subs({𝑅𝑝2𝑏:P2b,Rp2a:P2a})\nH_sym1\n\n\\(\\displaystyle \\frac{- C_{14} P2a P2b R_{241} s - C_{14} P2a R_{23} R_{241} s - C_{14} P2b R_{21} R_{241} s - C_{14} P2b R_{22} R_{241} s - C_{14} R_{21} R_{23} R_{241} s - C_{14} R_{22} R_{23} R_{241} s - P2a R_{241} - P2b R_{241} - R_{21} R_{241} - R_{23} R_{241}}{C_{14} P2a P2b R_{22} s + C_{14} P2a R_{22} R_{23} s + C_{14} P2a R_{22} R_{241} s + C_{14} P2b R_{21} R_{22} s + C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + P2a R_{22} + P2b R_{22} + R_{21} R_{22} + R_{22} R_{23}}\\)\n\n\nThe numerator and denominator of \\(H_{sym}\\) can be extracted and saved off as new variables, num_sym and denom_sym.\n\nnum_sym, denom_sym = fraction(H_sym1)\nnum_sym\n\n\\(\\displaystyle - C_{14} P2a P2b R_{241} s - C_{14} P2a R_{23} R_{241} s - C_{14} P2b R_{21} R_{241} s - C_{14} P2b R_{22} R_{241} s - C_{14} R_{21} R_{23} R_{241} s - C_{14} R_{22} R_{23} R_{241} s - P2a R_{241} - P2b R_{241} - R_{21} R_{241} - R_{23} R_{241}\\)\n\n\nThe root of the numerator polynomial is solved for and displayed.\n\nnum_root_sym = solve(num_sym,s)[0]\nnum_root_sym\n\n\\(\\displaystyle \\frac{- P2a - P2b - R_{21} - R_{23}}{C_{14} \\left(P2a P2b + P2a R_{23} + P2b R_{21} + P2b R_{22} + R_{21} R_{23} + R_{22} R_{23}\\right)}\\)\n\n\nDisplay the denominator polynomial.\n\ndenom_sym\n\n\\(\\displaystyle C_{14} P2a P2b R_{22} s + C_{14} P2a R_{22} R_{23} s + C_{14} P2a R_{22} R_{241} s + C_{14} P2b R_{21} R_{22} s + C_{14} R_{21} R_{22} R_{23} s + C_{14} R_{21} R_{22} R_{241} s + P2a R_{22} + P2b R_{22} + R_{21} R_{22} + R_{22} R_{23}\\)\n\n\nThe root of the denominator polynomial is solved for and displayed.\n\ndenom_root_sym = solve(denom_sym,s)[0]\ndenom_root_sym\n\n\\(\\displaystyle \\frac{- P2a - P2b - R_{21} - R_{23}}{C_{14} \\left(P2a P2b + P2a R_{23} + P2a R_{241} + P2b R_{21} + R_{21} R_{23} + R_{21} R_{241}\\right)}\\)\n\n\nNumerical values are substituted into the expressions for the roots, while leaving P2a and P2b as variables.\n\nnum_root = num_root_sym.subs(element_values)\nnum_root\n\n\\(\\displaystyle \\frac{256410256.410256 \\left(- P2a - P2b - 6500.0\\right)}{P2a P2b + 4700.0 P2a + 101800.0 P2b + 478460000.0}\\)\n\n\n\ndenom_root = denom_root_sym.subs(element_values)\ndenom_root\n\n\\(\\displaystyle \\frac{256410256.410256 \\left(- P2a - P2b - 6500.0\\right)}{P2a P2b + 104700.0 P2a + 1800.0 P2b + 188460000.0}\\)\n\n\nPymPy can be used to solve the equations:\n\\(P2_a+P2_b = 10k\\Omega\\)\n\\(numerator_{root} = denominator_{root}\\)\nRearranging the equations to put zero on the right hand side of the equal sign and using SymPy to solve for P2a nd P2b, we get:\n\nP2_a, P2_b = solve([num_root-denom_root,P2a+P2b-10000],P2a,P2b)[0]\nprint('solution: P2a = {:,.0f} and p2b = {:,.0f} ohms'.format(P2_a, P2_b))\n\nsolution: P2a = 6,450 and p2b = 3,550 ohms\n\n\nThis means that for a rotational displacement of 35.5% on P2, the treble response will be flat.\n\n\n25.9.5 Frequency response vs P2\nThe frequency response of the treble circuit as a function of P2 for selected positions is plotted below.\nFigure 25.12\n\nP2_setting = np.array([1,25,35.5,50,75,99])/100\nP2_value = 10e3\n\ntf_num_coef_list = []\ntf_denom_coef_list = []\n\ncolor_list = ['tab:blue','tab:red','tab:purple','tab:green','tab:orange','k']\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(P2_setting)):\n    element_values[Rp2a] = P2_value - P2_setting[i]*P2_value \n    element_values[Rp2b] = P2_setting[i]*P2_value \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    tf_num_coef_list.append(a)\n    tf_denom_coef_list.append(b)\n    \n    x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude, P2 at {:.0f}%'.format(P2_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase, P2 at {:.0f}%'.format(P2_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Treble magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.12: Treble path magnitude and phase response as a function of treble setting (P2). Solid lines are the magnitude responses at various settings of P2 and the dashed lines are the phase responses.\n\n\n\n\n\n\n\n25.9.6 Step response at P2=50%\nSetting the value of P2 to the midpoint, P2 = 50%, the transfer function is computed.\n\nP2_setting = 0.5 # percentage of rotation\n\nelement_values[Rp2a] = P2_setting*P2_value\nelement_values[Rp2b] = P2_value - P2_setting*P2_value\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 500 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.005, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*500*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal*1e3, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step*1e3,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts, mV')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response has a rather long decay time and asymptomatically approaches zero and -1 indicating the DC gain is -1.\n\n25.9.6.1 Group delay\nThe following python code calculates and plots the group delay. Notice that the scale for the vertical axis is msec.\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1e3,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((-0.25,0.25))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.\n\n\n\n25.9.7 Pole/zero locus plot\nThe plot below shows the frequency locations for the treble control pole and zero locations as a function of P2 rotation. Since the poles and zeros don’t have imaginary parts, the complex frequency is plotted on the vertical axis versus the treble control rotational position, from 1 to 99 percent. The plot provides a visual indication of how the poles and zeros change as a function P2.\n\nsym_num, sym_denom = fraction(H_sym) #returns numerator and denominator\n\np2_value = 10e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp2a] = p2_value - i*p2_value\n    element_values[Rp2b] = i*p2_value\n    num_roots.append(solve(sym_num.subs(element_values),s))\n    denom_roots.append(solve(sym_denom.subs(element_values),s))\n\nplt.plot(np.linspace(1,99,len(np.array(num_roots).flatten())),-np.array(num_roots).flatten()/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='zero')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots).flatten())),-np.array(denom_roots).flatten()/(2*np.pi)/1e3,'x-r',label='pole')\n\nplt.ylim((0,4))\nplt.legend(loc='upper left')\nplt.title('Treble control pole & zero frequency plot vs treble rotation %')\nplt.xlabel('Treble rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs P2 is rotated, the frequency location of the pole and zero move in opposite directions. At a low P2 rotation percentage, the pole has a lower frequency location than the zero, and above 35.5% rotation the pole has a higher frequency location than the zero.\nSince each zero has the effect of adding a -20 dB slope contribution to the frequency response and each pole has the effect of adding a +20 dB slope contribution to the frequency response, at low rotation percentage, there is a negative slope in the frequency response plot from the pole frequency to the zero frequency, where the slope is canceled by the zero. The designers of the Klon, either by accident or design chose to give the treble control more boost than cut over the rotational range.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#sec-effects_paths_linear_analysis",
    "href": "Klon Centaur part 1.html#sec-effects_paths_linear_analysis",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.10 Effects path linear analysis",
    "text": "25.10 Effects path linear analysis\nWhen the bypass switch, S1A/B is in the effect on position, R27 is shorted by the switch and the output jack is connected to the wiper terminal of P3 and the bypass signal is isolated by R26. The operation of the effects path is somewhat complicated and the function and purpose of some of the reactive branches in the circuit path are not obvious. The Chittum Klon Centaur schematic is shown below with parts of the circuit highlighted in different colors.\n\n\n\n\n\n\nFigure 25.13: Schematic of the Klon Centaur with the signal paths highlighted.\n\n\n\nThe red highlight is the node connected to the output of U1A. From this node, the guitar signal will travel forward in the circuit to C2, C3 and R5||C4. The path starting with C2, which is not highlighted, is the bypass path described in Section 25.8. The component, C3, also not highlighted, because it is common to the green highlighted path and the brown highlighted path, is the start of one path leading to the summing amplifier, U2A, highlighted in yellow. The inverting input of U2A is where the effects paths are summed together. Each path is described below:\n\nThe green highlighted path, which I’ve named, clean tone path 1, see Section 25.10.1, is a low pass filter with components R7 and C16. R19 can be considered part of the summing amplifier and sets the DC gain for this path with R20. One side of R7 is connected to C3 and C5||R6 and these components present a complex impedance seen by the R7 and C16 low pass filter, so we can’t just ignore these and analyze the low pass filter in isolation. C3 blocks the DC bias from the output of U1A, in addition to any other impedance effects it might be adding to the circuit’s operation.\nThe brown highlighted path, which I named, distortion path part A, see Section 25.10.3, consists of a reactive branch composed of C5||R6 and the gain control potentiometer P1B. The gain control potentiometer is a dual gang 100K \\(\\Omega\\) device. The wiper terminal of P1B is connected to ground and when P1B is fully CCW, the input to U1B is grounded, which effectively blocks the signal from traversing this path in the pedal. The operation of the reactive branches R11||C7 and R12||C8 are described below.\nThe gray highlighted path, named, distortion path part B, see Section 25.10.4, consists of DC blocking capacitors, C9 and C10, R13 and the clipping diodes D2 and D3. R13 softens the clipping action of the diodes and limits the diode current. D2 and D3 are not highlighted since they are omitted in the linear circuit analysis, described later. R16 is included in this path since it can be considered the summing input for this path. The reactive branch C11 and R15 is not highlighted since it is common to the purple highlighted path, and is connected to the left side of R16, not the inverting terminal of U2A. The interaction of the gray highlighted path and the purple highlighted path at the inverting input to U2A is not obvious and is analyzed below.\nThe purple highlighted path, named, clean tone path 2, see Section 25.10.2, consists of several reactive branches who’s function and operation is not obvious and is analyzed below. The gain control potentiometer P1A acts like a voltage divider, taking the signal from one end of C6 and attenuating the signal depending on the rotational position of the gain knob. Fully CCW, the signal at C6 is not attenuated and at the same time, the inverting input to U1B is grounded. The gain knob blends various amounts of either clean tone or distortion to the summing amplifier.\n\nThe schematic in Figure 25.14 will be used for MNA analysis. The circuit paths leading from the output of U1A are separated, with one path starting at C3. This path is connected to V1. The other path starts with R5||C4 and this path is connected to V2. A third path starts at the output of U1B and is connected to V3. The branch from the output of U1B to C9 was removed and the path terminates at node 8.\nBy using the superposition theorem, we can consider each voltage source independently and the composite result is the sum of the various results. The output of U1A is modeled as a voltage source, so the voltage at this node is determined by the voltage out U1A output. The current in each branch is determined by the impedance of each path. This allows examination of each path to see how the circuit works otherwise we would just see the composite results at node 2.\n\n\n\n\n\n\nFigure 25.14: LTSpice schematic of Klon Centaur with the sum paths driven by voltage sources.\n\n\n\nThe circuit in Figure 25.14 has two diodes, D2 and D3. These are omitted for MNA. There is no diode model supported by the MNA code so we have no choice but to ignore the diodes, which can be done when doing frequency domain analysis in the audio band. Diodes are not very frequency dependent since the junction capacitance is small, and at audio frequencies, plays a small role.\nThe diode capacitance can be ignored without too much loss in accuracy. D2 and D3 are used in the circuit to limit the amplitude of the signal from U1B. For signal amplitudes above the forward threshold voltage, the current through the diode exponentially increases with voltage. R13 limits current that U1B would need to source or sink for signal amplitudes above the diode’s threshold voltage, which limits the voltage at node 10 for large signals.\nSince we are primarily interested in examining the frequency response of the circuit paths and the V3 term cancels out in \\(H(s) = \\frac {v_2(s)}{v_{20}(s)}\\), we can treat the results of MNA as accurate for small signals without including the diodes in the circuit. See Section 26.6 and Figure 26.10 for a comparison of the LTSpice and MNA results that supports the idea of ignoring the diodes when doing frequency domain analysis.\nIn linear circuits, the principle of superposition applies, meaning that the response (voltage or current) to multiple inputs is the sum of the responses to each input applied individually. The Op Amp outputs control the voltages at the nodes they are connected to. This allows us to consider each path that originates at an Op Amp output independently and later using superposition, combine the results.\nIn the following analysis, the branches that are common to the node connected to the output of U1A are separated and replaced by voltage sources. This is shown in Figure 25.14, where \\(V_1\\), \\(V_2\\) and \\(V_3\\) drive the circuit branches. We can analyze the response from each of these sources one at a time, by setting either \\(V_1\\), \\(V_2\\) and \\(V_3\\) to one and the others to zero. The terms for the sources, \\(V_1\\), \\(V_2\\) or \\(V_3\\), cancel in the voltage transfer function, making the frequency response independent of the amplitude of the input source, with the condition that the diodes are not conducting. The analysis presented below is valid as long as the circuit remains in the linear domain.\nThe step response for each path, presented below, is calculated using a 0.1 volt square wave, which should keep the diodes in the non-conducting region. In Part 2, LTSpice will be used to examine the circuit when the diodes and possibly the Op Amp’s output are driven into the nonlinear range.\n\nDefine the frequency range for x axis to be used on all plots in this section and storage arrays for the magnitude of the frequency response. The frequency range for the x axis is 10 to 100kHz. The frequency response plots are generated for gains of 1, 10, 25, 50, 75 and 99 percent of the full scale value of the gain control potentiometer, P1, which is 100k\\(\\Omega\\). The plot colors for each gain setting are defined in the color list shown below. Arrays are declared to store the magnitude and radian frequency data for each path and each gain setting.\n\nx_axis = np.logspace(1, 5, 2000, endpoint=True)*2*np.pi\ncolor_list = ['tab:blue','tab:purple','tab:brown','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,2.5,9.75,25,50,75,99])/100\np1_value = 100e3\n\n# save the magnitude and radian frequency\nclean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\nclean_path1_w = np.zeros((len(gain_setting),len(x_axis)))\nclean_path2_mag = np.zeros((len(gain_setting),len(x_axis)))\nclean_path2_w = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathA_mag = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathA_w = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathB_mag = np.zeros((len(gain_setting),len(x_axis)))\ndiode_pathB_w = np.zeros((len(gain_setting),len(x_axis)))\n\n\n25.10.1 Clean tone path 1\n\n\n\n\n\n\nFigure 25.15: Klon Centaur schematic with clean tone path 1 highlighted.\n\n\n\nThe clean tone path in Figure 25.15 is highlighted. This signal path starts at the output of the input buffer Amp, U1A and runs to the output of the summing Op Amp, U2A. As described above this path can be analyzed in isolation of the other parts of the circuit based on the principle of superposition. This path starts with C3, which blocks the DC bias and forms a high pass filter blocking frequencies below the audio range. The signal in this path then continues to R7 and C16 which are a low pass filter. The branch consisting of C5 and R16 is terminated to ground when P1 is fully counterclockwise since the wiper of P1 is connected to the virtual ground. The low frequency gain of the summing amp, U2A, is determined by R7, R20 and R24.\nThe net list generated from Figure 25.14 is used for this analysis. V2 and V3 are set to zero and the transfer function from node 1 to node 2 is calculated. C5||R6 and the network surrounding U1B is included in the analysis since the impedance of these components appears along the path of interest.\nThe branch consisting of R5||C4 is the start of clean path 2. This circuit branch presents an impedance that is isolated since it is driven by V2, an ideal voltage source. C12 and R17, the other end of the clean path 2 are connected to the summing junction of U2A inverting input.\nBranch with C2 is not analyzed as part of clean path 1 since U1A output is an ideal voltage source and the current that flows from U1A into the branch containing C2 can be partitioned due to superposition.\nC13||R20 are in the feedback path of U2A. U2A is configured as an inverting summing amplifier. Pin 2 of U2A is a virtual ground since the Op Amp will keep the voltage difference between pins 2 and 3 to zero volts and pin 3 is connected to ground (as described above this is an AC ground). C13 limits the high frequency gain of U2A. This path is an AC coupled low pass filter.\n\nThe net list below has all the components of the direct and distortion paths, Figure 25.14. In the net list, the voltage sources V1, V2 and V3 are set to a value of 1. Later when we analyze various paths, some of these sources will be set to zero and by relying on the principle of superposition, we can isolate the various paths. In the net list, the diodes have been commented out.\n\n# change variable name to clean_path1_net_list\nclean_path_v3_net_list = '''\n* Klon-Centaur_clean_path_v3.asc\nV1 1 0 1\nR5 19 14 5.1e3\nR8 14 0 1.5e3\nC3 3 1 100e-9\nC4 19 14 68e-9\nC6 14 15 390e-9\nR9 15 0 1e3\nR6 4 3 10e3\nC5 4 3 68e-9\nRp1b2 14 16 50e3\nRp1a2 16 0 50e3\nRp1b1 0 4 50e3\nRp1a1 5 0 50e3\nR10 6 5 2e3\nR11 7 6 15e3\nC7 7 6 82e-9\nC8 8 7 390e-12\nR12 8 7 422e3\nR13 10 9 1e3\nC11 11 17 2.2e-9\nR15 17 16 22e3\nR17 12 16 27e3\nR18 18 16 12e3\nC12 12 18 27e-9\nR16 12 11 47e3\nR7 3 13 1.5e3\nR24 12 13 15e3\nR20 2 12 392e3\nC13 2 12 820e-12\nO1b 7 4 8\nO2a 12 0 2\n*D2 0 10 1N34A\n*D3 10 0 1N34A\nC16 13 0 1e-6\nC9 20 9 1e-6\nC10 11 10 1e-6\nV2 19 0 1\nV3 20 0 1\n'''\n\nCall the symbolic modified nodal analysis function.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(clean_path_v3_net_list)\n\nBuild and display the network equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{3} s v_{1} - C_{3} s v_{3} + I_{V1}\\)\\(0 = I_{O2a} + v_{12} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) + v_{2} \\left(C_{13} s + \\frac{1}{R_{20}}\\right)\\)\\(0 = - C_{3} s v_{1} + v_{3} \\left(C_{3} s + C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) + v_{4} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) - \\frac{v_{13}}{R_{7}}\\)\\(0 = v_{3} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) + v_{4} \\left(C_{5} s + \\frac{1}{Rp1b1} + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{5} \\cdot \\left(\\frac{1}{Rp1a1} + \\frac{1}{R_{10}}\\right) - \\frac{v_{6}}{R_{10}}\\)\\(0 = v_{6} \\left(C_{7} s + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) + v_{7} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) - \\frac{v_{5}}{R_{10}}\\)\\(0 = v_{6} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) + v_{7} \\left(C_{7} s + C_{8} s + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{8} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right) + v_{8} \\left(C_{8} s + \\frac{1}{R_{12}}\\right)\\)\\(0 = - C_{9} s v_{20} + v_{9} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{10}}{R_{13}}\\)\\(0 = - C_{10} s v_{11} + v_{10} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{9}}{R_{13}}\\)\\(0 = - C_{10} s v_{10} - C_{11} s v_{17} + v_{11} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{12}}{R_{16}}\\)\\(0 = - C_{12} s v_{18} + v_{12} \\left(C_{12} s + C_{13} s + \\frac{1}{R_{24}} + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) + v_{2} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) - \\frac{v_{13}}{R_{24}} - \\frac{v_{16}}{R_{17}} - \\frac{v_{11}}{R_{16}}\\)\\(0 = v_{13} \\left(C_{16} s + \\frac{1}{R_{7}} + \\frac{1}{R_{24}}\\right) - \\frac{v_{3}}{R_{7}} - \\frac{v_{12}}{R_{24}}\\)\\(0 = - C_{6} s v_{15} + v_{14} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) + v_{19} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) - \\frac{v_{16}}{Rp1b2}\\)\\(0 = - C_{6} s v_{14} + v_{15} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{16} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{14}}{Rp1b2} - \\frac{v_{18}}{R_{18}} - \\frac{v_{12}}{R_{17}} - \\frac{v_{17}}{R_{15}}\\)\\(0 = - C_{11} s v_{11} + v_{17} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{16}}{R_{15}}\\)\\(0 = - C_{12} s v_{12} + v_{18} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{16}}{R_{18}}\\)\\(0 = I_{V2} + v_{14} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{19} \\left(C_{4} s + \\frac{1}{R_{5}}\\right)\\)\\(0 = C_{9} s v_{20} - C_{9} s v_{9} + I_{V3}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{19}\\)\\(V_{3} = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{9}, \\  I_{V3}, \\  v_{5}, \\  R_{7}, \\  v_{13}, \\  V_{1}, \\  v_{12}, \\  R_{11}, \\  v_{14}, \\  v_{7}, \\  C_{5}, \\  C_{8}, \\  C_{10}, \\  C_{12}, \\  V_{2}, \\  v_{6}, \\  v_{10}, \\  R_{10}, \\  I_{V1}, \\  I_{O2a}, \\  R_{12}, \\  v_{1}, \\  R_{6}, \\  C_{3}, \\  C_{13}, \\  R_{5}, \\  v_{20}, \\  C_{7}, \\  R_{18}, \\  R_{8}, \\  I_{O1b}, \\  I_{V2}, \\  R_{16}, \\  s, \\  V_{3}, \\  Rp1b2, \\  C_{6}, \\  R_{17}, \\  R_{15}, \\  v_{2}, \\  v_{3}, \\  R_{9}, \\  C_{4}, \\  Rp1a1, \\  v_{16}, \\  v_{4}, \\  Rp1b1, \\  v_{15}, \\  R_{20}, \\  v_{18}, \\  R_{13}, \\  v_{19}, \\  v_{11}, \\  v_{17}, \\  Rp1a2, \\  C_{16}, \\  v_{9}, \\  C_{11}, \\  v_{8}, \\  R_{24}\\right)\\)\n\n\nConstruct a dictionary of element values.\n\nelement_values = SymMNA.get_part_values(network_df)\n\n\n25.10.1.1 Clean tone path 1 frequency response\nThe transfer function \\(H(s)=\\frac{v2}{v1}\\) is analyzed for various settings of the Gain control, P1. The gain setting is in steps of percentage of full scale, from 1 to 99 percent. The voltage sources V2 and V3 are set to zero so that the transfer function of clean tone path 1 can be examined.\n\nelement_values[V1] = 1\nelement_values[V2] = 0\nelement_values[V3] = 0\n\nThe plot below shows the frequency response of the path for various settings of P1 ranging from 1% to 99%.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    clean_path1_mag[i] = mag\n    clean_path1_w[i] = w    \n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-60,10))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.16: Clean tone path 1 magnitude and phase response\n\n\n\n\n\nThe Klon Centaur clean path 1 has a low pass profile in the guitar audio band. The path is AC coupled so there is some roll off in gain below 80 Hz. The position of P1 does not affect the gain of this path to any significant amount. There is only about 1.5 dB difference in gain between P1 being fully CW to fully CCW. The filter characteristics of peak gain, -3dB attenuation frequency and attenuation roll off for P1 setting of 50% are measured from the frequency response data using the code below.\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = clean_path1_mag[i].max()\nmax_gain_arg = clean_path1_mag[i].argmax()\nmax_gain_freq = clean_path1_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:.1f} Hz'.format(max_gain, max_gain_freq))\n\ngain_3dB_arg_offset = np.where(clean_path1_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nfreq_3dB = clean_path1_w[i][max_gain_arg+gain_3dB_arg_offset]/(2*np.pi)\nprint('-3dB frequency: {:.1f} Hz'.format(freq_3dB))\n\nprint('clean path 1 attenuation: {:.1f} dB per decade'.format(clean_path1_mag[i][1500] - clean_path1_mag[i][-1]))\n\ngain setting: 50%\nmax gain: 7.1 dB at 73.9 Hz\n-3dB frequency: 451.7 Hz\nclean path 1 attenuation: 39.9 dB per decade\n\n\nThe maximum gain of this path is 7.1 dB at 74 Hz with the gain control at 50%. As shown in the plot, the gain control does not affect the gain in this path too much. Within the guitar audio band, this path has a low pass characteristic with a -3dB frequency of 452 Hz and a roll off of about 40 dB per decade. As shown below there are two poles not canceled by zeros and this results in the 40 dB per decade roll off.\n\n\n25.10.1.2 Numerical solution for P1 at 50%\nThe analysis can be run for any setting of P1, for illustration a setting of 50% is used to generate numerical values.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(1 = v_{1}\\)\\(0 = v_{19}\\)\\(0 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{- 1.666 \\cdot 10^{36} s^{2} - 2.94 \\cdot 10^{39} s}{3.07377 \\cdot 10^{28} s^{4} + 3.8347452 \\cdot 10^{32} s^{3} + 1.324108096 \\cdot 10^{36} s^{2} + 1.3641377 \\cdot 10^{39} s + 9.5625 \\cdot 10^{40}}\\)\\(v_{3} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.822 \\cdot 10^{28} s^{2} + 1.98 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{4} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{5} = \\frac{1.56825 \\cdot 10^{37} s^{4} + 4.7313 \\cdot 10^{40} s^{3} + 4.50125 \\cdot 10^{43} s^{2} + 1.375 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{6} = \\frac{1.63098 \\cdot 10^{37} s^{4} + 4.920552 \\cdot 10^{40} s^{3} + 4.6813 \\cdot 10^{43} s^{2} + 1.43 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{7} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{8} = \\frac{1.2721644 \\cdot 10^{46} s^{5} + 7.45961435931766 \\cdot 10^{50} s^{4} + 2.18693901867302 \\cdot 10^{54} s^{3} + 2.07668666587681 \\cdot 10^{57} s^{2} + 6.37322274881527 \\cdot 10^{59} s}{1.2721644 \\cdot 10^{46} s^{5} + 2.09758384731754 \\cdot 10^{50} s^{4} + 1.10702928656076 \\cdot 10^{54} s^{3} + 2.03466134856873 \\cdot 10^{57} s^{2} + 1.21969565229069 \\cdot 10^{60} s + 8.09715639810431 \\cdot 10^{61}}\\)\\(v_{9} = 0.0\\)\\(v_{10} = 0.0\\)\\(v_{11} = 0.0\\)\\(v_{12} = 0.0\\)\\(v_{13} = \\frac{1.02 \\cdot 10^{28} s^{2} + 1.8 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{14} = 0.0\\)\\(v_{15} = 0.0\\)\\(v_{16} = 0.0\\)\\(v_{17} = 0.0\\)\\(v_{18} = 0.0\\)\\(v_{19} = 0.0\\)\\(v_{20} = 0.0\\)\\(I_{V1} = \\frac{- 1.0506 \\cdot 10^{29} s^{3} - 1.93544 \\cdot 10^{32} s^{2} - 1.53 \\cdot 10^{34} s}{1.53 \\cdot 10^{32} s^{3} + 1.4328 \\cdot 10^{36} s^{2} + 2.13344 \\cdot 10^{39} s + 1.53 \\cdot 10^{41}}\\)\\(I_{V2} = 0.0\\)\\(I_{V3} = 0.0\\)\\(I_{O1b} = \\frac{- 3.13650000000006 \\cdot 10^{40} s^{4} - 9.46260000000018 \\cdot 10^{43} s^{3} - 9.00250000000017 \\cdot 10^{46} s^{2} - 2.75000000000005 \\cdot 10^{49} s}{1.63098 \\cdot 10^{45} s^{4} + 1.6982148 \\cdot 10^{49} s^{3} + 3.87420704000001 \\cdot 10^{52} s^{2} + 2.54543933333334 \\cdot 10^{55} s + 1.70850000000001 \\cdot 10^{57}}\\)\\(I_{O2a} = \\frac{6.8 \\cdot 10^{23} s^{2} + 1.2 \\cdot 10^{27} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\nThe transfer function for the clean tone path 1 is calculated from the ratio of \\(v_{2}\\) and \\(v_{1}\\).\nThe voltage transfer function is \\(H(s)=\\frac {v_2} {v_{1}}\\):\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(- 1.666 \\cdot 10^{36} s^{2} - 2.94 \\cdot 10^{39} s\\right)}{3.07377 \\cdot 10^{28} s^{4} + 3.8347452 \\cdot 10^{32} s^{3} + 1.324108096 \\cdot 10^{36} s^{2} + 1.3641377 \\cdot 10^{39} s + 9.5625 \\cdot 10^{40}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nPole zero plot The poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above and printed below, there are two zeros and four poles in the transfer function. The zero at 0 Hz means that the direct current is blocked through this path, since the pole and zero near 0 Hz don’t quite cancel. Since the number of poles is greater than the number of zero, the transfer function is a low pass function.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 2\nz0: -280.86 Hz\nz1: 0.00 Hz\nnumber of poles: 4\np0: -1,198.55 Hz\np1: -495.13 Hz\np2: -279.87 Hz\np3: -12.02 Hz\n\n\n\n\n25.10.1.3 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 5 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*5*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero. There is a relatively large spike in the output at each square wave edge.\n\n\n25.10.1.4 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((-1,4))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.\n\n\n\n25.10.2 Clean tone path 2\n\n\n\n\n\n\nFigure 25.17: Klon Centaur schematic with clean tone path 2 highlighted.\n\n\n\nThe second clean tone path is highlighted in Figure 25.17. This circuit path, which runs from the output of the buffer amp to the output of the summing amp, U2A, is the least intuitive path in the pedal. The operation and interaction of the reactive branches with C4, C6, C11 and C12 is not very obvious. One thing to notice is that there is a DC path from the output of U1A to the inverting terminal of U2A. This will bias U2A to the DC level of the virtual ground. The DC path continues to the treble tone control circuit. V1 and V3 are set to zero and the transfer function from node 19 to node 2 is calculated.\nThe operation and purpose of this path has been discussed online in forums and web pages, see Section 25.3. None of these presented a detailed analysis to the level provided below. In this section, the path is analyzed while the input to the other paths are zero, so we can get the contribution of this path.\nThe C3 path has been partitioned since the output of U1A is an ideal voltage source and by applying superposition allows us to consider parts of the circuit independently. Since the circuit is considered a linear circuit,, the individual responses can be combined later to obtain the total response.\nThe C2 path is ignored since the circuit can be partitioned at each of the Op Amp’s outputs.\nThe C10 path is connected to the diodes and for now we can ignore the diodes since we are interested in the voltage transfer function and we assume the signal levels do not cause the diodes to conduct.\nThe components, C13||R20 and U2A, as described above, are part of an inverting low pass filter which sums the signals from the various paths.\nClean path 2 has reactive branches formed by the capacitors in the signal path or branching from the signal path. The presence of these capacitors (C4, C6, C10, C11 and C12) in the branches will produce poles and zeros in the voltage transfer function. It’s not obvious, at least to me, what is happening in this path and what the various branches are doing. We can analyze this path, setting V1 and V3 to zero in Figure 25.14 and using nodal analysis to obtain the voltage transfer function.\nLater in Section 27.3, I’ll look at the reactive branches isolated from the circuit to attempt to get some insight into the role they play in the overall operation of the circuit since the transfer function of Clean tone path 2 doesn’t provide much insight into what’s actually happening in this path; see Section 27.3.1, Section 27.3.2, Section 27.3.3 and Section 27.3.7.\n\n\n25.10.2.1 Frequency response versus P1\nThe frequency response for the clean tone path 2 for various settings of P1 is calculated and displayed below. The source \\(V_2\\) is set to one and the other sources are set to zero.\n\nelement_values[V1] = 0\nelement_values[V2] = 1\nelement_values[V3] = 0\n\nThe plot below shows the frequency response of the path for various settings of P1 ranging from 1% to 99%.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v19]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    clean_path2_mag[i] = mag\n    clean_path2_w[i] = w\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-60,20))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.18: Clean tone path 2 magnitude and phase response\n\n\n\n\n\nFrom the curves above, the clean path 2 has a low pass response with a cut off frequency about 2kHz and the gain varies from 10 dB to -30 dB controlled by the position of P1.\ndescribe filter characteristics, 3dB point, roll off, gain at 1kHz\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = clean_path2_mag[i].max()\nmax_gain_arg = clean_path2_mag[i].argmax()\nmax_gain_freq = clean_path2_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:.1f} Hz'.format(max_gain, max_gain_freq))\n\ngain_3dB_arg_offset = np.where(clean_path2_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nfreq_3dB = clean_path2_w[i][max_gain_arg+gain_3dB_arg_offset]/(2*np.pi)\nprint('-3dB frequency: {:.1f} Hz'.format(freq_3dB))\n\nprint('clean path 2 attenuation: {:.1f} dB per decade'.format(clean_path2_mag[i][1500] - clean_path2_mag[i][-1]))\n\ngain setting: 50%\nmax gain: -1.5 dB at 39.3 Hz\n-3dB frequency: 1109.2 Hz\nclean path 2 attenuation: 19.3 dB per decade\n\n\n\n\n25.10.2.2 Numerical solution for P1 at 50%\nThe transfer function for this path is solved for the case where P1 is set at a 50% rotational position.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numerical values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(0 = v_{1}\\)\\(1 = v_{19}\\)\\(0 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 0.0\\)\\(v_{2} = \\frac{- 1.26384690189495 \\cdot 10^{63} s^{5} - 3.30941715880806 \\cdot 10^{67} s^{4} - 1.76927318717644 \\cdot 10^{71} s^{3} - 3.29892164039092 \\cdot 10^{74} s^{2} - 1.88749342217544 \\cdot 10^{77} s - 7.25931088102553 \\cdot 10^{78}}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(v_{6} = 0.0\\)\\(v_{7} = 0.0\\)\\(v_{8} = 0.0\\)\\(v_{9} = \\frac{2.0138625 \\cdot 10^{55} s^{4} + 1.71863602941176 \\cdot 10^{59} s^{3} + 4.87499999999999 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{10} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 1.92002227941176 \\cdot 10^{56} s^{4} + 6.59363602941176 \\cdot 10^{59} s^{3} + 9.47058823529411 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{11} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 2.12140852941176 \\cdot 10^{56} s^{4} + 8.31227205882352 \\cdot 10^{59} s^{3} + 1.43455882352941 \\cdot 10^{63} s^{2} + 9.19117647058822 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{12} = 0.0\\)\\(v_{13} = 0.0\\)\\(v_{14} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.76830244412326 \\cdot 10^{60} s^{4} + 9.75686883763291 \\cdot 10^{63} s^{3} + 2.00756023341467 \\cdot 10^{67} s^{2} + 1.40196836955285 \\cdot 10^{70} s + 5.47822825670137 \\cdot 10^{71}}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\\(v_{15} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.57063979093177 \\cdot 10^{60} s^{4} + 5.72958732242324 \\cdot 10^{63} s^{3} + 5.3843527894717 \\cdot 10^{66} s^{2} + 2.13650902011353 \\cdot 10^{68} s}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\\(v_{16} = \\frac{4.72614965425532 \\cdot 10^{53} s^{5} + 1.34411248109 \\cdot 10^{58} s^{4} + 9.21167841492205 \\cdot 10^{61} s^{3} + 2.41846205484128 \\cdot 10^{65} s^{2} + 2.24113593696666 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{17} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 9.56082557247695 \\cdot 10^{57} s^{4} + 8.10026990741267 \\cdot 10^{61} s^{3} + 2.31064415746956 \\cdot 10^{65} s^{2} + 2.23683368415064 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{18} = \\frac{1.45868816489362 \\cdot 10^{57} s^{4} + 3.69828291543406 \\cdot 10^{61} s^{3} + 1.70166527761975 \\cdot 10^{65} s^{2} + 2.2123357321652 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{19} = 1.0\\)\\(v_{20} = 0.0\\)\\(I_{V1} = 0.0\\)\\(I_{V2} = \\frac{- 1.29871256480426 \\cdot 10^{71} s^{5} - 2.78057297595692 \\cdot 10^{75} s^{4} - 1.23998265533368 \\cdot 10^{79} s^{3} - 1.90922089398308 \\cdot 10^{82} s^{2} - 9.76878402295801 \\cdot 10^{84} s - 3.73327208955079 \\cdot 10^{86}}{7.70884347446809 \\cdot 10^{73} s^{5} + 3.67817386295305 \\cdot 10^{78} s^{4} + 4.51405215439493 \\cdot 10^{82} s^{3} + 1.00397005781958 \\cdot 10^{86} s^{2} + 6.31801858446797 \\cdot 10^{88} s + 2.45179159134104 \\cdot 10^{90}}\\)\\(I_{V3} = \\frac{2.0138625 \\cdot 10^{49} s^{5} + 1.71863602941176 \\cdot 10^{53} s^{4} + 4.87499999999999 \\cdot 10^{56} s^{3} + 4.59558823529411 \\cdot 10^{59} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(I_{O1b} = 0.0\\)\\(I_{O2a} = \\frac{5.15855878324468 \\cdot 10^{50} s^{5} + 1.35078251379921 \\cdot 10^{55} s^{4} + 7.22152321296506 \\cdot 10^{58} s^{3} + 1.34649862873099 \\cdot 10^{62} s^{2} + 7.70405478438957 \\cdot 10^{64} s + 2.96298403307165 \\cdot 10^{66}}{4.3362244543883 \\cdot 10^{55} s^{5} + 2.06897279791109 \\cdot 10^{60} s^{4} + 2.53915433684715 \\cdot 10^{64} s^{3} + 5.64733157523515 \\cdot 10^{67} s^{2} + 3.55388545376323 \\cdot 10^{70} s + 1.37913277012933 \\cdot 10^{72}}\\)\n\n\nThe transfer function for the Clean tone path 2 is calculated from the ratio of \\(v_{2}\\) and \\(v_{19}\\). There are six capacitors in the network that comprises this path, so the order of the denominator polynomial is six. The voltage transfer function is \\(H(s)=\\frac {v_2} {v_{19}}\\):\n\nH = U[v2]/U[v19]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(- 1.26384690189495 \\cdot 10^{63} s^{5} - 3.30941715880806 \\cdot 10^{67} s^{4} - 1.76927318717644 \\cdot 10^{71} s^{3} - 3.29892164039092 \\cdot 10^{74} s^{2} - 1.88749342217544 \\cdot 10^{77} s - 7.25931088102553 \\cdot 10^{78}\\right)}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n\n\n25.10.2.3 Poles and zeros\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the clean path 2 transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the poles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency. There are five zeros and six poles. There is no zero at 0 Hz. Since there are more poles than zeros, and the value of the last pole is greater than the value of the last zero, the transfer function is a low pass filter.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 5\nz0: -3,142.62 Hz\nz1: -458.92 Hz\nz2: -408.09 Hz\nz3: -151.29 Hz\nz4: -6.59 Hz\nnumber of poles: 6\np0: -4,629.79 Hz\np1: -2,545.69 Hz\np2: -495.13 Hz\np3: -231.62 Hz\np4: -180.17 Hz\np5: -6.60 Hz\n\n\n\n\n25.10.2.4 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 100 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. Since the diodes have been removed from the circuit for analysis, we can say that at these low signal amplitudes, the diodes are not active and can be ignored. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.025, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*100*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal*1e3, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step*1e3,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts, mV')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC offset is preserved and the DC gain of the path is less than -1. The DC gain can be calculated by setting the Laplace variable equal to 0.\n\nprint('DC gain: {:.2f}'.format(H.subs({s:0})))\n\nDC gain: -0.84\n\n\nThere is almost no overshoot in the response and the rise time is relatively fast, on the order of a couple milliseconds.\n\n\n25.10.2.5 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,0.2))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.\n\n\n\n25.10.3 Distortion path part A\n\n\n\n\n\n\nFigure 25.19: Klon Centaur distortion path part A schematic with the path highlighted.\n\n\n\nDistortion path part A is highlighted in Figure 25.19. There are four capacitors in this path which determine the frequency response. The signal level is also determined by the potentiometer P1B. The voltage transfer function from node 1 to node 8 is calculated below. The frequency response at node 8 shows some emphasis at 1 kHz as a function of the gain setting as seen in fig-distortion-path-part-A-freq-plot. The signal at the output of U1B, node 8, is what get clipped by the diodes. The guitar signal, already rich in harmonics, is heavily modified harmonically and amplitude limited by the diodes. In the net list the signal path at node 8 to C9 is removed and V3 is used to drive the rest of the path, because the MNA code is not modeling the diodes. So we can only look at the circuit up to that point.\nThe path starts at the output of U1A and ends at the output of U1B. The op amps isolate the path from the rest of the circuit.\nThe path starts with C3 and continues to R5||C4. The R7 & C16 branch (part of clean path 1) also connects to the C3, R5||C4 node. There are a lot of components in the circuit that connect to the path, some only tangentially, but still need to be included in the analysis.\nThe gain potentiometer, P1 is connected to the non-inverting input of U1B and the wiper of P1 is connected to the AC ground. The CCW end of P1 forms (modeled as Rp1b in Figure 25.14) a voltage divider with R6 and when P1 is fully CCW, the non-inverting input of U1B is grounded. This effectively stops the signal from traveling to U1B and the diodes.\nThe most interesting part of this path are the components in the feedback of U1B which are, R10, R11||C7, R12||C8 and P1B. These components are the main contributors to the gain and frequency response of signals in this path. It’s not obvious by inspection how these components play together, but some guesses can be made. Capacitor C3 AC couples the signal into the path, so the signals should be attenuated at very low frequencies. At high frequencies, the capacitor, C8, decreases in impedance and limits the gain of U1B. However one would need to examine the resonant frequencies of R11||C7 and R12||C8 to get an idea of what might be happening over the guitar audio band. The position of P1 complicates an intuitive inspection of the circuit’s operation and rather than guessing. To obtain some insight into the operation of the circuit, we could perform a nodal analysis of the circuit and then try to relate the dominant poles and zeros to the behavior of the circuit and to the individual components. In Section 27.3 an attempt is made to do this.\n\n25.10.3.1 Distortion path part A frequency response\nThe frequency response of the path for various settings of P1 is calculated and displayed below. The source \\(V_1\\) is set to one and the other sources are set to zero.\n\nelement_values[V1] = 1\nelement_values[V2] = 0\nelement_values[V3] = 0\n\nThe plot below shows the frequency response of the path for various settings of P1 ranging from 1% to 99%.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v8]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    diode_pathA_mag[i] = mag\n    diode_pathA_w[i] = w\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-40,40))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.20: Distortion path part A magnitude and phase response\n\n\n\n\n\nThe Klon Centaur distortion path part A has a band pass characteristic centered at 1kHz. The gain of this path at 1 kHz ranges from about -3 dB to 35 dB depending on the position of P1. Distortion path A shapes the tonal characteristics of the signal prior to the clipping diodes.\nThe frequency response for this path exhibits emphasis near 1,000 Hz for gains above 10% and starts to look like a band pass filter. The bandwidth for the filter is measured at the half-power points (gain −3 dB) and the quality factor, also called Q, is the reciprocal of the fractional bandwidth. These parameters are calculated below.\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = diode_pathA_mag[i].max()\nmax_gain_arg = diode_pathA_mag[i].argmax()\nmax_gain_freq = diode_pathA_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:,.0f} Hz'.format(max_gain, max_gain_freq))\n\nupper_3dB_arg_offset = np.where(diode_pathA_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nupper_3dB_freq = diode_pathA_w[i][max_gain_arg+upper_3dB_arg_offset]/(2*np.pi)\nprint('upper -3dB frequency: {:,.0f} Hz'.format(upper_3dB_freq))\n\nlower_3dB_arg = np.where(diode_pathA_mag[i][:max_gain_arg] &lt; max_gain - 3)[0][-1]\nlower_3dB_freq = diode_pathA_w[i][lower_3dB_arg]/(2*np.pi)\nprint('lower -3dB frequency: {:,.0f} Hz'.format(lower_3dB_freq))\n\ndiode_pathA_bw = upper_3dB_freq - lower_3dB_freq\nprint('bandwidth: {:,.0f} Hz'.format(diode_pathA_bw))\n\ndiode_pathA_q = max_gain_freq/diode_pathA_bw\nprint('Q factor: {:.1f}'.format(diode_pathA_q))\n\ngain setting: 50%\nmax gain: 12.2 dB at 1,109 Hz\nupper -3dB frequency: 2,788 Hz\nlower -3dB frequency: 464 Hz\nbandwidth: 2,323 Hz\nQ factor: 0.5\n\n\n\n\n25.10.3.2 Numerical solution for P1 at 50%\nThe transfer function for this path is solved for the case where P1 is set at a 50% rotational position.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numerical component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(1 = v_{1}\\)\\(0 = v_{19}\\)\\(0 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{- 1.666 \\cdot 10^{36} s^{2} - 2.94 \\cdot 10^{39} s}{3.07377 \\cdot 10^{28} s^{4} + 3.8347452 \\cdot 10^{32} s^{3} + 1.324108096 \\cdot 10^{36} s^{2} + 1.3641377 \\cdot 10^{39} s + 9.5625 \\cdot 10^{40}}\\)\\(v_{3} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.822 \\cdot 10^{28} s^{2} + 1.98 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{4} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{5} = \\frac{1.56825 \\cdot 10^{37} s^{4} + 4.7313 \\cdot 10^{40} s^{3} + 4.50125 \\cdot 10^{43} s^{2} + 1.375 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{6} = \\frac{1.63098 \\cdot 10^{37} s^{4} + 4.920552 \\cdot 10^{40} s^{3} + 4.6813 \\cdot 10^{43} s^{2} + 1.43 \\cdot 10^{46} s}{1.63098 \\cdot 10^{37} s^{4} + 1.6982148 \\cdot 10^{41} s^{3} + 3.87420704000001 \\cdot 10^{44} s^{2} + 2.54543933333334 \\cdot 10^{47} s + 1.70850000000001 \\cdot 10^{49}}\\)\\(v_{7} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{8} = \\frac{1.2721644 \\cdot 10^{46} s^{5} + 7.45961435931766 \\cdot 10^{50} s^{4} + 2.18693901867302 \\cdot 10^{54} s^{3} + 2.07668666587681 \\cdot 10^{57} s^{2} + 6.37322274881527 \\cdot 10^{59} s}{1.2721644 \\cdot 10^{46} s^{5} + 2.09758384731754 \\cdot 10^{50} s^{4} + 1.10702928656076 \\cdot 10^{54} s^{3} + 2.03466134856873 \\cdot 10^{57} s^{2} + 1.21969565229069 \\cdot 10^{60} s + 8.09715639810431 \\cdot 10^{61}}\\)\\(v_{9} = 0.0\\)\\(v_{10} = 0.0\\)\\(v_{11} = 0.0\\)\\(v_{12} = 0.0\\)\\(v_{13} = \\frac{1.02 \\cdot 10^{28} s^{2} + 1.8 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\\(v_{14} = 0.0\\)\\(v_{15} = 0.0\\)\\(v_{16} = 0.0\\)\\(v_{17} = 0.0\\)\\(v_{18} = 0.0\\)\\(v_{19} = 0.0\\)\\(v_{20} = 0.0\\)\\(I_{V1} = \\frac{- 1.0506 \\cdot 10^{29} s^{3} - 1.93544 \\cdot 10^{32} s^{2} - 1.53 \\cdot 10^{34} s}{1.53 \\cdot 10^{32} s^{3} + 1.4328 \\cdot 10^{36} s^{2} + 2.13344 \\cdot 10^{39} s + 1.53 \\cdot 10^{41}}\\)\\(I_{V2} = 0.0\\)\\(I_{V3} = 0.0\\)\\(I_{O1b} = \\frac{- 3.13650000000006 \\cdot 10^{40} s^{4} - 9.46260000000018 \\cdot 10^{43} s^{3} - 9.00250000000017 \\cdot 10^{46} s^{2} - 2.75000000000005 \\cdot 10^{49} s}{1.63098 \\cdot 10^{45} s^{4} + 1.6982148 \\cdot 10^{49} s^{3} + 3.87420704000001 \\cdot 10^{52} s^{2} + 2.54543933333334 \\cdot 10^{55} s + 1.70850000000001 \\cdot 10^{57}}\\)\\(I_{O2a} = \\frac{6.8 \\cdot 10^{23} s^{2} + 1.2 \\cdot 10^{27} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\nThe transfer function for the distortion path part A is calculated from the ratio of \\(v_{8}\\) and \\(v_{1}\\).\nThe voltage transfer function is \\(H(s)=\\frac {v_8} {v_{1}}\\):\n\nH = U[v8]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\cdot \\left(1.2721644 \\cdot 10^{46} s^{5} + 7.45961435931766 \\cdot 10^{50} s^{4} + 2.18693901867302 \\cdot 10^{54} s^{3} + 2.07668666587681 \\cdot 10^{57} s^{2} + 6.37322274881527 \\cdot 10^{59} s\\right)}{1.2721644 \\cdot 10^{46} s^{5} + 2.09758384731754 \\cdot 10^{50} s^{4} + 1.10702928656076 \\cdot 10^{54} s^{3} + 2.03466134856873 \\cdot 10^{57} s^{2} + 1.21969565229069 \\cdot 10^{60} s + 8.09715639810431 \\cdot 10^{61}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nPole zero plot The poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the location of poles and zeros of the transfer function plotted on the complex plane and the units are in radian frequency. The number of poles and zeros are equal. There is a zero at 0 Hz not canceled by a pole and the value of the last zero is greater than the value of the last pole. This suggests that the transfer function is a band pass filter.\nPrinting the values of the poles and zeros in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 5\nz0: -8,848.65 Hz\nz1: -234.05 Hz\nz2: -132.98 Hz\nz3: -116.71 Hz\nz4: 0.00 Hz\nnumber of poles: 5\np0: -1,198.55 Hz\np1: -967.04 Hz\np2: -279.87 Hz\np3: -166.72 Hz\np4: -12.02 Hz\n\n\n\n\n25.10.3.3 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 10 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input amplitude of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.2, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*10*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero. There is relatively a large spike in the output at each square wave edge. Might indicate that fast transients on the input get propagated to the diodes. This could be explored in more detail during prototype testing.\n\n\n25.10.3.4 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((-1,1))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.\n\n\n\n25.10.4 Distortion path part B\n\n\n\n\n\n\nFigure 25.21: Klon Centaur schematic with the distortion path part B highlighted.\n\n\n\nDistortion path part B is highlighted in Figure 25.21. This path contains the limiting diodes, D2 and D3, which are commented out of the net list since there is no diode model supported by the MNA code. C9 and C10 block the DC bias voltage from the output of U1B and the DC coming ultimately from U1A down the R5, P1A, R17 and R16 path. R13 limits the current to D2 and D3 when the signal is greater than the forward conduction voltage of the diodes and operates in the exponential part of the conduction curve. The clipping diodes when driven into conduction mode, generate additional harmonics that combine with the guitar signal, which is already rich in harmonics.\nAs described above the limiting diodes don’t affect the frequency response in a significant way, but they do control the maximum amplitude of the signal. This can be accounted for by setting V3 to 0.35 volts and looking at the response at node 2 with V1 and V2 set to zero.\nThe capacitor, C9, blocks DC at the output of U1A since this Op Amp is biased to +Vb (4.5Vdc). This keeps the D3 from being constantly forward biased, as well as allowing D2 to conduct during negative signal swings.\nR13 serves to limit the current from U1B when either D2 or D3 is forward biased by the signal.\nD2 and D3 are the Germanium diodes responsible for making the distortion desired by the guitar player. When the signal is nearly at or above the diode’s threshold, the diodes start to conduct current and this effectively limits the amplitude of the signal to about \\(\\pm 0.4\\) volts. The shape of the voltage to current curve, see Figure 26.3, determines the amplitude of each harmonic component generated.\nC10 blocks the bias voltage that is on pin 2 of U2A. Pin 3 of U2A is connected to +Vb and because the Op Amp is operating with feed back provided by R20 || C13 the voltage difference between pins 2 and 3 on U2A is zero, therefore R16 is biased at +Vb. Without C10, D3 would be continually forward biased.\nThe reactive branch formed by C11 and R15 is connected to the distortion path part B and needs to be included in the circuit analysis. The components R16, R17, R18, C11 and C12 form a PI network in this branch that is connected to the inverting terminal of U2A. It’s not obvious how these components are shaping the signal. The nodal analysis presented for this path includes these reactive paths. See Section 27.3.7 for an analysis of these branches.\nThe components, C13||R20 and U2A, as described above, are part of an inverting low pass filter which sums the signals from the various paths.\n\n25.10.4.1 Frequency response vs P1\nThe magnitude and phase response of the distortion path part B are plotted below for various setting on P1, the gain control potentiometer. The gain settings is shown as a percent of full scale rotation of the knob. The voltage sources, V1 and V2 shown in Figure 25.14 are set to zero and V3 is set to one and the transfer function \\(H(s)=\\frac{v_2}{v_{20}}\\) is plotted for various gain settings of 1% to 99%.\nAs described above, the term V3 in the transfer function gets canceled since it appears in both the numerator and denominator. So for values of V3 less than about \\(\\pm 0.3\\) volts, the diodes are not conducting and they can be ignored.\nThe Python code below sets the values of V1 = V2 = 0 and V3 = 1 in the component dictionary.\n\nelement_values[V1] = 0\nelement_values[V2] = 0\nelement_values[V3] = 1\n\nThe following Python code calculates and plots the transfer function for each value of gain setting.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v20]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    # use the bode function to calculate the magnitude and phase response\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    diode_pathB_mag[i] = mag\n    diode_pathB_w[i] = w\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((10,100e3))\nax1.set_ylim((-40,20))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\nFigure 25.22: Distortion path part B magnitude and phase response.\n\n\n\n\n\nDistortion path part B has a low pass filter characteristic. The some filter parameters at a gain setting of 50% are calculated below with the following code.\n\ni = 4 # index for 50%\nprint('gain setting: {:.0f}%'.format(gain_setting[i]*100))\n\nmax_gain = diode_pathB_mag[i].max()\nmax_gain_arg = diode_pathB_mag[i].argmax()\nmax_gain_freq = diode_pathB_w[i][max_gain_arg]/(2*np.pi)\nprint('max gain: {:.1f} dB at {:.1f} Hz'.format(max_gain, max_gain_freq))\n\ngain_3dB_arg_offset = np.where(diode_pathB_mag[i][max_gain_arg:] &lt; max_gain - 3)[0][0]\nfreq_3dB = diode_pathB_w[i][max_gain_arg+gain_3dB_arg_offset]/(2*np.pi)\nprint('-3dB frequency: {:.1f} Hz'.format(freq_3dB))\n\nprint('distortion path part B mag attenuation: {:.1f} dB per decade'.format(diode_pathB_mag[i][1500] - diode_pathB_mag[i][-1]))\n\ngain setting: 50%\nmax gain: 18.1 dB at 54.2 Hz\n-3dB frequency: 555.7 Hz\ndistortion path part B mag attenuation: 19.7 dB per decade\n\n\nThe distortion path part B has an attenuation slope of about -20 dB and a -3 dB frequency point of 555 Hz.\n\n\n25.10.4.2 Numerical solution for P1 at 50%\nThe transfer function for this path is solved for the case where P1 is set at a 50% rotational position.\n\np1_setting = 50/100 # setting the gain pot to 50%\n\nelement_values[Rp1a1] = p1_value - p1_setting*p1_value\nelement_values[Rp1b1] = p1_setting*p1_value\n\nelement_values[Rp1a2] = p1_value - p1_setting*p1_value\nelement_values[Rp1b2] = p1_setting*p1_value\n\nNE = NE_sym.subs(element_values)\n\nDisplay the network equations with component values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\\(0 = I_{O2a} + v_{12} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{2} \\cdot \\left(8.2 \\cdot 10^{-10} s + 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000666666666666667 v_{13} + v_{3} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{4} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = 0.00052 v_{5} - 0.0005 v_{6}\\)\\(0 = - 0.0005 v_{5} + v_{6} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{7} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{6} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{7} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{8} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} + v_{7} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{8} \\cdot \\left(3.9 \\cdot 10^{-10} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{20} - 0.001 v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{11} + v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{9}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{10} - 2.2 \\cdot 10^{-9} s v_{17} + v_{11} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{12}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 2.12765957446809 \\cdot 10^{-5} v_{11} + v_{12} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) - 6.66666666666667 \\cdot 10^{-5} v_{13} - 3.7037037037037 \\cdot 10^{-5} v_{16} + v_{2} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right)\\)\\(0 = - 6.66666666666667 \\cdot 10^{-5} v_{12} + v_{13} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 0.000666666666666667 v_{3}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{15} + v_{14} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{16} + v_{19} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{14} + v_{15} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{14} + 0.000205824915824916 v_{16} - 4.54545454545455 \\cdot 10^{-5} v_{17} - 8.33333333333333 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{11} - 4.54545454545455 \\cdot 10^{-5} v_{16} + v_{17} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} - 8.33333333333333 \\cdot 10^{-5} v_{16} + v_{18} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = I_{V2} + v_{14} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{19} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078431372549\\right)\\)\\(0 = I_{V3} + 1.0 \\cdot 10^{-6} s v_{20} - 1.0 \\cdot 10^{-6} s v_{9}\\)\\(0 = v_{1}\\)\\(0 = v_{19}\\)\\(1 = v_{20}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{12}\\)\n\n\nUse the SymPy’s solve function to find the node voltages and unknown currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 0.0\\)\\(v_{2} = \\frac{- 4.8116638262633 \\cdot 10^{63} s^{5} - 1.86402165198492 \\cdot 10^{68} s^{4} - 1.44698956852654 \\cdot 10^{72} s^{3} - 2.89838697892964 \\cdot 10^{75} s^{2} - 1.68943764340843 \\cdot 10^{78} s}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\\(v_{3} = 0.0\\)\\(v_{4} = 0.0\\)\\(v_{5} = 0.0\\)\\(v_{6} = 0.0\\)\\(v_{7} = 0.0\\)\\(v_{8} = 0.0\\)\\(v_{9} = \\frac{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29627373138023 \\cdot 10^{59} s^{4} + 2.81149214573178 \\cdot 10^{63} s^{3} + 6.20412190793865 \\cdot 10^{66} s^{2} + 3.81322450115202 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{10} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19836922372969 \\cdot 10^{59} s^{4} + 2.74080119229803 \\cdot 10^{63} s^{3} + 6.06858479379818 \\cdot 10^{66} s^{2} + 3.73660601392261 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{11} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19578429076426 \\cdot 10^{59} s^{4} + 2.73101074153298 \\cdot 10^{63} s^{3} + 5.99789384036444 \\cdot 10^{66} s^{2} + 3.60106889978214 \\cdot 10^{69} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{12} = 0.0\\)\\(v_{13} = 0.0\\)\\(v_{14} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 1.6734375 \\cdot 10^{60} s^{3} + 2.34375 \\cdot 10^{63} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{15} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 9.14062499999999 \\cdot 10^{59} s^{3}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{16} = \\frac{1.00693125 \\cdot 10^{54} s^{5} + 3.35690238970588 \\cdot 10^{58} s^{4} + 1.275328125 \\cdot 10^{62} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{17} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 1.46177548394608 \\cdot 10^{59} s^{4} + 4.04388334558824 \\cdot 10^{62} s^{3} + 2.77738425925926 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{18} = \\frac{3.1078125 \\cdot 10^{57} s^{4} + 9.40160845588234 \\cdot 10^{61} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(v_{19} = 0.0\\)\\(v_{20} = 1.0\\)\\(I_{V1} = 0.0\\)\\(I_{V2} = \\frac{2.0138625 \\cdot 10^{49} s^{5} + 1.71863602941176 \\cdot 10^{53} s^{4} + 4.87499999999999 \\cdot 10^{56} s^{3} + 4.59558823529411 \\cdot 10^{59} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\\(I_{V3} = \\frac{- 2.58493296542554 \\cdot 10^{53} s^{5} - 9.79045076505435 \\cdot 10^{57} s^{4} - 7.06909534337431 \\cdot 10^{61} s^{3} - 1.35537114140466 \\cdot 10^{65} s^{2} - 7.66184872294075 \\cdot 10^{67} s}{4.81802717154256 \\cdot 10^{57} s^{5} + 2.29885866434566 \\cdot 10^{62} s^{4} + 2.82128259649683 \\cdot 10^{66} s^{3} + 6.27481286137239 \\cdot 10^{69} s^{2} + 3.94876161529248 \\cdot 10^{72} s + 1.53236974458815 \\cdot 10^{74}}\\)\\(I_{O1b} = 0.0\\)\\(I_{O2a} = \\frac{1.96394441888298 \\cdot 10^{54} s^{5} + 7.60825164075479 \\cdot 10^{58} s^{4} + 5.90607987153688 \\cdot 10^{62} s^{3} + 1.18301509344067 \\cdot 10^{66} s^{2} + 6.89566385064667 \\cdot 10^{68} s}{4.3362244543883 \\cdot 10^{58} s^{5} + 2.06897279791109 \\cdot 10^{63} s^{4} + 2.53915433684715 \\cdot 10^{67} s^{3} + 5.64733157523515 \\cdot 10^{70} s^{2} + 3.55388545376323 \\cdot 10^{73} s + 1.37913277012933 \\cdot 10^{75}}\\)\n\n\nThe transfer function for the distortion path part B is calculated from the ratio of \\(v_{2}\\) and \\(v_{20}\\).\nThe voltage transfer function is \\(H(s)=\\frac {v_2} {v_{20}}\\):\n\nH = U[v2]/U[v20]\nH\n\n\\(\\displaystyle \\frac{1.0 \\left(- 4.8116638262633 \\cdot 10^{63} s^{5} - 1.86402165198492 \\cdot 10^{68} s^{4} - 1.44698956852654 \\cdot 10^{72} s^{3} - 2.89838697892964 \\cdot 10^{75} s^{2} - 1.68943764340843 \\cdot 10^{78} s\\right)}{8.7114749288661 \\cdot 10^{58} s^{6} + 4.42758037940265 \\cdot 10^{63} s^{5} + 6.39426906142035 \\cdot 10^{67} s^{4} + 2.72152037399421 \\cdot 10^{71} s^{3} + 4.243557822183 \\cdot 10^{74} s^{2} + 2.24888518595392 \\cdot 10^{77} s + 8.61957981330834 \\cdot 10^{78}}\\)\n\n\nThe coefficients for the numerator and denominator polynomials extracted using the following code.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\n\n\n25.10.4.3 Pole zero plot\nThe poles and zeros of the voltage transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above and the calculations below show that there are five zeros and six poles in the transfer function. Many of the poles and zeros are nearly at the same frequency, so they cancel. There is a zero at 0 Hz, because the path has no direct DC path from input to output. The poles near 500 Hz and 2,500 Hz along with the zero near 1,000 Hz determine the low pass shape of the path’s frequency response.\nPrinting the pole and zero values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in range(len(sys_zeros)):\n    print('z{:d}: {:,.2f} Hz'.format(i,sys_zeros[i]/(2*np.pi)))\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in range(len(sys_poles)):\n    print('p{:d}: {:,.2f} Hz'.format(i,sys_poles[i]/(2*np.pi)))\n\nnumber of zeros: 5\nz0: -4,631.99 Hz\nz1: -1,110.36 Hz\nz2: -243.00 Hz\nz3: -180.26 Hz\nz4: 0.00 Hz\nnumber of poles: 6\np0: -4,629.79 Hz\np1: -2,545.69 Hz\np2: -495.13 Hz\np3: -231.62 Hz\np4: -180.17 Hz\np5: -6.60 Hz\n\n\n\n\n25.10.4.4 Step response\nThe step response of the is calculated using the SciPy function lsim and plotted below. A square wave with a frequency of 5 Hz and an amplitude of 0.1 volts peak to peak is used as the input to this path. An input nearly of 0.1 Vpp is used to keep the signal levels in the path below the conduction threshold for the diodes. The input square wave has a positive 0.05 volt offset which allows us to examine the DC characteristics of the path. The frequency of the square wave was chosen to allow the time constant of the path to be plotted with sufficient resolution to be examined in the plot.\n\nt = np.linspace(0, 0.5, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*5*t, duty=0.5)/20+1/20\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows that the DC gain of the path is zero since after each step transition in the input signal, the output signal decays to zero. The time constant of the decay looks to be about 0.1 seconds.\nThere is a relatively large spike in the output at each square wave edge because there is a large amount of AC gain in the circuit provided by U2A. This could be explored in more detail during prototype testing. Signals in the pedal are getting filtered, so in part B of the path, edges from fast transients may have been removed.\n\n\n25.10.4.5 Group delay\nThe group delay for this path is calculated and plotted below.\n\nx = np.logspace(0, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)*1000,'-',label='group delay')\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.xlim((10,100e3))\nplt.ylim((0,1))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\n\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for frequencies in the guitar audio band, the group delay variation is less than 2 ms and therefore below the threshold of audibility as described in Section 25.7.6.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#overlay-amplitude-response-for-the-paths",
    "href": "Klon Centaur part 1.html#overlay-amplitude-response-for-the-paths",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.11 Overlay amplitude response for the paths",
    "text": "25.11 Overlay amplitude response for the paths\nFrequency response plots for the paths are overlaid to examine their relative gains through the summing amplifier. The solid lines are for the clean paths 1, 2 and the cascade of distortion path parts A and B. Distortion path parta A and part B are plotted as a dash/dot line since the signal in this path is modified by the diodes before traveling to part B of the path.\nThe frequency response data is plotted from 10 to 100 kHz and the amplitude starting at a level of -40 dB. The frequency band of 80 to 8kHz is the typical audio band of an electric guitar and is plotted to highlight the band of interest. It is possible that sub harmonics of the guitar signal might be present below 80 Hz, and it is also possible that harmonics of the signal could extend to frequencies above 8kHz. The highlighted frequency band is not an absolute limit, but drawn only as a reference to indicate the general area to focus on for the analysis.\nThe black line in the plots below is the sum of the dashed green and red lines. Since distortion paths part A and part B are in series, the total amplitude response is obtained from the product of the two parts. These are plotted as logarithmic values, so the product is the sum of the logarithmic values. The distortion path and clean paths 1 and 2 are summed at Op Amp U2A.\nWhen looking at the amplitude plots overlaid, you will need to imagine that signals on paths with greater gain will dominate over signals on paths that have less gain. If the gain levels on a path are greater than the other paths by about 2 dB, then signals on the lower gain paths will be less discernible in the output. In other words, when the guitar signal on each of the paths are summed together, the lower amplitude signals will be masked. Auditory masking is dependent on relative amplitudes and frequency content. As discussed below, the signal on clean path 1 appears to be masked, but this would need to be verified by listening tests.\nThe required input level needed to drive the diodes in the distortion path into non-linear range varies with the gain setting. At lower gain settings, say from 0 to 10%, input levels above 0.05 volts peak are needed to drive the diodes in the distortion path into non-linear range and achieve a blend of clean and distortion. At a gain setting of 50%, an input level of 0.015 volts peak is needed to drive the diodes into non-linear range, while clean path 1 is more than 10 dB down from the distortion path and clean path 2 is attenuating the signal. Both clean paths are probably not discernible in the output.\nWhat is heard at the output will depend on the signal level at the input. At a gain setting of 1%, that is with the gain control mostly counter clockwise, with input levels of less than 0.25 volts peak, the diodes will not be conducting to a degree where clipping of the signal will take place. This is explained below.\n\n\n25.11.1 Gain setting of 1%\nThe frequency response plots are plotted for a gain setting of 1%, which is 1% rotational travel on the knob in the clockwise direction. As shown below, clean path 2 has the most gain across the guitar audio band.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 0 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path part A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path part B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,20))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nClean path 2 is the path with the most gain across the guitar audio spectrum. Overall effect is about 10 dB of clean gain from 80 to 1kHz and above 1kHz, the gain rolls off. Clean path 1 is not contributing much to the output. The gain for distortion path part A is negative for the band 80 to 1kHz and about 0 dB for higher frequencies. Signals on clean path 1 are probably not perceptible in the output since the gain in this path is more than 3 dB lower than clean path 2.\n\nThe 1N34A diodes in the distortion path will start to conduct sufficient current to produce harmonics at a voltage near the knee of the diode’s voltage current curve, see Figure 26.3. For the purposes of the calculations below, this point on the curve or knee is 0.25 volts. Typically, the forward voltage at a current of 5 mA is used to define the forward conduction voltage, but here we are interested in using the voltage where the diode starts to conduct current and generate harmonics.\n\nDiode_knee_1N34A = 0.25\n\nThe calculation below finds the maximum gain points on the curves above. BY using the maximum points we can get an idea of the relative signal levels in the output from each path.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 5.8 dB at 1.00%\nclean path 2 maximum gain 12.0 dB at 1.00%\ncascade of A and B maximum gain 7.5 dB at 1.00%\npath A maximum gain 0.2 dB at 1%\npeak signal for diode conduction threshold: 0.241 Vp\n\n\nWith a gain setting of 1%, an input signal of greater than about 0.25 volts peak is needed to drive the diodes into conduction and to start producing harmonics. The gain of clean path 2 is substantially higher than that of clean path 1 and the signal on clean path 1 probably will not be discernible in the output. This assumption could be easily verified by conducting blind listening tests. A drive signal to the pedal of greater than 0.25 volts peak is needed to produce harmonics in output. Since the gain of the distortion path with P1 set to 1% is 4 dB lower than clean path 2, any harmonics would be difficult to discern.\n\n\n25.11.2 gain setting 2.5%\nThe frequency response plots are plotted for a gain setting of 2.5%, which is 2.5% rotational travel on the knob in the clockwise direction. At this gain setting, it appears that the clean path 2 and the distortion path are able to provide contributions to the output since the gains at some frequencies are comparable.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 1 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.1f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.1f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.1f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.1f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.1f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,20))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plots above, the gain for clean path 1 is substantially less than clean path 2. The calculations below show that the difference in gain is about 4 dB. At any drive level, the amplitude of the signal on clean path 2 will be more than twice that of clean path 1. The signal on clean path 1 probably will not be discernable in the output.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.2f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 6.0 dB at 2.50%\nclean path 2 maximum gain 10.8 dB at 2.50%\ncascade of A and B maximum gain 13.5 dB at 2.50%\npath A maximum gain 3.8 dB at 2.50%\npeak signal for diode conduction threshold: 0.105 Vp\n\n\nAn input signal of greater than about 0.1 volts peak is needed to drive the diodes into conduction and produce harmonics. Distortion path part A is starting to provide some boost to the signals as shown by the red dot/dash curve. Signals following the diodes are then filtered by the profile shown by the green dot/dash curve, which is the distortion path part B. Near 1 kHz, you can see that the cascade of the distortion path parts A and B are providing a bit of a boost over that of clean path 2. Diode path B has the most gain up to about 1kHz then clean path 2 has more. Diode path A is boosting the signal in the band 600 Hz and higher into the diodes so this signal should dominate from 300 Hz to about 3 kHz.\nSignals on clean path 1 will be overshadowed compared to the signals on other paths over most of the guitar audio band. The signal through Clean path 1 is probably below the perception threshold.\nThe gain profiles through paths 2 and the distortion path at a gain setting of 2.5% illustrate the need for a preamp pedal prior to the Klon to control the signal level to the Klon. Normal guitar playing might be too soft to achieve the desired mix of clean and distortion through the Klon.\n\n\n25.11.3 gain setting 9.75%\nThe frequency response plots are plotted for a gain setting of 9.75%, which is almost 10% rotational travel on the knob in the clockwise direction. At this gain setting, it appears that the clean paths and distortion path are able to provide contributions to the output since the gains at around 80 Hz are about the same.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 2 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.2f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.2f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.2f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.2f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.2f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,20))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAt the low end of the guitar audio range, about 80 Hz, the gains on the clean paths and the distortion path are the same. Over the remainder of the guitar audio band, the distortion path dominates. The plot above suggests that at a gain setting of 9% or more, signals through the distorting path will dominate in the output. If the guitar signal has sufficient amplitude to drive the diodes into clipping, then you will hear distortion in the output. If the guitar signal is very low, you will hear the guitar signal filtered by essentially a band pass filter with a center frequency of 1 kHz. The plot above suggests that at a gain setting of 9% or more, signals through the distorting path will dominate in the output.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.2f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 6.5 dB at 9.75%\nclean path 2 maximum gain 7.2 dB at 9.75%\ncascade of A and B maximum gain 19.2 dB at 9.75%\npath A maximum gain 7.2 dB at 9.75%\npeak signal for diode conduction threshold: 0.048 Vp\n\n\nAn input signal of greater than about 0.05 volts peak is needed to drive the diodes into conduction.\n\n\n\n25.11.4 gain setting 25%\nThe frequency response plots are plotted for a gain setting of 25%, which is 25% rotational travel on the knob in the clockwise direction. At this gain setting, it appears that the distortion path will dominate the output.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 3 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,30))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 25%.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 6.9 dB at 25.00%\nclean path 2 maximum gain 3.1 dB at 25.00%\ncascade of A and B maximum gain 22.1 dB at 25.00%\npath A maximum gain 9.1 dB at 25%\npeak signal for diode conduction threshold: 0.031 Vp\n\n\nAn input signal of greater than about 0.03 volts peak is needed to drive the diodes into conduction.\n\n\n25.11.5 gain setting 50%\nThe frequency response plots are plotted for a gain setting of 50%. At this gain setting, it appears that the distortion path will dominate the output.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 4 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2,P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,30))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 50%.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.3f} Vp'.format(Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 7.1 dB at 50.00%\nclean path 2 maximum gain -1.5 dB at 50.00%\ncascade of A and B maximum gain 25.5 dB at 50.00%\npath A maximum gain 12.2 dB at 50%\npeak signal for diode conduction threshold: 0.015 Vp\n\n\nAn input signal of greater than about 0.015 volts peak is needed to drive the diodes into conduction.\nBased on my research of how guitar players set up their Klons, a 40% to 60% gain position seems to be common to achieve the tone they desire. At this point clean path 2 is more than 3 dB less than Diode path B and probably not very audible. In the lower half of the guitar band, clean path 1 is about 2 to 3 dB less than diode path B and becoming less audible.\n\n\n25.11.6 gain setting 75%\nThe frequency response plots are plotted for a gain setting of 75%.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 5 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,40))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 75%.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.2f} mVp'.format(1000*Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 7.2 dB at 75.00%\nclean path 2 maximum gain -6.3 dB at 75.00%\ncascade of A and B maximum gain 30.6 dB at 75.00%\npath A maximum gain 17.4 dB at 75%\npeak signal for diode conduction threshold: 4.52 mVp\n\n\nAn input signal of greater than about 0.005 volts peak is needed to drive the diodes into conduction.\n\n\n25.11.7 gain setting 99%\nSetting the gain control to 99% of full scale and plotting the frequency response of the paths to compare the relative gains.\n\nplt.ylabel('magnitude, dB')\nplt.xlabel('frequency, Hz')\n\ni = 6 # set the index for the gain setting of interest\n\nplt.semilogx(clean_path1_w[i]/(2*np.pi), clean_path1_mag[i],'-b',label='Clean path 1, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(clean_path2_w[i]/(2*np.pi), clean_path2_mag[i],'-m',label='Clean path 2, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.semilogx(diode_pathA_w[i]/(2*np.pi), diode_pathA_mag[i],'-.r',label='Distortion path A, P1 @ {:.0f}%'.format(gain_setting[i]*100))\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i],'-.g',label='Distortion path B, P1 @ {:.0f}%'.format(gain_setting[i]*100))\n\n# cascade of diode path part A and B\nplt.semilogx(diode_pathB_w[i]/(2*np.pi), diode_pathB_mag[i]+diode_pathA_mag[i],'-k',label='Cascade of A and B @ {:.0f}%'.format(gain_setting[i]*100))\n\nplt.tick_params(axis='y')\nplt.xlim((10,100e3))\nplt.ylim((-40,50))\nplt.grid()\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.legend(bbox_to_anchor=(1,1))\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe signal on the distortion path will be the most prominent signal in the output when the gain is at 99%. As calculated below, the distortion path has sufficient gain that a peak signal of about 85 \\(\\mu V\\) will drive the diodes into conduction and generate harmonics. Signals on clean paths 1 and 2 probably are not discernible in the output.\n\nprint('clean path 1 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path1_mag[i].max(),gain_setting[i]*100))\nprint('clean path 2 maximum gain {:.1f} dB at {:.2f}%'.format(clean_path2_mag[i].max(),gain_setting[i]*100))\nprint('cascade of A and B maximum gain {:.1f} dB at {:.2f}%'.format((diode_pathB_mag[i]+diode_pathA_mag[i]).max(),gain_setting[i]*100))\n\nmax_gain_dB = diode_pathA_mag[i].max()\nprint('path A maximum gain {:.1f} dB at {:.0f}%'.format(max_gain_dB,gain_setting[i]*100))\nprint('peak signal for diode conduction threshold: {:.2f} uVp'.format(1e6*Diode_knee_1N34A/(10**(max_gain_dB/10))))\n\nclean path 1 maximum gain 7.2 dB at 99.00%\nclean path 2 maximum gain -27.4 dB at 99.00%\ncascade of A and B maximum gain 45.6 dB at 99.00%\npath A maximum gain 34.7 dB at 99%\npeak signal for diode conduction threshold: 84.67 uVp\n\n\nThe gains on the clean paths are not high enough to compete with the gain of the distortion path at a gain setting of 99%.\nAt this point in the analysis, I wonder why clean path 1 is part of the design. At low gain, clean path 2 has a gain greater than clean path 1. At a gain setting of about 10%, clean path 1 and 2 have gains along parts of the frequency response curve that are about the same, however both clean paths are overshadowed by the distortion path. It seems like clean path 1 never contributes to the output in a meaningful way. Perhaps clean path 1 was in the initial attempt to blend clean and distortion together, then clean path 2 added later.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 1.html#summary-for-part-1",
    "href": "Klon Centaur part 1.html#summary-for-part-1",
    "title": "25  Klon Centaur, Part 1",
    "section": "25.12 Summary for part 1",
    "text": "25.12 Summary for part 1\nPart 1 of the analysis used SMNA and the principle of superposition to perform a linear analysis of the Klon. In part 2, a comparison of results from LTSpice with diodes included are made with the linear analysis and the results are nearly identical. Here are a few comments:\n\nClean path 1 is not contributing to the output at a discernible level.\nThe mix and placement of the reactive branches in clean path 2 is a bit unusual when viewed as a filter.\nThe use of the dual gang pot, P1, could have been replaced by a signal pot by changing the topology of the circuits and paths. This is something that would have been discussed during a preliminary design review.\nThe use of a preamp before the Klon is recommended to better control the gain through the guitar signal chain. A variable gain preamp can set the drive level to the Klon and then the Klon’s gain pot can be used to set the desired level of distortion.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Klon Centaur, Part 1</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html",
    "href": "Klon Centaur part 2v0.html",
    "title": "26  Klon Centaur, Part 2",
    "section": "",
    "text": "26.1 Non-linear analysis with LTSpice\nIn this chapter, LTSpice will be used to analyze the operation of the pedal using device models for the Op Amps and diodes. The Op Amp and diode device models describe the nonlinear operation of these devices and LTSpice is capable of performing nonlinear analysis, something that the Python MNA can’t do.\nThe results from LTSpice are saved as a comma separated value (csv) file and imported into this notebook for plotting and comparison with the Python results. Figure 26.1 shows the schematic used in the LTSpice analysis. The circuit is a redrawn version of Martin Chittum’s Klon Centaur schematic shown in Figure 25.2 except that the ICL7660 and its associated components have been replaced by fixed voltage sources, \\(V2\\), \\(V3\\), \\(V4\\) and \\(V5\\).\nThe motivating reason for employing LTSpice for this part of the analysis is to explore the effects of the non-linear components. The Diodes, \\(D_2\\) and \\(D_3\\), are the primary components that introduce distortion into the signal path. Under the combined conditions of moderate gain setting on \\(P_1\\) and relatively large drive input, the Op Amp \\(U_{1B}\\) can be driven into saturation. When this occurs the output tone will be a combination of non-linearities produced by the clipping of the signal by the Op Amp as the signal levels are driven beyond the power supply rails for \\(U_{1B}\\) and the signal limiting resulting from the diodes.\nGiven the mystic and alleged magical ability of some types of Germanium diodes to produce superior musical sounds, it seems that Op Amp saturation should be avoided, otherwise the sound will be muddled and negating the point and argument for “special” Germanium diodes.\nThe analysis presented in this chapter will start with a description of the schematic in Figure 25.2. The Op Amps and Germanium diodes are discussed. Then LTSpice was used to do a parameter sweep where the input signal level was varied from 0.1 volts to 1.5 volts while the gain was varied from 1\\(\\Omega\\) to 99 k\\(\\Omega\\). The voltages at various points in the circuit were plotted versus these parameters. Next the circuit was examined with sinusoidal input signals of various amplitudes and the harmonic content of the diode limiting was examined. Actual musical signals were also used as input to the simulation since LTSpice has the ability to read wav files. Finally a comparison of LTSpice results versious Python MNA circuit analysis results is presented to validate the Python MNA analysis.\nThe following Python modules are used in this notebook.\nThe schematic shown below was drawn in LTSpice. The voltage converter, U3, in Figure 25.2, has been replaced by the voltage sources, \\(V2\\), \\(V3\\), \\(V4\\) and \\(V5\\). Voltage source, \\(V1\\), is the guitar input signal. The effects bypass switch modeled by setting \\(R_{26}\\) to 68k \\(\\Omega\\) and \\(R_{27}\\) to 0.01 \\(\\Omega\\), which models switch S1A shorting \\(R_{27}\\) to the wiper terminal of P3. All of the resistors and capacitors are assumed to be ideal. The schematic includes power supply connections for the Op Amps. In the analysis that follows, I’ll be looking at conditions where the Op Amps might be driven into saturation.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#sec-nonlinear_analysis",
    "href": "Klon Centaur part 2v0.html#sec-nonlinear_analysis",
    "title": "26  Klon Centaur, Part 2",
    "section": "",
    "text": "Figure 26.1: Schematic of the Klon Centaur used for the LTSpice nonlinear analysis.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#semiconductor-components",
    "href": "Klon Centaur part 2v0.html#semiconductor-components",
    "title": "26  Klon Centaur, Part 2",
    "section": "26.2 Semiconductor components",
    "text": "26.2 Semiconductor components\nWithin the Klon Centaur’s circuits there are several semiconductor devices used. These are the diodes, Op Amps and voltage converter. This section will describe these components and their use in the circuit.\n\n26.2.1 Dual High Slew Rate JFET Input Op Amp - TL072\nThe operational amplifier (Op Amp) used in the pedal is the TL072, available from Texas Instruments. The TL072 is a dual, high slew rate, JFET-input Op Amp and is part of a family of industry-standard devices (TL071, TL072, and TL074). There are next-generation versions available (TL071H, TL072H, and TL074H). The TL072 product continues to be available for existing customers, but new designs should consider an alternate product.\nThe TL072 provides outstanding value for cost-sensitive applications, and features include: low offset (1 mV, typical), high slew rate (20 V/µs), and common-mode input to the positive supply. High ESD (1.5 kV, HBM), integrated EMI and RF filters, and operation across the full –40°C to 125°C enable the TL07xH devices to be used in the most rugged and demanding applications.\nThe TL072 is available from Digikey from two manufacturers, Texas Instruments and STMicroelectronics.\nThe in LTSpice circuit simulations that follow, the following PSpice Model model from Texas Instruments was used:\n* TL072 OPERATIONAL AMPLIFIER \"MACROMODEL\" SUBCIRCUIT\n* CREATED USING PARTS RELEASE 4.01 ON 06/16/89 AT 13:08\n* (REV N/A)      SUPPLY VOLTAGE: +/-15V\n* CONNECTIONS:   NON-INVERTING INPUT\n*                | INVERTING INPUT\n*                | | POSITIVE POWER SUPPLY\n*                | | | NEGATIVE POWER SUPPLY\n*                | | | | OUTPUT\n*                | | | | |\n.SUBCKT TL072    1 2 3 4 5\n*\n  C1   11 12 3.498E-12\n  C2    6  7 15.00E-12\n  DC    5 53 DX\n  DE   54  5 DX\n  DLP  90 91 DX\n  DLN  92 90 DX\n  DP    4  3 DX\n  EGND 99  0 POLY(2) (3,0) (4,0) 0 .5 .5\n  FB    7 99 POLY(5) VB VC VE VLP VLN 0 4.715E6 -5E6 5E6 5E6 -5E6\n  GA    6  0 11 12 282.8E-6\n  GCM   0  6 10 99 8.942E-9\n  ISS   3 10 DC 195.0E-6\n  HLIM 90  0 VLIM 1K\n  J1   11  2 10 JX\n  J2   12  1 10 JX\n  R2    6  9 100.0E3\n  RD1   4 11 3.536E3\n  RD2   4 12 3.536E3\n  RO1   8  5 150\n  RO2   7 99 150\n  RP    3  4 2.143E3\n  RSS  10 99 1.026E6\n  VB    9  0 DC 0\n  VC    3 53 DC 2.200\n  VE   54  4 DC 2.200\n  VLIM  7  8 DC 0\n  VLP  91  0 DC 25\n  VLN   0 92 DC 25\n.MODEL DX D(IS=800.0E-18)\n.MODEL JX PJF(IS=15.00E-12 BETA=270.1E-6 VTO=-1)\n.ENDS\nThe following informative references are recommended:\n\nOp amps in small-signal audio design – Part 1: Op amp history, properties\nOp amps in small-signal audio design – Part 2: Distortion in bipolar and JFET input op-amps\nOp amps in small-signal audio design – Part 3: Selecting the right op amp\n\n\n\n26.2.2 General Purpose Germanium Diode - 1N34A\nThe clipping diodes, \\(D_2\\) and \\(D_3\\), are type 1N34A, a general purpose point contact Germanium diode. As recounted in interviews with Bill Finnegan, many versions of the 1N34A from various vendors were evaluated and 1N34A diodes from one particular source were selected based on listening tests. Bill has not disclosed the exact source of the 1N34A diodes he used, so this aspect of the Klon Centaur has remained a trade secret. It has been reported that Bill’s initial stock of Germanium diodes have been depleted and new production uses diodes from a new source.\nWhile the electrical characteristics of Germanium semiconductor devices is well understood, the sonic properties of audio circuits using Germanium semiconductor devices have been described as being warm and more musical. Accordingly, some mystic and urban lour have come to be associated with the use of Germanium diodes and transistors. Most online commentators seem to focus on the forward voltage drop of Germanium diodes along with some sonic qualities. Here are two excerpts:\nForward voltage of various diodes:\n\nMe and Dylan and David from the DIY guitar pedal/effects community decided to see for ourselves what the fuzz is about regarding diodes and their “softness”. Why do people like Germaniums over Silicons? What is the effect of multiple diodes in series? How exactly does the PN junction of a MOSFET look like? All these questions and more will be answered.\n\nEmulating germanium diodes\n\nWhen you get into vintage effect pedals etc. you might get to know the amazing germanium diode. These diodes are truly worse in every way compared to silicon diodes, and thus aren’t being produced anymore. This makes them a treasure for those who are chasing the vintage tone. Luckily here and there germanium diode surpluses are still being sold with nice profit margins.\n\n\nBut what is so special about germanium? Well, people claim that they clip “softer” than silicon diodes. This makes your tone sound “smoother” and whatever. In my post about testing diodes it is clear that the knee (slope) of germanium diodes is indeed smoother than those of silicon diodes so that’s one way to prove that it has “some” impact on your tone. But can’t we emulate this soft knee in some way?\n\n\nThe blogpost also showed how you can simply put diodes in series to double the forward voltage, but also make the knee softer. Putting 4 or more silicons in series gets you close to the softness of a germanium, but with a forward voltage of 2.8V.\n\nMy analysis of the circuits used in the Klon Centaur cannot evaluate the sonic aspects of Germanium diodes, something that could be properly investigated by building prototype circuits and doing blind listen tests, but instead will focus on the general electrical characteristics of the 1N34A. The 1N34A diode model used in the LTSpice simulations is:\n.model 1N34A D(bv=75 cjo=0.5e-12 eg=0.67 ibv=18e-3 is=2e-7 rs=7 n=1.3 vj=0.1 m=0.27)\nThe circuit shown below is used to evaluate the 1N34A model.\n\n\n\n\n\n\nFigure 26.2: Schematic of LTSpice diode test jig.\n\n\n\nThe following code loads the voltage versus current data for the 1N34A Germanium diode and the 1N914 Silicon diode models.\n\nfn = 'Diode-vi-curve.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\nCopy the data from the csv file into NumPy arrays.\n\n# initialize some empty arrays\nD_1N34A_voltage = np.zeros(len(LTSpice_data))\nD_1N34A_diode_current = np.zeros(len(LTSpice_data))\nD_1N914_voltage = np.zeros(len(LTSpice_data))\nD_1N914_diode_current = np.zeros(len(LTSpice_data))\n\n# load csv data into the array\nfor i in range(len(LTSpice_data)):\n    D_1N34A_voltage[i] = LTSpice_data[i][0]\n    D_1N34A_diode_current[i] = LTSpice_data[i][1]*1000\n    D_1N914_voltage[i] = LTSpice_data[i][2]\n    D_1N914_diode_current[i] = LTSpice_data[i][3]*1000\n\nPlot the LTSpice simulated forward voltage versus current relationship for 1N34A and 1N914 diode models.\n\nfig1, ax1 = plt.subplots()\nax1.plot([10, 100, 1000], [1,2,3])\n\nax1.text(D_1N34A_voltage[1375], D_1N34A_diode_current[1375], '{:.2f} volts, {:.2f} mA   '.format(D_1N34A_voltage[1375], D_1N34A_diode_current[1375]), fontsize=8, horizontalalignment='right', verticalalignment='center')\n\nax1.plot(D_1N34A_voltage, D_1N34A_diode_current,'-b',label='1N34A')\nax1.plot(D_1N34A_voltage[1375], D_1N34A_diode_current[1375],'xb')\n\nax1.plot(D_1N914_voltage, D_1N914_diode_current,'-r',label='1N914')\n\nax1.set_xlim(0.1,1)\nax1.set_ylim(0,10)\n\nax1.set_xlabel('volts')\nax1.set_ylabel('current. mA')\n\nax1.set_xscale('log')\nax1.set_xticks([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 1.0])\nax1.get_xaxis().set_major_formatter(matplotlib.ticker.ScalarFormatter())\n\nax1.get_xaxis().set_tick_params(which='minor', size=0)\nax1.get_xaxis().set_tick_params(which='minor', width=0)\n\nax1.grid()\nax1.legend()\nplt.title('Forward voltage versus current for 1N34A and 1N914 diode models')\nplt.show()\n\n\n\n\n\n\n\nFigure 26.3: Voltage vs current plot for 1N34A and 1N914 diodes.\n\n\n\n\n\nAs shown in the plot above, the VI curves for the 1N34A and 1N914 diode models are different. The 1N34A has a forward voltage of 0.38 volts at 5mA, whereas the 1N914 had a forward voltage of about 0.62 volts at 5mA. The shape of the two curves is also different with the 1N34A curve being a bit more rounded. The harmonics generated in audio circuits using the 1N34A will have a different set of amplitude coefficients and a different sound.\n\n\n26.2.3 CMOS Switched Capacitor Voltage Converter - ICL7660\nThe electrical power to operate the Klon Centaur comes from the DC jack or the internal 9 volt battery. Nominally both the DC jack or the battery are 9 volt sources, however as the battery drains, the voltage will be less than 9 volts and the power source connected to the DC jack might be slightly different than 9 volts. The 9 volt power source is filtered by \\(C_{17}\\) and \\(D_4\\) provides reverse voltage protection. Internal to the Klon Centaur there are four power supply rails derived from the 9 volt battery or the DC jack. The 9 volts is divided by two using resistors R29 and R30 to produce +4.5V and C18 stabilizes this voltage.\n\\(U_3\\) is a CMOS switched capacitor voltage converter, part number ICL7660, which converts positive 9 volts into -9 and +18 volts. The ICL7660, with a few external components, can double, divide, or multiply a positive input voltage. The ICL7660 will operate from 1.5V to 10V input voltage and can deliver upto 10mA with a 0.5V output drop. The ICL7660 is currently produced by Renesas Electronics Corporation and Analog Devices Inc./Maxim Integrated, and distributed by Digikey under the part numbers, ICL7660CPAZ and ICL7660CPA+.\nThe Op Amps \\(U_1\\) and \\(U_2\\) are connected to different supply rails. \\(U_{1A}\\) and \\(U_{1B}\\) power supply voltages are 9 volts and ground. The signal ground is a virtual ground with a voltage of 4.5 volts. This allows audio signals processed by \\(U_1\\) to swing between about 2 volts and 7 volts peak to peak without clipping. The power supply levels for \\(U_{2A}\\) and \\(U_{2B}\\) are 18 volts and -9 volts. This allows signals processed by \\(U_2\\) to swing between about -7 to +16 volts peak to peak without clipping.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#input-voltage-and-gain-sweep",
    "href": "Klon Centaur part 2v0.html#input-voltage-and-gain-sweep",
    "title": "26  Klon Centaur, Part 2",
    "section": "26.3 Input Voltage and Gain Sweep",
    "text": "26.3 Input Voltage and Gain Sweep\nLTSpice was set up to run a series of simulations which stepped though a list of \\(V1\\) amplitudes and values for \\(R_{gain}\\). The frequency of \\(V1\\) was set to 1 kHz since this is the frequency where some resonant paths peak. The voltage range used for \\(V1\\) is 0.1 volts to 1.5 volts. The following SPICE commands were used:\n.tran 0 5m 0\n.param Rtone=5k\n.param Routput=99.999k\n.step param Rgain list 1 250 500 750 1k 2.5k 5k 7.5k 10k 15k 20k 25k 30k 35k 40k 45k 50k 55k 60k 65k 70k 75k 80k 85k 90k 92.5k 95k 97.5k 99.9k\n.step param V1_amp list 0.1 0.25 0.5 0.75 1.0 1.25 1.5\nThe following Python reads in the data file generated by LTSpice.\n\nLTSpice_data_fn = 'Sweep_Vin_&_Rgain.csv'\nLTSpice_sweep_df = pd.read_csv(LTSpice_data_fn)\n\nThere are about 354,000 records in the Pandas dataframe. Voltage data was collected from the nodes listed in Table 26.1 and a short description of the node’s location in the circuit is provided.\n\n\n\nTable 26.1: Nodes and connections\n\n\n\n\n\nNode\nDescription\n\n\n\n\n7\nU1A output\n\n\n14\nU1B output\n\n\n17\nright side of C10\n\n\n19\nU2A output\n\n\n21\nU2B output\n\n\n\n\n\n\nA sample of the first 5 records in the dataframe are displayed below. Each simulation run for the various \\(V1\\) gains and \\(R_{gain}\\) setting is delimited by Step Information: ….\n\nLTSpice_sweep_df.head(5)\n\n\n\n\n\n\n\n\ntime\nV(7)\nV(14)\nV(17)\nV(19)\nV(21)\n\n\n\n\n0\nStep Information: V1_amp=100m Rgain=1 (Step: ...\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n0\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n2\n1.25000001460762E-08\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n3\n2.50000002921524E-08\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n4\n5.00000005843049E-08\n4.499977\n4.500065\n4.500011\n4.50035\n4.499677\n\n\n\n\n\n\n\nIn the csv file, there are lines of text for each new step in the simulation. For example:\nStep Information: V1_amp=100m Rgain=1K (Step: 29/203)\nThese lines of text are used to locate the index of the start of the data from each simulation sweep by looking at each record for the word ‘Step’ and a list of index values is created.\n\nlst = LTSpice_sweep_df['time'].tolist()\n\nstep_index = []\nrow_cnt = 0\nfor i in lst:\n    if 'Step' in i:\n        step_index.append(row_cnt)\n    row_cnt += 1\n\nA new dataframe called sweep_df is created. The following code finds the peak to peak voltage at each node for each sweep and loads the values into the dataframe.\n\nsweep_df = pd.DataFrame(columns=['V1amp','Rgain','V7pp','V14pp','V17pp','V19pp','V21pp'])\n\nfor i in range(0,len(step_index)):\n    #\n    row_elements = LTSpice_sweep_df['time'][step_index[i]].split()\n\n    #\n    Rgain_str = row_elements[3][6:]\n    Rgain_value = float(Rgain_str.replace('K', 'e3'))\n    Rgain_percent = Rgain_value/100e3*100\n    V1_amp_str = row_elements[2][7:]\n    V1_amp_value = float(V1_amp_str.replace('m', 'e-3'))\n\n    #\n    if i == 0:\n        v7_pp_value = LTSpice_sweep_df['V(7)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(7)'][0:step_index[i+1]].min()\n        v14_pp_value = LTSpice_sweep_df['V(14)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(14)'][0:step_index[i+1]].min()\n        v17_pp_value = LTSpice_sweep_df['V(17)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(17)'][0:step_index[i+1]].min()\n        v19_pp_value = LTSpice_sweep_df['V(19)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(19)'][0:step_index[i+1]].min()\n        v21_pp_value = LTSpice_sweep_df['V(21)'][0:step_index[i+1]].max() - LTSpice_sweep_df['V(21)'][0:step_index[i+1]].min()\n    elif i &lt; len(step_index)-1:\n        v7_pp_value = LTSpice_sweep_df['V(7)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(7)'][step_index[i]:step_index[i+1]].min()\n        v14_pp_value = LTSpice_sweep_df['V(14)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(14)'][step_index[i]:step_index[i+1]].min()\n        v17_pp_value = LTSpice_sweep_df['V(17)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(17)'][step_index[i]:step_index[i+1]].min()\n        v19_pp_value = LTSpice_sweep_df['V(19)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(19)'][step_index[i]:step_index[i+1]].min()        \n        v21_pp_value = LTSpice_sweep_df['V(21)'][step_index[i]:step_index[i+1]].max() - LTSpice_sweep_df['V(21)'][step_index[i]:step_index[i+1]].min()        \n    else:\n        v7_pp_value = LTSpice_sweep_df['V(7)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(7)'][step_index[i]:-1].min()        \n        v14_pp_value = LTSpice_sweep_df['V(14)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(14)'][step_index[i]:-1].min()  \n        v17_pp_value = LTSpice_sweep_df['V(17)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(17)'][step_index[i]:-1].min()  \n        v19_pp_value = LTSpice_sweep_df['V(19)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(19)'][step_index[i]:-1].min()   \n        v21_pp_value = LTSpice_sweep_df['V(21)'][step_index[i]:-1].max() - LTSpice_sweep_df['V(21)'][step_index[i]:-1].min()          \n\n    # load values into new dataframe\n    sweep_df.loc[i] = [V1_amp_value, Rgain_percent, v7_pp_value,v14_pp_value,v17_pp_value,v19_pp_value,v21_pp_value]\n\nThe first five lines of the dataframe are displayed below.\n\nsweep_df.head(5)\n\n\n\n\n\n\n\n\nV1amp\nRgain\nV7pp\nV14pp\nV17pp\nV19pp\nV21pp\n\n\n\n\n0\n0.10\n0.001\n0.197555\n0.000146\n0.000140\n0.138082\n0.161292\n\n\n1\n0.25\n0.001\n0.493868\n0.000367\n0.000352\n0.345193\n0.403173\n\n\n2\n0.50\n0.001\n0.987762\n0.000732\n0.000703\n0.690350\n0.806184\n\n\n3\n0.75\n0.001\n1.481557\n0.001101\n0.001054\n1.035477\n1.209899\n\n\n4\n1.00\n0.001\n1.975554\n0.001466\n0.001405\n1.380598\n1.612327\n\n\n\n\n\n\n\nA list of the amplitudes of \\(V1\\) used for each sweep is created from the dataframe as well as a list of the \\(R_{gain}\\) sweep values.\n\nV1_amp_list = sweep_df['V1amp'].unique()\nRgain_list = sweep_df['Rgain'].unique()\n\n\n26.3.1 Op Amp saturation at Node 14 - \\(U_{1B}\\) output\nNode V14 is the output of \\(U_{1B}\\). This is the distortion path part A. As can be seen, an input of 1.5 volts is needed to saturate the Op Amp at the lowest gain setting. At a gain setting of 50%, an input of 0.75 volts peak will drive the Op Amp into saturation. Supply rail voltages for \\(U_1\\) are 9 volts and ground, with a virtual ground reference of 4.5 volts. This means that at some gain settings, it is likely that guitar signals with even small peak to peak amplitudes will drive \\(U_{1B}\\) into saturation.\nThe peak to peak values for \\(v_{14}\\) are plotted versus \\(R_{gain}\\) and \\(V1\\).\n\nfor i in V1_amp_list:\n    plt.plot(sweep_df[sweep_df['V1amp'] == i]['Rgain'].to_numpy(),sweep_df[sweep_df['V1amp'] == i]['V14pp'].to_numpy(),'-',label = 'V1={:.2f}'.format(i))\n\n# position legend outside the graph\nplt.legend(bbox_to_anchor=(1.3,1)) # V1 legend position: relative (horizontal position, vertical position) \n\nplt.ylabel('U1 output, Vpp')\nplt.xlabel('Rgain value, k\\u03A9')\n\nax1.set_ylim((-0.5,6))\nplt.grid()\nplt.title('Node 14 Vpp levels versus $R_{gain}$ and $V1$')\n\nplt.show()\n\n\n\n\n\n\n\nFigure 26.4: Node 14 peak to peak voltage versus \\(R_{gain}\\) and \\(V1\\) input.\n\n\n\n\n\nAs shown above, \\(U_{1B}\\), maximum output swing is about 6Vpp. This is because the power rails for \\(U_1\\) are 0 and 9V and \\(U_1\\) is not rail-to-rail capable. The SPICE model used for the TLO72 Op Amp reproduces the maximum output signal swing. If the gain pot, \\(P_1\\) is set midpoint, signal inputs greater than 0.75V will drive U1B’s output into saturation as shown on the red curve above. This likely means that for mid range gain settings and loud guitar inputs, the guitar signal is first clipped by \\(U_{1B}\\) and then again by the diodes. Any large harmonics generated by \\(U_{1B}\\) will be mostly altered by \\(D_2\\) and \\(D_3\\).\n\n\n26.3.2 Guitar Output Signal Levels\nSince I don’t own a guitar and I’m not a guitar player, I searched online to find typical guitar signal levels. Various references such as Electric Guitar Output and Electric Guitar Output Voltage Levels placed the guitar output level in the range of 15\\(\\mu\\)V to 740mV depending on playing style, string gauge and pickup type.\nThe reference, Guitar & Bass Pickup Output Voltages, provided the following table with comments:\n\n\n\nTable 26.2: Pickup Output Voltage - Averaged RMS (Peak)\n\n\n\n\n\nModified Maton\nNeck (2.0kΩ)\nMiddle (N/A)\nBridge (2.0kΩ)\n\n\n\n\nE1\n40 mV (150mV)\n\n32 mV (200mV)\n\n\nE2\n12 mV (120mV)\n\n20 mV (300mV)\n\n\nChord\n36 mV (200mV)\n\n\n\n\nAverage\n29 mV (156 mV)\n\n29 mV (267 mV)\n\n\n\n\n\n\n\n\n\nTable 26.3: More Pickup Output Voltages\n\n\n\n\n\n\n\n\n\n\n\nSamick ‘TV Twenty’\nNeck (11.5kΩ)\nMiddle (11.3kΩ)\nBridge (15.3kΩ)\n\n\n\n\nE1\n44 mV (250mV)\n76 mV (300 mV)\n120 mV (800 mV)\n\n\nE2\n12 mV (50 mV)\n12 mV (159 mV)\n16 mV (200 mV)\n\n\nChord\n76 mV (450 mV)\n72 mV (400 mV)\n128 mV (850 mV)\n\n\nAverage\n44 mV (250 mV)\n53 mV (283 mV)\n88 mV (617 mV)\n\n\n\n\n\n\n\nTabulated results aren’t especially useful, for the simple reason that there will be huge variations due to playing style, and what’s being played. However, I did summarize the results. All numbers are millivolts (RMS) taken from the scope captures shown below. I didn’t include the bass, only the two guitars. Note that I use light gauge strings, and you will get more level with thicker ones. I don’t have a set for comparison, but I’d expect that you could get at least 6dB (×2) more when played hard. The pickup resistance is also shown in the table, not because it’s especially useful on its own, but you can make comparisons. It includes the parallel resistance of the volume control, as I didn’t feel like dismantling my guitars for a more accurate measurement.\n\nSo it would seem possible that when playing chords, some relatively high signal levels are produced by the guitar and that saturation of \\(U_{1B}\\)’s output is likely. It seems likely to me that over driving \\(U_{1B}\\) was a design oversight since the tone of the pedal is claimed to emanate from the hand selected Germanium diodes.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#sinusoidal-input",
    "href": "Klon Centaur part 2v0.html#sinusoidal-input",
    "title": "26  Klon Centaur, Part 2",
    "section": "26.4 Sinusoidal Input",
    "text": "26.4 Sinusoidal Input\nIn this section the transient analysis simulation results from LTSpice for the voltages at the diodes, \\(v_{17}\\), is examined by using NumPy and SciPy functions. The input stimulus to the Klon Centaur circuit is a 1kHz sine wave. The LTSpice simulation was run with various gain settings and input amplitude values.\nA new Pandas data frame is declared with the column names shown below. In this dataframe the node voltage versus time is tabulated for each input level and gain setting.\n\ntd_node_voltage_df = pd.DataFrame(columns=['V1amp','Rgain','time','V7','V14','V17','V19','V21'])\n\nData is loaded into the new dataframe with the following code.\n\nfor i in range(0,len(step_index)):\n    #\n    row_elements = LTSpice_sweep_df['time'][step_index[i]].split()\n\n    # convert the units of 'K' and 'm' to float\n    Rgain_str = row_elements[3][6:]\n    Rgain_value = float(Rgain_str.replace('K', 'e3'))\n    Rgain_percent = Rgain_value/100e3*100\n    V1_amp_str = row_elements[2][7:]\n    V1_amp_value = float(V1_amp_str.replace('m', 'e-3'))\n\n    #\n    if i == 0:\n        time_values = LTSpice_sweep_df['time'][1:step_index[i+1]].to_numpy()\n        v7_values = LTSpice_sweep_df['V(7)'][1:step_index[i+1]].to_numpy()\n        v14_values = LTSpice_sweep_df['V(14)'][1:step_index[i+1]].to_numpy()\n        v17_values = LTSpice_sweep_df['V(17)'][1:step_index[i+1]].to_numpy()\n        v19_values = LTSpice_sweep_df['V(19)'][1:step_index[i+1]].to_numpy()\n        v21_values = LTSpice_sweep_df['V(21)'][1:step_index[i+1]].to_numpy()\n    elif (i != 0) and (i &lt; len(step_index)-1):\n        time_values = LTSpice_sweep_df['time'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v7_values = LTSpice_sweep_df['V(7)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v14_values = LTSpice_sweep_df['V(14)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v17_values = LTSpice_sweep_df['V(17)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v19_values = LTSpice_sweep_df['V(19)'][step_index[i]+1:step_index[i+1]].to_numpy()\n        v21_values = LTSpice_sweep_df['V(21)'][step_index[i]+1:step_index[i+1]].to_numpy()\n    else:\n        time_values = LTSpice_sweep_df['time'][step_index[i]+1:-1].to_numpy()\n        v7_values = LTSpice_sweep_df['V(7)'][step_index[i]+1:-1].to_numpy()\n        v14_values = LTSpice_sweep_df['V(14)'][step_index[i]+1:-1].to_numpy()\n        v17_values = LTSpice_sweep_df['V(17)'][step_index[i]+1:-1].to_numpy()\n        v19_values = LTSpice_sweep_df['V(19)'][step_index[i]+1:-1].to_numpy()\n        v21_values = LTSpice_sweep_df['V(21)'][step_index[i]+1:-1].to_numpy()\n\n    # load values into new dataframe\n    td_node_voltage_df.loc[i] = [V1_amp_value, Rgain_percent,time_values,v7_values,v14_values,v17_values,v19_values,v21_values]\n\nThe first five records in the dataframe are displayed below.\n\ntd_node_voltage_df.head(5)\n\n\n\n\n\n\n\n\nV1amp\nRgain\ntime\nV7\nV14\nV17\nV19\nV21\n\n\n\n\n0\n0.10\n0.001\n[0, 1.25000001460762E-08, 2.50000002921524E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n1\n0.25\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n2\n0.50\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n3\n0.75\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n4\n1.00\n0.001\n[0, 6.25000007303811E-09, 1.25000001460762E-08...\n[4.499977, 4.499977, 4.499977, 4.499977, 4.499...\n[4.500065, 4.500065, 4.500065, 4.500065, 4.500...\n[4.500011, 4.500011, 4.500011, 4.500011, 4.500...\n[4.50035, 4.50035, 4.50035, 4.50035, 4.50035, ...\n[4.499677, 4.499677, 4.499677, 4.499677, 4.499...\n\n\n\n\n\n\n\nAt an offset of 127 in the dataframe, the gain setting is 60% and the input amplitude is 0.25 volts. This will produce a signal at the diodes a bit larger than the conduction threshold and the signal will be slightly voltage limited as shown in the plot below.\n\ni=127\nprint('Node 17, voltage vs input level V1amp={:.3f}, Rgain={:.0f}'.format(td_node_voltage_df.loc[i]['V1amp'],td_node_voltage_df.loc[i]['Rgain']))\nnum_samples = len(td_node_voltage_df.loc[i]['time'])\nprint(f'Number of samples in the simulation: {num_samples:,d}')\n\nNode 17, voltage vs input level V1amp=0.250, Rgain=60\nNumber of samples in the simulation: 1,280\n\n\nThe bias voltage of 4.5 has been subtracted from the values in the plot.\n\nplt.plot(np.asarray(td_node_voltage_df.loc[i]['time'], dtype=float),\n         np.asarray(td_node_voltage_df.loc[i]['V17'], dtype=float) - 4.5,\n         '-')\n\nplt.ylabel('Node voltage, volts')\nplt.xlabel('time')\n#plt.grid()\nplt.title('Node 17 voltage, offset removed')\nplt.show()\n\n\n\n\n\n\n\nFigure 26.5: Node 17, voltage at input level V1=0.25 and Rgain=60\n\n\n\n\n\nThe plot above shows the voltage at node 17. Somewhat evident is the rounding of the peaks of the waveform.\nLTSpice returns the node voltages versus time where the sample interval is not uniform. LTSpice varies the time step to aid in the solution convergence. By plotting time data versus sample number we can see in the plot below, the function is not a straight line, but somewhat stair cased.\n\nt_data = np.asarray(td_node_voltage_df.loc[i]['time'], dtype=float)\ny_data = np.asarray(td_node_voltage_df.loc[i]['V17'], dtype=float) - 4.5\n\n# plot the data\nplt.plot(t_data[0:300])\nplt.xlabel('time samples')\nplt.ylabel('time, sec')\nplt.title('Title')\nplt.show()\n\n\n\n\n\n\n\nFigure 26.6: Node 17, sample time plotted\n\n\n\n\n\nWe can use NumPy’s function interp to resample the data so that the sample intervals are uniform.\n\nstop_time = 20e-3\nxnew = np.linspace(0, stop_time, int(len(t_data))) #np.linspace(0, 10, num=1001)\nynew = np.interp(xnew, t_data, y_data)\n\nThe harmonic content of the signal plotted in Figure 26.5 can be examined by the use of Fast Fourier transform (FFT). Since the simulation data ends abruptly, there is typically a non-zero value for the last data point in the simulation. A window function is typically used to minimize the “spectral leakage” associated with any discontinuities at the ends of the data set and helps to produce a more accurate representation of the signal’s true frequency content.\nThere are many window functions described in the signal processing literature. The window function used in this analysis is the Hann function and implemented by the NumPy function hanning. The Hann function is a taper formed by using a weighted cosine. The window is named after Julius von Hann, often referred to as Hanning. It is also known as the raised cosine, because of its similarity to a raised-cosine distribution.\nThe data, window and windowed data is plotted below.\n\nfft_window = np.hanning(len(xnew))\nyw = ynew*fft_window\n\n# plot the data\nplt.plot(xnew,ynew)\nplt.plot(xnew ,yw)\nplt.plot(xnew,fft_window)\nplt.xlabel('Time, sec')\nplt.ylabel('Voltage, volts')\nplt.legend(['Node 17 voltage', 'windowed data', 'window function'], loc='best')\nplt.title('Title')\nplt.show()\n\n\n\n\n\n\n\nFigure 26.7: Node 17 voltage, window and windowed data\n\n\n\n\n\nThe plot above overlays the voltage at node 17, the window function and the windowed data.\nThe following code displays various parameters about the signal sample being analyzed.\n\nnum_samples = len(ynew)\nprint(f'The number of samples is: {num_samples:,.0f}')\n\nsps = num_samples/stop_time\nprint(f'The sample rate is: {sps:,.0f} samples per second')\n\nnyquist_freq = sps/2\nprint(f'The Nyquist frequency: {nyquist_freq:,.0f} Hz')\n\ndt = stop_time/len(xnew)\nprint(f'The sample interval: {dt*1e6} \\u03BCs')\n\nThe number of samples is: 1,280\nThe sample rate is: 64,000 samples per second\nThe Nyquist frequency: 32,000 Hz\nThe sample interval: 15.625 μs\n\n\nThe SciPy library includes functions to compute discrete Fourier transforms, which are used in the code below to find the frequency components of the voltage at node 17. The SciPy function fft computes the one dimensional discrete Fourier Transform (DFT) using the Fast Fourier Transform (FFT) algorithm.\n\nyw_fft = scipy.fft.fft(yw)\n\nThe following code displays the frequency components of node 17 voltage. To display the amplitude spectrum in volts rms, take the two-sided amplitude amplitude spectrum and multiply the non-DC components by the square root of two and discard the second half of the array. The following equations show the calculations from a two-sided FFT to a single-sided amplitude spectrum.\n\nyw_fft_ss = yw_fft[0:int(num_samples/2)] # use lower half of the array\nfreq = np.arange(int(num_samples/2))*sps/num_samples\n\nk = np.ones(len(freq)) # Scaling factor is sqrt(2) except for at DC when it is 1\nk[1:] = k[1:]*sqrt(2)\nywf_ss_Vrms_dB = 20*np.log10(abs(2*k*yw_fft_ss/num_samples)) # 2 is the Hann window correction factor\n\nplt.plot(freq,ywf_ss_Vrms_dB)\nplt.xlim(0,10000)\nplt.ylim(-100,-10)\nplt.ylabel('amplitude, dBVrms')\nplt.xlabel('frequency, Hz')\nplt.title('FFT of the voltage at node 17')\n#plt.legend(loc='best')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\nFigure 26.8: Node 17, frequency spectrum.\n\n\n\n\n\nThe frequency plot shows that odd harmonics are generated by the clipping action of the diodes.\nAlthough LTSpice can calculate the FFT of voltages or currents, Python can also be used to display the simulation results and perform additional analysis. As shown above, node voltages and branch currents can be extracted from LTSpice and brought into JupyterLab.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#actual-signals",
    "href": "Klon Centaur part 2v0.html#actual-signals",
    "title": "26  Klon Centaur, Part 2",
    "section": "26.5 Actual Signals",
    "text": "26.5 Actual Signals\nA useful feature of LTSpice is capability to use wav files as input signals to a circuit simulation. Actual guitar signals in the form of wav files were obtained from Sample Focus. The wav files are availabe under their Standard License and are free to use. I chose the file clean-electric-guitar-harmonic-reality.wav since I thought it represented someting close to the type of signals that a player would run through their Klon Centaur.\nA transient analysis was performed using the file Klon-Centaur_v2_wavefile.asc and the input source, V1, wavefile = clean-electric-guitar-harmonic-reality.wav was declared as the value of V1. The simulation output was written to a wav file with the directive, .wave “klon_out.wav” 16 44.1k V(2). Using this file, the output of the circuit can be listened to on a computers audio player. The node voltages a several places were written to a csv file to be processed and plotted by Python in this notebook. The schematic includes a pre-amp labeled as U1. The gain as been set to unity, but other gains can be obtained by adjusting the values of resistors \\(R_{19}\\) and \\(R_{14}\\).\nThe following Python modules are loaded into the JupyterLab environment in order to read wav files.\n\nfrom scipy.io import wavfile\nimport scipy.io\n\nThe simulation input file, clean-electric-guitar-harmonic-reality.wav, is loaded to the variable wav_input. The input file has two channels since it’s a stereo recording and these are the left and right channels. The length of the audio sample and the sample rate is displayed below.\n\nsamplerate_input, wav_input = wavfile.read('clean-electric-guitar-harmonic-reality.wav')\nlength_in = wav_input.shape[0] / samplerate_input\nprint(f\"length = {length_in} seconds\")\nprint(f\"sample rate = {samplerate_input:,.0f} sps\")\n\nlength = 6.4 seconds\nsample rate = 44,100 sps\n\n\nSince the wave file contains stereo data, each channel is extracted, but only channel 0 is displayed.\n\n# split the data in channels\nchan0 = np.zeros(len(wav_input))\nchan1 = np.zeros(len(wav_input))\n\nfor i in range(len(wav_input)):\n    chan0[i] =  wav_input[i][0]\n    chan1[i] =  wav_input[i][1]    \n\ntime = np.linspace(0, length_in, len(wav_input))\nplt.plot(time, chan0, label=\"channel 0\")\nplt.legend()\nplt.xlabel(\"Time [s]\")\nplt.ylabel(\"Amplitude\")\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see in the plot above, the input signal consists of five strums on the guitar. The amplitude of the signal in the plot above is the value of the 16 bit binary data. LTSpice converts the binary data to volts.\nThe following code reads the csv file saved after the simulation and places the data into a Python dataframe. Notice that the node voltage at \\(v_{14}\\) has had the 4.5V offset removed.\n\nLTSpice_wavefile_df = pd.read_csv('wavefile_Vin.csv',delimiter='\\t')\n\nThe first ten lines in the dataframe are:\n\nLTSpice_wavefile_df.head(10)\n\n\n\n\n\n\n\n\ntime\nV(1)\nV(2)\nV(14)-4.5\nV(16)\n\n\n\n\n0\n0.000000\n4.499921e-24\n6.839725e-13\n0.000218\n7.566022e-13\n\n\n1\n0.000386\n-3.242693e-07\n-5.593652e-08\n0.000217\n-2.294244e-07\n\n\n2\n0.000392\n-8.991888e-06\n-2.135811e-06\n0.000205\n-1.153911e-05\n\n\n3\n0.000399\n-1.766024e-05\n-6.099190e-06\n0.000190\n-2.611201e-05\n\n\n4\n0.000405\n-2.632934e-05\n-1.194607e-05\n0.000171\n-4.394813e-05\n\n\n5\n0.000412\n-3.499917e-05\n-1.967646e-05\n0.000149\n-6.504747e-05\n\n\n6\n0.000418\n-4.366974e-05\n-2.929036e-05\n0.000123\n-8.941003e-05\n\n\n7\n0.000424\n-5.234105e-05\n-4.078776e-05\n0.000094\n-1.170358e-04\n\n\n8\n0.000431\n-6.101310e-05\n-5.416866e-05\n0.000061\n-1.479248e-04\n\n\n9\n0.000437\n-7.730443e-05\n-7.190395e-05\n0.000018\n-1.888111e-04\n\n\n\n\n\n\n\nThe data is saved to several NumPy arrays to be processed and displayed using Python. Of interest are the input and output nodes, \\(v_1\\) and \\(v_2\\), as well as the nodes \\(v_{14}\\) and \\(v_{16}\\).\n\nt_data = np.asarray(LTSpice_wavefile_df['time'], dtype=float)\nv1_data = np.asarray(LTSpice_wavefile_df['V(1)'], dtype=float)\nv2_data = np.asarray(LTSpice_wavefile_df['V(2)'], dtype=float)\nv14_data = np.asarray(LTSpice_wavefile_df['V(14)-4.5'], dtype=float)\nv16_data = np.asarray(LTSpice_wavefile_df['V(16)'], dtype=float)\n\nThe following code plots the voltage at nodes \\(v_1\\) and \\(v_2\\), which are the input and output nodes of the Klon Centaur. Only the first 54 ms or so is plotted.\n\nstart_index = 3500\nstop_index = 10000\nplt.plot(t_data[start_index:stop_index]*1000,v1_data[start_index:stop_index],'-r',label='V1')\n#plt.plot(t_data[start_index:stop_index]*1000,v16_data[start_index:stop_index],'-',label='V16')\n#plt.plot(t_data[start_index:stop_index]*1000,v14_data[start_index:stop_index],'-',label='V14')\nplt.plot(t_data[start_index:stop_index]*1000,v2_data[start_index:stop_index],'-b',label='V2')\n\nplt.ylabel('Node voltage, volts')\nplt.xlabel('time,ms')\nplt.grid()\nplt.title('title')\n\n#plt.legend(loc=\"lower right\")\nplt.legend(bbox_to_anchor=(1.2,1))\nplt.show()\n\n\n\n\n\n\n\nFigure 26.9: Actual signals caption\n\n\n\n\n\nThe plot above shows the pedal has some gain applied to the signal. The fundamental frequency appears the same, but the overall waveform is much different, as would be expected since the pedal is modifying the input signal with filtering and amplitude clipping by the diodes.\nThe plot below shows the voltage plots for node \\(v_{14}\\), the output terminal of \\(U_{1B}\\) and \\(v_{16}\\), the voltage on \\(D_2\\).\n\nstart_index = 3500\nstop_index = 10000\n#plt.plot(t_data[start_index:stop_index]*1000,v1_data[start_index:stop_index],'-',label='V1')\nplt.plot(t_data[start_index:stop_index]*1000,v16_data[start_index:stop_index],'-k', linewidth=1, label='V14')\nplt.plot(t_data[start_index:stop_index]*1000,v14_data[start_index:stop_index],'-r', linewidth=0.5, label='V16')\n#plt.plot(t_data[start_index:stop_index]*1000,v2_data[start_index:stop_index],'-',label='V2')\n\nplt.ylabel('Node voltage, volts')\nplt.xlabel('time,ms')\nplt.grid()\nplt.title('title')\n\n#plt.legend(loc=\"lower right\")\nplt.legend(bbox_to_anchor=(1.2,1))\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the amplitude limiting caused by the diodes on the signal.\nFrom here additional numerical analysis of the node voltages can be performed within the JupyterLab notebook using the signal processing code of NumPy and SciPy. Python’s numerical analysis capability can be combined with circuit simulation results from LTSpice and actual physical measurements of prototype circuits to aid the designer in the analysis and development of electronic circuits.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#sec-Comparison_of_MNA_and_LTSpice_results",
    "href": "Klon Centaur part 2v0.html#sec-Comparison_of_MNA_and_LTSpice_results",
    "title": "26  Klon Centaur, Part 2",
    "section": "26.6 Comparison of MNA and LTSpice results",
    "text": "26.6 Comparison of MNA and LTSpice results\nIn this section the solutions obtained from MNA and LTSpice will be compared to each other. As shown below the two solutions are very comparable which allows us to have a high degree of confidence in the accuracy of the MNA solution.\nThe netlist for the MNA solution was obtained from Figure 25.3 and the schematic of Figure 26.1 was used for the LTSpice simulation. For the MNA solution, the diodes, \\(D_2\\) and \\(D_3\\) were removed from the netlist by inserting an asterisk at the start of those lines which turn the lines into comments, shown below. Additionally, the MNA netlist treats the Op Amps as ideal Op Amps. In the LTSpice simulation, device modules are used for the diodes and Op Amps. This will add some accuracy to the simulation. The amplitude of the input signal, \\(V1\\), in the LTSpice simulation was chosen to be \\(\\pm25 mV\\) in the transient simulations, so that the diodes would not be conducting. This keeps both the MNA and the LTSpice solutions in the linear domain.\nThe MNA solution is presented first, followed by loading and reading the exported LTSpice simulation results which were exported as a csv file. The two solutions are plotted on the same graph so that the results can be compared.\nThe netlist for the circuit in Figure 25.3, was exported and shown below.\n\nnet_list = '''\n* Klon-Centaur_v1.asc\nV1 1 0 1\nR1 3 1 10e3\nR2 0 4 1000e3\nC1 4 3 100e-9\nR5 7 25 5.1e3\nR8 25 0 1.5e3\nC3 8 7 100e-9\nC4 7 25 68e-9\nC6 25 26 390e-9\nR9 26 0 1e3\nR6 9 8 10e3\nC5 9 8 68e-9\nRp1b2 25 27 50e3\nRp1a2 27 0 50e3\nRp1b1 11 0 50e3\nRp1a1 0 9 50e3\nR10 12 11 2e3\nR11 13 12 15e3\nC7 13 12 82e-9\nC8 14 13 390e-12\nR12 14 13 422e3\nR13 16 15 1e3\nC11 17 28 2.2e-9\nR15 28 27 22e3\nR17 18 27 27e3\nR18 29 27 12e3\nC12 18 29 27e-9\nR16 18 17 47e3\nR7 8 10 1.5e3\nR24 18 10 15e3\nR20 19 18 392e3\nC13 19 18 820e-12\nR21 19 32 1.8e3\nR22 20 19 100e3\nRp2a 32 30 5e3\nRp2b 30 31 5e3\nC14 20 30 3.9e-9\nR241 21 20 100e3\nR25 23 22 560\nR23 21 31 4.7e3\nO1a 7 4 7\nO1b 13 9 14\nO2a 18 0 19\nO2b 20 0 21\nR3 5 0 100e3\nR4 6 5 560\n*D2 0 16 1N34A\n*D3 16 0 1N34A\nC2 7 5 4.7e-6\nC16 10 0 1e-6\nC9 14 15 1e-6\nC10 17 16 1e-6\nC15 21 22 4.7e-6\nR26 2 6 68e3\nR28 2 0 100e3\nRp3a 23 24 50e3\nRp3b 24 0 50e3\nR27 2 24 0.01\n'''\n\nThe symbolic modified nodal analysis function is called with the netlist and the MNA results are returned.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe netlist report provides some statistics about the circuit, which are printed below.\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 56\nnumber of branches: 52\nnumber of nodes: 32\nnumber of unknown currents: 5\nnumber of RLC (passive components): 51\nnumber of resistors: 35\nnumber of capacitors: 16\nnumber of inductors: 0\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of Op Amps: 4\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\nThere are 32 nodes and 5 unknown currents in the circuit. This means that the MNA technique will generate a system of 37 equations for SymPy to solve.\nThe network equations are assembled with the following lines of Python code.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nThe system of equations is displayed with the following code using the markdown function.\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = v_{2} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{24}}{R_{27}} - \\frac{v_{6}}{R_{26}}\\)\\(0 = - C_{1} s v_{4} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}}\\)\\(0 = - C_{1} s v_{3} + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}}\\right)\\)\\(0 = - C_{2} s v_{7} + v_{5} \\left(C_{2} s + \\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{4}}\\)\\(0 = v_{6} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{2}}{R_{26}}\\)\\(0 = - C_{2} s v_{5} - C_{3} s v_{8} + I_{O1a} + v_{25} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{7} \\left(C_{2} s + C_{3} s + C_{4} s + \\frac{1}{R_{5}}\\right)\\)\\(0 = - C_{3} s v_{7} + v_{8} \\left(C_{3} s + C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) + v_{9} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) - \\frac{v_{10}}{R_{7}}\\)\\(0 = v_{8} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) + v_{9} \\left(C_{5} s + \\frac{1}{Rp1a1} + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{10} \\left(C_{16} s + \\frac{1}{R_{7}} + \\frac{1}{R_{24}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{18}}{R_{24}}\\)\\(0 = v_{11} \\cdot \\left(\\frac{1}{Rp1b1} + \\frac{1}{R_{10}}\\right) - \\frac{v_{12}}{R_{10}}\\)\\(0 = v_{12} \\left(C_{7} s + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) + v_{13} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) - \\frac{v_{11}}{R_{10}}\\)\\(0 = v_{12} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) + v_{13} \\left(C_{7} s + C_{8} s + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{14} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right)\\)\\(0 = - C_{9} s v_{15} + I_{O1b} + v_{13} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right) + v_{14} \\left(C_{8} s + C_{9} s + \\frac{1}{R_{12}}\\right)\\)\\(0 = - C_{9} s v_{14} + v_{15} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{16}}{R_{13}}\\)\\(0 = - C_{10} s v_{17} + v_{16} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{15}}{R_{13}}\\)\\(0 = - C_{10} s v_{16} - C_{11} s v_{28} + v_{17} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{18}}{R_{16}}\\)\\(0 = - C_{12} s v_{29} + v_{18} \\left(C_{12} s + C_{13} s + \\frac{1}{R_{24}} + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) + v_{19} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) - \\frac{v_{10}}{R_{24}} - \\frac{v_{27}}{R_{17}} - \\frac{v_{17}}{R_{16}}\\)\\(0 = I_{O2a} + v_{18} \\left(- C_{13} s - \\frac{1}{R_{20}}\\right) + v_{19} \\left(C_{13} s + \\frac{1}{R_{22}} + \\frac{1}{R_{21}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{20}}{R_{22}} - \\frac{v_{32}}{R_{21}}\\)\\(0 = - C_{14} s v_{30} + v_{20} \\left(C_{14} s + \\frac{1}{R_{241}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{21}}{R_{241}} - \\frac{v_{19}}{R_{22}}\\)\\(0 = - C_{15} s v_{22} + I_{O2b} + v_{21} \\left(C_{15} s + \\frac{1}{R_{241}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{20}}{R_{241}} - \\frac{v_{31}}{R_{23}}\\)\\(0 = - C_{15} s v_{21} + v_{22} \\left(C_{15} s + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}}\\)\\(0 = v_{23} \\cdot \\left(\\frac{1}{Rp3a} + \\frac{1}{R_{25}}\\right) - \\frac{v_{24}}{Rp3a} - \\frac{v_{22}}{R_{25}}\\)\\(0 = v_{24} \\cdot \\left(\\frac{1}{Rp3b} + \\frac{1}{Rp3a} + \\frac{1}{R_{27}}\\right) - \\frac{v_{23}}{Rp3a} - \\frac{v_{2}}{R_{27}}\\)\\(0 = - C_{6} s v_{26} + v_{25} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) + v_{7} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) - \\frac{v_{27}}{Rp1b2}\\)\\(0 = - C_{6} s v_{25} + v_{26} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{27} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{25}}{Rp1b2} - \\frac{v_{29}}{R_{18}} - \\frac{v_{18}}{R_{17}} - \\frac{v_{28}}{R_{15}}\\)\\(0 = - C_{11} s v_{17} + v_{28} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{27}}{R_{15}}\\)\\(0 = - C_{12} s v_{18} + v_{29} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{27}}{R_{18}}\\)\\(0 = - C_{14} s v_{20} + v_{30} \\left(C_{14} s + \\frac{1}{Rp2b} + \\frac{1}{Rp2a}\\right) - \\frac{v_{31}}{Rp2b} - \\frac{v_{32}}{Rp2a}\\)\\(0 = v_{31} \\cdot \\left(\\frac{1}{Rp2b} + \\frac{1}{R_{23}}\\right) - \\frac{v_{30}}{Rp2b} - \\frac{v_{21}}{R_{23}}\\)\\(0 = v_{32} \\cdot \\left(\\frac{1}{Rp2a} + \\frac{1}{R_{21}}\\right) - \\frac{v_{30}}{Rp2a} - \\frac{v_{19}}{R_{21}}\\)\\(V_{1} = v_{1}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{13} - v_{9}\\)\\(0 = v_{18}\\)\\(0 = v_{20}\\)\n\n\nThere are too many equations and symbols for SymPy to obtain a symbolic solution and symbolic results would not be useful.\nThe following code is used to turn the free symbols into SymPy variables and the numeric values for the components are put into a Python dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n26.6.1 Numerical Solution\nAs shown below, the value of \\(V1\\) is set to one. The value of \\(V1\\) gets canceled in the voltage transfer function, so this value does not affect the solution. The bypass switch is put into the effects position by setting the values of \\(R_{26}\\) and \\(R_{27}\\). The controls on the Klon Centaur are set to mid position.\n\nelement_values[V1] = 1\n\n# bypass switch in effects position\nelement_values[R26] = 68e3\nelement_values[R27] = 0.01\n\n# gain pot, P1\nP1_value = 100e3\nP1_setting = 0.5 # a percent of full scale\nelement_values[Rp1b2] = P1_setting*P1_value\nelement_values[Rp1a2] = P1_value - P1_setting*P1_value\nelement_values[Rp1b1] = P1_setting*P1_value\nelement_values[Rp1a1] = P1_value - P1_setting*P1_value\n\n# treble pot, P2\nP2_value = 10e3\nP2_setting = 0.5\nelement_values[Rp2b] = P2_setting*P2_value\nelement_values[Rp2a] = P2_value - P2_setting*P2_value\n\n#output pot, P3\nP3_value = 100e3\nP3_setting = 0.5\nelement_values[Rp3b] = P3_setting*P3_value\nelement_values[Rp3a] = P3_value - P3_setting*P3_value\n\nThe following code replaces the symbols in the network equations with numerical values and displays the equations.\n\nNE = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.0001 v_{1} - 0.0001 v_{3}\\)\\(0 = 100.000024705882 v_{2} - 100.0 v_{24} - 1.47058823529412 \\cdot 10^{-5} v_{6}\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{4} - 0.0001 v_{1} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.0001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{3} + v_{4} \\cdot \\left(1.0 \\cdot 10^{-7} s + 1.0 \\cdot 10^{-6}\\right)\\)\\(0 = - 4.7 \\cdot 10^{-6} s v_{7} + v_{5} \\cdot \\left(4.7 \\cdot 10^{-6} s + 0.00179571428571429\\right) - 0.00178571428571429 v_{6}\\)\\(0 = - 1.47058823529412 \\cdot 10^{-5} v_{2} - 0.00178571428571429 v_{5} + 0.00180042016806723 v_{6}\\)\\(0 = I_{O1a} - 4.7 \\cdot 10^{-6} s v_{5} - 1.0 \\cdot 10^{-7} s v_{8} + v_{25} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right) + v_{7} \\cdot \\left(4.868 \\cdot 10^{-6} s + 0.000196078431372549\\right)\\)\\(0 = - 1.0 \\cdot 10^{-7} s v_{7} - 0.000666666666666667 v_{10} + v_{8} \\cdot \\left(1.68 \\cdot 10^{-7} s + 0.000766666666666667\\right) + v_{9} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right)\\)\\(0 = v_{8} \\left(- 6.8 \\cdot 10^{-8} s - 0.0001\\right) + v_{9} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.00012\\right)\\)\\(0 = v_{10} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.000733333333333333\\right) - 6.66666666666667 \\cdot 10^{-5} v_{18} - 0.000666666666666667 v_{8}\\)\\(0 = 0.00052 v_{11} - 0.0005 v_{12}\\)\\(0 = - 0.0005 v_{11} + v_{12} \\cdot \\left(8.2 \\cdot 10^{-8} s + 0.000566666666666667\\right) + v_{13} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right)\\)\\(0 = v_{12} \\left(- 8.2 \\cdot 10^{-8} s - 6.66666666666667 \\cdot 10^{-5}\\right) + v_{13} \\cdot \\left(8.239 \\cdot 10^{-8} s + 6.90363349131122 \\cdot 10^{-5}\\right) + v_{14} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = I_{O1b} - 1.0 \\cdot 10^{-6} s v_{15} + v_{13} \\left(- 3.9 \\cdot 10^{-10} s - 2.3696682464455 \\cdot 10^{-6}\\right) + v_{14} \\cdot \\left(1.00039 \\cdot 10^{-6} s + 2.3696682464455 \\cdot 10^{-6}\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{14} + v_{15} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{16}\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{17} - 0.001 v_{15} + v_{16} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\\(0 = - 1.0 \\cdot 10^{-6} s v_{16} - 2.2 \\cdot 10^{-9} s v_{28} + v_{17} \\cdot \\left(1.0022 \\cdot 10^{-6} s + 2.12765957446809 \\cdot 10^{-5}\\right) - 2.12765957446809 \\cdot 10^{-5} v_{18}\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{29} - 6.66666666666667 \\cdot 10^{-5} v_{10} - 2.12765957446809 \\cdot 10^{-5} v_{17} + v_{18} \\cdot \\left(2.782 \\cdot 10^{-8} s + 0.000127531319856548\\right) + v_{19} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) - 3.7037037037037 \\cdot 10^{-5} v_{27}\\)\\(0 = I_{O2a} + v_{18} \\left(- 8.2 \\cdot 10^{-10} s - 2.55102040816327 \\cdot 10^{-6}\\right) + v_{19} \\cdot \\left(8.2 \\cdot 10^{-10} s + 0.000568106575963719\\right) - 1.0 \\cdot 10^{-5} v_{20} - 0.000555555555555556 v_{32}\\)\\(0 = - 3.9 \\cdot 10^{-9} s v_{30} - 1.0 \\cdot 10^{-5} v_{19} + v_{20} \\cdot \\left(3.9 \\cdot 10^{-9} s + 2.0 \\cdot 10^{-5}\\right) - 1.0 \\cdot 10^{-5} v_{21}\\)\\(0 = I_{O2b} - 4.7 \\cdot 10^{-6} s v_{22} - 1.0 \\cdot 10^{-5} v_{20} + v_{21} \\cdot \\left(4.7 \\cdot 10^{-6} s + 0.000222765957446809\\right) - 0.000212765957446809 v_{31}\\)\\(0 = - 4.7 \\cdot 10^{-6} s v_{21} + v_{22} \\cdot \\left(4.7 \\cdot 10^{-6} s + 0.00178571428571429\\right) - 0.00178571428571429 v_{23}\\)\\(0 = - 0.00178571428571429 v_{22} + 0.00180571428571429 v_{23} - 2.0 \\cdot 10^{-5} v_{24}\\)\\(0 = - 100.0 v_{2} - 2.0 \\cdot 10^{-5} v_{23} + 100.00004 v_{24}\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{26} + v_{25} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745098039216\\right) - 2.0 \\cdot 10^{-5} v_{27} + v_{7} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078431372549\\right)\\)\\(0 = - 3.9 \\cdot 10^{-7} s v_{25} + v_{26} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\\(0 = - 3.7037037037037 \\cdot 10^{-5} v_{18} - 2.0 \\cdot 10^{-5} v_{25} + 0.000205824915824916 v_{27} - 4.54545454545455 \\cdot 10^{-5} v_{28} - 8.33333333333333 \\cdot 10^{-5} v_{29}\\)\\(0 = - 2.2 \\cdot 10^{-9} s v_{17} - 4.54545454545455 \\cdot 10^{-5} v_{27} + v_{28} \\cdot \\left(2.2 \\cdot 10^{-9} s + 4.54545454545455 \\cdot 10^{-5}\\right)\\)\\(0 = - 2.7 \\cdot 10^{-8} s v_{18} - 8.33333333333333 \\cdot 10^{-5} v_{27} + v_{29} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.33333333333333 \\cdot 10^{-5}\\right)\\)\\(0 = - 3.9 \\cdot 10^{-9} s v_{20} + v_{30} \\cdot \\left(3.9 \\cdot 10^{-9} s + 0.0004\\right) - 0.0002 v_{31} - 0.0002 v_{32}\\)\\(0 = - 0.000212765957446809 v_{21} - 0.0002 v_{30} + 0.000412765957446809 v_{31}\\)\\(0 = - 0.000555555555555556 v_{19} - 0.0002 v_{30} + 0.000755555555555556 v_{32}\\)\\(1 = v_{1}\\)\\(0 = - v_{4} + v_{7}\\)\\(0 = v_{13} - v_{9}\\)\\(0 = v_{18}\\)\\(0 = v_{20}\\)\n\n\nSolve for voltages and currents and display the results.\n\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{1.60460486959839 \\cdot 10^{204} s^{15} + 3.27859737275232 \\cdot 10^{209} s^{14} + 2.24239224921523 \\cdot 10^{214} s^{13} + 6.17846960611372 \\cdot 10^{218} s^{12} + 6.98631389088568 \\cdot 10^{222} s^{11} + 3.84144613823827 \\cdot 10^{226} s^{10} + 1.14176089090876 \\cdot 10^{230} s^{9} + 1.9487479169721 \\cdot 10^{233} s^{8} + 1.9264469914375 \\cdot 10^{236} s^{7} + 1.04007382786928 \\cdot 10^{239} s^{6} + 2.4949612511751 \\cdot 10^{241} s^{5} + 8.71156576910649 \\cdot 10^{242} s^{4} + 1.59377116458413 \\cdot 10^{244} s^{3} + 5.83569842526406 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{3} = \\frac{100.0 s + 1000.0}{101.0 s + 1000.0}\\)\\(v_{4} = \\frac{100.0 s}{101.0 s + 1000.0}\\)\\(v_{5} = \\frac{7.08081890044526 \\cdot 10^{204} s^{15} + 5.16811216386491 \\cdot 10^{209} s^{14} + 1.44527574255849 \\cdot 10^{214} s^{13} + 2.06993156176013 \\cdot 10^{218} s^{12} + 1.70763881138264 \\cdot 10^{222} s^{11} + 8.56283170735283 \\cdot 10^{225} s^{10} + 2.66372688771691 \\cdot 10^{229} s^{9} + 5.13265459135094 \\cdot 10^{232} s^{8} + 5.97388273658386 \\cdot 10^{235} s^{7} + 3.92904920853072 \\cdot 10^{238} s^{6} + 1.24088217015922 \\cdot 10^{241} s^{5} + 1.14762193670536 \\cdot 10^{243} s^{4} + 2.99189745426633 \\cdot 10^{244} s^{3} + 9.40378060745908 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{6} = \\frac{7.03608903088174 \\cdot 10^{204} s^{15} + 5.15267855413586 \\cdot 10^{209} s^{14} + 1.45178661250784 \\cdot 10^{214} s^{13} + 2.10349021556464 \\cdot 10^{218} s^{12} + 1.75075517725956 \\cdot 10^{222} s^{11} + 8.80666065452342 \\cdot 10^{225} s^{10} + 2.73522884121702 \\cdot 10^{229} s^{9} + 5.24990520050914 \\cdot 10^{232} s^{8} + 6.08244062485052 \\cdot 10^{235} s^{7} + 3.9819101460933 \\cdot 10^{238} s^{6} + 1.25112552321302 \\cdot 10^{241} s^{5} + 1.14536375990424 \\cdot 10^{243} s^{4} + 2.98047751957814 \\cdot 10^{244} s^{3} + 9.37463641227194 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{7} = \\frac{100.0 s}{101.0 s + 1000.0}\\)\\(v_{8} = \\frac{1.53 \\cdot 10^{27} s^{4} + 3.822 \\cdot 10^{30} s^{3} + 1.98 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{9} = \\frac{1.53 \\cdot 10^{27} s^{4} + 3.372 \\cdot 10^{30} s^{3} + 1.65 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{10} = \\frac{1.02 \\cdot 10^{30} s^{3} + 1.8 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{11} = \\frac{1.56825 \\cdot 10^{39} s^{5} + 4.7313 \\cdot 10^{42} s^{4} + 4.50125 \\cdot 10^{45} s^{3} + 1.375 \\cdot 10^{48} s^{2}}{1.6472898 \\cdot 10^{39} s^{5} + 1.716827928 \\cdot 10^{43} s^{4} + 3.92993125840001 \\cdot 10^{46} s^{3} + 2.60963579706668 \\cdot 10^{49} s^{2} + 1.98012893333334 \\cdot 10^{51} s + 1.70850000000001 \\cdot 10^{52}}\\)\\(v_{12} = \\frac{1.63098 \\cdot 10^{39} s^{5} + 4.920552 \\cdot 10^{42} s^{4} + 4.6813 \\cdot 10^{45} s^{3} + 1.43 \\cdot 10^{48} s^{2}}{1.6472898 \\cdot 10^{39} s^{5} + 1.716827928 \\cdot 10^{43} s^{4} + 3.92993125840001 \\cdot 10^{46} s^{3} + 2.60963579706668 \\cdot 10^{49} s^{2} + 1.98012893333334 \\cdot 10^{51} s + 1.70850000000001 \\cdot 10^{52}}\\)\\(v_{13} = \\frac{1.53 \\cdot 10^{27} s^{4} + 3.372 \\cdot 10^{30} s^{3} + 1.65 \\cdot 10^{33} s^{2}}{1.5453 \\cdot 10^{27} s^{4} + 1.448658 \\cdot 10^{31} s^{3} + 2.1691024 \\cdot 10^{34} s^{2} + 1.758644 \\cdot 10^{36} s + 1.53 \\cdot 10^{37}}\\)\\(v_{14} = \\frac{1.2721644 \\cdot 10^{48} s^{6} + 7.45961435931766 \\cdot 10^{52} s^{5} + 2.18693901867302 \\cdot 10^{56} s^{4} + 2.07668666587681 \\cdot 10^{59} s^{3} + 6.37322274881527 \\cdot 10^{61} s^{2}}{1.284886044 \\cdot 10^{48} s^{6} + 2.11983185019071 \\cdot 10^{52} s^{5} + 1.12019716327369 \\cdot 10^{56} s^{4} + 2.06607825492002 \\cdot 10^{59} s^{3} + 1.25223922229928 \\cdot 10^{62} s^{2} + 9.39782361437604 \\cdot 10^{63} s + 8.09715639810431 \\cdot 10^{64}}\\)\\(v_{15} = \\frac{6.12932264586913 \\cdot 10^{102} s^{11} + 6.51555635737714 \\cdot 10^{107} s^{10} + 2.17603109429572 \\cdot 10^{112} s^{9} + 2.68844248892112 \\cdot 10^{116} s^{8} + 1.13053821227643 \\cdot 10^{120} s^{7} + 2.23994746250022 \\cdot 10^{123} s^{6} + 2.30739995895308 \\cdot 10^{126} s^{5} + 1.20420010870915 \\cdot 10^{129} s^{4} + 2.58996550003362 \\cdot 10^{131} s^{3} + 4.88678797757097 \\cdot 10^{132} s^{2}}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{16} = \\frac{5.82609631815901 \\cdot 10^{102} s^{11} + 6.20459033050087 \\cdot 10^{107} s^{10} + 2.08899742179437 \\cdot 10^{112} s^{9} + 2.61237691738473 \\cdot 10^{116} s^{8} + 1.1029219023253 \\cdot 10^{120} s^{7} + 2.18945780465391 \\cdot 10^{123} s^{6} + 2.25814621576051 \\cdot 10^{126} s^{5} + 1.17971076699241 \\cdot 10^{129} s^{4} + 2.54117204265127 \\cdot 10^{131} s^{3} + 4.88678797757097 \\cdot 10^{132} s^{2}}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{17} = \\frac{5.82609631815901 \\cdot 10^{102} s^{11} + 6.20155806722377 \\cdot 10^{107} s^{10} + 2.08588776152561 \\cdot 10^{112} s^{9} + 2.6036735501346 \\cdot 10^{116} s^{8} + 1.09531534517166 \\cdot 10^{120} s^{7} + 2.16184149470277 \\cdot 10^{123} s^{6} + 2.2076565579142 \\cdot 10^{126} s^{5} + 1.13045702379984 \\cdot 10^{129} s^{4} + 2.2962786254839 \\cdot 10^{131} s^{3} + 7.44223933649292 \\cdot 10^{129} s^{2}}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{18} = 0.0\\)\\(v_{19} = \\frac{- 7.729048460181 \\cdot 10^{111} s^{11} - 6.70683975958242 \\cdot 10^{116} s^{10} - 1.81971363059071 \\cdot 10^{121} s^{9} - 1.67621479136811 \\cdot 10^{125} s^{8} - 6.52036854696871 \\cdot 10^{128} s^{7} - 1.29707240532995 \\cdot 10^{132} s^{6} - 1.40520092072882 \\cdot 10^{135} s^{5} - 7.99228974825901 \\cdot 10^{137} s^{4} - 1.93754865846681 \\cdot 10^{140} s^{3} - 4.5595739475291 \\cdot 10^{141} s^{2} - 5.87797755461241 \\cdot 10^{142} s}{1.11932525587559 \\cdot 10^{107} s^{12} + 7.53562243981751 \\cdot 10^{111} s^{11} + 1.85774899364618 \\cdot 10^{116} s^{10} + 2.21913676324559 \\cdot 10^{120} s^{9} + 1.44029380607801 \\cdot 10^{124} s^{8} + 5.35372971100406 \\cdot 10^{127} s^{7} + 1.16592059808606 \\cdot 10^{131} s^{6} + 1.47731120257604 \\cdot 10^{134} s^{5} + 1.03131600544421 \\cdot 10^{137} s^{4} + 3.39523523720125 \\cdot 10^{139} s^{3} + 3.22720097422481 \\cdot 10^{141} s^{2} + 9.92148657875569 \\cdot 10^{142} s + 6.97940858343004 \\cdot 10^{143}}\\)\\(v_{20} = 0.0\\)\\(v_{21} = \\frac{3.95481784029325 \\cdot 10^{142} s^{12} + 3.59328293991187 \\cdot 10^{147} s^{11} + 1.07126591160631 \\cdot 10^{152} s^{10} + 1.2379488657562 \\cdot 10^{156} s^{9} + 6.83908611414043 \\cdot 10^{159} s^{8} + 2.02622810355854 \\cdot 10^{163} s^{7} + 3.42946419411261 \\cdot 10^{166} s^{6} + 3.34535147697467 \\cdot 10^{169} s^{5} + 1.76926228708653 \\cdot 10^{172} s^{4} + 4.0721594196483 \\cdot 10^{174} s^{3} + 9.55806164763192 \\cdot 10^{175} s^{2} + 1.22830078078907 \\cdot 10^{177} s}{4.12410117110505 \\cdot 10^{137} s^{13} + 3.0103661400075 \\cdot 10^{142} s^{12} + 8.41948178298009 \\cdot 10^{146} s^{11} + 1.20583791200201 \\cdot 10^{151} s^{10} + 9.94394854727057 \\cdot 10^{154} s^{9} + 4.98228898678412 \\cdot 10^{158} s^{8} + 1.54832846094415 \\cdot 10^{162} s^{7} + 2.98069258113566 \\cdot 10^{165} s^{6} + 3.4670700029695 \\cdot 10^{168} s^{5} + 2.28020147721265 \\cdot 10^{171} s^{4} + 7.21381116019837 \\cdot 10^{173} s^{3} + 6.78032628263838 \\cdot 10^{175} s^{2} + 2.07583050373503 \\cdot 10^{177} s + 1.4584630398505 \\cdot 10^{178}}\\)\\(v_{22} = \\frac{6.85813943594846 \\cdot 10^{209} s^{14} + 6.23149200163213 \\cdot 10^{214} s^{13} + 1.85798416714712 \\cdot 10^{219} s^{12} + 2.14759495200953 \\cdot 10^{223} s^{11} + 1.18695802863377 \\cdot 10^{227} s^{10} + 3.51914477074802 \\cdot 10^{230} s^{9} + 5.96321503551836 \\cdot 10^{233} s^{8} + 5.82860517934846 \\cdot 10^{236} s^{7} + 3.09491694101256 \\cdot 10^{239} s^{6} + 7.20414774924852 \\cdot 10^{241} s^{5} + 1.98864584585651 \\cdot 10^{243} s^{4} + 2.98014618856633 \\cdot 10^{244} s^{3} + 1.20559813397992 \\cdot 10^{245} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{23} = \\frac{1.7772515220219 \\cdot 10^{202} s^{15} + 6.81849260987794 \\cdot 10^{209} s^{14} + 6.18730893852549 \\cdot 10^{214} s^{13} + 1.84424847158735 \\cdot 10^{219} s^{12} + 2.13154630657843 \\cdot 10^{223} s^{11} + 1.17806610880784 \\cdot 10^{227} s^{10} + 3.49281298994759 \\cdot 10^{230} s^{9} + 5.91875100545495 \\cdot 10^{233} s^{8} + 5.78538507711761 \\cdot 10^{236} s^{7} + 3.07215760493155 \\cdot 10^{239} s^{6} + 7.15198904282505 \\cdot 10^{241} s^{5} + 1.97626859181365 \\cdot 10^{243} s^{4} + 2.96479076850346 \\cdot 10^{244} s^{3} + 1.19870858018881 \\cdot 10^{245} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{24} = \\frac{1.6046042313112 \\cdot 10^{204} s^{15} + 3.27859742501188 \\cdot 10^{209} s^{14} + 2.24239258971998 \\cdot 10^{214} s^{13} + 6.17847082322234 \\cdot 10^{218} s^{12} + 6.98631535945215 \\cdot 10^{222} s^{11} + 3.8414469577917 \\cdot 10^{226} s^{10} + 1.1417611327669 \\cdot 10^{230} s^{9} + 1.94874832122297 \\cdot 10^{233} s^{8} + 1.92644737793556 \\cdot 10^{236} s^{7} + 1.04007402627119 \\cdot 10^{239} s^{6} + 2.49496168358823 \\cdot 10^{241} s^{5} + 8.71156623701718 \\cdot 10^{242} s^{4} + 1.59377112003383 \\cdot 10^{244} s^{3} + 5.83569848840183 \\cdot 10^{244} s^{2}}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\\(v_{25} = \\frac{2.45172905834765 \\cdot 10^{103} s^{11} + 9.68148531052587 \\cdot 10^{107} s^{10} + 1.4606354787583 \\cdot 10^{112} s^{9} + 1.1118010386943 \\cdot 10^{116} s^{8} + 4.74470229541557 \\cdot 10^{119} s^{7} + 1.18318963185146 \\cdot 10^{123} s^{6} + 1.71551739396071 \\cdot 10^{126} s^{5} + 1.36079544612597 \\cdot 10^{129} s^{4} + 4.9599835245097 \\cdot 10^{131} s^{3} + 4.50843208510485 \\cdot 10^{133} s^{2} + 1.10895177447563 \\cdot 10^{135} s}{2.47624634893113 \\cdot 10^{103} s^{11} + 1.59004486411129 \\cdot 10^{108} s^{10} + 3.61517379487977 \\cdot 10^{112} s^{9} + 3.78464232805846 \\cdot 10^{116} s^{8} + 2.00891207055978 \\cdot 10^{120} s^{7} + 5.59415322555028 \\cdot 10^{123} s^{6} + 8.38986340894985 \\cdot 10^{126} s^{5} + 6.58119928527113 \\cdot 10^{129} s^{4} + 2.34134961457795 \\cdot 10^{132} s^{3} + 2.27227126156765 \\cdot 10^{134} s^{2} + 7.03932584377252 \\cdot 10^{135} s + 4.96313499266136 \\cdot 10^{136}}\\)\\(v_{26} = \\frac{1.8859454294982 \\cdot 10^{102} s^{11} + 6.96372064155883 \\cdot 10^{106} s^{10} + 9.4500881336385 \\cdot 10^{110} s^{9} + 6.12921616081805 \\cdot 10^{114} s^{8} + 2.07817710908427 \\cdot 10^{118} s^{7} + 3.77279945248749 \\cdot 10^{121} s^{6} + 3.52244289588368 \\cdot 10^{124} s^{5} + 1.43575241665188 \\cdot 10^{127} s^{4} + 1.33955488977009 \\cdot 10^{129} s^{3} + 3.3268553234269 \\cdot 10^{130} s^{2}}{1.90480488379318 \\cdot 10^{102} s^{11} + 1.22311143393176 \\cdot 10^{107} s^{10} + 2.78090291913828 \\cdot 10^{111} s^{9} + 2.91126332927574 \\cdot 10^{115} s^{8} + 1.54531697735368 \\cdot 10^{119} s^{7} + 4.30319478888483 \\cdot 10^{122} s^{6} + 6.45374108380758 \\cdot 10^{125} s^{5} + 5.0624609886701 \\cdot 10^{128} s^{4} + 1.80103816505996 \\cdot 10^{131} s^{3} + 1.74790097043665 \\cdot 10^{133} s^{2} + 5.41486603367117 \\cdot 10^{134} s + 3.81779614820105 \\cdot 10^{135}}\\)\\(v_{27} = \\frac{1.88222602341909 \\cdot 10^{102} s^{11} + 1.44831320913199 \\cdot 10^{107} s^{10} + 3.33801857194441 \\cdot 10^{111} s^{9} + 2.10195340190251 \\cdot 10^{115} s^{8} + 6.09908734298142 \\cdot 10^{118} s^{7} + 1.03118401308102 \\cdot 10^{122} s^{6} + 1.15158862697664 \\cdot 10^{125} s^{5} + 8.34202083067121 \\cdot 10^{127} s^{4} + 3.11019048617547 \\cdot 10^{130} s^{3} + 2.89886444198637 \\cdot 10^{132} s^{2} + 7.19752353626009 \\cdot 10^{133} s}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{28} = \\frac{5.82609631815901 \\cdot 10^{102} s^{11} + 5.38670883277337 \\cdot 10^{107} s^{10} + 1.27216965746747 \\cdot 10^{112} s^{9} + 6.64897103289498 \\cdot 10^{115} s^{8} + 1.55848892487266 \\cdot 10^{119} s^{7} + 2.0196506789592 \\cdot 10^{122} s^{6} + 1.65370058165892 \\cdot 10^{125} s^{5} + 9.3035629828195 \\cdot 10^{127} s^{4} + 3.09621286334538 \\cdot 10^{130} s^{3} + 2.89538084059482 \\cdot 10^{132} s^{2} + 7.19752353626009 \\cdot 10^{133} s}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{29} = \\frac{5.80933957845398 \\cdot 10^{105} s^{10} + 4.29080189304769 \\cdot 10^{110} s^{9} + 8.97820488469026 \\cdot 10^{114} s^{8} + 3.71645960936262 \\cdot 10^{118} s^{7} + 7.3537893012926 \\cdot 10^{121} s^{6} + 9.12978651085666 \\cdot 10^{124} s^{5} + 7.36450542873379 \\cdot 10^{127} s^{4} + 3.01702284548585 \\cdot 10^{130} s^{3} + 2.87554446572889 \\cdot 10^{132} s^{2} + 7.19752353626009 \\cdot 10^{133} s}{6.19061587232783 \\cdot 10^{102} s^{11} + 3.97511216027823 \\cdot 10^{107} s^{10} + 9.03793448719941 \\cdot 10^{111} s^{9} + 9.46160582014616 \\cdot 10^{115} s^{8} + 5.02228017639945 \\cdot 10^{119} s^{7} + 1.39853830638757 \\cdot 10^{123} s^{6} + 2.09746585223746 \\cdot 10^{126} s^{5} + 1.64529982131778 \\cdot 10^{129} s^{4} + 5.85337403644487 \\cdot 10^{131} s^{3} + 5.68067815391911 \\cdot 10^{133} s^{2} + 1.75983146094313 \\cdot 10^{135} s + 1.24078374816534 \\cdot 10^{136}}\\)\\(v_{30} = \\frac{- 8.51604883530572 \\cdot 10^{145} s^{11} - 7.38975505425107 \\cdot 10^{150} s^{10} - 2.00500362033169 \\cdot 10^{155} s^{9} - 1.84689319717609 \\cdot 10^{159} s^{8} - 7.18429665129523 \\cdot 10^{162} s^{7} - 1.42914512745319 \\cdot 10^{166} s^{6} - 1.54828368925286 \\cdot 10^{169} s^{5} - 8.80609432748894 \\cdot 10^{171} s^{4} - 2.13483704770277 \\cdot 10^{174} s^{3} - 5.02384667470906 \\cdot 10^{175} s^{2} - 6.47649502597865 \\cdot 10^{176} s}{1.23723035133151 \\cdot 10^{138} s^{13} + 9.03109842002251 \\cdot 10^{142} s^{12} + 2.52584453489403 \\cdot 10^{147} s^{11} + 3.61751373600603 \\cdot 10^{151} s^{10} + 2.98318456418117 \\cdot 10^{155} s^{9} + 1.49468669603524 \\cdot 10^{159} s^{8} + 4.64498538283244 \\cdot 10^{162} s^{7} + 8.94207774340698 \\cdot 10^{165} s^{6} + 1.04012100089085 \\cdot 10^{169} s^{5} + 6.84060443163796 \\cdot 10^{171} s^{4} + 2.16414334805951 \\cdot 10^{174} s^{3} + 2.03409788479151 \\cdot 10^{176} s^{2} + 6.22749151120508 \\cdot 10^{177} s + 4.3753891195515 \\cdot 10^{178}}\\)\\(v_{31} = \\frac{6.11569769117515 \\cdot 10^{142} s^{12} + 5.51535977354834 \\cdot 10^{147} s^{11} + 1.62079074088092 \\cdot 10^{152} s^{10} + 1.81720425616362 \\cdot 10^{156} s^{9} + 9.68101996756486 \\cdot 10^{159} s^{8} + 2.78523733270819 \\cdot 10^{163} s^{7} + 4.61082276419168 \\cdot 10^{166} s^{6} + 4.42302462011667 \\cdot 10^{169} s^{5} + 2.3092855641627 \\cdot 10^{172} s^{4} + 5.26274816190945 \\cdot 10^{174} s^{3} + 1.23462727158089 \\cdot 10^{176} s^{2} + 1.58562464429135 \\cdot 10^{177} s}{1.23723035133151 \\cdot 10^{138} s^{13} + 9.03109842002251 \\cdot 10^{142} s^{12} + 2.52584453489403 \\cdot 10^{147} s^{11} + 3.61751373600603 \\cdot 10^{151} s^{10} + 2.98318456418117 \\cdot 10^{155} s^{9} + 1.49468669603524 \\cdot 10^{159} s^{8} + 4.64498538283244 \\cdot 10^{162} s^{7} + 8.94207774340698 \\cdot 10^{165} s^{6} + 1.04012100089085 \\cdot 10^{169} s^{5} + 6.84060443163796 \\cdot 10^{171} s^{4} + 2.16414334805951 \\cdot 10^{174} s^{3} + 2.03409788479151 \\cdot 10^{176} s^{2} + 6.22749151120508 \\cdot 10^{177} s + 4.3753891195515 \\cdot 10^{178}}\\)\\(v_{32} = \\frac{- 2.09392021448787 \\cdot 10^{142} s^{12} - 1.94326032460412 \\cdot 10^{147} s^{11} - 6.02561137520802 \\cdot 10^{151} s^{10} - 7.51406465858297 \\cdot 10^{155} s^{9} - 4.5049667155391 \\cdot 10^{159} s^{8} - 1.41665499765086 \\cdot 10^{163} s^{7} - 2.4997681836795 \\cdot 10^{166} s^{6} - 2.51225462752033 \\cdot 10^{169} s^{5} - 1.35822245396784 \\cdot 10^{172} s^{4} - 3.17780063580552 \\cdot 10^{174} s^{3} - 7.46507632725237 \\cdot 10^{175} s^{2} - 9.6030788316236 \\cdot 10^{176} s}{4.12410117110505 \\cdot 10^{137} s^{13} + 3.0103661400075 \\cdot 10^{142} s^{12} + 8.41948178298009 \\cdot 10^{146} s^{11} + 1.20583791200201 \\cdot 10^{151} s^{10} + 9.94394854727057 \\cdot 10^{154} s^{9} + 4.98228898678412 \\cdot 10^{158} s^{8} + 1.54832846094415 \\cdot 10^{162} s^{7} + 2.98069258113566 \\cdot 10^{165} s^{6} + 3.4670700029695 \\cdot 10^{168} s^{5} + 2.28020147721265 \\cdot 10^{171} s^{4} + 7.21381116019837 \\cdot 10^{173} s^{3} + 6.78032628263838 \\cdot 10^{175} s^{2} + 2.07583050373503 \\cdot 10^{177} s + 1.4584630398505 \\cdot 10^{178}}\\)\\(I_{V1} = - \\frac{s}{1010000.0 s + 10000000.0}\\)\\(I_{O1a} = \\frac{- 2.70597410328679 \\cdot 10^{219} s^{15} - 1.40952219736433 \\cdot 10^{224} s^{14} - 2.89506196813579 \\cdot 10^{228} s^{13} - 3.04164245258279 \\cdot 10^{232} s^{12} - 1.83147809274918 \\cdot 10^{236} s^{11} - 6.73574545204554 \\cdot 10^{239} s^{10} - 1.5665738047603 \\cdot 10^{243} s^{9} - 2.32141567625824 \\cdot 10^{246} s^{8} - 2.14477529599212 \\cdot 10^{249} s^{7} - 1.16030830949982 \\cdot 10^{252} s^{6} - 3.18519845024456 \\cdot 10^{254} s^{5} - 3.09847396565709 \\cdot 10^{256} s^{4} - 8.94956428372171 \\cdot 10^{257} s^{3} - 5.14067180787152 \\cdot 10^{258} s^{2} - 7.57219841131285 \\cdot 10^{258} s}{1.14426033431195 \\cdot 10^{222} s^{15} + 8.35332028071706 \\cdot 10^{226} s^{14} + 2.33666500385672 \\cdot 10^{231} s^{13} + 3.34741928805962 \\cdot 10^{235} s^{12} + 2.76150756989043 \\cdot 10^{239} s^{11} + 1.38442436148026 \\cdot 10^{243} s^{10} + 4.30623628788468 \\cdot 10^{246} s^{9} + 8.30212816663644 \\cdot 10^{249} s^{8} + 9.68123085316084 \\cdot 10^{252} s^{7} + 6.3982750284636 \\cdot 10^{255} s^{6} + 2.04872740406202 \\cdot 10^{258} s^{5} + 2.03099522034642 \\cdot 10^{260} s^{4} + 7.18430910233388 \\cdot 10^{261} s^{3} + 8.56450849506381 \\cdot 10^{262} s^{2} + 3.71961416513097 \\cdot 10^{263} s + 4.97297061330902 \\cdot 10^{263}}\\)\\(I_{O1b} = \\frac{- 4.21097917053769 \\cdot 10^{104} s^{11} - 3.77924980566261 \\cdot 10^{109} s^{10} - 9.92997441757908 \\cdot 10^{113} s^{9} - 8.50908134662235 \\cdot 10^{117} s^{8} - 3.06757906646461 \\cdot 10^{121} s^{7} - 5.59206863004313 \\cdot 10^{124} s^{6} - 5.45154925766715 \\cdot 10^{127} s^{5} - 2.71561053418032 \\cdot 10^{130} s^{4} - 5.46266159572619 \\cdot 10^{132} s^{3} - 1.99716435906042 \\cdot 10^{133} s^{2}}{6.19061587232783 \\cdot 10^{108} s^{11} + 3.97511216027823 \\cdot 10^{113} s^{10} + 9.03793448719942 \\cdot 10^{117} s^{9} + 9.46160582014616 \\cdot 10^{121} s^{8} + 5.02228017639945 \\cdot 10^{125} s^{7} + 1.39853830638757 \\cdot 10^{129} s^{6} + 2.09746585223746 \\cdot 10^{132} s^{5} + 1.64529982131778 \\cdot 10^{135} s^{4} + 5.85337403644487 \\cdot 10^{137} s^{3} + 5.68067815391911 \\cdot 10^{139} s^{2} + 1.75983146094313 \\cdot 10^{141} s + 1.24078374816534 \\cdot 10^{142}}\\)\\(I_{O2a} = \\frac{3.3626013454035 \\cdot 10^{136} s^{13} + 9.65376563272377 \\cdot 10^{141} s^{12} + 6.94781520560786 \\cdot 10^{146} s^{11} + 1.92876721384856 \\cdot 10^{151} s^{10} + 2.22164463155264 \\cdot 10^{155} s^{9} + 1.24858671565291 \\cdot 10^{159} s^{8} + 3.76102357261743 \\cdot 10^{162} s^{7} + 6.4489486322457 \\cdot 10^{165} s^{6} + 6.35343543582645 \\cdot 10^{168} s^{5} + 3.38584747530741 \\cdot 10^{171} s^{4} + 7.83854999479935 \\cdot 10^{173} s^{3} + 1.8403929052726 \\cdot 10^{175} s^{2} + 2.36593974661912 \\cdot 10^{176} s}{5.93870568639127 \\cdot 10^{140} s^{13} + 4.3349272416108 \\cdot 10^{145} s^{12} + 1.21240537674913 \\cdot 10^{150} s^{11} + 1.73640659328289 \\cdot 10^{154} s^{10} + 1.43192859080696 \\cdot 10^{158} s^{9} + 7.17449614096913 \\cdot 10^{161} s^{8} + 2.22959298375957 \\cdot 10^{165} s^{7} + 4.29219731683535 \\cdot 10^{168} s^{6} + 4.99258080427609 \\cdot 10^{171} s^{5} + 3.28349012718622 \\cdot 10^{174} s^{4} + 1.03878880706857 \\cdot 10^{177} s^{3} + 9.76366984699927 \\cdot 10^{178} s^{2} + 2.98919592537844 \\cdot 10^{180} s + 2.10018677738472 \\cdot 10^{181}}\\)\\(I_{O2b} = \\frac{2.03114459659645 \\cdot 10^{202} s^{15} - 5.41693661192227 \\cdot 10^{208} s^{14} - 5.04785253855921 \\cdot 10^{213} s^{13} - 1.53008409272363 \\cdot 10^{218} s^{12} - 1.81469537957374 \\cdot 10^{222} s^{11} - 1.03167063298355 \\cdot 10^{226} s^{10} - 3.12503707997176 \\cdot 10^{229} s^{9} - 5.37863302316374 \\cdot 10^{232} s^{8} - 5.31943071374497 \\cdot 10^{235} s^{7} - 2.85232586842996 \\cdot 10^{238} s^{6} - 6.71226680183562 \\cdot 10^{240} s^{5} - 1.97687215290958 \\cdot 10^{242} s^{4} - 3.0724877848804 \\cdot 10^{243} s^{3} - 1.58099876055239 \\cdot 10^{244} s^{2} - 2.1981591906048 \\cdot 10^{244} s}{4.57704133724782 \\cdot 10^{207} s^{15} + 3.34132811228682 \\cdot 10^{212} s^{14} + 9.34666001542689 \\cdot 10^{216} s^{13} + 1.33896771522385 \\cdot 10^{221} s^{12} + 1.10460302795617 \\cdot 10^{225} s^{11} + 5.53769744592102 \\cdot 10^{228} s^{10} + 1.72249451515387 \\cdot 10^{232} s^{9} + 3.32085126665458 \\cdot 10^{235} s^{8} + 3.87249234126433 \\cdot 10^{238} s^{7} + 2.55931001138544 \\cdot 10^{241} s^{6} + 8.19490961624807 \\cdot 10^{243} s^{5} + 8.12398088138566 \\cdot 10^{245} s^{4} + 2.87372364093355 \\cdot 10^{247} s^{3} + 3.42580339802553 \\cdot 10^{248} s^{2} + 1.48784566605239 \\cdot 10^{249} s + 1.98918824532361 \\cdot 10^{249}}\\)\n\n\n\n\n26.6.2 Magnitude and Phase Response\nThe voltage transfer function, \\(\\frac{v2(s)}{v1(s)}\\), is calculated below.\n\nH = U[v2]/U[v1]\nH\n\n\\(\\displaystyle \\frac{1.0 \\cdot \\left(1.60460486959839 \\cdot 10^{204} s^{15} + 3.27859737275232 \\cdot 10^{209} s^{14} + 2.24239224921523 \\cdot 10^{214} s^{13} + 6.17846960611372 \\cdot 10^{218} s^{12} + 6.98631389088568 \\cdot 10^{222} s^{11} + 3.84144613823827 \\cdot 10^{226} s^{10} + 1.14176089090876 \\cdot 10^{230} s^{9} + 1.9487479169721 \\cdot 10^{233} s^{8} + 1.9264469914375 \\cdot 10^{236} s^{7} + 1.04007382786928 \\cdot 10^{239} s^{6} + 2.4949612511751 \\cdot 10^{241} s^{5} + 8.71156576910649 \\cdot 10^{242} s^{4} + 1.59377116458413 \\cdot 10^{244} s^{3} + 5.83569842526406 \\cdot 10^{244} s^{2}\\right)}{7.15162708944972 \\cdot 10^{204} s^{15} + 5.22082517544816 \\cdot 10^{209} s^{14} + 1.46041562741045 \\cdot 10^{214} s^{13} + 2.09213705503726 \\cdot 10^{218} s^{12} + 1.72594223118152 \\cdot 10^{222} s^{11} + 8.6526522592516 \\cdot 10^{225} s^{10} + 2.69139767992792 \\cdot 10^{229} s^{9} + 5.18883010414778 \\cdot 10^{232} s^{8} + 6.05076928322552 \\cdot 10^{235} s^{7} + 3.99892189278975 \\cdot 10^{238} s^{6} + 1.28045462753876 \\cdot 10^{241} s^{5} + 1.26937201271651 \\cdot 10^{243} s^{4} + 4.49019318895868 \\cdot 10^{244} s^{3} + 5.35281780941488 \\cdot 10^{245} s^{2} + 2.32475885320685 \\cdot 10^{246} s + 3.10810663331814 \\cdot 10^{246}}\\)\n\n\nThe SciPy function bode is used to calculate the magnitude and phase of the transfer function.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\nx = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x) # returns: rad/s, mag in dB, phase in deg\n\nRead the frequency response data from LTSpice so the LTSpice and Python results plots can be overlaid for comparison.\n\nfn = 'Klon-Centaur_v2_freq_resp.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nH_v2 = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    H_v2[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results using np.unwrap(2 * phase) / 2) to keep the phase plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(H_v2)[0:-1]),'-k',label='LTSpice sch v2 mag')    # LTSpice magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-r',label='MNA mag, dB')    # MNA magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\nplt.legend(loc='upper right')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(H_v2)[0:-1]/2) *180/np.pi,':',color='k',label='LTSpice phase')  # LTSpice phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='r',label='MNA phase')  # MNA phase plot\nplt.legend(loc='lower right')\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3)\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\nFigure 26.10: LTSpice and MNA data magnitude and phase response plotted for comparison\n\n\n\n\n\nAs shown above, there is a slight difference between the MNA results and the LTSpice simulation, but generally there is good agreement. The LTSpice simulation is using device models for the diodes and Op Amps which accounts for the slight differences.\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the voltage transfer function are plotted on the complex frequency plane.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Complex plane Pole / Zero Plot')\nplt.xlabel('real part, \\u03C3')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane and the units are in radian frequency. These values are printed in the following table.\n\ntable_header = ['Zeros, rad/s', 'Poles, rad/s']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:,.2f}'.format(sys_zeros[i])\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:,.2f}'.format(sys_poles[i])\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, rad/s       Poles, rad/s\n-----------------  --------------\n-95,456.35+0.00j   -29,089.84\n-60,141.16+0.00j   -15,995.02\n-31,576.17+0.00j   -7,530.71\n-7,000.27+0.00j    -6,076.07\n-4,086.01+0.00j    -5,671.58\n-1,544.35+0.00j    -3,111.00\n-1,226.10+53.30j   -1,758.48\n-1,226.10-53.30j   -1,455.33\n-1,015.01+250.67j  -1,132.02\n-1,015.01-250.67j  -1,047.53\n-16.52+17.66j      -75.51\n-16.52-17.66j      -41.49\n-4.72+0.00j        -9.90\n0.00+0.00j         -4.97\n0.00+0.00j         -2.47\n\n\n\n26.6.2.1 Square Wave Response\nThe SciPy function lsim was used to calculate the time domain response to a 10 Hz square wave. The input amplitude is scaled and level shifted to produce a 0 to 50 mV signal which keeps the levels at node 16 below the diode conduction level.\n\nt = np.linspace(0, 0.2, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*10*t, duty=0.5)/40+1/40\n\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal, 'r', alpha=0.75, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step,'b', linewidth=1.25, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.ylim((-.4,.4))\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the input square wave in red and the out signal in blue. The signal path is AC coupled as indicated by the lack of DC response in the plot. The decay time is a bit over 25 ms.\nAt the leading edge of the square wave input, there is about a 250 mV spike, which suggests a large AC gain in the circuit because the abrupt change in the input signal at the leading edge of steps of the square wave produces substantial harmonic components within the pass band of the pedal’s frequency response.\nThe square wave simulation data from LTSpice was loaded in the JupyterLab notebook so that the data could be overlaid along with the NMA solution.\n\nfn = 'Klon-Centaur_v2_square_wave.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n# initialize some empty arrays\ntime = np.zeros(len(LTSpice_data))\nvoltage1 = np.zeros(len(LTSpice_data))\nvoltage2 = np.zeros(len(LTSpice_data))\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    time[i] = LTSpice_data[i][0]\n    voltage1[i] = LTSpice_data[i][1]\n    voltage2[i] = LTSpice_data[i][2]\n\nThe code below generates the plots for the LTSpice and Python MNA data.\n\nplt.title('LTSpice and Python MNA results')\n\n#plt.plot(time, voltage1, 'g', alpha = 1.0, linewidth=1, label='LTSpice v1(t)')\nplt.plot(time, voltage2, '-.r', alpha = 1.0, linewidth=2, label='LTSpice v2(t)')\n\n#plt.plot(t_step, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step, y_step,'b', alpha = 1.0, linewidth = 1.0, label='Python MNA result')\n\nplt.ylabel('v(t), volts')\nplt.xlabel('time, sec')\n\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, there is close agreement between the two solutions in both the frequency and time domain for input signal levels and gain settings that do not produce node voltages at node 16 with levels that would drive the diodes into conduction.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 2v0.html#summary-for-part-2",
    "href": "Klon Centaur part 2v0.html#summary-for-part-2",
    "title": "26  Klon Centaur, Part 2",
    "section": "26.7 Summary for part 2",
    "text": "26.7 Summary for part 2\nThe semiconductor parts used in the pedal were described as well as the SPICE device models used in the LTSpice simulations. The MNA method can not easily handle the non-linear operation resulting from saturated Op Amp outputs or forwarded biased diodes. LTSpice was used to examine the operating point where the Op Amps would be driven into saturation.\nFrom the analysis it appears that output of \\(U_{1A}\\) could be clipping the signal at some combinations of input level and gain. Python was used to display the results of LTSpice transient analysis and the harmonic content of the distorted signal was plotted. The operation of the pedal with actual music signals as inputs was simulated. This illustrates how MNA can be used in conjunction with LTSpice to do circuit analysis and generate reports.\nFinally analysis results obtained from LTSpice were compared to the Python MNA results. The magnitude, phase and time domain plots superimpose giving us confidence that the Python analysis results are correct.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Klon Centaur, Part 2</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html",
    "href": "Klon Centaur part 3v1.html",
    "title": "27  Klon Centaur, Part 3",
    "section": "",
    "text": "27.1 Design Review\nThis Chapter is the final installment in the Klon Centaur series. Presented in this notebook are a few comments I would provide, if I was attending a design review. Design reviews are standard practice across most industries. A short list of Klon Centaur clones is presented. Then an analysis of some of the reactive paths in the pedal’s circuits are presented. This is of particular interest since the function and operation of parts of the circuits is not intuitively obvious. The series on the Klon Centaur concludes with a final summary and comments.\nThis section is not a formal design review, but will only present some comments and concerns that might have come up at design review. I don’t know if Finnegan ever conducted any design reviews as is typically done in industry. In hindsight he should have taken steps to legally protect his design beyond trademarking the CENTAUR ™ name. I suppose at the time he didn’t know how popular his pedal would become and lack of funds limited his ability to patent Klon Centaur design. There are many examples of electric circuits that have been patented and Finnegan could have sought out help from friends to help with this aspect. He was naive to think that covering the components with black goop (epoxy) would keep his circuit a secret. Additionally, starting a business based on a product that had a critical component, the Germanium diodes, in extremely limited supply was shortsighted.\nIt has been reported that Finnegan worked with MIT graduate Fred Fenning and other electrical engineer friends on this project. The description of the development is a little vague but sounded like the design flow was mainly building prototype circuits, fiddling with the design and Finnegan doing evaluation and playing tests to get the tone he wanted. The design and development of the pedal took four and half years.\nSometimes it’s hard to describe exactly what makes something popular, but it’s evident that Finnegan’s goal to build a pedal that would provide guitar players with an open, transparent tone, similar to that of a turned-up tube amplifier, was unique and successful. The scarcity of original pedals contributes to them being coveted, valuable and copied. The ability to blend clean and distortion at low to high volume levels is what made this pedal unique at the time.\nHere are a few comments that I would provide during a design review:",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Klon Centaur, Part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#sec-design_review",
    "href": "Klon Centaur part 3v1.html#sec-design_review",
    "title": "27  Klon Centaur, Part 3",
    "section": "",
    "text": "The circuit analysis present in Part 1, Figure 25.15, shows that Clean Path 1 seems to contribute minimally to the output of the pedal, since the signal on this path gets covered over by signals on the other paths. I think the design could be simplified by removing this path. Blind listing tests would validate this assertion.\nThe analysis presented in Section 27.3.3 seems to show that the function of this path is somewhat superfluous since the zero created by \\(C_{13}\\) and \\(R_{20}\\) negates the frequency emphasis created by this path.\nThe use of the dual gang pot, \\(P_1\\), to blend Clean Path 2 and the diode path should be evaluated. Perhaps there is a way the blending could be accomplished with a single pot. This would simplify the bill of materials and wiring the connections of the printed circuit board (PCB) to \\(P_1\\).\nIt seems that loud playing at gains of more than 50% will saturate U1b, those harmonics will color the tone. This aspect of the signal flow through the pedal needs to be examined more closely to determine if this is a desirable effect. Although, \\(D_2\\) and \\(D_3\\) will re-shape the harmonics.\nThe internal wiring of the PCB to \\(S_1\\), \\(D_1\\) and the pots could be simplified to make assembly and production simplified.\nThe use of hand selected Germanium diodes is a problem since this limits future production with a parts obsolescence problem down the road.\nA tolerance, reliability and temperature analysis of the design should be done. The mix of carbon and metal film resistors is unusual and contributes to a longer Bill of Materials (BOM).\nOther reviews such as: requirements review, production readiness review, documentation review, testing review",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Klon Centaur, Part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#klon-centaur-clones",
    "href": "Klon Centaur part 3v1.html#klon-centaur-clones",
    "title": "27  Klon Centaur, Part 3",
    "section": "27.2 Klon Centaur Clones",
    "text": "27.2 Klon Centaur Clones\nThe Klon Centaur is one of the most legendary and sought-after overdrive pedals in guitar history and clones stem from a few key factors. Bill Finnegan famously “gooped” (covered in epoxy resin) the circuit board of the original Centaurs to prevent replication. However, the circuit was eventually reverse-engineered and schematics became available online around 2008. The limited production of the original Klons (around 8,000 units) and their legendary status led to extremely high prices on the secondary market. This created a huge demand for more affordable alternatives.\nOnce the circuit was reverse engineered, several manufacturers began producing clones. These variations emerged for several reasons. Primarily to offer the Klon sound at a much lower price point and sourcing the exact original components (especially certain germanium diodes) became difficult and expensive, leading manufacturers to use readily available alternatives that aim to replicate the sound.\nIn 2014, Finnegan released the Klon KTR, a redesigned version intended for mass production. It uses surface-mount device (SMD) components, is smaller, and includes a buffered/true bypass selector. While the circuit is fundamentally the same as the original, the change in manufacturing methods and component types (even if the same type components, like germanium diodes) can lead to subtle differences that some purists notice.\nMany clones (Klones) introduce “improvements” or additional features that weren’t on the original, such as:\n\nBass boost switches (to address the Klon’s subtle low-end roll-off).\nDifferent clipping diode options (silicon, LED, other germanium types) offer different overdrive textures.\nSeparate clean blend and gain controls (the original Klon uses a dual-ganged gain pot that blends clean and over driven signals).\nSmaller enclosures.\nTrue bypass versus a buffered bypass option.\n\nIn essence, the Klon Centaur variations exist due to a combination of intentional minor adjustments by the original creator, the need to adapt the design for wider production (KTR), and the extensive efforts of other manufacturers to replicate, modify, and improve upon a highly sought-after and influential circuit.\nThere are many pedals inspired by the Klon Centaur, here are a few:\n\nWampler Tumnus Overdrive Pedal: This is a very popular Klon clone that captures the essence of the Klon Centaur in a compact and affordable package. It has a wide range of gain on tap, from a subtle boost to a more overdriven sound. It also has a toggle switch that allows you to select between two different clipping voicings.\nEarthQuaker Devices Westwood Translucent Overdrive: This pedal is a bit more of a modern take on the Klon Centaur sound. It has a more aggressive clipping section that can add a bit more bite to your overdrive sound. It also has a three-band EQ that allows you to dial in your tone precisely.\nJ Rockett Rockaway Archer: This pedal is another well-regarded Klon clone that is known for its versatility. It has a wide range of gain on tap, as well as a toggle switch that allows you to select between two different clipping voicings. It also has a built-in clean boost that can be used to push your amp into overdrive.\nTone City Bad Horse Overdrive: This is a very affordable Klon clone that is surprisingly good. It captures the essence of the Klon Centaur sound in a compact and affordable package. However, it is not quite as transparent as some of the other pedals on this list.\nBest Klon clones 2024: Our pick of the best Klon Centaur Klones for every budget: From straight-up clones to full reimaginings, here are some of the best Klon Centaur-inspired pedals on the market today.\nWay Huge Smalls Deep State Conspiracy Theory Diodes Overdrive: The following bit of snake oil can be found in their product description:\n\nThe Way Huge Deep State Overdrive is a limited-edition guitar pedal designed to emulate the sound of the Klon Centaur, a highly sought-after overdrive pedal from the mid-1990s. The Deep State utilizes a unique diode that Way Huge’s “resident mad scientist” Jeorge Tripps discovered. Tripps’ discovery of the diode was accidental and occurred during an experiment where he inserted the diodes into a Conspiracy Theory overdrive. Way Huge describes this diode as having a “truly magical-sounding voltage drop,” resulting in “smooth, velvety clipping” that is very responsive to playing dynamics.\n\n\nA recent development in the world of Klon clones is that a legal complaint was filed in United States District Court, District of Massachusetts by Klon LLC against Empower Tribe, dated May 30, 2025. It seems the essence of the complaint centers around the use of Klon’s registered “CENTAUR” Trade Mark on Behringer’s CENTARA OVERDRIVE pedal, which has now been branded as “CENTARA”, but originally called “CENTAUR”.\nKlon obtained two U.S. trademark registrations for the CENTAUR:\n\nU.S. Reg. No. 5661741, registered on January 22, 2019, for electronic effects pedals, foot pedals, guitar pedals, sound effect pedals (Class 15), and repair/maintenance services (Class 37).\nU.S. Reg. No. 6147899, registered on September 8, 2020, for electronic effects pedals, sound effect pedals (Class 9), foot pedals, and guitar pedals (Class 15).\n\nAside from the trademarked “Centaur” name, the pedal’s circuits, function and operation do not seem to be protected intellectual property.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Klon Centaur, Part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#sec-analysis_of_reactive_branches",
    "href": "Klon Centaur part 3v1.html#sec-analysis_of_reactive_branches",
    "title": "27  Klon Centaur, Part 3",
    "section": "27.3 Analysis of Reactive Branches",
    "text": "27.3 Analysis of Reactive Branches\nThe following analysis will examine some of the reactive branches in the pedal’s circuits. A branch is essentially a portion of a circuit that contains one or more circuit elements (like resistors, capacitors, inductors etc.), connects two nodes and provides a topological framework for describing and analyzing the interconnections of components within an electrical circuit. In electrical circuits, reactive branches are branches that contain components that store and release energy rather than simply dissipating it as heat. These components are primarily inductors and capacitors. We want to answer the question - what are the components in this branch of the circuit doing? We have to be careful about loading effects provided by the other components attached to the branch we are analyzing that have been excluded. With this in mind, we can attempt to provide an intuitive explanation of the circuit’s operation.\n\nThe following Python modules are used in this JupyterLab notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\nfrom tabulate import tabulate\ninit_printing()\n\nThe function below is used to display less digits when printing equations. It was copied from stackoverflow from the link provided in the comment.\n\ndef round_expr(expr, num_digits):\n    '''\n    from stackoverflow, used to display fewer digits\n    https://stackoverflow.com/questions/48491577/printing-the-output-rounded-to-3-decimals-in-sympy\n    '''\n    return expr.xreplace({n : round(n, num_digits) for n in expr.atoms(Number)})\n\n\n27.3.1 Reactive Branch 1\nThe circuit shown below is reactive branch 1. This circuit is a modified version of the circuit path analyzed in Section 25.10.1 and is a slightly modified version of the highlighted portion of circuit shown in Figure 25.15.\nThis circuit branch starts at the output of Op Amp \\(U_{1A}\\) and follows the components \\(C_3\\), \\(R_7\\) and \\(R_{24}\\) to the Op Amp \\(U_{2A}\\). Components \\(R_6\\), \\(C_5\\), \\(P_1\\) and \\(C_{16}\\) connect to circuit nodes along the branch of interest. The output of \\(U_{1A}\\) is replaced by the independent voltage source \\(V_1\\). The inverting input of \\(U_{2A}\\) is connected to \\(R_{24}\\) and this is the summing junction for other signal paths in the Klon Centaur. \\(C_3\\) acts as a DC block. The components, \\(C_5\\), \\(R_6\\) and \\(P_1\\) on node 3, and components \\(R_7\\) and \\(C_16\\) complete a low pass filter section ending at node 5.\nThe components,\\(R_{24}\\), \\(R_{20}\\) and \\(U_{2A}\\) are configured as an inverting amplifier with a gain of \\(\\frac{R_{20}}{R_{24}}\\).\nThe circuit shown below is effectively a low pass filter with a DC block. \\(C_3\\) will block low frequencies down to DC. \\(C_4\\), \\(R_6\\) and \\(R_{p1b}\\) will put a zero in the transfer function along with \\(C_3\\). Given that there are three capacitors in the circuit, there are likely three poles in the voltage transfer function. \\(C_{13}\\) in the feedback of \\(U_{2A}\\) was omitted from the analysis so that the operation of the circuit could be analyzed without the pole created by \\(R_{20}\\) and \\(C_{13}\\) from dominating the frequency response of the transfer function.\nThe component \\(R_{p1b1}\\) in Figure 27.1 is one of the dual ganged pots in \\(P_1\\). The wiper of \\(P_1\\) is connected to ground. Node 4 in the schematic below is connected to the non-inverting input of \\(U_{1B}\\), but this connection is being ignored for this analysis since \\(U_{1B}\\) is not on the signal path we are interested in. We can still get an idea of what the components shown in the schematic are doing, but the exact location of the poles and zeros will be a little off.\n\n\n\n\n\n\nFigure 27.1: Schematic of reactive branch 1.\n\n\n\nThe netlist below was exported from LTSpice.\n\nreactive_branch_1_net_list = '''\n* Klon-Centaur_sum_path1_v1.asc\nV1 1 0 1\nC3 3 1 100e-9\nR6 4 3 10e3\nC5 4 3 68e-9\nR7 3 5 1.5e3\nR24 6 5 15e3\nC16 5 0 1e-6\nRp1b 0 4 50e3\nO2a 6 0 2\nR20 2 6 392e3\n*C13 2 6 820e-12\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_1_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{3} s v_{1} - C_{3} s v_{3} + I_{V1}\\)\\(0 = I_{O2a} + \\frac{v_{2}}{R_{20}} - \\frac{v_{6}}{R_{20}}\\)\\(0 = - C_{3} s v_{1} + v_{3} \\left(C_{3} s + C_{5} s + \\frac{1}{R_{7}} + \\frac{1}{R_{6}}\\right) + v_{4} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) - \\frac{v_{5}}{R_{7}}\\)\\(0 = v_{3} \\left(- C_{5} s - \\frac{1}{R_{6}}\\right) + v_{4} \\left(C_{5} s + \\frac{1}{Rp1b} + \\frac{1}{R_{6}}\\right)\\)\\(0 = v_{5} \\left(C_{16} s + \\frac{1}{R_{7}} + \\frac{1}{R_{24}}\\right) - \\frac{v_{3}}{R_{7}} - \\frac{v_{6}}{R_{24}}\\)\\(0 = v_{6} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{5}}{R_{24}} - \\frac{v_{2}}{R_{20}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{6}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n27.3.1.1 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the node voltages and dependent currents using symbolic notation.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{3} C_{5} R_{20} R_{6} Rp1b V_{1} s^{2} - C_{3} R_{20} R_{6} V_{1} s - C_{3} R_{20} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{3} = \\frac{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b V_{1} s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} V_{1} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b V_{1} s^{2} + C_{3} R_{24} R_{6} V_{1} s + C_{3} R_{24} Rp1b V_{1} s + C_{3} R_{6} R_{7} V_{1} s + C_{3} R_{7} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{4} = \\frac{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b V_{1} s^{3} + C_{16} C_{3} R_{24} R_{7} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b V_{1} s^{2} + C_{3} R_{24} Rp1b V_{1} s + C_{3} R_{7} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{5} = \\frac{C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{2} + C_{3} R_{24} R_{6} V_{1} s + C_{3} R_{24} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(v_{6} = 0\\)\\(I_{V1} = \\frac{- C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} V_{1} s^{3} - C_{16} C_{3} C_{5} R_{24} R_{6} Rp1b V_{1} s^{3} - C_{16} C_{3} R_{24} R_{6} V_{1} s^{2} - C_{16} C_{3} R_{24} R_{7} V_{1} s^{2} - C_{16} C_{3} R_{24} Rp1b V_{1} s^{2} - C_{3} C_{5} R_{24} R_{6} V_{1} s^{2} - C_{3} C_{5} R_{6} R_{7} V_{1} s^{2} - C_{3} C_{5} R_{6} Rp1b V_{1} s^{2} - C_{3} R_{24} V_{1} s - C_{3} R_{6} V_{1} s - C_{3} R_{7} V_{1} s - C_{3} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\\(I_{O2a} = \\frac{C_{3} C_{5} R_{6} Rp1b V_{1} s^{2} + C_{3} R_{6} V_{1} s + C_{3} Rp1b V_{1} s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{- C_{3} C_{5} R_{20} R_{6} Rp1b s^{2} - C_{3} R_{20} R_{6} s - C_{3} R_{20} Rp1b s}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b}\\)\n\n\nThe numerator is a second order polynomial and the denominator is a third order polynomial. Generally, the order of the dominator is equal to the number of reactive elements in the circuit; sometimes roots of the numerator will exactly cancel with a root of the denominator polynomial. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n27.3.1.2 Numerator Polynomial of \\(H_{sym}(s)\\)\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=- C_{3} C_{5} R_{20} R_{6} Rp1b s^{2} - C_{3} R_{20} R_{6} s - C_{3} R_{20} Rp1b s\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$&lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=- C_{3} C_{5} R_{20} R_{6} Rp1b\\)\n\n\n\\(b_1=- C_{3} R_{20} R_{6} - C_{3} R_{20} Rp1b\\)\n\n\n\\(b_0=0\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nMarkdown('There are {:d} zeros, which are:\\\n    &lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;'.format(len(num_root_sym),latex(num_root_sym[0]),latex(num_root_sym[1])))\n\nThere are 2 zeros, which are:\n\n\\(z_0=0\\)\n\n\n\\(z_1=\\frac{- R_{6} - Rp1b}{C_{5} R_{6} Rp1b}\\)\n\n\n\n\\(C_3\\) is responsible for the zero at \\(\\omega=0\\) since this capacitor provids an open circuit at DC.\n\n\n27.3.1.3 Denominator Polynomial of \\(H_{sym}(s)\\)\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b s^{3} + C_{16} C_{3} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{3} R_{24} R_{7} Rp1b s^{2} + C_{16} C_{5} R_{24} R_{6} R_{7} s^{2} + C_{16} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{16} R_{24} R_{6} s + C_{16} R_{24} R_{7} s + C_{16} R_{24} Rp1b s + C_{3} C_{5} R_{24} R_{6} Rp1b s^{2} + C_{3} C_{5} R_{6} R_{7} Rp1b s^{2} + C_{3} R_{24} R_{6} s + C_{3} R_{24} Rp1b s + C_{3} R_{6} R_{7} s + C_{3} R_{7} Rp1b s + C_{5} R_{24} R_{6} s + C_{5} R_{6} R_{7} s + C_{5} R_{6} Rp1b s + R_{24} + R_{6} + R_{7} + Rp1b\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_3s^3+a_2s^2+a_1s+a_0\\)\nwhere \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\na3 = H_sym_denom.coeff(s**3)\na2 = H_sym_denom.coeff(s**2)\na1 = H_sym_denom.coeff(s**1)\na0 = (H_sym_denom - a1*s*1 - a2*s**2 - a3*s**3).expand()\nMarkdown('&lt;p&gt;$a_3={:s}$&lt;/p&gt;&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;\\\n    $a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a3),\n    latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_3=C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b\\)\n\n\n\\(a_2=C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\)\n\n\n\\(a_1=C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\)\n\n\n\\(a_0=R_{24} + R_{6} + R_{7} + Rp1b\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transfer function, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are:\\\n    &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;&lt;p&gt;$p_2={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1]),latex(denom_root_sym[2])))\n\nThere are 3 poles, which are:\n\n\\(p_0=- \\frac{- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}}{3} - \\frac{C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b}{3 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b}\\)\n\n\n\\(p_1=- \\frac{- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}}{3} - \\frac{C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b}{3 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b}\\)\n\n\n\\(p_2=- \\frac{- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{2}}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}}\\right)^{3} + \\left(\\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{2 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}\\right)^{2}}}{2} + \\frac{27 \\left(R_{24} + R_{6} + R_{7} + Rp1b\\right)}{2 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b} - \\frac{9 \\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right) \\left(C_{16} R_{24} R_{6} + C_{16} R_{24} R_{7} + C_{16} R_{24} Rp1b + C_{3} R_{24} R_{6} + C_{3} R_{24} Rp1b + C_{3} R_{6} R_{7} + C_{3} R_{7} Rp1b + C_{5} R_{24} R_{6} + C_{5} R_{6} R_{7} + C_{5} R_{6} Rp1b\\right)}{2 C_{16}^{2} C_{3}^{2} C_{5}^{2} R_{24}^{2} R_{6}^{2} R_{7}^{2} Rp1b^{2}} + \\frac{\\left(C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b\\right)^{3}}{C_{16}^{3} C_{3}^{3} C_{5}^{3} R_{24}^{3} R_{6}^{3} R_{7}^{3} Rp1b^{3}}}}{3} - \\frac{C_{16} C_{3} R_{24} R_{6} R_{7} + C_{16} C_{3} R_{24} R_{7} Rp1b + C_{16} C_{5} R_{24} R_{6} R_{7} + C_{16} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{24} R_{6} Rp1b + C_{3} C_{5} R_{6} R_{7} Rp1b}{3 C_{16} C_{3} C_{5} R_{24} R_{6} R_{7} Rp1b}\\)\n\n\n\nThe expressions for the poles of \\(H(s)\\) are rather long and not very intuitive.\n\n\n27.3.1.4 Numerical Solution for P1 at 50%\nThe network equations can be numerically solved when the element values are included in the calculations. The solution below is for when \\(R_{p1b1}\\) is set to 50%.\n\nequ_N = NE_sym.subs(element_values)\n\nWe get the following numerical network equations:\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],8)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\n\n\n\\(0 = I_{O2a} + 2.55 \\cdot 10^{-6} v_{2} - 2.55 \\cdot 10^{-6} v_{6}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} + v_{3} \\cdot \\left(1.7 \\cdot 10^{-7} s + 0.00076667\\right) + v_{4} \\left(- 7.0 \\cdot 10^{-8} s - 0.0001\\right) - 0.00066667 v_{5}\\)\n\n\n\\(0 = v_{3} \\left(- 7.0 \\cdot 10^{-8} s - 0.0001\\right) + v_{4} \\cdot \\left(7.0 \\cdot 10^{-8} s + 0.00012\\right)\\)\n\n\n\\(0 = - 0.00066667 v_{3} + v_{5} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.00073333\\right) - 6.667 \\cdot 10^{-5} v_{6}\\)\n\n\n\\(0 = - 2.55 \\cdot 10^{-6} v_{2} - 6.667 \\cdot 10^{-5} v_{5} + 6.922 \\cdot 10^{-5} v_{6}\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = v_{6}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{- 2.6656 \\cdot 10^{29} s^{2} - 4.704 \\cdot 10^{32} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{3} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.822 \\cdot 10^{28} s^{2} + 1.98 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{4} = \\frac{1.53 \\cdot 10^{25} s^{3} + 3.372 \\cdot 10^{28} s^{2} + 1.65 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{5} = \\frac{1.02 \\cdot 10^{28} s^{2} + 1.8 \\cdot 10^{31} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\n\\(v_{6} = 0.0\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 2.6656 \\cdot 10^{29} s^{2} - 4.704 \\cdot 10^{32} s}{1.53 \\cdot 10^{25} s^{3} + 1.4328 \\cdot 10^{29} s^{2} + 2.13344 \\cdot 10^{32} s + 1.53 \\cdot 10^{34}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n\n\n27.3.1.5 Pole Zero Plot\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob',\n    markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-280.86      -1198.55\n0.00         -279.87\n             -12.02\n\n\n\n\n27.3.1.6 Reactive Branch 1 Frequency Response\nThe transfer function \\(H(s)=\\frac{v2}{v1}\\) is analyzed for various settings of the Gain control, P1. The gain setting is in steps of percentage of full scale, from 1 to 99% and is plotted below.\n\n# setup\nx_axis = np.logspace(0, 5, 2000, endpoint=True)*2*np.pi\ncolor_list = ['tab:blue','tab:purple','tab:brown','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,2.5,9.75,25,50,75,99])/100\np1_value = 100e3\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1b] = p1_value - gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1] #U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    sys = (a, b)\n\n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode(sys, w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='magnitude @ {:.0f}% gain'.format(gain_setting[i]*100)) # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase @ {:.0f}% gain'.format(gain_setting[i]*100)) # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# set plot limits for display\nplt.xlim((1,100e3))\nax1.set_ylim((-60,10))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\nax1.grid()\nplt.title('Magnitude and phase response for gains of 1% to 99%')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the band pass characteristic of the circuit in Figure 27.1. The highlighted frequencies are the guitar audio band. Rotation of \\(P_{1B}\\) has a limited effect in this path. Keep in mind that a pole at 500 Hz from \\(C_{13}\\) is not included which would move the low pass corner frequency considerably lower if it was included.\n\n\n\n27.3.2 Reactive Branch 2\nThe circuit shown below is reactive branch 2. This circuit is part of the circuit path analyzed in Section 25.10.3 and is a slightly modified version of the highlighted portion of circuit shown in Figure 25.19.\n\n\n\n\n\n\nFigure 27.2: Schematic of reactive branch 2.\n\n\n\nThe schematic above includes the components that are in the feed back loop around U1B. \\(P_1\\) is modeled by two resistors, Rp1a1 and Rp1b1. The wiper of P1 is connected to ground. When \\(P_1\\) fully clockwise, \\(V_1\\) is shunted by the full value of \\(P_1\\), which is 100 k\\(\\Omega\\), and node 3 is effectively connected to ground. When \\(P_1\\) is fully counter clockwise, the wiper, which is connected to ground is effectively grounding \\(V_1\\) and the non-inverting terminal of \\(U_{1B}\\), which prevents the signal from propagating to \\(U_{1B}\\).\nThe parallel combination of \\(C_8\\) and \\(R_{12}\\) along with \\(C_7\\) and \\(R_{11}\\) determine the frequency response. The netlist below was exported from LTSpice.\n\nreactive_branch_2_net_list = '''\n*reactive_branch_2.asc\nV1 1 0 1\nRp1b1 0 1 50e3\nRp1a1 3 0 50e3\nR10 4 3 2e3\nR11 5 4 15e3\nC7 5 4 82e-9\nC8 2 5 390e-12\nR12 2 5 422e3\nO1B 5 1 2\n'''\n\nUsing the function SymMNA.smna generate the network equations from the MNA matrices and display the equations.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_2_net_list)\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{Rp1b1}\\)\\(0 = I_{O1b} + v_{2} \\left(C_{8} s + \\frac{1}{R_{12}}\\right) + v_{5} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right)\\)\\(0 = v_{3} \\cdot \\left(\\frac{1}{Rp1a1} + \\frac{1}{R_{10}}\\right) - \\frac{v_{4}}{R_{10}}\\)\\(0 = v_{4} \\left(C_{7} s + \\frac{1}{R_{11}} + \\frac{1}{R_{10}}\\right) + v_{5} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) - \\frac{v_{3}}{R_{10}}\\)\\(0 = v_{2} \\left(- C_{8} s - \\frac{1}{R_{12}}\\right) + v_{4} \\left(- C_{7} s - \\frac{1}{R_{11}}\\right) + v_{5} \\left(C_{7} s + C_{8} s + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right)\\)\\(V_{1} = v_{1}\\)\\(0 = - v_{1} + v_{5}\\)\n\n\nTurn the free symbols into SymPy variables and load the element values.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n27.3.2.1 Symbolic solution\nThe network equations for the circuit in Figure 27.2 can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{7} C_{8} R_{10} R_{11} R_{12} V_{1} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 V_{1} s^{2} + C_{7} R_{10} R_{11} V_{1} s + C_{7} R_{11} R_{12} V_{1} s + C_{7} R_{11} Rp1a1 V_{1} s + C_{8} R_{10} R_{12} V_{1} s + C_{8} R_{11} R_{12} V_{1} s + C_{8} R_{12} Rp1a1 V_{1} s + R_{10} V_{1} + R_{11} V_{1} + R_{12} V_{1} + Rp1a1 V_{1}}{C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\\(v_{3} = \\frac{C_{7} R_{11} Rp1a1 V_{1} s + Rp1a1 V_{1}}{C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\\(v_{4} = \\frac{C_{7} R_{10} R_{11} V_{1} s + C_{7} R_{11} Rp1a1 V_{1} s + R_{10} V_{1} + Rp1a1 V_{1}}{C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\\(v_{5} = V_{1}\\)\\(I_{V1} = - \\frac{V_{1}}{Rp1b1}\\)\\(I_{O1b} = \\frac{- C_{7} R_{11} V_{1} s - V_{1}}{C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} R_{12} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + R_{12} + Rp1a1}{C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + Rp1a1}\\)\n\n\nBoth the numerator and denominator are second order polynomials.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n27.3.2.2 Numerator Polynomial\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} R_{12} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + R_{12} + Rp1a1\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$\\\n    &lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=C_{7} C_{8} R_{10} R_{11} R_{12} + C_{7} C_{8} R_{11} R_{12} Rp1a1\\)\n\n\n\\(b_1=C_{7} R_{10} R_{11} + C_{7} R_{11} R_{12} + C_{7} R_{11} Rp1a1 + C_{8} R_{10} R_{12} + C_{8} R_{11} R_{12} + C_{8} R_{12} Rp1a1\\)\n\n\n\\(b_0=R_{10} + R_{11} + R_{12} + Rp1a1\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nMarkdown('There are {:d} zeros, which are:\\\n    &lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;'.format(len(num_root_sym),latex(num_root_sym[0]),latex(num_root_sym[1])))\n\nThere are 2 zeros, which are:\n\n\\(z_0=\\frac{- C_{7} R_{10} R_{11} - C_{7} R_{11} R_{12} - C_{7} R_{11} Rp1a1 - C_{8} R_{10} R_{12} - C_{8} R_{11} R_{12} - C_{8} R_{12} Rp1a1 - \\sqrt{C_{7}^{2} R_{10}^{2} R_{11}^{2} + 2 C_{7}^{2} R_{10} R_{11}^{2} R_{12} + 2 C_{7}^{2} R_{10} R_{11}^{2} Rp1a1 + C_{7}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{7}^{2} R_{11}^{2} R_{12} Rp1a1 + C_{7}^{2} R_{11}^{2} Rp1a1^{2} - 2 C_{7} C_{8} R_{10}^{2} R_{11} R_{12} - 2 C_{7} C_{8} R_{10} R_{11}^{2} R_{12} - 2 C_{7} C_{8} R_{10} R_{11} R_{12}^{2} - 4 C_{7} C_{8} R_{10} R_{11} R_{12} Rp1a1 + 2 C_{7} C_{8} R_{11}^{2} R_{12}^{2} - 2 C_{7} C_{8} R_{11}^{2} R_{12} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12}^{2} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12} Rp1a1^{2} + C_{8}^{2} R_{10}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{11} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{11} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{12}^{2} Rp1a1^{2}}}{2 C_{7} C_{8} R_{11} R_{12} \\left(R_{10} + Rp1a1\\right)}\\)\n\n\n\\(z_1=\\frac{- C_{7} R_{10} R_{11} - C_{7} R_{11} R_{12} - C_{7} R_{11} Rp1a1 - C_{8} R_{10} R_{12} - C_{8} R_{11} R_{12} - C_{8} R_{12} Rp1a1 + \\sqrt{C_{7}^{2} R_{10}^{2} R_{11}^{2} + 2 C_{7}^{2} R_{10} R_{11}^{2} R_{12} + 2 C_{7}^{2} R_{10} R_{11}^{2} Rp1a1 + C_{7}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{7}^{2} R_{11}^{2} R_{12} Rp1a1 + C_{7}^{2} R_{11}^{2} Rp1a1^{2} - 2 C_{7} C_{8} R_{10}^{2} R_{11} R_{12} - 2 C_{7} C_{8} R_{10} R_{11}^{2} R_{12} - 2 C_{7} C_{8} R_{10} R_{11} R_{12}^{2} - 4 C_{7} C_{8} R_{10} R_{11} R_{12} Rp1a1 + 2 C_{7} C_{8} R_{11}^{2} R_{12}^{2} - 2 C_{7} C_{8} R_{11}^{2} R_{12} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12}^{2} Rp1a1 - 2 C_{7} C_{8} R_{11} R_{12} Rp1a1^{2} + C_{8}^{2} R_{10}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{11} R_{12}^{2} + 2 C_{8}^{2} R_{10} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{11}^{2} R_{12}^{2} + 2 C_{8}^{2} R_{11} R_{12}^{2} Rp1a1 + C_{8}^{2} R_{12}^{2} Rp1a1^{2}}}{2 C_{7} C_{8} R_{11} R_{12} \\left(R_{10} + Rp1a1\\right)}\\)\n\n\n\n\n\n27.3.2.3 Denominator Polynomial\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{7} C_{8} R_{10} R_{11} R_{12} s^{2} + C_{7} C_{8} R_{11} R_{12} Rp1a1 s^{2} + C_{7} R_{10} R_{11} s + C_{7} R_{11} Rp1a1 s + C_{8} R_{10} R_{12} s + C_{8} R_{11} R_{12} s + C_{8} R_{12} Rp1a1 s + R_{10} + R_{11} + Rp1a1\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_3s^3+a_2s^2+a_1s+a_0\\)\nwhere \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\n\n\n\n\\(a_2=C_{7} C_{8} R_{10} R_{11} R_{12} + C_{7} C_{8} R_{11} R_{12} Rp1a1\\)\n\n\n\\(a_1=C_{7} R_{10} R_{11} + C_{7} R_{11} Rp1a1 + C_{8} R_{10} R_{12} + C_{8} R_{11} R_{12} + C_{8} R_{12} Rp1a1\\)\n\n\n\\(a_0=R_{10} + R_{11} + Rp1a1\\)\n\n\n\nThe roots of the denominator polynomial can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are:\\\n    &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1])))\n\nThere are 2 poles, which are:\n\n\\(p_0=- \\frac{1}{C_{8} R_{12}}\\)\n\n\n\\(p_1=\\frac{- R_{10} - R_{11} - Rp1a1}{C_{7} R_{11} \\left(R_{10} + Rp1a1\\right)}\\)\n\n\n\n\n\n27.3.2.4 Numerical Solution for P1 at 50%\nA numerical solution for the network equations is obtained for P1 at 50% rotation. The element values are substituted into the equations and displayed.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],6)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 2.0 \\cdot 10^{-5} v_{1}\\)\n\n\n\\(0 = I_{O1b} + 2.0 \\cdot 10^{-6} v_{2} - 2.0 \\cdot 10^{-6} v_{5}\\)\n\n\n\\(0 = 0.00052 v_{3} - 0.0005 v_{4}\\)\n\n\n\\(0 = - 0.0005 v_{3} + 0.000567 v_{4} - 6.7 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-6} v_{2} - 6.7 \\cdot 10^{-5} v_{4} + 6.9 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = - v_{1} + v_{5}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{3.74166 \\cdot 10^{22} s^{2} + 2.11154097156402 \\cdot 10^{27} s + 1.7381516587678 \\cdot 10^{30}}{3.74166 \\cdot 10^{22} s^{2} + 2.66540971563981 \\cdot 10^{26} s + 2.38151658767774 \\cdot 10^{29}}\\)\n\n\n\\(v_{3} = \\frac{3075000000000.0 s + 2.5 \\cdot 10^{15}}{3198000000000.0 s + 3.35000000000001 \\cdot 10^{15}}\\)\n\n\n\\(v_{4} = \\frac{3198000000000.0 s + 2.6 \\cdot 10^{15}}{3198000000000.0 s + 3.35000000000001 \\cdot 10^{15}}\\)\n\n\n\\(v_{5} = 1.0\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{3.74166 \\cdot 10^{22} s^{2} + 2.11154097156402 \\cdot 10^{27} s + 1.7381516587678 \\cdot 10^{30}}{3.74166 \\cdot 10^{22} s^{2} + 2.66540971563981 \\cdot 10^{26} s + 2.38151658767774 \\cdot 10^{29}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n\n\n27.3.2.5 Pole Zero Plot\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob',\n    markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-8848.65     -967.04\n-132.98      -166.72\n\n\n\n\n27.3.2.6 Pole/Zero Locus Plot versus \\(P_1\\) value\nFor each position of \\(P_1\\), there are two zeros and two poles. The plot below shows the frequency locations for the pole and zero locations as a function of \\(P_1\\) rotation. Since the poles and zeros don’t have imaginary parts, the complex frequency is plotted on the vertical axis versus the gain control rotational position, from 1 to 99 percent. The plot provides a visual indication of how the poles and zeros change as a function \\(P_1\\).\n\nsym_num, sym_denom = fraction(H_sym) #returns numerator and denominator\n\np1_value = 100e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp1a1] = p1_value - i*p1_value\n    element_values[Rp1b1] = i*p1_value\n    num_roots.append(solve(sym_num.subs(element_values),s))\n    denom_roots.append(solve(sym_denom.subs(element_values),s))\n\n# put the zeros into an array\nz0_locus = np.zeros(len(np.array(num_roots)))\nz1_locus = np.zeros(len(np.array(num_roots)))\nfor i in range(len(np.array(num_roots))):\n    z0_locus[i] = -np.array(num_roots)[i][0]    \n    z1_locus[i] = -np.array(num_roots)[i][1]        \n\n# put the poles into an array\np0_locus = np.zeros(len(np.array(denom_roots)))\np1_locus = np.zeros(len(np.array(denom_roots)))\nfor i in range(len(np.array(denom_roots))):\n    p0_locus[i] = -np.array(denom_roots)[i][0]    \n    p1_locus[i] = -np.array(denom_roots)[i][1]        \n\nAfter solving for the numerator and dominator roots of the transfer function at various positions of \\(P_1\\), we can examine the range of frequencies that the zeros take on as \\(P_1\\) is rotated.\n\nprint(f'z0 range as a function of P1: {z0_locus.min()/(2*np.pi)/1e3:.3f} to {z0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z1 range as a function of P1: {z1_locus.min()/(2*np.pi)/1e3:.3f} to {z1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\nz0 range as a function of P1: 5.023 to 137.640 kHz\nz1 range as a function of P1: 0.133 to 0.133 kHz\n\n\nAs shown above, \\(z_0\\) will move from about 5kHz to 137 kHz as \\(P_1\\) is rotated. \\(z_1\\)’s position in the complex frequency plane remains constant. The position of \\(z_0\\) is plotted below.\n\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z0_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_0')\n#plt.plot(np.linspace(1,99,len(np.array(num_roots))),z1_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_1')\n\n#plt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-r', markerfacecolor='none',label='p_0')\n#plt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-r', markerfacecolor='none',label='p_1')\n\nplt.ylim((0,140))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the position of \\(z_0\\) moves more dramatically when \\(P_1\\) is rotated from 80 to 100%.\nThe range of the poles on the complex plane is printed below.\n\nprint(f'p0 range as a function of P1: {p0_locus.min()/(2*np.pi)/1e3:.3f} to {p0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p1 range as a function of P1: {p1_locus.min()/(2*np.pi)/1e3:.3f} to {p1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\np0 range as a function of P1: 0.967 to 0.967 kHz\np1 range as a function of P1: 0.149 to 0.776 kHz\n\n\nThe position of \\(p_0\\) is constant and \\(p_1\\) moves from 150 Hz to 776 Hz as \\(P_1\\) is rotated.\n\n#plt.plot(np.linspace(1,99,len(np.array(num_roots))),z0_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_0')\n#plt.plot(np.linspace(1,99,len(np.array(num_roots))),z1_locus/(2*np.pi)/1e3,'o-b', markerfacecolor='none',label='z_1')\n\n#plt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-k', markerfacecolor='none',label='p_0')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-r', markerfacecolor='none',label='p_1')\n\nplt.ylim((0,1))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, \\(p_1\\) moves more dramatically as \\(P_1\\) is rotated from 80% to 100%.\n\n\n27.3.2.7 Reactive Branch 2 Frequency Response\nThe voltage transfer function for the reactive branch shown in Figure 27.2 is plotted below.\n\n# set up\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,25,50,75,99])/100\np1_value = 100e3\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a1] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b1] = gain_setting[i]*p1_value\n    \n    #element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    #element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    #tf_num_coef_list.append(a)\n    #tf_denom_coef_list.append(b)\n    \n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    #clean_path1_mag[i] = mag\n    \n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='mag: {:.0f}%'.format(gain_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase: {:.0f}%'.format(gain_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\n#ax1.legend(loc='lower left')\n#ax2.legend(loc='lower right')\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, when the gain is increased, a resonance develops near 1 kHz.\n\n\n\n27.3.3 Reactive Branch 3\nThe schematic shown below represents the highlighted parts of the Klon Centuar circuit shown in Figure 25.17 and Figure 25.21. The voltage source \\(V_1\\) is the output Op Amp of \\(U_{1A}\\) and the voltage source \\(V_2\\) is the output of \\(U_{1B}\\). The Diodes \\(D_1\\) and \\(D_2\\) have been commented out in the netlist. Node 10 is the summing junction for clean path 2 and the diode path.\nOne of the ganged pots in \\(P_1\\), which is the gain control, is represented in the schematic by the resistors \\(R_{p1b2}\\) and \\(R_{p1a2}\\). The variable \\(R_{gain}\\) is used to control the position of the wiper. The gain pot, \\(P_1\\)’s terminals, are across \\(R_9\\) and \\(C_6\\) and \\(P_1\\)’s wiper contact at node 5 and forms a voltage divider that controls the signal amplitude at node 5.\nIn this section of the analysis we will look at the reactive path from node 1 to node 2 with \\(V_2\\) set to zero. This will include most of the components that are attached to these nodes. The components that are not included are those components along clean path 1 shown in Figure 25.15. Node 10 below is a virtual ground and by superposition we can separate out the contribution from clan path 1 and add it back later if we want to consider the combined contribution of the signals from the inputs to the summing junction. For now we are only interested in reactive branch 3.\nThe capacitor \\(C_{13}\\) shown in Figure 25.17 has been removed from this analysis. \\(C_{13}\\) in parallel with \\(R_{20}\\) in the feedback path around \\(U_{2B}\\) adds a zero to the voltage transfer function at about 500 Hz. The effect of this low pass filter is excluded from this analysis since we are interested only in the reactive path prior to \\(U_{1B}\\)\nWe will examine the solution to the network equations with \\(P_1\\) set to 50%. A symbolic solution was taking too long on my laptop, so this step was skipped. The poles and zeros for \\(P_1\\) are plotted and tabulated. The locus of poles and zeros for the transfer function are plotted to see how they move in the frequency domain as a function of \\(P_1\\). Finally, a frequency response plot of the voltage transfer function versus gain settings is generated.\nIn Section 27.3.4 and Section 27.3.6, reactive branch 3 is divided into two smaller subcircuits at \\(P_1\\). This is done to gain some insight into the operation of components along this path.\n\n\n\n\n\n\nFigure 27.3: Schematic of reactive branches 3 and 4. Reactive branch 3 is the path from V1 to V2 and reactive branch 4 is the path from V3 to V2.\n\n\n\nThe netlist below was exported from LTSpice when the schematic was generated.\n\nReactive_branch_3_4_net_list = '''\n* Reactive_branch_3&4.asc\nV1 1 0 1\nV2 6 0 0\nR5 1 3 5.1e3\nR8 3 0 1.5e3\nC4 1 3 68e-9\nC6 3 4 390e-9\nR9 4 0 1e3\nRp1b2 3 5 50e3\nRp1a2 5 0 50e3\nR13 8 7 1e3\nC11 9 11 2.2e-9\nR15 11 5 22e3\nR17 10 5 27e3\nR18 12 5 12e3\nC12 10 12 27e-9\nR16 10 9 47e3\n*R20 2 10 100e3\nR20 2 10 392e3\n*C13 2 10 820e-12\nO2a 10 0 2\n*D2 0 8 1N34A\n*D3 8 0 1N34A\nC9 6 7 1e-6\nC10 9 8 1e-6\n'''\n\nThe function SymMNA.smna generates the MNA matrices from the netlist.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Reactive_branch_3_4_net_list)\n\nThe following code builds and displays the symbolic circuit equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) + v_{3} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right)\\)\\(0 = I_{O2a} - \\frac{v_{10}}{R_{20}} + \\frac{v_{2}}{R_{20}}\\)\\(0 = - C_{6} s v_{4} + v_{1} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{3} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{Rp1b2}\\)\\(0 = - C_{6} s v_{3} + v_{4} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{5} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{3}}{Rp1b2} - \\frac{v_{12}}{R_{18}} - \\frac{v_{10}}{R_{17}} - \\frac{v_{11}}{R_{15}}\\)\\(0 = C_{9} s v_{6} - C_{9} s v_{7} + I_{V2}\\)\\(0 = - C_{9} s v_{6} + v_{7} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{8}}{R_{13}}\\)\\(0 = - C_{10} s v_{9} + v_{8} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{7}}{R_{13}}\\)\\(0 = - C_{10} s v_{8} - C_{11} s v_{11} + v_{9} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{10}}{R_{16}}\\)\\(0 = - C_{12} s v_{12} + v_{10} \\left(C_{12} s + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{2}}{R_{20}} - \\frac{v_{5}}{R_{17}} - \\frac{v_{9}}{R_{16}}\\)\\(0 = - C_{11} s v_{9} + v_{11} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{5}}{R_{15}}\\)\\(0 = - C_{12} s v_{10} + v_{12} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{5}}{R_{18}}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{6}\\)\\(0 = v_{10}\\)\n\n\nThe free symbols in the equations above are turned into SymPy variables and the element values are loaded into a Python dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n27.3.3.1 Numerical Solution for P1 at 50%\nThe network equations were too complex to generate symbolic solutions on my laptop. A numerical solution for the equations can easily be generated and this was done for \\(P_1\\) = 50%. The element values are substituted into the equations and displayed.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],9)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(6.8 \\cdot 10^{-8} s + 0.000196078\\right) + v_{3} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078\\right)\\)\n\n\n\\(0 = I_{O2a} - 2.551 \\cdot 10^{-6} v_{10} + 2.551 \\cdot 10^{-6} v_{2}\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{4} + v_{1} \\left(- 6.8 \\cdot 10^{-8} s - 0.000196078\\right) + v_{3} \\cdot \\left(4.58 \\cdot 10^{-7} s + 0.000882745\\right) - 2.0 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{3} + v_{4} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(0 = - 3.7037 \\cdot 10^{-5} v_{10} - 4.5455 \\cdot 10^{-5} v_{11} - 8.3333 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{3} + 0.000205825 v_{5}\\)\n\n\n\\(0 = I_{V2} + 1.0 \\cdot 10^{-6} s v_{6} - 1.0 \\cdot 10^{-6} s v_{7}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{8}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{9} - 0.001 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-9} s v_{11} - 1.0 \\cdot 10^{-6} s v_{8} - 2.1277 \\cdot 10^{-5} v_{10} + v_{9} \\cdot \\left(1.002 \\cdot 10^{-6} s + 2.1277 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{12} + v_{10} \\cdot \\left(2.7 \\cdot 10^{-8} s + 6.0865 \\cdot 10^{-5}\\right) - 2.551 \\cdot 10^{-6} v_{2} - 3.7037 \\cdot 10^{-5} v_{5} - 2.1277 \\cdot 10^{-5} v_{9}\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-9} s v_{9} + v_{11} \\cdot \\left(2.0 \\cdot 10^{-9} s + 4.5455 \\cdot 10^{-5}\\right) - 4.5455 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{10} + v_{12} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.3333 \\cdot 10^{-5}\\right) - 8.3333 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = v_{6}\\)\n\n\n\\(0 = v_{10}\\)\n\n\n\nUse SymPy to solve for the unknown voltages and currents in the network equations. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{- 2.02215504303191 \\cdot 10^{56} s^{5} - 5.2950674540929 \\cdot 10^{60} s^{4} - 2.8308370994823 \\cdot 10^{64} s^{3} - 5.27827462462547 \\cdot 10^{67} s^{2} - 3.01998947548071 \\cdot 10^{70} s - 1.16148974096409 \\cdot 10^{72}}{4.3362244543883 \\cdot 10^{55} s^{5} + 2.06897279791109 \\cdot 10^{60} s^{4} + 2.53915433684715 \\cdot 10^{64} s^{3} + 5.64733157523515 \\cdot 10^{67} s^{2} + 3.55388545376323 \\cdot 10^{70} s + 1.37913277012933 \\cdot 10^{72}}\\)\n\n\n\\(v_{3} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.76830244412326 \\cdot 10^{60} s^{4} + 9.75686883763291 \\cdot 10^{63} s^{3} + 2.00756023341467 \\cdot 10^{67} s^{2} + 1.40196836955285 \\cdot 10^{70} s + 5.47822825670137 \\cdot 10^{71}}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\n\n\n\\(v_{4} = \\frac{7.70884347446809 \\cdot 10^{55} s^{5} + 1.57063979093177 \\cdot 10^{60} s^{4} + 5.72958732242324 \\cdot 10^{63} s^{3} + 5.3843527894717 \\cdot 10^{66} s^{2} + 2.13650902011353 \\cdot 10^{68} s}{7.70884347446809 \\cdot 10^{55} s^{5} + 3.67817386295305 \\cdot 10^{60} s^{4} + 4.51405215439493 \\cdot 10^{64} s^{3} + 1.00397005781958 \\cdot 10^{68} s^{2} + 6.31801858446797 \\cdot 10^{70} s + 2.45179159134104 \\cdot 10^{72}}\\)\n\n\n\\(v_{5} = \\frac{4.72614965425532 \\cdot 10^{53} s^{5} + 1.34411248109 \\cdot 10^{58} s^{4} + 9.21167841492205 \\cdot 10^{61} s^{3} + 2.41846205484128 \\cdot 10^{65} s^{2} + 2.24113593696666 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{6} = 0.0\\)\n\n\n\\(v_{7} = \\frac{2.0138625 \\cdot 10^{55} s^{4} + 1.71863602941176 \\cdot 10^{59} s^{3} + 4.87499999999999 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{8} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 1.92002227941176 \\cdot 10^{56} s^{4} + 6.59363602941176 \\cdot 10^{59} s^{3} + 9.47058823529411 \\cdot 10^{62} s^{2} + 4.59558823529411 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{9} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 2.12140852941176 \\cdot 10^{56} s^{4} + 8.31227205882352 \\cdot 10^{59} s^{3} + 1.43455882352941 \\cdot 10^{63} s^{2} + 9.19117647058822 \\cdot 10^{65} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{10} = 0.0\\)\n\n\n\\(v_{11} = \\frac{2.0138625 \\cdot 10^{52} s^{5} + 9.56082557247695 \\cdot 10^{57} s^{4} + 8.10026990741267 \\cdot 10^{61} s^{3} + 2.31064415746956 \\cdot 10^{65} s^{2} + 2.23683368415064 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{12} = \\frac{1.45868816489362 \\cdot 10^{57} s^{4} + 3.69828291543406 \\cdot 10^{61} s^{3} + 1.70166527761975 \\cdot 10^{65} s^{2} + 2.2123357321652 \\cdot 10^{68} s + 8.88895209921494 \\cdot 10^{69}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 2.02215504303191 \\cdot 10^{56} s^{5} - 5.2950674540929 \\cdot 10^{60} s^{4} - 2.8308370994823 \\cdot 10^{64} s^{3} - 5.27827462462547 \\cdot 10^{67} s^{2} - 3.01998947548071 \\cdot 10^{70} s - 1.16148974096409 \\cdot 10^{72}}{4.3362244543883 \\cdot 10^{55} s^{5} + 2.06897279791109 \\cdot 10^{60} s^{4} + 2.53915433684715 \\cdot 10^{64} s^{3} + 5.64733157523515 \\cdot 10^{67} s^{2} + 3.55388545376323 \\cdot 10^{70} s + 1.37913277012933 \\cdot 10^{72}}\\)\n\n\nThe code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot for P1=50%')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-3142.62     -4629.79\n-458.92      -2545.69\n-408.09      -231.62\n-151.29      -180.17\n-6.59        -6.6\n\n\n\n\n27.3.3.2 Pole/Zero Locus Plot versus P1 value\nThere are 5 zeros and poles in the voltage transfer function. Solutions for the values of the poles and zeros as a function of \\(P_1\\)’s rotational position are saved to an array.\n\np1_value = 100e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp1a2] = p1_value - i*p1_value\n    element_values[Rp1b2] = i*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)    \n    sys_tf = signal.TransferFunction(a,b)\n    \n    num_roots.append(np.roots(sys_tf.num))\n    denom_roots.append(np.roots(sys_tf.den))\n\n# put the zeros into an array\nz0_locus = np.zeros(len(np.array(num_roots)))\nz1_locus = np.zeros(len(np.array(num_roots)))\nz2_locus = np.zeros(len(np.array(num_roots)))\nz3_locus = np.zeros(len(np.array(num_roots)))\nz4_locus = np.zeros(len(np.array(num_roots)))\n\nfor i in range(len(np.array(num_roots))):\n    z0_locus[i] = -np.array(num_roots)[i][0]    \n    z1_locus[i] = -np.array(num_roots)[i][1]        \n    z2_locus[i] = -np.array(num_roots)[i][2]    \n    z3_locus[i] = -np.array(num_roots)[i][3]  \n    z4_locus[i] = -np.array(num_roots)[i][4]    \n    \n# put the poles into an array\np0_locus = np.zeros(len(np.array(denom_roots)))\np1_locus = np.zeros(len(np.array(denom_roots)))\np2_locus = np.zeros(len(np.array(denom_roots)))\np3_locus = np.zeros(len(np.array(denom_roots)))\np4_locus = np.zeros(len(np.array(denom_roots)))\n\nfor i in range(len(np.array(denom_roots))):\n    p0_locus[i] = -np.array(denom_roots)[i][0]    \n    p1_locus[i] = -np.array(denom_roots)[i][1]       \n    p2_locus[i] = -np.array(denom_roots)[i][2]      \n    p3_locus[i] = -np.array(denom_roots)[i][3]      \n    p4_locus[i] = -np.array(denom_roots)[i][4]      \n\nThe range of values the zeros take on as a function of \\(P_1\\) is printed below.\n\nprint(f'z0 range as a function of P1: {z0_locus.min()/(2*np.pi)/1e3:.3f} to {z0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z1 range as a function of P1: {z1_locus.min()/(2*np.pi)/1e3:.3f} to {z1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z2 range as a function of P1: {z2_locus.min()/(2*np.pi)/1e3:.3f} to {z2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z3 range as a function of P1: {z3_locus.min()/(2*np.pi)/1e3:.3f} to {z3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z4 range as a function of P1: {z4_locus.min()/(2*np.pi)/1e3:.3f} to {z4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\nz0 range as a function of P1: 3.143 to 3.143 kHz\nz1 range as a function of P1: 0.459 to 0.459 kHz\nz2 range as a function of P1: 0.408 to 0.408 kHz\nz3 range as a function of P1: 0.151 to 0.151 kHz\nz4 range as a function of P1: 0.007 to 0.007 kHz\n\n\nAs shown above, the zeros of the transfer function don’t change with \\(P_1\\).\nThe range of values the poles take on as a function of \\(P_1\\) is printed below.\n\nprint(f'p0 range as a function of P1: {p0_locus.min()/(2*np.pi)/1e3:.3f} to {p0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p1 range as a function of P1: {p1_locus.min()/(2*np.pi)/1e3:.3f} to {p1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p2 range as a function of P1: {p2_locus.min()/(2*np.pi)/1e3:.3f} to {p2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p3 range as a function of P1: {p3_locus.min()/(2*np.pi)/1e3:.3f} to {p3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p4 range as a function of P1: {p4_locus.min()/(2*np.pi)/1e3:.3f} to {p4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\np0 range as a function of P1: 4.611 to 5.043 kHz\np1 range as a function of P1: 2.546 to 3.046 kHz\np2 range as a function of P1: 0.232 to 0.455 kHz\np3 range as a function of P1: 0.179 to 0.181 kHz\np4 range as a function of P1: 0.007 to 0.007 kHz\n\n\nAs shown above the poles of the transfer function vary with \\(P_1\\), and these are plotted below.\n\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_0')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_1')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p2_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_2')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p3_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_3')\n\nplt.ylim((0,6))\nplt.legend(loc='upper left')\nplt.title('Gain control pole frequency plot vs gain pot rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plots above, the pole locations don’t change all that much as a function of \\(P_1\\) rotation.\n\n\n27.3.3.3 Reactive Branch 3 Frequency Response\nThe plot below shows the magnitude and phase of voltage transfer function versus frequency at various positions of \\(P_1\\).\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,25,50,75,99])/100\np1_value = 100e3\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    #element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    #element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v1]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    #tf_num_coef_list.append(a)\n    #tf_denom_coef_list.append(b)\n    \n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    #clean_path1_mag[i] = mag\n    \n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='mag: {:.0f}%'.format(gain_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase: {:.0f}%'.format(gain_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\n#ax1.legend(loc='lower left')\n#ax2.legend(loc='lower right')\nax1.grid()\nplt.title('Magnitude and phase response')\n#plt.savefig('plt_rb_3.png')\nplt.show()\n\n\n\n\n\n\n\n\nThe magnitude and phase of voltage transfer function for reactive branch 3 shows about a 20 dB increase in gain over the guitar frequency band.\nKeep in mind that \\(C_{13}\\) and \\(R_{20}\\) put a pole into the voltage transfer function at about 500 Hz, which reduces the frequency emphasis plotted above. This can be easily seen if \\(C_{13}\\) is included in the netlist and the analysis above is re-run. Poles and zeros with C13 as shown below, notice the addition of a pole at 495 Hz.\nZeros, Hz    Poles, Hz\n-----------  -----------\n-3142.62     -4629.79\n-458.92      -2545.69\n-408.09      -495.13\n-151.29      -231.62\n-6.59        -180.17\n             -6.6\nThe plot of transfer function with \\(C_{13}\\) included in the analysis is:\n\n\n\nFrequency response of reactive branch 3 with C13 included in the analysis.\n\n\nNotice that zero at 500 Hz now dominates the shape of the transfer function, which is now somewhat flat over the guitar band and a low pass filter with a cutoff starting around 3 kHz.\n\n\n\n27.3.4 Reactive Branch 3a\nThe schematic shown below is a sub-circuit of reactive branch 3 from \\(V_1\\) to \\(P_1\\) (in the schematic below, the reference designator for \\(P_1\\) is \\(R_{p1ab2}\\) since \\(P_1\\) is modeled as two resistors.). In Figure 27.4, the nodes have been renumbered and \\(P_1\\) has been replaced by a fixed value resistor of 100 k\\(\\Omega\\).\nThe branch from node 1 to node 3 is composed of components \\(R_5\\) and \\(C_4\\), and these have a resonant frequency of about 450 Hz. \\(R_5\\) and \\(C_4\\) are in parallel with each other and in series with the signal path and this arrangement forms a zero in the voltage transfer function. The components \\(R_9\\) and \\(C_6\\) are in series with each other and have a resonant frequency of about 400 Hz and present a shunt to the signal path, which produces a second zero in the voltage transfer function. By inspection we can see the gain is \\((R_8||P_1)/(R_5+R_8||P_1)\\) at \\(\\omega=0\\) since the capacitors are open circuits at DC. At high frequency the gain is 1 since \\(C_4\\) looks like a short at high frequency.\n\n\n\n\n\n\nFigure 27.4: Schematic of reactive branch 3a.\n\n\n\nThe netlist below was obtained from the LTSpice schematic.\n\nreactive_branch_3_4_a_net_list = '''\n* Reactive_branch_3&4_a.asc\nR5 1 2 5.1e3\nR8 2 0 1.5e3\nC4 1 2 68e-9\nC6 2 3 390e-9\nR9 3 0 1e3\nRp1ab2 2 0 100e3\nV1 1 0 1\n'''\n\nThe MNA matrices are generated by calling SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_3_4_a_net_list)\n\nThe network equations are built from the MNA matrices.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) + v_{2} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right)\\)\\(0 = - C_{6} s v_{3} + v_{1} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{2} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right)\\)\\(0 = - C_{6} s v_{2} + v_{3} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are turned into SymPy symbols and the element values are loaded into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n27.3.4.1 Symbolic solution\nThe network equations can be solved symbolically and are displayed below.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{4} R_{5} R_{8} Rp1ab2 V_{1} s + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s + R_{8} Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(v_{3} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(I_{V1} = \\frac{- C_{4} C_{6} R_{5} R_{8} R_{9} V_{1} s^{2} - C_{4} C_{6} R_{5} R_{8} Rp1ab2 V_{1} s^{2} - C_{4} C_{6} R_{5} R_{9} Rp1ab2 V_{1} s^{2} - C_{4} R_{5} R_{8} V_{1} s - C_{4} R_{5} Rp1ab2 V_{1} s - C_{6} R_{8} R_{9} V_{1} s - C_{6} R_{8} Rp1ab2 V_{1} s - C_{6} R_{9} Rp1ab2 V_{1} s - R_{8} V_{1} - Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\n\n\nSymPy can solve and display the node voltage equations.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{4} R_{5} R_{8} Rp1ab2 V_{1} s + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s + R_{8} Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(v_{3} = \\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 V_{1} s^{2} + C_{6} R_{8} R_{9} Rp1ab2 V_{1} s}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\\(I_{V1} = \\frac{- C_{4} C_{6} R_{5} R_{8} R_{9} V_{1} s^{2} - C_{4} C_{6} R_{5} R_{8} Rp1ab2 V_{1} s^{2} - C_{4} C_{6} R_{5} R_{9} Rp1ab2 V_{1} s^{2} - C_{4} R_{5} R_{8} V_{1} s - C_{4} R_{5} Rp1ab2 V_{1} s - C_{6} R_{8} R_{9} V_{1} s - C_{6} R_{8} Rp1ab2 V_{1} s - C_{6} R_{9} Rp1ab2 V_{1} s - R_{8} V_{1} - Rp1ab2 V_{1}}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{8} Rp1ab2}{C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2}\\)\n\n\nWe can look at the numerator and denominator polynomials of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n27.3.4.2 Numerator Polynomial\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{8} Rp1ab2\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$\\\n    &lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(b_1=C_{4} R_{5} R_{8} Rp1ab2 + C_{6} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(b_0=R_{8} Rp1ab2\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nMarkdown('There are {:d} zeros, which are:\\\n    &lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;'.format(len(num_root_sym),latex(num_root_sym[0]),latex(num_root_sym[1])))\n\nThere are 2 zeros, which are:\n\n\\(z_0=- \\frac{1}{C_{4} R_{5}}\\)\n\n\n\\(z_1=- \\frac{1}{C_{6} R_{9}}\\)\n\n\n\n\n\n27.3.4.3 Denominator Polynomial\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2 s^{2} + C_{4} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{8} R_{9} s + C_{6} R_{5} R_{8} Rp1ab2 s + C_{6} R_{5} R_{9} Rp1ab2 s + C_{6} R_{8} R_{9} Rp1ab2 s + R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_2s^2+a_1s+a_0\\)\nwhere \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\n\n\n\\(a_2=C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(a_1=C_{4} R_{5} R_{8} Rp1ab2 + C_{6} R_{5} R_{8} R_{9} + C_{6} R_{5} R_{8} Rp1ab2 + C_{6} R_{5} R_{9} Rp1ab2 + C_{6} R_{8} R_{9} Rp1ab2\\)\n\n\n\\(a_0=R_{5} R_{8} + R_{5} Rp1ab2 + R_{8} Rp1ab2\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transder fuction, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are:\\\n    &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1])))\n\nThere are 2 poles, which are:\n\n\\(p_0=\\frac{- C_{4} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{8} R_{9} - C_{6} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{9} Rp1ab2 - C_{6} R_{8} R_{9} Rp1ab2 - \\sqrt{C_{4}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9}^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + C_{6}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{9}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8} R_{9}^{2} Rp1ab2^{2} + C_{6}^{2} R_{8}^{2} R_{9}^{2} Rp1ab2^{2}}}{2 C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2}\\)\n\n\n\\(p_1=\\frac{- C_{4} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{8} R_{9} - C_{6} R_{5} R_{8} Rp1ab2 - C_{6} R_{5} R_{9} Rp1ab2 - C_{6} R_{8} R_{9} Rp1ab2 + \\sqrt{C_{4}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + 2 C_{4} C_{6} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} - 2 C_{4} C_{6} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9}^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8}^{2} R_{9} Rp1ab2 + C_{6}^{2} R_{5}^{2} R_{8}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5}^{2} R_{8} R_{9} Rp1ab2^{2} + C_{6}^{2} R_{5}^{2} R_{9}^{2} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9}^{2} Rp1ab2 + 2 C_{6}^{2} R_{5} R_{8}^{2} R_{9} Rp1ab2^{2} + 2 C_{6}^{2} R_{5} R_{8} R_{9}^{2} Rp1ab2^{2} + C_{6}^{2} R_{8}^{2} R_{9}^{2} Rp1ab2^{2}}}{2 C_{4} C_{6} R_{5} R_{8} R_{9} Rp1ab2}\\)\n\n\n\n\n\n\n27.3.5 Analysis Using the Extra Element Theorem\nThe coefficients of the numerator and denominator polynomials for the transfer function of the circuit shown in Figure 27.4 can be determined by using the N Extra Element Theorem of Middlebrook, Vorperian, and Lindal (1998). Since there are only two reactive components in the circuit, this can be performed by inspection. See the example starting on slide 85 of Basso (2016). The following code cells walk through the steps.\nThe denominator polynomial coefficients \\(c_2\\) and \\(c_1\\) in the expression:\n\\(c_2s^2+c_1s+1\\)\ncan be found by the following steps. First find the time constants \\(\\tau_1\\) and \\(\\tau_2\\) while \\(V_1=0\\). To find \\(\\tau_1\\), look at Figure 27.4 with \\(V_1=0\\) and \\(C_6\\) replaced by its impedance at \\(\\omega=0\\), which is an open circuit. The resistance seen by \\(C_4\\) is the parallel combination of \\(R_5\\), \\(R_8\\) and \\(R_{p1ab2}\\) which is equal to \\(\\frac {1} {\\frac {1}{R_5}+\\frac {1}{R_8}+\\frac {1}{R_{p1ab2}} }\\). We can create a new symbol \\(Rp\\) to represent the parallel combination of \\(R_5\\), \\(R_8\\) and \\(R_{p1ab2}\\).\n\nRp = symbols('Rp')\n\ntau_1 = C4*Rp\nMarkdown('The time constant $\\\\tau_1 = {:s}$.'.format(latex(tau_1)))\n\nThe time constant \\(\\tau_1 = C_{4} Rp\\).\n\n\nTo find \\(\\tau_2\\), replace \\(C_4\\) its impedance at \\(\\omega=0\\), which is an open circuit. The resistance seen by \\(C_6\\) is \\(R_9\\) plus the parallel combination of \\(R_5\\), \\(R_8\\) and \\(R_{p1ab2}\\) which is equal to \\(R_9 + \\frac {1} {\\frac {1}{R_5}+\\frac {1}{R_8}+\\frac {1}{R_{p1ab2}} }\\).\n\ntau_2 = C6*(Rp+R9)\nMarkdown('The time constant $\\\\tau_2 = {:s}$.'.format(latex(tau_2)))\n\nThe time constant \\(\\tau_2 = C_{6} \\left(R_{9} + Rp\\right)\\).\n\n\n\nc_1 = tau_1+tau_2\nMarkdown('The denominator polynomial coefficient, $c_1 = \\\\tau_1+\\\\tau_2 = {:s}$.'.format(latex(c_1)))\n\nThe denominator polynomial coefficient, \\(c_1 = \\tau_1+\\tau_2 = C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\).\n\n\nTo find \\(c_2\\), place C1 in its high-frequency and look into C2, \\(V_1\\) is still zero, this is \\(\\tau_1^2\\) and \\(a_2 = \\tau_1 \\tau_1^2\\).\n\n# tau_1^2\ntau_1_2 = (C6*R9)\nMarkdown('$\\\\tau_1^2 = {:s}$'.format(latex(tau_1_2)))\n\n\\(\\tau_1^2 = C_{6} R_{9}\\)\n\n\nThe second coeeficient is equal to \\(\\tau_1 \\tau_1^2\\).\n\nc_2 = tau_1*tau_1_2\nMarkdown('$c_2 = {:s}$'.format(latex(c_2)))\n\n\\(c_2 = C_{4} C_{6} R_{9} Rp\\)\n\n\n\nMarkdown('The denominator polynomial = ${:s}$'.format(latex(c_2*s**2+c_1*s+1)))\n\nThe denominator polynomial = \\(C_{4} C_{6} R_{9} Rp s^{2} + s \\left(C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\right) + 1\\)\n\n\nTo find if \\(C_4\\) and \\(C_6\\) cause zeros in the transfer function, the following procedure is used:\n\nPlace \\(C_4\\) in its high-frequency state while \\(C_6\\) is in its low frequency state, check if the stimulus can propagate through the circuit to form a response on the output.\nThe place \\(C_6\\) in its high-frequency state while \\(C_4\\) is in its low frequency state, check if the stimulus can propagate through the circuit to form a response on the output.\n\nIn both cases the stimulus can propagate through the circuit to form a response on the output.\nTo find the locations of the zeros, you have to find the impedance condition in the circuit where, for a certain stimulus frequency, you null the response. Either a series impedance becomes an infinite value or a shunt branch is zero. This happens for:\n\nt1 = C6*R9\nt2 = C4*R5\nMarkdown('$t_1 = C_6R_9$ and $t_2 = C_4R_5$')\n\n\\(t_1 = C_6R_9\\) and \\(t_2 = C_4R_5\\)\n\n\n\nMarkdown('We can write the numerator polynomial in factored form: ${:s}$'.format(latex((s+1/t1)*(s+1/t2))))\n\nWe can write the numerator polynomial in factored form: \\(\\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)\\)\n\n\nThe DC gain of the transfer function, \\(H_0\\) can be found by letting \\(\\omega=0\\) and is:\n\\(H_0=\\frac{R_8||P_1}{R_5+R_8||P_1}\\)\nNow we can write the transfer function:\n\nH_0 = symbols('H_0')\nMarkdown('$H(s)={:s}$'.format(latex(H_0*(s+1/t1)*(s+1/t2)/(c_2*s**2+c_1*s+1))))\n\n\\(H(s)=\\frac{H_{0} \\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)}{C_{4} C_{6} R_{9} Rp s^{2} + s \\left(C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\right) + 1}\\)\n\n\nThe expression obtained for \\(H(s)\\) above can be checked by substituting element values and comparing to the MNA results above.\nSubstituting \\(R_{p1ab2}\\) for \\(P_1\\), the expression for \\(H_0\\) is:\n\nH_0 = (1/(1/R8+1/Rp1ab2))/(R5+1/(1/R8+1/Rp1ab2))\nMarkdown('$H_0(s)={:s}$'.format(latex(H_0)))\n\n\\(H_0(s)=\\frac{1}{\\left(R_{5} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}}\\right) \\left(\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}\\right)}\\)\n\n\nPutting all the sysmbols together, we get:\n\nMarkdown('$H(s)={:s}$'.format(latex(H_0*(s+1/t1)*(s+1/t2)/(c_2*s**2+c_1*s+1))))\n\n\\(H(s)=\\frac{\\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)}{\\left(R_{5} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}}\\right) \\left(\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}\\right) \\left(C_{4} C_{6} R_{9} Rp s^{2} + s \\left(C_{4} Rp + C_{6} \\left(R_{9} + Rp\\right)\\right) + 1\\right)}\\)\n\n\nMaking the substitution for \\(R_P\\) we get:\n\nH = (H_0*(s+1/t1)*(s+1/t2)/(c_2*s**2+c_1*s+1)).subs({Rp:1/(1/R5+1/R8+1/Rp1ab2)})\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{\\left(s + \\frac{1}{C_{4} R_{5}}\\right) \\left(s + \\frac{1}{C_{6} R_{9}}\\right)}{\\left(R_{5} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}}\\right) \\left(\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}}\\right) \\left(\\frac{C_{4} C_{6} R_{9} s^{2}}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}} + s \\left(\\frac{C_{4}}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}} + C_{6} \\left(R_{9} + \\frac{1}{\\frac{1}{Rp1ab2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}}\\right)\\right) + 1\\right)}\\)\n\n\nPutting in the element values we get:\n\nH = H.subs(element_values)\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{0.224668613794653 \\left(s + 2564.10256410256\\right) \\left(s + 2883.50634371396\\right)}{3.03868793529544 \\cdot 10^{-8} s^{2} + 0.00091478094810155 s + 1}\\)\n\n\nNow we can extract the numerator and demoninator and compare to the MNA results.\n\nH1_num, H1_denom = fraction(H)\n\nThe numerator obtained with the EET is:\n\nH1_num.expand()/H1_num.expand().coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 5447.60890781652 s + 7393606.00952296\\)\n\n\nWhich exactly matches the numberator obtained from MNA.\n\nH_sym_num.subs(element_values)/H_sym_num.subs(element_values).coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 5447.60890781652 s + 7393606.00952297\\)\n\n\nLooking at the demominators, the demininator obtanained from the EET is :\n\nH1_denom/H1_denom.coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 30104.4716529146 s + 32908940.3483867\\)\n\n\nWhich exactly matches the demoninator obtained from MNA.\n\nH_sym_denom.subs(element_values)/H_sym_denom.subs(element_values).coeff(s**2)\n\n\\(\\displaystyle 1.0 s^{2} + 30104.4716529146 s + 32908940.3483867\\)\n\n\nThis varifies that the EET solution is valid. If the circuit is a 2nd order circuit, this analysis approach can be useful.\n\n27.3.5.1 Numerical Solution\nIf numerical values are substituted for the reference designators in the symbolic equations, the following numerical equations can be obtained.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],8)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(7.0 \\cdot 10^{-8} s + 0.00019608\\right) + v_{2} \\left(- 7.0 \\cdot 10^{-8} s - 0.00019608\\right)\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{3} + v_{1} \\left(- 7.0 \\cdot 10^{-8} s - 0.00019608\\right) + v_{2} \\cdot \\left(4.6 \\cdot 10^{-7} s + 0.00087275\\right)\\)\n\n\n\\(0 = - 3.9 \\cdot 10^{-7} s v_{2} + v_{3} \\cdot \\left(3.9 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{2652000000000.0 s^{2} + 1.44470588235294 \\cdot 10^{16} s + 1.96078431372549 \\cdot 10^{19}}{2652000000000.0 s^{2} + 7.98370588235294 \\cdot 10^{16} s + 8.72745098039216 \\cdot 10^{19}}\\)\n\n\n\\(v_{3} = \\frac{2652000000000.0 s^{2} + 7.64705882352941 \\cdot 10^{15} s}{2652000000000.0 s^{2} + 7.98370588235294 \\cdot 10^{16} s + 8.72745098039216 \\cdot 10^{19}}\\)\n\n\n\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('The transfer function is: $H(s)={:s}$'.format(latex(H)))\n\nThe transfer function is: \\(H(s)=\\frac{2652000000000.0 s^{2} + 1.44470588235294 \\cdot 10^{16} s + 1.96078431372549 \\cdot 10^{19}}{2652000000000.0 s^{2} + 7.98370588235294 \\cdot 10^{16} s + 8.72745098039216 \\cdot 10^{19}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-458.92      -4610.47\n-408.09      -180.8\n\n\n\n\n27.3.5.2 Reactive Branch 3a Frequency Response\nThe frequency response for the circuit in Figure 27.4 is shown below.\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n#gain_setting = np.array([1,25,50,75,99])/100\n#p1_value = 100e3\n\n#tf_num_coef_list = []\n#tf_denom_coef_list = []\n\n#clean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\n\n#color_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n#x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n#clean_path1_mag[i] = mag\n\n# plot the results\ni=0\nax1.semilogx(w/(2*np.pi), mag,'-k',label='mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':k',label='phase')  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\nax1.set_ylim((-20,5))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nBy examining the circuit in Figure 27.4, we can see that there is a DC path from node 1 to node 2. At \\(\\omega=0\\), the capacitors act as open circuits and the circuit reduces to a voltage divider equal to \\(\\frac {R_8||P_1} {R_5+R_8||P_1}\\) between nodes 1 and 2. At high frequencies, the capacitors act as short circuits and at high frequencies node 2 is shorted to node 1 by \\(C_4\\)\n\n\n\n27.3.6 Reactive Branch 3b\nThe branch composed of components \\(R_{15}\\), \\(C_{11}\\) and \\(R_{16}\\) and the branch composed of components \\(R_{17}\\), \\(R_{18}\\) and \\(C_{12}\\), form an unusual summing network attached to node 10 in Figure 27.3. The signal from the diode path combines with the signal from clean path 2 through \\(C_{11}\\) at node 9.\nThe resistor \\(R_{16}\\) conducts this blended signal into the summing junction at node 10. The signal from clean path 2 travels through the branch composed of components \\(R_{17}\\), \\(R_{18}\\) and \\(C_{12}\\) to the summing junction at node 10. The branch from node 5 to node 10, consisting of components \\(R_{17}\\), \\(R_{18}\\) and \\(C_{12}\\), attaches to the summing junction at node 10 and combines the signal from clean path 2. These components have resonances that contribute to the poles and zeros of the transfer function.\nThe components \\(R_{18}\\) and \\(C_{12}\\) have a resonant frequency of about 500 Hz and since these are in series contribute to a pole to the transfer function at their resonant frequency. The components \\(R_{18}+R_{17}\\) and \\(C_{12}\\) have a resonant frequency of about 150 Hz and these contribute to a zero to the transfer function at their resonant frequency.\nIt’s not clear how the arrangement of these components attached to the summing junction were determined, perhaps this topology came to look like this by experimentation in the circuit prototyping and testing phase of the design.\nWhen \\(P_{1A}\\) in Figure 25.17, is rotated fully clockwise the wiper is connected to the ground end and no signal propagates along the path. When \\(P_{1A}\\) is rotated fully counter clockwise, the wiper is connected to \\(C_6\\) and the clean signal can propagate along the path. Otherwise, \\(P_{1A}\\) acts as a voltage divider and the amplitude of the signal can be adjusted by the user.\nThe schematic in Figure 27.3 has been redrawn below, notice that the node numbers have changed. The capacitor values for \\(C_{10}\\) and \\(C_9\\) have been combined and 0.5 \\(\\mu\\)F has been used for the value of \\(C_{10}\\) below.\n\n\n\n\n\n\nFigure 27.5: Schematic of reactive branch 3b.\n\n\n\nThe capacitor, \\(C_9\\), has been absorbed into \\(C_{10}\\) in the schematic above in order to reduce the component and node count for the MNA. Since \\(C_9\\) and \\(C_{10}\\) are in series, the value of \\(C_{10}\\) has been adjusted. The capacitor \\(C_{13}\\) has not been included in the netlist so we can observe the operation of this reactive branch without the zero created at 500 Hz by \\(C_{13}\\).\n\nreactive_branch_3_4_a_net_list = '''\n* Reactive_branch_3b.asc\nR13 3 0 1e3\nC11 4 6 2.2e-9\nR15 6 1 22e3\nR17 5 1 27e3\nR18 7 1 12e3\nC12 5 7 27e-9\nR16 5 4 47e3\nV1 1 0 1\nC10 4 3 0.5e-6\nR20 2 5 392e3\n*C13 2 5 820e-12\nO2A 5 0 2\n'''\n\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(reactive_branch_3_4_a_net_list)\n\nBuild the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{7}}{R_{18}} - \\frac{v_{5}}{R_{17}} - \\frac{v_{6}}{R_{15}}\\)\\(0 = I_{O2a} + \\frac{v_{2}}{R_{20}} - \\frac{v_{5}}{R_{20}}\\)\\(0 = - C_{10} s v_{4} + v_{3} \\left(C_{10} s + \\frac{1}{R_{13}}\\right)\\)\\(0 = - C_{10} s v_{3} - C_{11} s v_{6} + v_{4} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{5}}{R_{16}}\\)\\(0 = - C_{12} s v_{7} + v_{5} \\left(C_{12} s + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{2}}{R_{20}} - \\frac{v_{1}}{R_{17}} - \\frac{v_{4}}{R_{16}}\\)\\(0 = - C_{11} s v_{4} + v_{6} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{1}}{R_{15}}\\)\\(0 = - C_{12} s v_{5} + v_{7} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{1}}{R_{18}}\\)\\(V_{1} = v_{1}\\)\\(0 = v_{5}\\)\n\n\nTurn the free symbols into SymPy variables and load the element values.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n27.3.6.1 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the node voltages and dependent currents using symbolic notation.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20} V_{1} s^{3} - C_{10} C_{11} R_{13} R_{15} R_{20} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{16} R_{20} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{17} R_{20} V_{1} s^{2} - C_{10} C_{11} R_{15} R_{16} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{17} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{18} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{17} R_{20} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{18} R_{20} V_{1} s^{2} - C_{10} R_{13} R_{20} V_{1} s - C_{10} R_{16} R_{20} V_{1} s - C_{11} C_{12} R_{15} R_{17} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{15} R_{18} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{17} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{18} R_{20} V_{1} s^{2} - C_{11} C_{12} R_{17} R_{18} R_{20} V_{1} s^{2} - C_{11} R_{15} R_{20} V_{1} s - C_{11} R_{16} R_{20} V_{1} s - C_{11} R_{17} R_{20} V_{1} s - C_{12} R_{17} R_{20} V_{1} s - C_{12} R_{18} R_{20} V_{1} s - R_{20} V_{1}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\\(v_{3} = \\frac{C_{10} C_{11} R_{13} R_{16} V_{1} s^{2}}{C_{10} C_{11} R_{13} R_{15} s^{2} + C_{10} C_{11} R_{13} R_{16} s^{2} + C_{10} C_{11} R_{15} R_{16} s^{2} + C_{10} R_{13} s + C_{10} R_{16} s + C_{11} R_{15} s + C_{11} R_{16} s + 1}\\)\\(v_{4} = \\frac{C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} + C_{11} R_{16} V_{1} s}{C_{10} C_{11} R_{13} R_{15} s^{2} + C_{10} C_{11} R_{13} R_{16} s^{2} + C_{10} C_{11} R_{15} R_{16} s^{2} + C_{10} R_{13} s + C_{10} R_{16} s + C_{11} R_{15} s + C_{11} R_{16} s + 1}\\)\\(v_{5} = 0\\)\\(v_{6} = \\frac{C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} + C_{10} R_{13} V_{1} s + C_{10} R_{16} V_{1} s + C_{11} R_{16} V_{1} s + V_{1}}{C_{10} C_{11} R_{13} R_{15} s^{2} + C_{10} C_{11} R_{13} R_{16} s^{2} + C_{10} C_{11} R_{15} R_{16} s^{2} + C_{10} R_{13} s + C_{10} R_{16} s + C_{11} R_{15} s + C_{11} R_{16} s + 1}\\)\\(v_{7} = \\frac{V_{1}}{C_{12} R_{18} s + 1}\\)\\(I_{V1} = \\frac{- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} V_{1} s^{3} - C_{10} C_{11} C_{12} R_{16} R_{17} R_{18} V_{1} s^{3} - C_{10} C_{11} R_{13} R_{15} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} - C_{10} C_{11} R_{13} R_{17} V_{1} s^{2} - C_{10} C_{11} R_{15} R_{16} V_{1} s^{2} - C_{10} C_{11} R_{16} R_{17} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{17} V_{1} s^{2} - C_{10} C_{12} R_{13} R_{18} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{17} V_{1} s^{2} - C_{10} C_{12} R_{16} R_{18} V_{1} s^{2} - C_{10} R_{13} V_{1} s - C_{10} R_{16} V_{1} s - C_{11} C_{12} R_{15} R_{17} V_{1} s^{2} - C_{11} C_{12} R_{15} R_{18} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{17} V_{1} s^{2} - C_{11} C_{12} R_{16} R_{18} V_{1} s^{2} - C_{11} C_{12} R_{17} R_{18} V_{1} s^{2} - C_{11} R_{15} V_{1} s - C_{11} R_{16} V_{1} s - C_{11} R_{17} V_{1} s - C_{12} R_{17} V_{1} s - C_{12} R_{18} V_{1} s - V_{1}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\\(I_{O2a} = \\frac{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} V_{1} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} V_{1} s^{3} + C_{10} C_{11} R_{13} R_{15} V_{1} s^{2} + C_{10} C_{11} R_{13} R_{16} V_{1} s^{2} + C_{10} C_{11} R_{13} R_{17} V_{1} s^{2} + C_{10} C_{11} R_{15} R_{16} V_{1} s^{2} + C_{10} C_{12} R_{13} R_{17} V_{1} s^{2} + C_{10} C_{12} R_{13} R_{18} V_{1} s^{2} + C_{10} C_{12} R_{16} R_{17} V_{1} s^{2} + C_{10} C_{12} R_{16} R_{18} V_{1} s^{2} + C_{10} R_{13} V_{1} s + C_{10} R_{16} V_{1} s + C_{11} C_{12} R_{15} R_{17} V_{1} s^{2} + C_{11} C_{12} R_{15} R_{18} V_{1} s^{2} + C_{11} C_{12} R_{16} R_{17} V_{1} s^{2} + C_{11} C_{12} R_{16} R_{18} V_{1} s^{2} + C_{11} C_{12} R_{17} R_{18} V_{1} s^{2} + C_{11} R_{15} V_{1} s + C_{11} R_{16} V_{1} s + C_{11} R_{17} V_{1} s + C_{12} R_{17} V_{1} s + C_{12} R_{18} V_{1} s + V_{1}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} R_{13} R_{15} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{16} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{11} R_{15} R_{16} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{18} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{10} R_{13} R_{20} s - C_{10} R_{16} R_{20} s - C_{11} C_{12} R_{15} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{15} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{17} R_{18} R_{20} s^{2} - C_{11} R_{15} R_{20} s - C_{11} R_{16} R_{20} s - C_{11} R_{17} R_{20} s - C_{12} R_{17} R_{20} s - C_{12} R_{18} R_{20} s - R_{20}}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}}\\)\n\n\nThe numerator and the denominator are third order polynomials in terms of \\(s\\). Generally, the order of the dominator is equal to the number of reactive elements in the circuit. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n27.3.6.2 Numerator Polynomial of \\(H_{sym}(s)\\)\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} s^{3} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20} s^{3} - C_{10} C_{11} R_{13} R_{15} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{16} R_{20} s^{2} - C_{10} C_{11} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{11} R_{15} R_{16} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{13} R_{18} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{10} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{10} R_{13} R_{20} s - C_{10} R_{16} R_{20} s - C_{11} C_{12} R_{15} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{15} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{17} R_{20} s^{2} - C_{11} C_{12} R_{16} R_{18} R_{20} s^{2} - C_{11} C_{12} R_{17} R_{18} R_{20} s^{2} - C_{11} R_{15} R_{20} s - C_{11} R_{16} R_{20} s - C_{11} R_{17} R_{20} s - C_{12} R_{17} R_{20} s - C_{12} R_{18} R_{20} s - R_{20}\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_3s^{3}+b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_3\\), \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb3 = H_sym_num.coeff(s**3)\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2 - b3*s**3).expand()\n\nMarkdown('&lt;p&gt;$b_3={:s}$&lt;/p&gt;&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$\\\n    &lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b3),latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_3=- C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} R_{20} - C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} R_{20} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{20} - C_{10} C_{11} C_{12} R_{15} R_{16} R_{18} R_{20}\\)\n\n\n\\(b_2=- C_{10} C_{11} R_{13} R_{15} R_{20} - C_{10} C_{11} R_{13} R_{16} R_{20} - C_{10} C_{11} R_{13} R_{17} R_{20} - C_{10} C_{11} R_{15} R_{16} R_{20} - C_{10} C_{12} R_{13} R_{17} R_{20} - C_{10} C_{12} R_{13} R_{18} R_{20} - C_{10} C_{12} R_{16} R_{17} R_{20} - C_{10} C_{12} R_{16} R_{18} R_{20} - C_{11} C_{12} R_{15} R_{17} R_{20} - C_{11} C_{12} R_{15} R_{18} R_{20} - C_{11} C_{12} R_{16} R_{17} R_{20} - C_{11} C_{12} R_{16} R_{18} R_{20} - C_{11} C_{12} R_{17} R_{18} R_{20}\\)\n\n\n\\(b_1=- C_{10} R_{13} R_{20} - C_{10} R_{16} R_{20} - C_{11} R_{15} R_{20} - C_{11} R_{16} R_{20} - C_{11} R_{17} R_{20} - C_{12} R_{17} R_{20} - C_{12} R_{18} R_{20}\\)\n\n\n\\(b_0=- R_{20}\\)\n\n\n\nThe roots of the numerator polynomial can easily be found with SymPy. This filter has two transmission zeros, which can be found using the solve function on the numerator polynomial.\n\nnum_root_sym = solve(H_sym_num,s)\n\nThere are three solutions:\n\nMarkdown('&lt;p&gt;$z_0={:s}$&lt;/p&gt;&lt;p&gt;$z_1={:s}$&lt;/p&gt;&lt;p&gt;$z_2={:s}$&lt;/p&gt;'.format(latex(num_root_sym[0]),latex(num_root_sym[1]),latex(num_root_sym[2])))\n\n\n\\(z_0=- \\frac{- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}}{3} - \\frac{C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}}{3 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)}\\)\n\n\n\\(z_1=- \\frac{- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}}{3 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}} - \\frac{\\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}}{3} - \\frac{C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}}{3 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)}\\)\n\n\n\\(z_2=- \\frac{- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}}{3 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}} - \\frac{\\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(- \\frac{3 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right)}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{2}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}}\\right)^{3} + \\left(- \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}} + \\frac{2 \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}\\right)^{2}}}{2} - \\frac{9 \\left(C_{10} R_{13} + C_{10} R_{16} + C_{11} R_{15} + C_{11} R_{16} + C_{11} R_{17} + C_{12} R_{17} + C_{12} R_{18}\\right) \\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{2}} + \\frac{27}{2 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)} + \\frac{\\left(C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}\\right)^{3}}{\\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)^{3}}}}{3} - \\frac{C_{10} C_{11} R_{13} R_{15} + C_{10} C_{11} R_{13} R_{16} + C_{10} C_{11} R_{13} R_{17} + C_{10} C_{11} R_{15} R_{16} + C_{10} C_{12} R_{13} R_{17} + C_{10} C_{12} R_{13} R_{18} + C_{10} C_{12} R_{16} R_{17} + C_{10} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{15} R_{17} + C_{11} C_{12} R_{15} R_{18} + C_{11} C_{12} R_{16} R_{17} + C_{11} C_{12} R_{16} R_{18} + C_{11} C_{12} R_{17} R_{18}}{3 \\left(C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{15} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{18}\\right)}\\)\n\n\n\n\n\n27.3.6.3 Denominator Polynomial of \\(H_{sym}(s)\\)\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18} s^{3} + C_{10} C_{11} R_{13} R_{15} R_{17} s^{2} + C_{10} C_{11} R_{13} R_{16} R_{17} s^{2} + C_{10} C_{11} R_{15} R_{16} R_{17} s^{2} + C_{10} C_{12} R_{13} R_{17} R_{18} s^{2} + C_{10} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{10} R_{13} R_{17} s + C_{10} R_{16} R_{17} s + C_{11} C_{12} R_{15} R_{17} R_{18} s^{2} + C_{11} C_{12} R_{16} R_{17} R_{18} s^{2} + C_{11} R_{15} R_{17} s + C_{11} R_{16} R_{17} s + C_{12} R_{17} R_{18} s + R_{17}\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_3s^3+a_2s^2+a_1s+a_0\\)\nwhere \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\na3 = H_sym_denom.coeff(s**3)\na2 = H_sym_denom.coeff(s**2)\na1 = H_sym_denom.coeff(s**1)\na0 = (H_sym_denom - a1*s*1 - a2*s**2 - a3*s**3).expand()\nMarkdown('&lt;p&gt;$a_3={:s}$&lt;/p&gt;&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;\\\n    $a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a3),\n    latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_3=C_{10} C_{11} C_{12} R_{13} R_{15} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{13} R_{16} R_{17} R_{18} + C_{10} C_{11} C_{12} R_{15} R_{16} R_{17} R_{18}\\)\n\n\n\\(a_2=C_{10} C_{11} R_{13} R_{15} R_{17} + C_{10} C_{11} R_{13} R_{16} R_{17} + C_{10} C_{11} R_{15} R_{16} R_{17} + C_{10} C_{12} R_{13} R_{17} R_{18} + C_{10} C_{12} R_{16} R_{17} R_{18} + C_{11} C_{12} R_{15} R_{17} R_{18} + C_{11} C_{12} R_{16} R_{17} R_{18}\\)\n\n\n\\(a_1=C_{10} R_{13} R_{17} + C_{10} R_{16} R_{17} + C_{11} R_{15} R_{17} + C_{11} R_{16} R_{17} + C_{12} R_{17} R_{18}\\)\n\n\n\\(a_0=R_{17}\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transfer function, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nThe poles of the transfer function are:\n\nMarkdown('&lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;&lt;p&gt;$p_2={:s}$&lt;/p&gt;'.format(latex(denom_root_sym[0]),latex(denom_root_sym[1]),latex(denom_root_sym[2])))\n\n\n\\(p_0=- \\frac{1}{C_{12} R_{18}}\\)\n\n\n\\(p_1=\\frac{- C_{10} R_{13} - C_{10} R_{16} - C_{11} R_{15} - C_{11} R_{16} - \\sqrt{C_{10}^{2} R_{13}^{2} + 2 C_{10}^{2} R_{13} R_{16} + C_{10}^{2} R_{16}^{2} - 2 C_{10} C_{11} R_{13} R_{15} - 2 C_{10} C_{11} R_{13} R_{16} - 2 C_{10} C_{11} R_{15} R_{16} + 2 C_{10} C_{11} R_{16}^{2} + C_{11}^{2} R_{15}^{2} + 2 C_{11}^{2} R_{15} R_{16} + C_{11}^{2} R_{16}^{2}}}{2 C_{10} C_{11} R_{13} R_{15} + 2 C_{10} C_{11} R_{13} R_{16} + 2 C_{10} C_{11} R_{15} R_{16}}\\)\n\n\n\\(p_2=\\frac{- C_{10} R_{13} - C_{10} R_{16} - C_{11} R_{15} - C_{11} R_{16} + \\sqrt{C_{10}^{2} R_{13}^{2} + 2 C_{10}^{2} R_{13} R_{16} + C_{10}^{2} R_{16}^{2} - 2 C_{10} C_{11} R_{13} R_{15} - 2 C_{10} C_{11} R_{13} R_{16} - 2 C_{10} C_{11} R_{15} R_{16} + 2 C_{10} C_{11} R_{16}^{2} + C_{11}^{2} R_{15}^{2} + 2 C_{11}^{2} R_{15} R_{16} + C_{11}^{2} R_{16}^{2}}}{2 C_{10} C_{11} R_{13} R_{15} + 2 C_{10} C_{11} R_{13} R_{16} + 2 C_{10} C_{11} R_{15} R_{16}}\\)\n\n\n\nThe expressions for the zeros and poles of \\(H(s)\\) are rather long and not very intuitive.\n\n\n27.3.6.4 Numerical Solution\nAfter substituting the element values into the network equations, we get the following numerical equations:\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],9)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 0.000165825 v_{1} - 3.7037 \\cdot 10^{-5} v_{5} - 4.5455 \\cdot 10^{-5} v_{6} - 8.3333 \\cdot 10^{-5} v_{7}\\)\n\n\n\\(0 = I_{O2a} + 2.551 \\cdot 10^{-6} v_{2} - 2.551 \\cdot 10^{-6} v_{5}\\)\n\n\n\\(0 = - 5.0 \\cdot 10^{-7} s v_{4} + v_{3} \\cdot \\left(5.0 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(0 = - 5.0 \\cdot 10^{-7} s v_{3} - 2.0 \\cdot 10^{-9} s v_{6} + v_{4} \\cdot \\left(5.02 \\cdot 10^{-7} s + 2.1277 \\cdot 10^{-5}\\right) - 2.1277 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{7} - 3.7037 \\cdot 10^{-5} v_{1} - 2.551 \\cdot 10^{-6} v_{2} - 2.1277 \\cdot 10^{-5} v_{4} + v_{5} \\cdot \\left(2.7 \\cdot 10^{-8} s + 6.0865 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = - 2.0 \\cdot 10^{-9} s v_{4} - 4.5455 \\cdot 10^{-5} v_{1} + v_{6} \\cdot \\left(2.0 \\cdot 10^{-9} s + 4.5455 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = - 2.7 \\cdot 10^{-8} s v_{5} - 8.3333 \\cdot 10^{-5} v_{1} + v_{7} \\cdot \\left(2.7 \\cdot 10^{-8} s + 8.3333 \\cdot 10^{-5}\\right)\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\\(0 = v_{5}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{- 7.62501901595745 \\cdot 10^{36} s^{3} - 1.58125055488394 \\cdot 10^{41} s^{2} - 1.4965495647969 \\cdot 10^{44} s - 5.92359767891683 \\cdot 10^{45}}{1.60389694148936 \\cdot 10^{35} s^{3} + 3.68772736943907 \\cdot 10^{39} s^{2} + 9.98619741295937 \\cdot 10^{42} s + 4.08002901353966 \\cdot 10^{44}}\\)\n\n\n\\(v_{3} = \\frac{4.99999999999999 \\cdot 10^{24} s^{2}}{1.17340425531915 \\cdot 10^{26} s^{2} + 2.33576402321083 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}\\)\n\n\n\\(v_{4} = \\frac{4.99999999999999 \\cdot 10^{24} s^{2} + 9.99999999999999 \\cdot 10^{27} s}{1.17340425531915 \\cdot 10^{26} s^{2} + 2.33576402321083 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}\\)\n\n\n\\(v_{5} = 0.0\\)\n\n\n\\(v_{6} = \\frac{4.99999999999999 \\cdot 10^{24} s^{2} + 2.331083172147 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}{1.17340425531915 \\cdot 10^{26} s^{2} + 2.33576402321083 \\cdot 10^{30} s + 9.67117988394585 \\cdot 10^{31}}\\)\n\n\n\\(v_{7} = \\frac{250000.0}{81.0 s + 250000.0}\\)\n\n\n\nThe voltage transfer function is displayed below.\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 7.62501901595745 \\cdot 10^{36} s^{3} - 1.58125055488394 \\cdot 10^{41} s^{2} - 1.4965495647969 \\cdot 10^{44} s - 5.92359767891683 \\cdot 10^{45}}{1.60389694148936 \\cdot 10^{35} s^{3} + 3.68772736943907 \\cdot 10^{39} s^{2} + 9.98619741295937 \\cdot 10^{42} s + 4.08002901353966 \\cdot 10^{44}}\\)\n\n\nThe code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-3142.62     -3161.52\n-151.29      -491.22\n-6.59        -6.6\n\n\n\n\n27.3.6.5 Reactive Branch 3b Frequency Response\nThe amplitude and phase of the reactive branch is plotted below.\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n#gain_setting = np.array([1,25,50,75,99])/100\n#p1_value = 100e3\n\n#tf_num_coef_list = []\n#tf_denom_coef_list = []\n\n#clean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\n\n#color_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\nH = U[v2]/U[v1]\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n\n#x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n#clean_path1_mag[i] = mag\n\n# plot the results\ni=0\nax1.semilogx(w/(2*np.pi), mag,'-k',label='mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':k',label='phase')  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\nax1.set_ylim((0,40))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the amplitude response, there is a lot of gain in this path since \\(R_{20}\\) is relatively large compared to the impedance of the other components connected to the non-inverting input of \\(U_{2A}\\). One thing to keep in mind is that the effect of \\(C_{13}\\) is not included in the plot above. The zero created at 500 Hz by \\(C_{13}\\) creates a dominating low pass response, which makes me wonder how much do the components \\(C_{11}\\) and \\(C_{12}\\) contribute to the overall tone created by the pedal.\n\n\n\n27.3.7 Reactive Branch 4\nReactive branch 4 is the circuit path following the diodes, \\(D_2\\) and \\(D_3\\) and shown in Figure 25.21. The diodes have been commented out in this analysis and \\(V_1\\) has been turned off and \\(V_2\\) is set to a value of 1. The source \\(V_2\\) represents the signal after the diode shaping. In Figure 27.3 the components from reactive paths 3 and 4 are connected at the non-inverting terminals of \\(U_{2A}\\). This makes the netlist rather long and the number of equations makes a symbolic solution impracticable. Notice that \\(C_{13}\\) is not included in the netlist, which is noted below.\n\nReactive_branch_3_4_net_list = '''\n* Reactive_branch_3&4.asc\nV1 1 0 0\nV2 6 0 1\nR5 1 3 5.1e3\nR8 3 0 1.5e3\nC4 1 3 68e-9\nC6 3 4 390e-9\nR9 4 0 1e3\nRp1b2 3 5 50e3\nRp1a2 5 0 50e3\nR13 8 7 1e3\nC11 9 11 2.2e-9\nR15 11 5 22e3\nR17 10 5 27e3\nR18 12 5 12e3\nC12 10 12 27e-9\nR16 10 9 47e3\n*R20 2 10 100e3\nR20 2 10 393e3\n*C13 2 10 820e-12\nO2a 10 0 2\n*D2 0 8 1N34A\n*D3 8 0 1N34A\nC9 6 7 1e-6\nC10 9 8 1e-6\n'''\n\nThe following code takes the netlist and builds and displays the MNA equations.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Reactive_branch_3_4_net_list)\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\left(C_{4} s + \\frac{1}{R_{5}}\\right) + v_{3} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right)\\)\\(0 = I_{O2a} - \\frac{v_{10}}{R_{20}} + \\frac{v_{2}}{R_{20}}\\)\\(0 = - C_{6} s v_{4} + v_{1} \\left(- C_{4} s - \\frac{1}{R_{5}}\\right) + v_{3} \\left(C_{4} s + C_{6} s + \\frac{1}{Rp1b2} + \\frac{1}{R_{8}} + \\frac{1}{R_{5}}\\right) - \\frac{v_{5}}{Rp1b2}\\)\\(0 = - C_{6} s v_{3} + v_{4} \\left(C_{6} s + \\frac{1}{R_{9}}\\right)\\)\\(0 = v_{5} \\cdot \\left(\\frac{1}{Rp1b2} + \\frac{1}{Rp1a2} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{3}}{Rp1b2} - \\frac{v_{12}}{R_{18}} - \\frac{v_{10}}{R_{17}} - \\frac{v_{11}}{R_{15}}\\)\\(0 = C_{9} s v_{6} - C_{9} s v_{7} + I_{V2}\\)\\(0 = - C_{9} s v_{6} + v_{7} \\left(C_{9} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{8}}{R_{13}}\\)\\(0 = - C_{10} s v_{9} + v_{8} \\left(C_{10} s + \\frac{1}{R_{13}}\\right) - \\frac{v_{7}}{R_{13}}\\)\\(0 = - C_{10} s v_{8} - C_{11} s v_{11} + v_{9} \\left(C_{10} s + C_{11} s + \\frac{1}{R_{16}}\\right) - \\frac{v_{10}}{R_{16}}\\)\\(0 = - C_{12} s v_{12} + v_{10} \\left(C_{12} s + \\frac{1}{R_{20}} + \\frac{1}{R_{17}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{2}}{R_{20}} - \\frac{v_{5}}{R_{17}} - \\frac{v_{9}}{R_{16}}\\)\\(0 = - C_{11} s v_{9} + v_{11} \\left(C_{11} s + \\frac{1}{R_{15}}\\right) - \\frac{v_{5}}{R_{15}}\\)\\(0 = - C_{12} s v_{10} + v_{12} \\left(C_{12} s + \\frac{1}{R_{18}}\\right) - \\frac{v_{5}}{R_{18}}\\)\\(V_{1} = v_{1}\\)\\(V_{2} = v_{6}\\)\\(0 = v_{10}\\)\n\n\nTurn the free symbols into SymPy variables and load the element values.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n27.3.7.1 Numerical Solution for P1 at 50%\nSubstitute the component values into the network equations and display the numerical equations.\n\nequ_N = NE_sym.subs(element_values)\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(round_expr(equ_N.lhs[i],7)))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.0001961\\right) + v_{3} \\left(- 1.0 \\cdot 10^{-7} s - 0.0001961\\right)\\)\n\n\n\\(0 = I_{O2a} - 2.5 \\cdot 10^{-6} v_{10} + 2.5 \\cdot 10^{-6} v_{2}\\)\n\n\n\\(0 = - 4.0 \\cdot 10^{-7} s v_{4} + v_{1} \\left(- 1.0 \\cdot 10^{-7} s - 0.0001961\\right) + v_{3} \\cdot \\left(5.0 \\cdot 10^{-7} s + 0.0008827\\right) - 2.0 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = - 4.0 \\cdot 10^{-7} s v_{3} + v_{4} \\cdot \\left(4.0 \\cdot 10^{-7} s + 0.001\\right)\\)\n\n\n\\(0 = - 3.7 \\cdot 10^{-5} v_{10} - 4.55 \\cdot 10^{-5} v_{11} - 8.33 \\cdot 10^{-5} v_{12} - 2.0 \\cdot 10^{-5} v_{3} + 0.0002058 v_{5}\\)\n\n\n\\(0 = I_{V2} + 1.0 \\cdot 10^{-6} s v_{6} - 1.0 \\cdot 10^{-6} s v_{7}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{6} + v_{7} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right) - 0.001 v_{8}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{9} - 0.001 v_{7} + v_{8} \\cdot \\left(1.0 \\cdot 10^{-6} s + 0.001\\right)\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-6} s v_{8} - 2.13 \\cdot 10^{-5} v_{10} + v_{9} \\cdot \\left(1.0 \\cdot 10^{-6} s + 2.13 \\cdot 10^{-5}\\right)\\)\n\n\n\\(0 = 6.09 \\cdot 10^{-5} v_{10} - 2.5 \\cdot 10^{-6} v_{2} - 3.7 \\cdot 10^{-5} v_{5} - 2.13 \\cdot 10^{-5} v_{9}\\)\n\n\n\\(0 = 4.55 \\cdot 10^{-5} v_{11} - 4.55 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = 8.33 \\cdot 10^{-5} v_{12} - 8.33 \\cdot 10^{-5} v_{5}\\)\n\n\n\\(0 = v_{1}\\)\n\n\n\\(1.0 = v_{6}\\)\n\n\n\\(0 = v_{10}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_2\\), and the Op Amp’s output terminal. The unknown currents, \\(I_{V1}\\) and \\(I_{O1}\\), are not displayed. The node voltages are:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    if str(i)[0] == 'v': # only display the node voltages\n        temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 0.0\\)\n\n\n\\(v_{2} = \\frac{- 1.96394441888298 \\cdot 10^{71} s^{5} - 7.60825164075479 \\cdot 10^{75} s^{4} - 5.90607987153688 \\cdot 10^{79} s^{3} - 1.18301509344067 \\cdot 10^{83} s^{2} - 6.89566385064667 \\cdot 10^{85} s}{1.10336500111661 \\cdot 10^{70} s^{5} + 5.26456182674577 \\cdot 10^{74} s^{4} + 6.46095251106143 \\cdot 10^{78} s^{3} + 1.43698004458909 \\cdot 10^{82} s^{2} + 9.04296553120415 \\cdot 10^{84} s + 3.50924368989652 \\cdot 10^{86}}\\)\n\n\n\\(v_{3} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 1.6734375 \\cdot 10^{60} s^{3} + 2.34375 \\cdot 10^{63} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{4} = \\frac{2.9615625 \\cdot 10^{56} s^{4} + 9.14062499999999 \\cdot 10^{59} s^{3}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{5} = \\frac{1.00693125 \\cdot 10^{54} s^{5} + 3.35690238970588 \\cdot 10^{58} s^{4} + 1.275328125 \\cdot 10^{62} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{6} = 1.0\\)\n\n\n\\(v_{7} = \\frac{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29627373138023 \\cdot 10^{59} s^{4} + 2.81149214573178 \\cdot 10^{63} s^{3} + 6.20412190793865 \\cdot 10^{66} s^{2} + 3.81322450115202 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{8} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19836922372969 \\cdot 10^{59} s^{4} + 2.74080119229803 \\cdot 10^{63} s^{3} + 6.06858479379818 \\cdot 10^{66} s^{2} + 3.73660601392261 \\cdot 10^{69} s + 7.66184872294075 \\cdot 10^{70}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{9} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 2.19578429076426 \\cdot 10^{59} s^{4} + 2.73101074153298 \\cdot 10^{63} s^{3} + 5.99789384036444 \\cdot 10^{66} s^{2} + 3.60106889978214 \\cdot 10^{69} s}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{10} = 0.0\\)\n\n\n\\(v_{11} = \\frac{4.559533875 \\cdot 10^{54} s^{5} + 1.46177548394608 \\cdot 10^{59} s^{4} + 4.04388334558824 \\cdot 10^{62} s^{3} + 2.77738425925926 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\\(v_{12} = \\frac{3.1078125 \\cdot 10^{57} s^{4} + 9.40160845588234 \\cdot 10^{61} s^{3} + 1.0344669117647 \\cdot 10^{65} s^{2}}{4.81802717154256 \\cdot 10^{54} s^{5} + 2.29885866434566 \\cdot 10^{59} s^{4} + 2.82128259649683 \\cdot 10^{63} s^{3} + 6.27481286137239 \\cdot 10^{66} s^{2} + 3.94876161529248 \\cdot 10^{69} s + 1.53236974458815 \\cdot 10^{71}}\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v6]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{- 1.96394441888298 \\cdot 10^{71} s^{5} - 7.60825164075479 \\cdot 10^{75} s^{4} - 5.90607987153688 \\cdot 10^{79} s^{3} - 1.18301509344067 \\cdot 10^{83} s^{2} - 6.89566385064667 \\cdot 10^{85} s}{1.10336500111661 \\cdot 10^{70} s^{5} + 5.26456182674577 \\cdot 10^{74} s^{4} + 6.46095251106143 \\cdot 10^{78} s^{3} + 1.43698004458909 \\cdot 10^{82} s^{2} + 9.04296553120415 \\cdot 10^{84} s + 3.50924368989652 \\cdot 10^{86}}\\)\n\n\nThe SciPy function, TransferFunction, is used to represent the system as the continuous-time transfer function. The code below extracts the numerator and denominator polynomials from the voltage transfer function. Then coefficients of the terms are used to build a SciPy transfer function object.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n\n\n27.3.7.2 Pole Zero Plot\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.2f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.2f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  -----------\n-4631.99     -4629.79\n-1110.36     -2545.69\n-243         -231.62\n-180.26      -180.17\n0            -6.6\n\n\n\n\n27.3.7.3 Pole/Zero Locus Plot versus P1 value\nThere are six zeros and six poles. The code below solves the network equations and finds the numerator and denominator roots of the transfer function for various rotation positions of \\(P_1\\).\n\np1_value = 100e3\nnum_roots = []\ndenom_roots = []\nfor i in np.linspace(1,99,20)/100:\n    element_values[Rp1a2] = p1_value - i*p1_value\n    element_values[Rp1b2] = i*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v6]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)    \n    sys_tf = signal.TransferFunction(a,b)\n    \n    num_roots.append(np.roots(sys_tf.num))\n    denom_roots.append(np.roots(sys_tf.den))\n\nThe range of values taken on by the zeros as \\(P_1\\) is rotated are printed below.\n\n# put the zeros into an array\nz0_locus = np.zeros(len(np.array(num_roots)))\nz1_locus = np.zeros(len(np.array(num_roots)))\nz2_locus = np.zeros(len(np.array(num_roots)))\nz3_locus = np.zeros(len(np.array(num_roots)))\nz4_locus = np.zeros(len(np.array(num_roots)))\n\nfor i in range(len(np.array(num_roots))):\n    z0_locus[i] = -np.array(num_roots)[i][0]    \n    z1_locus[i] = -np.array(num_roots)[i][1]        \n    z2_locus[i] = -np.array(num_roots)[i][2]    \n    z3_locus[i] = -np.array(num_roots)[i][3]  \n    z4_locus[i] = -np.array(num_roots)[i][4]    \n\nprint(f'z0 range as a function of P1: {z0_locus.min()/(2*np.pi)/1e3:.3f} to {z0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z1 range as a function of P1: {z1_locus.min()/(2*np.pi)/1e3:.3f} to {z1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z2 range as a function of P1: {z2_locus.min()/(2*np.pi)/1e3:.3f} to {z2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z3 range as a function of P1: {z3_locus.min()/(2*np.pi)/1e3:.3f} to {z3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'z4 range as a function of P1: {z4_locus.min()/(2*np.pi)/1e3:.3f} to {z4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\nz0 range as a function of P1: 4.611 to 5.652 kHz\nz1 range as a function of P1: 1.111 to 2.529 kHz\nz2 range as a function of P1: 0.243 to 0.467 kHz\nz3 range as a function of P1: 0.179 to 0.181 kHz\nz4 range as a function of P1: -0.000 to -0.000 kHz\n\n\nThe plot provides a visual indication of how the zeros change in frequency as a function of the rotational position of \\(P_1\\).\n\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z0_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_0')\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z1_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_1')\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z2_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_2')\nplt.plot(np.linspace(1,99,len(np.array(num_roots))),z3_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='z_3')\n\nplt.ylim((0,6))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the zeros are relatively constant versus \\(P_1\\) for most of the rotational range.\nThe range of values for each of the poles as function of \\(P_1\\) are printed below.\n\n# put the poles into an array\np0_locus = np.zeros(len(np.array(denom_roots)))\np1_locus = np.zeros(len(np.array(denom_roots)))\np2_locus = np.zeros(len(np.array(denom_roots)))\np3_locus = np.zeros(len(np.array(denom_roots)))\np4_locus = np.zeros(len(np.array(denom_roots)))\n\nfor i in range(len(np.array(denom_roots))):\n    p0_locus[i] = -np.array(denom_roots)[i][0]    \n    p1_locus[i] = -np.array(denom_roots)[i][1]       \n    p2_locus[i] = -np.array(denom_roots)[i][2]      \n    p3_locus[i] = -np.array(denom_roots)[i][3]      \n    p4_locus[i] = -np.array(denom_roots)[i][4]      \n\nprint(f'p0 range as a function of P1: {p0_locus.min()/(2*np.pi)/1e3:.3f} to {p0_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p1 range as a function of P1: {p1_locus.min()/(2*np.pi)/1e3:.3f} to {p1_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p2 range as a function of P1: {p2_locus.min()/(2*np.pi)/1e3:.3f} to {p2_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p3 range as a function of P1: {p3_locus.min()/(2*np.pi)/1e3:.3f} to {p3_locus.max()/(2*np.pi)/1e3:.3f} kHz')\nprint(f'p4 range as a function of P1: {p4_locus.min()/(2*np.pi)/1e3:.3f} to {p4_locus.max()/(2*np.pi)/1e3:.3f} kHz')\n\np0 range as a function of P1: 4.611 to 5.043 kHz\np1 range as a function of P1: 2.546 to 3.046 kHz\np2 range as a function of P1: 0.232 to 0.455 kHz\np3 range as a function of P1: 0.179 to 0.181 kHz\np4 range as a function of P1: 0.007 to 0.007 kHz\n\n\nThe plot provides a visual indication of how the poles change in frequency as a function of the rotational position of \\(P_1\\).\n\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p0_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_0')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p1_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_1')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p2_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_2')\nplt.plot(np.linspace(1,99,len(np.array(denom_roots))),p3_locus/(2*np.pi)/1e3,'x-', markerfacecolor='none',label='p_3')\n\nplt.ylim((0,6))\nplt.legend(loc='upper left')\nplt.title('Gain control pole & zero frequency plot vs gain rotation %')\nplt.xlabel('Gain rotation percentage')\nplt.ylabel('pole and zero frequency, kHz')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above, the poles are relatively constant versus \\(P_1\\) for most of the rotational range.\n\n\n27.3.7.4 Reactive Branch 4 Frequency Response\nThe frequency response of reactive branch 4 is plotted below. The gain setting is a percent of full scale.\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\ncolor_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\ngain_setting = np.array([1,25,50,75,99])/100\np1_value = 100e3\n\n#tf_num_coef_list = []\n#tf_denom_coef_list = []\n\n#clean_path1_mag = np.zeros((len(gain_setting),len(x_axis)))\n\n#color_list = ['tab:blue','tab:red','tab:green','tab:orange','k']\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfor i in range(len(gain_setting)):\n    element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    #element_values[Rp1a2] = p1_value - gain_setting[i]*p1_value\n    #element_values[Rp1b2] = gain_setting[i]*p1_value\n    \n    NE = NE_sym.subs(element_values)\n    U = solve(NE,X)\n    H = U[v2]/U[v6]\n    num, denom = fraction(H) #returns numerator and denominator\n\n    # convert symbolic to NumPy polynomial\n    a = np.array(Poly(num, s).all_coeffs(), dtype=float)\n    b = np.array(Poly(denom, s).all_coeffs(), dtype=float)\n    #tf_num_coef_list.append(a)\n    #tf_denom_coef_list.append(b)\n    \n    #x = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n    w, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n    #clean_path1_mag[i] = mag\n    \n    # plot the results.  \n    ax1.semilogx(w/(2*np.pi), mag,'-',color=color_list[i],label='mag: {:.0f}%'.format(gain_setting[i]*100))    # magnitude plot\n    ax2.semilogx(w/(2*np.pi), phase,':',color=color_list[i],label='phase: {:.0f}%'.format(gain_setting[i]*100))  # phase plot\n\n# highlight the guitar audio band, 80 to 8kHz\nplt.axvspan(80, 8e3, color='y', alpha=0.3) \n\n#ax1.set_ylim((0,15))\n\n# position legends outside the graph\nax1.legend(bbox_to_anchor=(1.6,1)) # magnitude legend position: relative (horizontal position, vertical position) \nax2.legend(bbox_to_anchor=(1.6,0.5)) # phase legend position:\n\n#ax1.legend(loc='lower left')\n#ax2.legend(loc='lower right')\nax1.grid()\nplt.title('Magnitude and phase response')\n#plt.savefig('reactive_path_4_bode.png')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that influence of the rotation of \\(P_1\\) has a large effect on the amplitude response at \\(P_1\\) rotational positions of 50 and 75%. However when \\(C_{13}\\) is included in the analysis, the zero created at about 500 Hz greatly influences the response along this path as shown in the plot below.\n\n\n\nReactive path 4 with \\(C_{13}\\) included in the netlist.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Klon Centaur, Part 3</span>"
    ]
  },
  {
    "objectID": "Klon Centaur part 3v1.html#summary",
    "href": "Klon Centaur part 3v1.html#summary",
    "title": "27  Klon Centaur, Part 3",
    "section": "27.4 Summary",
    "text": "27.4 Summary\nThe Klon Centaur is a famous, highly sought-after and legendary guitar pedal. The pedal was adopted by some notable players (Jeff Beck, Mark Tremonti, John Mayer, Andy Summers, Peter Frampton, Jason Isbell, James Hetfield, Joe Perry, Britt Daniel, David Grissom, Adam Hann, Joe Bonamassa). The limited initial production and long wait times led to its rarity and high demand.\nWorking on this series of JupyterLab pages has given me the opportunity to to learn a few things about electric guitars and pedals. If I were to continue farther down this path, the next step would be to build some breadboard circuits and verify my analysis by comparing calculated with measured results.\nHere are a few of my observations:\n\nClean path 1 not contributing much and signals on this path appear to be covered by the clean path 2 and the diode path.\nReactive branches 3 and 4 are unusual filters\n\nBranch 3 provides 20 dB of emphasis across the guitar audio band\nBranch 4 provides 3 to 4 dB of emphasis across the guitar audio band\n\nBoth seem superfluous and appear to be dominated by \\(R_{20}\\) and \\(C_{13}\\)\n\n\n\n\n\n\nBasso, Christophe. 2016. “Introduction to Fast Analytical Techniques: Application to Small-Signal Modeling.” 2016. https://www.powersimtof.com/Downloads/PPTs/Chris%20Basso%20APEC%20seminar%202016.pdf.\n\n\nMiddlebrook, R. D., V. Vorperian, and J. Lindal. 1998. “The n Extra Element Theorem.” IEEE Transactions on Circuits and Systems I: Fundamental Theory and Applications 45 (9): 919–35. https://doi.org/10.1109/81.721258.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Klon Centaur, Part 3</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html",
    "href": "Wien bridge oscillator.html",
    "title": "28  Wien Bridge Oscillator",
    "section": "",
    "text": "28.1 Introduction\nLast update: 29 July 2025\nThis chapter is about a type of electronic oscillator called a Wien Bridge Oscillator. An electronic oscillator is a circuit that converts a direct current power source into an alternating current signal. Essentially, it generates a periodic, repetitive electrical signal. A Wien Bridge oscillator uses a frequency selective bridge circuit as the topology for the oscillator. The bridge circuit was originally developed by Max Wien in 1891 for impedance measurements. The bridge circuit consists of four resistors and two capacitors.\nStudying electronic oscillators is fundamental for anyone wanting to learn about electronics. Oscillators are examples of circuits that utilize positive feedback. Many oscillators rely on resonant circuits (LC tanks or crystal resonators) to determine their frequency. Studying oscillators introduces concepts like frequency stability, phase noise and harmonic distortion, which are crucial for designing high-performance electronic systems. Understanding different oscillator types (RC, LC, crystal, VCOs, etc.) helps in selecting the right component for a specific application based on requirements for frequency range, stability, cost and power consumption.\nThe use of MNA and Python can enable easy symbolic and numerical analysis of Wien Bridge oscillators.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#introduction",
    "href": "Wien bridge oscillator.html#introduction",
    "title": "28  Wien Bridge Oscillator",
    "section": "",
    "text": "Figure 28.1: Schematic of a Wien Bridge Oscillator drawn in a bridge configuration.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#circuit-description",
    "href": "Wien bridge oscillator.html#circuit-description",
    "title": "28  Wien Bridge Oscillator",
    "section": "28.2 Circuit Description",
    "text": "28.2 Circuit Description\nThe circuit in Figure 28.1 is a Wien Bridge oscillator drawn to emphasize the bridge topology. A bridge circuit is a type of electrical circuit topology where two circuit branches are “bridged” by a third branch connected between them at an intermediate point. It’s often visualized as an “H” or diamond shape. A bridge circuit essentially consists of two parallel voltage dividers sharing a common power source. A third branch, often containing a galvanometer (a sensitive current meter) or a voltmeter, connects the midpoints of these two voltage dividers. The key to many bridge circuits is the “balance” or “null” condition. When the bridge is balanced, the voltage potential at the midpoints of the two parallel branches is equal, meaning no current flows through the bridging branch (or the voltage difference across it is zero).\nThe element values in the schematic have all been set to 1; in Section 28.5, the element values will be determined. The components \\(R_1\\), \\(R_2\\) and \\(C_1\\) and \\(C_2\\) do not need to be of equal value, but if they are, some of the analysis is simplified. The circuit above is missing the amplitude stabilizing elements that are usually included in real world implementations of the Wien Bridge oscillator. See Section 28.6 for a version of an actual implementation.\nThe following Python modules are used in this JupyterLab notebook.\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\nfrom tabulate import tabulate\ninit_printing()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#network-equations",
    "href": "Wien bridge oscillator.html#network-equations",
    "title": "28  Wien Bridge Oscillator",
    "section": "28.3 Network Equations",
    "text": "28.3 Network Equations\nThe netlist for the schematic above was generated by LTSpice and copied into the cell below.\n\nWien_bridge_v0_net_list = '''\n* Wien bridge oscillator v0.asc\nO1 4 2 1\nR4 4 1 1\nR1 0 2 1\nR3 0 4 1\nR2 2 3 1\nC2 3 1 1\nC1 0 2 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Wien_bridge_v0_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = - C_{2} s v_{3} + I_{O1} + v_{1} \\left(C_{2} s + \\frac{1}{R_{4}}\\right) - \\frac{v_{4}}{R_{4}}\\)\\(0 = v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\)\\(0 = - C_{2} s v_{1} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\)\\(0 = v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{3}}\\right) - \\frac{v_{1}}{R_{4}}\\)\\(0 = - v_{2} + v_{4}\\)\n\n\nThere is no independent voltage or current source in the circuit, so all the node voltages are zero.\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#open-loop-analysis",
    "href": "Wien bridge oscillator.html#open-loop-analysis",
    "title": "28  Wien Bridge Oscillator",
    "section": "28.4 Open Loop Analysis",
    "text": "28.4 Open Loop Analysis\nThe analysis presented here follows the same steps that can be found in Budak (1974). While most sophisticated control systems are closed-loop (meaning they use feedback), open-loop analysis is incredibly important for several reasons. The open-loop transfer function (\\(G(s)H(s)\\) or just \\(G(s)\\) if \\(H(s)=1\\)) represents the inherent dynamics of the system you are trying to control. By analyzing the open-loop circuit you can understand how the circuit responds to inputs without any corrective action from a feedback loop. This tells you about its natural gain, phase shift, time delays and stability characteristics in isolation. It helps in identifying poles and zeros that are inherent to the system.\nThe circuit shown below is the open loop Wien Bridge circuit. \\(V_1\\) is the output of the Op Amp that drives the frequency selective parts of the oscillator and the value of \\(V_1\\) is K. The element values have been set to 1 because we are doing a symbolic solution to start with.\n\n\n\n\n\n\nFigure 28.2: Schematic used for loop calculations\n\n\n\nThe netlist below was exported from LTSpice.\n\nWien_bridge_loop_gain_net_list = '''\n* Wien bridge loop gain.asc\nR2 3 2 1\nR1 2 0 1\nC1 2 0 1\nC2 1 3 1\nV1 1 0 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Wien_bridge_loop_gain_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = C_{2} s v_{1} - C_{2} s v_{3} + I_{V1}\\)\\(0 = v_{2} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}}\\)\\(0 = - C_{2} s v_{1} + v_{3} \\left(C_{2} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{2}}{R_{2}}\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\n\n28.4.0.1 Symbolic solution\nThe network equations for the circuit in Figure 28.2 can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the node voltages and dependent currents using symbolic notation.\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{2} R_{1} V_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\\(v_{3} = \\frac{C_{1} C_{2} R_{1} R_{2} V_{1} s^{2} + C_{2} R_{1} V_{1} s + C_{2} R_{2} V_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\\(I_{V1} = \\frac{- C_{1} C_{2} R_{1} V_{1} s^{2} - C_{2} V_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C_{2} R_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1}\\)\n\n\nThe numerator is a first order polynomial and the denominator is a second order polynomial. Generally, the order of the dominator is equal to the number of reactive elements in the circuit; sometimes roots of the numerator will exactly cancel with a root of the denominator polynomial. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym,s) #returns numerator and denominator\n\n\n\n28.4.0.2 Numerator Polynomial of \\(H_{sym}(s)\\)\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num)))\n\n\\(N(s)=C_{2} R_{1} s\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_2s^{2}+b_1s+b_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb2 = H_sym_num.coeff(s**2)\nb1 = H_sym_num.coeff(s**1)\nb0 = (H_sym_num - b1*s*1 - b2*s**2).expand()\n\nMarkdown('&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$&lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_2=0\\)\n\n\n\\(b_1=C_{2} R_{1}\\)\n\n\n\\(b_0=0\\)\n\n\n\nThe roots of the numerator polynomial can easily be found by inspection. There is only one root and the value is zero.\n\n\n28.4.0.3 Denominator Polynomial of \\(H_{sym}(s)\\)\nThe denominator polynomial of the transfer function is called the characteristic polynomial. The roots of the denominator, also called poles of the system, determine the system’s stability. If any of these roots have a positive real part, the system is unstable, meaning its output will grow unbounded. The roots also influence how the system responds to changes in input (the transient response). They affect things like how quickly the system settles to a new state, whether it oscillates, and the damping of those oscillations. Each root of the characteristic polynomial corresponds to a natural mode of the system.\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom)))\n\n\\(D(s)=C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_3\\), \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_2s^2+a_1s+a_0\\)\nwhere \\(a_2\\), \\(a_1\\) and \\(a_0\\) are:\n\na2 = H_sym_denom.coeff(s**2)\na1 = H_sym_denom.coeff(s**1)\na0 = (H_sym_denom - a1*s*1 - a2*s**2).expand()\nMarkdown('&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;$a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_2=C_{1} C_{2} R_{1} R_{2}\\)\n\n\n\\(a_1=C_{1} R_{1} + C_{2} R_{1} + C_{2} R_{2}\\)\n\n\n\\(a_0=1\\)\n\n\n\nThe roots of the denominator polynomial, which are the poles of the transfer function, can be found with SymPy.\n\ndenom_root_sym = solve(H_sym_denom,s)\n\nMarkdown('There are {:d} poles, which are: &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(denom_root_sym),latex(denom_root_sym[0]),latex(denom_root_sym[1])))\n\nThere are 2 poles, which are:\n\n\\(p_0=\\frac{- C_{1} R_{1} - C_{2} R_{1} - C_{2} R_{2} - \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\\(p_1=\\frac{- C_{1} R_{1} - C_{2} R_{1} - C_{2} R_{2} + \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\n\\(H(s)\\) is a band pass function. We can find \\(\\omega_n\\) and Q.\n\nomega_n = sqrt(a0/a2)\nMarkdown('The natural frequency is: ${:s}$'.format(latex(omega_n)))\n\nThe natural frequency is: \\(\\sqrt{\\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\n\nBW = (a1/a2)\nMarkdown('The bandwidth is: ${:s}$'.format(latex(BW)))\n\nThe bandwidth is: \\(\\frac{C_{1} R_{1} + C_{2} R_{1} + C_{2} R_{2}}{C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\nquality_factor = omega_n/BW\nMarkdown('The Q is: ${:s}$'.format(latex(quality_factor)))\n\nThe Q is: \\(\\frac{C_{1} C_{2} R_{1} R_{2} \\sqrt{\\frac{1}{C_{1} C_{2} R_{1} R_{2}}}}{C_{1} R_{1} + C_{2} R_{1} + C_{2} R_{2}}\\)\n\n\nAccording to Budak (1974), the 3 dB bandwidth of the loop gain is more than \\(2\\omega_n\\). Most often R’s and C’s are made the same so \\(BW=3\\omega_n\\). Accordingly, the frequency selectivity is somewhat poor.\n\n\n28.4.1 Characteristic Equation\nThe Wien bridge oscillator has positive feedback provided by the RC components \\(R_1\\), \\(R_2\\), \\(C_1\\) and \\(C_2\\). Including K as the gain term, the characteristic equation becomes \\(1 - KH(s) = 0\\). The roots of the characteristic equation dictate the circuit’s stability. For stable positive feedback, oscillation requires the roots of \\(1 - G(s)H(s) = 0\\) to have zero real parts.\nWe can define a new symbol, K, to be the gain of the Op Amp determined by \\(R_3\\) and \\(R_4\\) in Figure 28.1.\n\nK = symbols('K')\n\n\nMarkdown('The characteristic equation is: ${:s}$'.format(latex(1-K*H_sym)))\n\nThe characteristic equation is: \\(- \\frac{C_{2} K R_{1} s}{C_{1} C_{2} R_{1} R_{2} s^{2} + C_{1} R_{1} s + C_{2} R_{1} s + C_{2} R_{2} s + 1} + 1\\)\n\n\nWe can solve for the roots of the characteristic equation.\n\nroots_char_equ = solve(1-K*H_sym,s)\nMarkdown('There are {:d} roots, which are: &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(roots_char_equ),latex(roots_char_equ[0]),latex(roots_char_equ[1])))\n\nThere are 2 roots, which are:\n\n\\(p_0=\\frac{- C_{1} R_{1} + C_{2} K R_{1} - C_{2} R_{1} - C_{2} R_{2} - \\sqrt{C_{1}^{2} R_{1}^{2} - 2 C_{1} C_{2} K R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} K^{2} R_{1}^{2} - 2 C_{2}^{2} K R_{1}^{2} - 2 C_{2}^{2} K R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\\(p_1=\\frac{- C_{1} R_{1} + C_{2} K R_{1} - C_{2} R_{1} - C_{2} R_{2} + \\sqrt{C_{1}^{2} R_{1}^{2} - 2 C_{1} C_{2} K R_{1}^{2} + 2 C_{1} C_{2} R_{1}^{2} - 2 C_{1} C_{2} R_{1} R_{2} + C_{2}^{2} K^{2} R_{1}^{2} - 2 C_{2}^{2} K R_{1}^{2} - 2 C_{2}^{2} K R_{1} R_{2} + C_{2}^{2} R_{1}^{2} + 2 C_{2}^{2} R_{1} R_{2} + C_{2}^{2} R_{2}^{2}}}{2 C_{1} C_{2} R_{1} R_{2}}\\)\n\n\n\nFor the oscillator to run and be stable, the roots need to be imaginary with a real part equal to zero. From the expressions for the roots, we can see that the real part of the roots will be zero if \\(-C_1R_1 + C_2KR_1 - C_2R_1 - C_2R_2=0\\). This is called the critical value, \\(K_c\\). If \\(K \\lt K_c\\), the roots are in the left hand complex frequency plane and oscillations will not be sustained. If \\(K \\gt K_c\\), the oscillations will grow and the amplitude will exceed the dynamic range of the Op Amp. Maintaining the exact value of \\(K_c\\) is not possible in the real world and the circuit in Figure 28.3 is one example of a realistic circuit.\nWe can solve this expression to determine the component values to make the real part zero.\n\nMarkdown('Solving for K, we get: K = ${:s}$'.format(latex(solve(-C1*R1 + C2*K*R1 - C2*R1 - C2*R2,K))))\n\nSolving for K, we get: K = \\(\\left[ \\frac{C_{1}}{C_{2}} + 1 + \\frac{R_{2}}{R_{1}}\\right]\\)\n\n\nIf we substitute the expression for K back into the characteristic equation we get a set of imaginary poles.\n\nroots_char_equ = solve((1-K*H_sym).subs({K:1+R2/R1+C1/C2}),s)\nMarkdown('There are {:d} roots, which are: &lt;p&gt;$p_0={:s}$&lt;/p&gt;&lt;p&gt;$p_1={:s}$&lt;/p&gt;'.format(len(roots_char_equ),latex(roots_char_equ[0]),latex(roots_char_equ[1])))\n\nThere are 2 roots, which are:\n\n\\(p_0=- \\sqrt{- \\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\n\\(p_1=\\sqrt{- \\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\n\nThus, with the gain, \\(K=1+R_2/R_1+C_1/C_2\\), we get two imaginary roots.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#sec-design-example",
    "href": "Wien bridge oscillator.html#sec-design-example",
    "title": "28  Wien Bridge Oscillator",
    "section": "28.5 Design Example",
    "text": "28.5 Design Example\nFor the example design, we want the Wien Bridge oscillator to have a frequency of 1kHz. If we let \\(R=R_1=R_2\\) and \\(C_1 = C_2 = 0.1\\mu F\\), we can solve for \\(R\\).\nFirst we declare a new symbol, \\(R\\).\n\nR = symbols('R')\n\nThe expression for the natural frequency was obtained from the characteristic polynomial.\n\nMarkdown('The expression for the natural frequency is: $\\omega_n={:s}$'.format(latex(omega_n)))\n\nThe expression for the natural frequency is: \\(\\omega_n=\\sqrt{\\frac{1}{C_{1} C_{2} R_{1} R_{2}}}\\)\n\n\nAfter making some substitutions, we can solve for \\(R\\); we get the numerical value for R.\n\nR = solve(omega_n.subs({C1:0.1e-6,C2:0.1e-6,R1:R,R2:R})-2*np.pi*1e3,R)[1]\nMarkdown('R = ${:s}$'.format(latex(R)))\n\nR = \\(1591.54943091895\\)\n\n\nWe can update the element values as follows:\n\nelement_values[R1] = R\nelement_values[R2] = R\nelement_values[C1] = 0.1e-6\nelement_values[C2] = 0.1e-6\n\nIf we substitute these values into the expression for K, we get:\n\nMarkdown('K = ${:s}$'.format(latex((1+C1/C2+R2/R1).subs(element_values))))\n\nK = \\(3.0\\)\n\n\nK, which is the gain of the Op Amp is \\(K=1+R_4/R_3\\). If we choose \\(R_3=1k\\Omega\\) and solve for \\(R_4\\), we get:\n\nK = 1+R4/R3\nsolve(K.subs({R3:1e3})-3,R4)[0]\nMarkdown('R4 = ${:s}$'.format(latex(solve(K.subs({R3:1e3})-3,R4)[0])))\n\nR4 = \\(2000.0\\)\n\n\nWe can update the element values for \\(R_3\\) and \\(R_4\\).\n\nelement_values[R3] = 1e3\nelement_values[R4] = 2e3\n\n\n28.5.1 Numerical Solution\nThe network equations can be numerically solved when the element values are included in the calculations.\n\nequ_N = NE_sym.subs(element_values)\n\nWe get the following numerical network equations:\n\ntemp = ''\nfor i in range(shape(equ_N.lhs)[0]):\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(equ_N.rhs[i]),\n        latex(equ_N.lhs[i]))\n\nMarkdown(temp)\n\n\n\\(0 = I_{V1} + 1.0 \\cdot 10^{-7} s v_{1} - 1.0 \\cdot 10^{-7} s v_{3}\\)\n\n\n\\(0 = v_{2} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.00125663706143592\\right) - 0.000628318530717959 v_{3}\\)\n\n\n\\(0 = - 1.0 \\cdot 10^{-7} s v_{1} - 0.000628318530717959 v_{2} + v_{3} \\cdot \\left(1.0 \\cdot 10^{-7} s + 0.000628318530717959\\right)\\)\n\n\n\\(1.0 = v_{1}\\)\n\n\n\nSymPy can solve for unknown node voltages and the unknown currents from the independent voltage source, \\(V_1\\). The node voltages and unknown current is:\n\nU = solve(equ_N,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '&lt;p&gt;${:s} = {:s}$&lt;/p&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\n\\(v_{1} = 1.0\\)\n\n\n\\(v_{2} = \\frac{6.28318530717959 \\cdot 10^{25} s}{1.0 \\cdot 10^{22} s^{2} + 1.88495559215388 \\cdot 10^{26} s + 3.94784176043576 \\cdot 10^{29}}\\)\n\n\n\\(v_{3} = \\frac{1.0 \\cdot 10^{22} s^{2} + 1.25663706143592 \\cdot 10^{26} s}{1.0 \\cdot 10^{22} s^{2} + 1.88495559215388 \\cdot 10^{26} s + 3.94784176043576 \\cdot 10^{29}}\\)\n\n\n\\(I_{V1} = \\frac{- 6.28318530717959 \\cdot 10^{25} s^{2} - 3.94784176043576 \\cdot 10^{29} s}{1.0 \\cdot 10^{29} s^{2} + 1.88495559215388 \\cdot 10^{33} s + 3.94784176043576 \\cdot 10^{36}}\\)\n\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\), is:\n\nH = (U[v2]/U[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H)))\n\n\\(H(s)=\\frac{6.28318530717959 \\cdot 10^{25} s}{1.0 \\cdot 10^{22} s^{2} + 1.88495559215388 \\cdot 10^{26} s + 3.94784176043576 \\cdot 10^{29}}\\)\n\n\n\n\n28.5.2 Characteristic Equation\nIn control systems engineering, the characteristic equation is a fundamental algebraic equation that plays a crucial role in understanding and analyzing the behavior, and most importantly, the stability of a dynamic system. The value \\(k=3\\) was determined above. The roots of the characteristic equation directly reveal critical information about the system’s dynamic response and stability. The roots of the characteristic equation are the poles of the closed-loop system. If a pair of roots lies exactly on the imaginary axis (with zero real part), the system is marginally stable. This usually means the system will oscillate continuously without decaying or growing.\nThe solve function can determine the roots of the characteristic equation.\n\nchar_equ_roots = solve(1-3*H,s)\nMarkdown('There are {:d} imaginary roots at, {:,.0f}$j\\omega$ Hz and {:,.0f}$j\\omega$ Hz.'.format(len(char_equ_roots),complex(char_equ_roots[0]/(2*np.pi)).imag,complex(char_equ_roots[1]/(2*np.pi)).imag))\n\nThere are 2 imaginary roots at, -1,000\\(j\\omega\\) Hz and 1,000\\(j\\omega\\) Hz.\n\n\n\n\n28.5.3 Feedback Transfer Function\nThe feedback transfer function of Figure 28.2 is \\(H_{sym}(s)=\\frac {v_2(s)}{v_1(s)}\\). The magnitude and phase response is plotted below.\n\nH_num, H_denom = fraction(3*H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\n# setup\nx_axis = np.logspace(1, 5, 2000, endpoint=False)*2*np.pi\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n# plot the magnitude and phase\nax1.semilogx(w/(2*np.pi), mag,'-k',label='mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':k',label='phase')  # phase plot\n\nax1.set_ylim((-40,5))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe band pass nature of the feedback transfer function limits the oscillation frequency to \\(\\omega_n\\).",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#sec-ltspice-simulation",
    "href": "Wien bridge oscillator.html#sec-ltspice-simulation",
    "title": "28  Wien Bridge Oscillator",
    "section": "28.6 LTSpice Simulation",
    "text": "28.6 LTSpice Simulation\nThe circuit shown below is an example of a Wien Bridge oscillator with standard component values and amplitude stabilizing components consisting of \\(R_5\\), \\(D_1\\) and \\(D_2\\). There are many other examples of Wien Bridge oscillators online.\n\n\n\n\n\n\nFigure 28.3: Schematic used for LTSpice.\n\n\n\nThe circuit above is from Franco (2002), Figure 10.3 (a). The component values were chosen from the design example above. The value for \\(R_4\\) was chosen a bit higher to keep the poles in the right hand plane over tolerance and temperature variations. This circuit can be simulated in LTSpice with the following file.\n* Wien bridge oscillator v1.asc\nXU1 4 2 1 opamp Aol=100K GBW=10Meg\nR4 1 4 2.1k\nR2 3 2 1.58k\nR1 2 0 1.58k\nR3 4 0 1k\nC1 2 0 0.1µ\nC2 1 3 0.1µ\nD1 4 5 1N914\nD2 5 4 1N914\nR5 5 1 100\n.model D D\n.lib standard.dio\n.lib opamp.sub\n.tran 0.1s\n.ic V(2)=0.01\n.backanno\n.end",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Wien bridge oscillator.html#summary",
    "href": "Wien bridge oscillator.html#summary",
    "title": "28  Wien Bridge Oscillator",
    "section": "28.7 Summary",
    "text": "28.7 Summary\nThis notebook has presented some of the analysis and calculations for the design of a Wien Bridge oscillator using Python and MNA. Oscillators are networks that produce a pair of imaginary axis poles. When a circuit has poles exactly on the imaginary axis (e.g., at \\(j\\omega_0\\) and \\(-j\\omega_0\\)), it means that the system will exhibit a sustained, undamped oscillation at the frequency \\(\\omega_0\\). There is no exponential decay or growth; the oscillations continue indefinitely. Oscillators are designed with positive feedback loops. This positive feedback, along with specific gain and phase conditions, put the system’s poles onto the imaginary axis. Without this positive feedback, the poles would typically be in the left half of the s-plane (leading to stable, decaying responses).\n\n\n\n\nBudak, A. 1974. Passive and Active Network Analysis and Synthesis. Houghton Mifflin.\n\n\nFranco, Sergio. 2002. Design with Operational Amplifiers and Analog Integrated Circuits, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Wien Bridge Oscillator</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html",
    "href": "Diode Circuit.html",
    "title": "29  Diode Circuit",
    "section": "",
    "text": "29.1 Introduction\nLast update: 13 Oct 2025\nThis chapter explores two circuits where diodes are used. A diode is a two-terminal electronic component that acts like a one-way valve for electric current. It allows current to flow easily in one direction, called the “forward direction” or “forward bias” and severely restricts or blocks current from flowing in the opposite direction, called the “reverse direction” or “reverse bias”. The voltage to current relationship is non-linear and often expressed by what is called the Ideal Equation of Diode, shown below.\n\\[i = I_s \\left( e^{\\frac{qV}{nkT}} - 1 \\right) \\tag{29.1}\\]\nWhere:\n\\(i\\) = Current flowing through the diode\n\\(I_s\\) = Reverse or dark saturation current, a typical value for silicon is \\(10^{-12}\\) Amperes\n\\(e\\) = Base of the neutral logarithm, 2.71828\n\\(q\\) = Charge on the electron, \\(1.602 \\cdot 10^{-19}\\) in coulombs\n\\(V\\) = Applied voltage across the diode\n\\(n\\) = Ideality factor, typically between 1 and 2 for silicon diodes\n\\(k\\) = Boltzmann’s constant, \\(1.380 \\times 10^{-23}\\) jouals/Kelvin\n\\(T\\) = Absolute Temperature in Kelvin, at room temperature is 300 Kelvin\nDiodes have two terminals, one is the Anode, through which current flows into the diode when the diode is forward biased or conducting in the forward direction. The other terminal is the Cathode, through which current flows out of the diode. In schematic diagrams, the diode symbol is a triangle pointing towards a line. The triangle represents the anode, and the line represents the cathode. The arrow points in the direction of “conventional current flow” (from positive to negative). By convention, current is defined as the direction in which positive charges would flow. This is opposite to the actual flow of electrons, which are negatively charged.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html#introduction",
    "href": "Diode Circuit.html#introduction",
    "title": "29  Diode Circuit",
    "section": "",
    "text": "29.1.1 History of the Diode\nThe history of the diode goes back to the 19th and early 20th centuries, rooted in the discovery of one-way electrical conduction, or rectification. In 1874, German physicist Ferdinand Braun discovered the rectification effect in metal-sulfide crystals, an early form of the semiconductor diode. Separately, English physicist Frederick Guthrie observed the thermionic emission effect in 1873, where current flows one way from a heated metal to a cooler electrode in a vacuum; this was independently rediscovered by Thomas Edison in 1880. Building on this, John Ambrose Fleming patented the first practical vacuum tube diode, known as the Fleming valve, in 1904, which was widely used in early radio. Concurrently, crystal-based “cat’s whisker” diodes gained use in radio receivers, and the term “diode” itself was coined by William Henry Eccles in 1919. The true revolution came with the development of the modern P-N junction semiconductor diode, which became practical after advancements in materials and techniques in the mid-20th century, leading to smaller, more efficient, and reliable devices that eventually replaced most vacuum tube diodes.\nThe history of thermionic emission, the discharge of electrons from a heated surface, begins with early observations in the 19th century. The phenomenon was reported as early as 1853 by Edmond Becquerel and revisited in 1873 by Frederick Guthrie, who noted that a red-hot, negatively charged iron sphere would lose its charge. A more formalized discovery came in 1883, when Thomas Edison observed the one-way flow of current between a heated filament and a separate metal plate in his incandescent lamp, an effect he patented but didn’t immediately find a use for, and which became known as the “Edison effect.” However, the physical mechanism was not fully understood until after J.J. Thomson’s discovery of the electron in 1897. The effect’s practical application began in 1904 when John Ambrose Fleming used it to invent the first vacuum tube, or diode (Fleming valve), enabling the rectification of alternating current for radio. Later, Owen Willans Richardson provided the theoretical and mathematical framework, for which he was awarded the Nobel Prize in Physics in 1928, solidifying the scientific understanding of the effect now widely termed thermionic emission.\nThe Fleming valve, also known as the thermionic valve or diode, was a pivotal invention in the history of electronics, conceived by Sir John Ambrose Fleming. Building upon the earlier work of Thomas Edison concerning the “Edison effect” (the flow of current from a heated filament to a separate metal plate in a vacuum), Fleming developed the device in 1904 while seeking a more sensitive detector for radio waves for the Marconi Company. His breakthrough involved placing both a heated filament (cathode) and a separate metal plate (anode) inside an evacuated glass bulb. This two-element vacuum tube acted as a rectifier, allowing electric current to flow in only one direction, which was crucial for converting alternating current (AC) radio signals into detectable direct current (DC). This simple but revolutionary device marked the birth of vacuum tube technology, enabling significant advances in wireless telegraphy and setting the stage for the later invention of the triode and the subsequent development of radio, telephony, and computing.\n\n\n29.1.2 Shockley ideal diode equation\nThe Shockley ideal diode equation, or diode law, is a fundamental formula in semiconductor physics that describes the exponential relationship between the current (\\(I\\)) and voltage (\\(V\\)) in a p-n junction diode. It is named after Nobel laureate William Shockley, one of the co-inventors of the transistor, who first derived an equation for the voltage across a p-n junction in a comprehensive article published in 1949. The subsequent development of the equation, which relates current as a function of voltage under specific assumptions, became known as the ideal diode equation. Researchers found that for many silicon junctions, the original equation was insufficient, leading to the introduction of the ideality factor (or emission coefficient, typically denoted as \\(n\\)), which accounts for non-ideal effects like carrier recombination within the junction, resulting in Equation 29.1.\n\n\n29.1.3 Applications of Diodes\nThe common usage of diodes are listed below:\n\nRectification: This is one of the most common uses. Diodes convert alternating current (AC), which periodically reverses direction, into pulsating direct current (DC), which flows in only one direction. This is fundamental for power supplies in almost all electronic devices.\nVoltage Regulation: Zener diodes are specifically designed to operate in reverse breakdown and maintain a stable voltage across their terminals, making them useful for voltage regulation and overvoltage protection.\nSignal Demodulation: In radio receivers, diodes are used to extract audio signals from modulated radio waves.\nLogic Gates: Diodes can be used in simple logic circuits.\nLight Emission: Light-Emitting Diodes (LEDs) are a type of diode that produces light when current flows through them in the forward direction.\nLight Detection: Photodiodes produce an electrical current when they absorb light, used in sensors and solar cells.\nProtection: Diodes can protect circuits from reverse polarity or voltage spikes.\n\nThe following Python modules are used:\n\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker\nimport pandas as pd\nimport SymMNA\nfrom IPython.display import display, Markdown, Math, Latex\nfrom tabulate import tabulate\ninit_printing()\n\nThe scipy.optimize.fsolve function is a core tool in the SciPy library for root finding of non-linear equations. It numerically finds the input values (roots) where a given function or system of non-linear equations equals zero.\n\nfrom scipy.optimize import fsolve",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html#the-ideal-diode-equation",
    "href": "Diode Circuit.html#the-ideal-diode-equation",
    "title": "29  Diode Circuit",
    "section": "29.2 The Ideal Diode Equation",
    "text": "29.2 The Ideal Diode Equation\nThe ideal diode equation is plotted below.\n\n# Constants for the Diode Equation\nI_s = 1e-12 # Saturation current (Is) in Amperes. This value can vary widely.\nn = 1.2 # Ideality factor (n). Typically between 1 and 2 for silicon diodes.\nk = 1.380649e-23 # Boltzmann's constant in J/K\nq = 1.602176634e-19 # Electron charge in Coulombs\nT = 300 # Temperature in Kelvin (room temperature is approximately 300K)\n\nThe ideal diode equation i splotted below with a range of values for the diode voltage ranging from -0.2 volts to 1.0 volts.\n\n# Create a range of diode voltage values to plot\nV_D_values = np.linspace(-0.2, 1, 500)\n\n# Calculate the corresponding current (I) values for each voltage\nI_values = I_s * (np.exp(V_D_values*q/(n*k*T)) - 1)\n\n# Create the plot\nplt.figure(figsize=(10, 6))\nplt.plot(V_D_values, I_values, color='blue')\n\n# Add labels and a title\nplt.title('Ideal Diode I-V Characteristic Curve', fontsize=12)\nplt.xlabel('Diode Voltage ($V_D$) in Volts', fontsize=12)\nplt.ylabel('Diode Current ($I$) in Amperes', fontsize=12)\n\n# Add a grid for better readability\nplt.grid(True, linestyle='--', alpha=0.7)\n\n# Add a legend\n#plt.legend()\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html#forward-biased-diode-circuit",
    "href": "Diode Circuit.html#forward-biased-diode-circuit",
    "title": "29  Diode Circuit",
    "section": "29.3 Forward Biased Diode Circuit",
    "text": "29.3 Forward Biased Diode Circuit\nThe schematic shown in Figure 29.1 has a 1N914 diode with resistor \\(R_1\\) acting as a current limiter. The 1N914A datasheet from ON Semiconductor provides the device specifications. The 1N914 model parameters used in LTspice are:\n.model 1N914 D(Is=2.52n Rs=.568 N=1.752 Cjo=4p M=.4 tt=20n Iave=200m Vpk=75 mfg=OnSemi type=silicon).\n\n\n\n\n\n\nFigure 29.1: Diode circuit with current limiting resistor.\n\n\n\n\\(D_1\\) in Figure 29.1 can be replaced with a current source as shown in the netlist below.\n\nDiode_as_current_source_net_list = '''\n* Diode_as_current_source.asc\nR1 2 1 1e3\nV1 1 0 5\nI1 2 0 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Diode_as_current_source_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}}\\)\\(- I_{1} = - \\frac{v_{1}}{R_{1}} + \\frac{v_{2}}{R_{1}}\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\nThe network equations for the netlist can be solved symbolically and the node voltages and dependent currents are diesplayed using symbolic notation.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - I_{1} R_{1} + V_{1}\\)\\(I_{V1} = - I_{1}\\)\n\n\nI1 is the current of the 1N914 and the following expression for the diode current can be developed from the equation:\n\\(I_{1N914} = I_S \\left( e^{\\frac{qv2}{nkT}} - 1 \\right)\\)\nThe expression for the current in \\(D_1\\) in terms of \\(v_2\\) is shown below.\n\nI_s, n = symbols('I_s n')\n\nI_1n914 = (I_s*(exp(v2*q/(n*k*T))-1)).subs({I_s:2.52e-9, n:1.752})\nI_1n914\n\n\\(\\displaystyle 2.52 \\cdot 10^{-9} e^{22.0786113423708 v_{2}} - 2.52 \\cdot 10^{-9}\\)\n\n\nIn the expression for \\(v_2\\), the diode equation is substituted for \\(I_1\\) along with other component values and saved as eq1.\n\neq1 = U_sym[v2].subs({I1:I_1n914, V1:5, R1:1e3})\neq1\n\n\\(\\displaystyle 5.00000252 - 2.52 \\cdot 10^{-6} e^{22.0786113423708 v_{2}}\\)\n\n\nWe want to find the value of \\(v_2\\) for which eq1 equals \\(v_2\\) and we can create a function that expresses this relation.\n\nlam_f = lambdify(v2, eq1-v2)\n\nUsing the fsolve function, an initial guess of 0.55 and asking for a solution with a tolerance of \\(10^{-6}\\), we can get the diode voltage which is calculated and printed below.\n\nprint(f'The diode voltage is: {fsolve(lam_f, 0.55, xtol=1e-6)[0]:0.3f}')\n\nThe diode voltage is: 0.650\n\n\nThe solution obtained from LTSpice is \\(v_2=0.653229\\), which agrees within two decimal places of the solution obtained from Python. The small difference can be attributed to the diode model used by LTSpice.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html#another-diode-circuit",
    "href": "Diode Circuit.html#another-diode-circuit",
    "title": "29  Diode Circuit",
    "section": "29.4 Another Diode Circuit",
    "text": "29.4 Another Diode Circuit\nThe schematic below shows a circuit with two diodes and two current limiting resistors. \\(D_1\\) is a 1N914 type diode and \\(D_2\\) is a 1N5817 Schottky diode. The Schottky diode is a semiconductor device formed by a junction between a metal and a semiconductor (typically n-type), as opposed to the p-n junction of a conventional diode. This metal-semiconductor junction creates a Schottky barrier, which allows the diode to have a significantly lower forward voltage drop (typically 0.15 V to 0.45 V) and much faster switching speed compared to standard diodes.\n\n\n\n\n\n\nFigure 29.2: Schematic of a circuit containing two diodes.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html#load-the-net-list",
    "href": "Diode Circuit.html#load-the-net-list",
    "title": "29  Diode Circuit",
    "section": "29.5 Load the net list",
    "text": "29.5 Load the net list\nThe netlist for Figure 29.2 with current sources \\(I_1\\) and \\(I_2\\) replacing the diodes.\n\nDiode_circuit_2_net_list = '''\nI1 2 0 1\nR1 2 1 500\nV1 1 0 5\nI2 3 0 1\nR2 2 3 500\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(Diode_circuit_2_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{2}}{R_{1}}\\)\\(- I_{1} = v_{2} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} - \\frac{v_{1}}{R_{1}}\\)\\(- I_{2} = - \\frac{v_{2}}{R_{2}} + \\frac{v_{3}}{R_{2}}\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\nThe network equations for the netlist can be solved symbolically and the node voltages and dependent currents are diesplayed using symbolic notation.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = - I_{1} R_{1} - I_{2} R_{1} + V_{1}\\)\\(v_{3} = - I_{1} R_{1} - I_{2} R_{1} - I_{2} R_{2} + V_{1}\\)\\(I_{V1} = - I_{1} - I_{2}\\)\n\n\nThe schematic shown in Figure 29.2 has a 1N5817 diode with resistor \\(R_2\\) acting as a current limiter. The 1N5817 datasheet from Diodes Incorporated provides the device specifications. The 1N5817 model parameters used in LTspice are:\n.model 1N5817 D(Is=31.7u Rs=.051 N=1.373 Cjo=190p M=.3 Eg=.69 Xti=2 Iave=1 Vpk=20 mfg=OnSemi type=Schottky)\n\nI_1n5817 = (I_s*(exp(v3*q/(n*k*T))-1)).subs({I_s:31.7e-6, n:1.373})\nI_1n5817\n\n\\(\\displaystyle 3.17 \\cdot 10^{-5} e^{28.1731442620784 v_{3}} - 3.17 \\cdot 10^{-5}\\)\n\n\nThe code below creates a new equation, eq1, by substituting the diode equations for \\(I_1\\) and \\(I_2\\). The element values for \\(R_1\\), \\(R_2\\) and \\(V_1\\) are also put into the equation.\n\neq1 = U_sym[v2].subs({I1:I_1n914, I2:I_1n5817}).subs({R1:500,R2:500,V1:5})\neq1\n\n\\(\\displaystyle - 1.26 \\cdot 10^{-6} e^{22.0786113423708 v_{2}} - 0.01585 e^{28.1731442620784 v_{3}} + 5.01585126\\)\n\n\nThe equation, eq1 minus \\(v_2\\), is converted to a function by using the lamdify operation.\n\neq1_lam = lambdify([v2,v3], eq1-v2)\n\nThe code below creates a new equation, eq2, by substituting the diode equations for \\(I_1\\) and \\(I_2\\). The element values for \\(R_1\\), \\(R_2\\) and \\(V_1\\) are also put into the equation.\n\neq2 = U_sym[v3].subs({I1:I_1n914, I2:I_1n5817}).subs({R1:500,R2:500,V1:5})\neq2\n\n\\(\\displaystyle - 1.26 \\cdot 10^{-6} e^{22.0786113423708 v_{2}} - 0.0317 e^{28.1731442620784 v_{3}} + 5.03170126\\)\n\n\nThe equation, eq2 minus \\(v_3\\), is converted to a function by using the lamdify operation.\n\neq2_lam = lambdify([v2,v3], eq2-v3)\n\nA function called func4 is created so that it can be used as an argument to the fsolve function.\n\ndef func4(vars):\n    v2, v3 = vars\n    return [eq1_lam(v2,v3), eq2_lam(v2,v3)]\n\nnode_v2, node_v3 = fsolve(func4, [0.5, 0.2], xtol=1e-6)\n\nprint(f'The voltage at node 2 is: {node_v2:0.3f} and the voltage at node 3 is: {node_v3:0.3f}')\n\nThe voltage at node 2 is: 0.675 and the voltage at node 3 is: 0.127\n\n\nThe Python results are reasonable close to the LTSpice solution for Figure 29.2 as shown below.\n       --- Operating Point ---\n\nV(2):    0.679966    voltage\nV(1):    5   voltage\nV(3):    0.127193    voltage\nI(D1):   0.00753452  device_current\nI(D2):   0.00110555  device_current\nI(R1):   -0.00864007     device_current\nI(R2):   0.00110555  device_current\nI(V1):   -0.00864007     device_current",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Diode Circuit.html#summary",
    "href": "Diode Circuit.html#summary",
    "title": "29  Diode Circuit",
    "section": "29.6 Summary",
    "text": "29.6 Summary\nThis chapter focused on integrating the nonlinear diode equation into standard circuit network analysis, demonstrating how to use techniques like nodal analysis to solve for unknown node voltages in diode circuits. The methodology was introduced by first analyzing a fundamental circuit consisting of a single resistor and a single diode, establishing the core steps for solving such nonlinear equations by using SymPy’s fsolve function. This process was then scaled up and successfully applied to a more complex network configuration featuring two diodes and two resistors.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Diode Circuit</span>"
    ]
  },
  {
    "objectID": "Bridged-T-coil_v2.html",
    "href": "Bridged-T-coil_v2.html",
    "title": "30  Bridged T Coil",
    "section": "",
    "text": "30.1 Introduction\nLast update: 16 Aug 2025\nThis Jupyter notebook is about an interesting circuit called the Bridge T-Coil shown in Figure 30.2. I first became aquatinted with the Bridge T-Coil circuit when reading through Analog Circuit Design: Art, Science and Personalities, edited by Williams (1991). It was kind of surprising to me that I hadn’t come across this circuit before since I had been a practicing electrical engineer for more than 20 years at the time. As I was researching this topic, I came across Bridged Networks in Zverev (1967), Figure 2.29, where a bridged T-Coil is shown for a n=3 Butterworth filter.\nChapter 14 in Williams (1991) is about Fast Vertical Amplifiers, which are amplifiers used in oscilloscopes. Figure 14-6 in the book is a schematic of an asymmetrical T-Coil circuit and some equations, the derivation of the equations was described as complex and they were considered a trade secret. This description intrigued and prompted me learn a bit more about the Bridge T-Coil.\nBefore describing the Bridge T-Coil, I would like to say a few words about Analog Circuit Design: Art, Science and Personalities. In the world of electronics, certain books transcend the typical textbook format to become celebrated resources that shape a generation of engineers. Jim Williams’ edited book is one such work. More than just a collection of technical articles, it is a curated journey into the minds of some of the most brilliant and innovative thinkers in the field of analog design.\nThis unique book presents a fascinating perspective on the practice of circuit design, going beyond the dry theory of textbooks to explore the creative, intuitive, and sometimes idiosyncratic processes that lead to breakthrough designs. The book is divided into four main sections\nEach chapter is written by a different personality and the contributors from a “who’s who” of analog circuit design, including luminaries like Bob Pease, George A. Philbrick, Barry Gilbert and Williams himself. The authors often share personal and anecdotal experiences which reveal the thought processes, clever tricks and practical wisdom gained from decades of hands-on work. It’s a rare glimpse into the practical, real-world challenges and triumphs of these engineering notables.\nJim Williams, a legendary analog designer and application engineer at Linear Technology (now part of Analog Devices), was uniquely positioned to bring this project to fruition. His own passion for the craft and his deep connections within the industry allowed him to assemble this extraordinary collection of essays.\nFast Vertical Amplifiers\nThe Bridge T-Coil circuit was introduced in Williams (1991), Chapter 14, titled, Good Engineering and Fast Vertical Amplifiers, by John Addis. A fast vertical amplifier is a critical component of an analog oscilloscope. It takes a small input signal, amplifies it, and drives the vertical deflection plates of a cathode-ray tube (CRT), causing the electron beam to move up and down in proportion to the input signal’s voltage. This action creates the vertical trace on the screen, which represents the signal’s amplitude. The “fast” aspect of these amplifiers refers to their high bandwidth, allowing them to accurately amplify high-frequency signals.\nThe history of fast vertical amplifiers is intertwined with the development of the oscilloscope itself. The first oscilloscopes, or oscillographs, were electromechanical devices invented by French physicist André Blondel in the late 19th century. These had a very limited frequency response (in the kilohertz range).\nA major leap came with German physicist Karl Ferdinand Braun’s invention of the cathode-ray tube (CRT) in 1897. The CRT was the first electronic display oscilloscope. However, early CRTs had stability issues. It wasn’t until Vladimir K. Zworykin’s 1931 invention of a permanently sealed, high-vacuum CRT with a thermionic emitter that the oscilloscope became a practical, commercial tool. This stable CRT allowed for the creation of usable oscilloscopes by companies like General Radio.\nFor decades, the design of vertical amplifiers relied on vacuum tubes* (also known as valves). These early amplifiers used thermionic valves to amplify the signal, with the design often employing a push-pull output stage. This was a differential amplifier that provided two signals of opposite polarity to the vertical deflection plates of the CRT. This push-pull configuration had several advantages, including the cancellation of unwanted signals (like power supply hum), suppression of even harmonics, and greater power output.\nThe development of new amplifier topologies and the use of negative feedback, a technique invented by Harold Stephen Black in 1927, allowed designers to trade some gain for reduced distortion and other benefits. This was a crucial step toward building more accurate and faster amplifiers. The period following World War II, fueled by technical advancements and a growing consumer market, became a “golden age” for valve development and amplifier circuit design.\nThe schematic below is from the Tektronix 545A Instrunction Manual, which was a pioneering high-performance oscilloscope that became a standard in the electronics industry during the late 1950s and 1960s. It was a crucial tool for engineers and scientists working on complex systems, from early computers to the U.S. space program.\nIn the schematic you can see the tube’s plate (anode) and cathode, connected to a series of center tapped inductors. This arrangement is a series of Bridged T-coils.\nJohn Addis is a legendary figure in the world of analog electronics, particularly known for his significant contributions to Tektronix’s oscilloscopes, especially their fast vertical amplifiers. While there isn’t one single consolidated “history of fast vertical amplifiers” written by John Addis readily available as a published book or extensive article, his work and insights are deeply embedded in the history of these devices, and he has certainly shared his knowledge through various channels (patents, internal Tektronix documents, and informal discussions).\nFrom what’s known about John Addis’s career and the development of fast vertical amplifiers at Tektronix, his “history” would essentially trace the evolution of these crucial components within high-performance oscilloscopes.\nIn summary, a “history of fast vertical amplifiers by John Addis” would be less about a formal historical narrative and more about a practical, deeply technical dive into the design evolution of these critical components, seen through the lens of one of their most influential developers at Tektronix. It would highlight the challenges, the ingenious solutions, and the continuous pushing of bandwidth and fidelity limits that characterized the golden age of analog oscilloscopes.\nThe schematic below is redrawn from Williams (1991) Figure 14-6. In my version of the schematic, the reference designations, \\(L_S\\) and \\(R_S\\), have been replace by \\(L_a\\) and \\(R_a\\) because the subscript \\(s\\) was a little confusing in the network equations along side the Laplace \\(s\\) variable in the equations. Also, I set all the component values to 1. This is the schematic that accompanies Bob Ross’s design equations, alos in the figure and presented below.\nIn Williams (1991), John Addis writes,\nEquations from figure 14-6 are:\n\\(\\theta = \\tan^{-1} \\sqrt {\\frac {1}{\\zeta ^2} - 1}\\)\n\\(\\zeta = \\frac {1}{\\sqrt {\\tan^2 \\theta +1}}\\)\n\\(L_1 = \\frac {C_L}{4} \\left[ 1+\\frac{1}{4\\zeta^2} \\right] \\left[ R_L+R_S\\right]^2 - R_L R_S C_L - L_S\\)\n\\(L_2 = \\frac {C_L}{4} \\left[ 1+\\frac{1}{4\\zeta^2} \\right] \\left[ R_L+R_S\\right]^2 - L_S\\)\n\\(L_T = R_L^2 C_L\\)\n\\(M = \\frac{C_L}{4} \\left[ R_L^2 - R_S^2 - \\frac {1}{4 \\zeta ^2} \\left[ R_L+R_S\\right]^2 \\right] + L_S\\)\n\\(C_B = \\frac{C_L}{16 \\zeta^2} \\left[ \\frac {R_L+R_S}{R_L} \\right]^2\\)\n\\(s = \\frac{-4\\zeta^2}{(R_L+R_S) C_L} \\pm j \\frac {4\\zeta}{(R_L+R_S) C_L} \\sqrt {1-\\zeta^2}\\)\n\\(L_1 + M = \\frac{R_L C_L}{2} \\left[ R_L - R_S \\right]\\)\n\\(L_2 + M = \\frac{R_L C_L}{2} \\left[ R_L + R_S \\right]\\)\nSome of the above equations are similar to those found in Ginzton et al. (1948). Other than saying these equations were a trade secret, John Addis didn’t provide any explanation of how the equations were derived or how the design process uses these equations. Over the years Bob Ross has given several presentations about the Bridged T-coil and he uses Wang Algebra to solve the circuit equations and use the results to design T-coils, see Ross (2011) and Ross and Ling (2022). In Razavi (2015) there is an overview given of the Bridged T-Coil along with some equations.\nI think the design steps for using the equations above are - first to choose the damping ratio, \\(\\zeta\\), or the angle \\(\\theta\\), which is the angle of the polar coordinate of the poles. By choosing \\(\\zeta=\\sqrt{1/2}\\) or \\(\\theta=30\\) degrees, the Bridge T-coil circuit will have what is called a maximally flat envelope delay. This is where the group delay is as constant as across a specific range of frequencies. For systems that transmit complex signals, such as digital data or audio, it is crucial to maintain the integrity of the signal’s waveform. A filter with a maximally flat envelope delay ensures that all parts of the signal arrive at the output at the same time, preventing distortion and preserving the signal’s original shape. \\(R_L\\), \\(R_S\\) and \\(C_L\\), which are the source and load components are inputs to the design. \\(L_S\\) (shown as \\(L_a\\) in my re-drawn version fig-t-coil-fig_14-6) is the added inductor for the decoupled equivalent circuit of \\(L_1\\) and \\(L_2\\). With these parameters, numeric values for \\(L_1\\), \\(L_2\\), \\(M\\) and \\(C_B\\) can be calculated.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Bridged T Coil</span>"
    ]
  },
  {
    "objectID": "Bridged-T-coil_v2.html#introduction",
    "href": "Bridged-T-coil_v2.html#introduction",
    "title": "30  Bridged T Coil",
    "section": "",
    "text": "What is Analog Design?\nThe Making of an Analog Engineer\nIntuitions and Insights\nTechniques, Tips and Applications\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30.1: Part of the schematic from Tektronix’s manual for the Type 454A oscilliscope.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 30.2: T coil ver 1a, this is the figure from Williams (1991). I 1st came across this and was intrigued by the write up and then found there is a lot of continued interest in the circuit.\n\n\n\n\n\nThese new amplifiers had rise times comparable to the propagation time between stages, so it became important to eliminate reflections between stages. The bridged T coil became extremely important because it allowed the input of each stage to be very well terminated. The F1, doubler’s simple high frequency input impedance could be well modeled with a series RLC. Bob Ross wrote the equations for the asymmetrical bridged T coil which could peak a series RLC load. The derivation Figure 14-6. is quite complex, and the equations were held as a trade secret until recently. The F1, doubler and the bridged T coil were used extensively in the Tektronix 7904 introduced in 1972.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Bridged T Coil</span>"
    ]
  },
  {
    "objectID": "Bridged-T-coil_v2.html#the-bridged-t-coil",
    "href": "Bridged-T-coil_v2.html#the-bridged-t-coil",
    "title": "30  Bridged T Coil",
    "section": "30.2 The Bridged T-Coil",
    "text": "30.2 The Bridged T-Coil\nThe Bridged T-Coil is a specialized circuit topology used to extend the bandwidth of high-speed electronic systems. Its primary applications include amplifiers, line drivers, and input/output (I/O) interfaces. A bridged T-coil is a two-port network characterized by its T-shaped configuration. It consists of two mutually coupled inductors and a bridging capacitor that connects across the two series arms of the T-network. The mutual inductance between the two inductors is a critical component of its operation, enabling unique impedance and transfer function characteristics. The use of bridged T-coils provides several significant advantages in high-frequency applications:\n\nThe most significant application of the T-coil is the extension of a circuit’s signal bandwidth. This is achieved at a much greater factor than traditional inductive peaking techniques, which is crucial for high-speed data transmission where signal integrity must be preserved across a broad range of frequencies.\nIn high-speed integrated circuits (ICs), parasitic capacitance can severely limit the maximum operating frequency. Bridged T-coils are incorporated on-chip to counteract these parasitic effects, thereby maintaining performance.\nBridged T-coils can be designed to maintain a nearly constant input impedance over a wide frequency range. This characteristic is vital for impedance matching, preventing signal reflections and allowing for the cascading of multiple circuits without degradation.\nBridged T-coils are also utilized in ESD protection circuits. They effectively match the impedance of ESD devices over a broad band, providing robust protection without compromising high-frequency performance.\n\nWhile the detailed mathematical analysis is complex, the fundamental principle can be intuitively understood. The Bridged T-coil, through the combination of its coupled inductors and the bridging capacitor, creates a lumped element transmission line.\nThe concept of the Bridged T-coil has a notable history, dating back to 1948. Its design was famously used by Tektronix engineers in the wideband oscilloscope amplifiers of the 1960s, where it provided a significant performance advantage that was treated as a trade secret for many years. Today the use of a Bridged T-coil remains an indispensable matching circuit used for overcoming the inherent unwanted parasitic effects of in modern high-speed communication and instrumentation systems.\nThe theoretical basis for the Bridged T-Coil goes back to Ginzton et al. (1948) and Wang (1934). However it saw the most significant practical development and application as a trade secret by Tektronix engineers in the late 1960s. This history makes pinpointing a single, definitive patent tricky, as the core concept might be foundational, while specific implementations or improvements are patented.\n\n\n\n\n\n\nFigure 30.3: This schematic is from Ginzton et al. (1948) and shows the application of mutual inductance between the coils. This basic idea has been applied to transistor amplifiers in modern designs.\n\n\n\n\n30.2.1 Technical Papers\nIn addition to the papers cited in this JupyterLab notebook, I asked Google’s Gemini to research recent published papers on the topic of Bridged T-coils and Gemini generated the following report, Bridged T-coil Research Analysis. Common themes contained in recient papers are novel design methodologies and compact layouts.\n\n\n30.2.2 Patents\nBased on patent searches and historical accounts, a key patent that directly addresses a “bridged-T termination network” and is highly relevant to the concept is US3155927A - Bridged-t termination network, filed by by Thomas T. True filed September 12, 1960. This patent describes a termination network providing a constant input impedance with a capacitive load, specifically mentioning a “bridged-T network as commonly represented in block form.”\nIt’s also important to note that many of the applications and further developments of bridged T-coils in high-speed electronics and integrated circuits have led to subsequent patents that build upon or utilize the core bridged T-coil concept. For example, the search results show patents like:\n\nU.S. Patent 20060109023A1 - T-coil apparatus and method for compensating capacitance (Analog Devices Inc., filed 2003)\nU.S. Patent 3532982A - Transmission line termination circuit (Tektronix Inc., filed 1967, issued 1970 - this one cites the True patent, indicating its relevance to Tektronix’s work).\n\nPatent applications for the Bridge T-Coil are somewhat difficult for these reasons:\n\nFundamental concept vs. Specific Implementation: The basic bridged-T connection itself might be considered a fundamental circuit topology rather than a patentable invention in the modern sense after its initial theoretical description. Patents typically cover novel and non-obvious implementations or applications of such concepts.\nTrade Secrets: As mentioned previously, Tektronix famously kept the detailed design equations and methodologies for their T-coil implementations as trade secrets for many years. This meant they leveraged proprietary knowledge rather than relying solely on patents for competitive advantage in certain areas.\nOngoing Development: The T-coil concept has been adapted and improved over decades, leading to numerous patents on specific circuit designs, integration techniques (e.g., on-chip T-coils), and applications (e.g., in ESD protection circuits, high-speed transceivers).\n\nSo, while US3155927A by Thomas T. True is a significant early patent for a “bridged-T termination network,” the broader landscape of “bridged T-coil” technology is covered by a multitude of patents related to its various applications and refinements over time.\n“Bridged T-coil” is a specific circuit topology that has been in use for many decades, particularly in the field of high-speed electronics. As such, the core concept itself is not new and is not likely to be patented in its most basic form. However, there may be patents on specific implementations, improvements, or applications of the bridged T-coil circuit.\nBased on a search of patents and publications from the last five years, here is a relevant patent - U.S. Patent 10944397, issued on March 9, 2021, to Cadence Design Systems, Inc. This patent is titled “Compact four-terminal TCOIL” and describes a T-coil structure that provides more bandwidth and less reflection and group delay variation than traditional three-terminal structures, while consuming the same amount of area on a chip. The patent is concerned with the specific physical layout and terminal configuration of the T-coil circuit within an integrated circuit (IC) to improve its performance in high-speed applications.\nIn addition to this granted patent, there are other applications and publications that reference the use of bridged T-coils, but they do not appear to be for the fundamental circuit itself. These are typically for specific uses of the circuit to address a particular problem. For example, U.S. Patent 20240409893 (publication date: December 5, 2024) filed by Marvell Asia Pte Ltd. for a “Bridged T-coil for increased bandwidth in hard disk drive write circuitry.” This application describes the use of a bridged T-coil in a hard disk drive’s write circuitry to improve performance.\nSee my Genimi generated report on Bridged T-Coil Patent Search for patents awarded in the last five years.\n\n\n30.2.3 Circuit Analysis\nMost of the circuit analysis cited in this notebook start with decoupling the inductors, \\(L_1\\) and \\(L_2\\). Given the large amount of algebra required to generate design equations, many of the papers skip past a lot of steps when describing the process. There are two common approaches. Bob Ross relies on Wang Algebra as explained in Ross (2011) and Ross and Ling (2022).\nIn Paramesh and Allstot (2006), after decoupling the inductors and applying the Extra Element Theorem to generate the transimpedance function, the author reduces the fourth order denominator to a second order polynomial by getting two poles to cancel the two zeros. My analysis approach will follow some of the same steps, but I will not need to decouple the inductors nor use the Extra Element Theorem since MNA can work through the algebra without resorting to these simplifications.\nThe following YouTube video also cover the topic of Bridge T-coil circuit analsis:\n\nAnalyze T-Coil Circuit Using Symbolic Toolbox.\nWhy T-Coils for Impedance Matching?\nBridged T Coil Analysis Part 1\nBridged T Coil Analysis Part 2\n\nMost papers do not use the Bridged T-Coil circuit in Figure 30.2 but use the basic circuit shown in Figure 30.4. The input port is usually at node 1 and the out node is either node 2 or node 3 depending on the application. In the following sections the topics of Bandwidth Enhancement and Electrostatic Discharge (ESD) Protection are discussed.\n\n\n\n\n\n\nFigure 30.4: Schematic of the basic T-Coil.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Bridged T Coil</span>"
    ]
  },
  {
    "objectID": "Bridged-T-coil_v2.html#bandwidth-enhancement",
    "href": "Bridged-T-coil_v2.html#bandwidth-enhancement",
    "title": "30  Bridged T Coil",
    "section": "30.3 Bandwidth Enhancement",
    "text": "30.3 Bandwidth Enhancement\nOne application of the Bridge T-coil is bandwidth enhancement. In high-speed integrated circuits, parasitic capacitance can severely limit the circuit’s operating frequency. T-coils are incorporated on-chip to counteract these parasitic effects and maintain performance. T-coils can extend the signal bandwidth of a circuit by a significantly greater factor than traditional inductive peaking techniques. For example, consider the circuits shown in Figure 30.5, where (a) is a basic common source FET amplifier. The bandwidth of this circuit is determined by the drain resistor and the capacitance of the load. This basic amplifier is analyzed below as the common source reference amplifier. Figure 30.5 (b) shows an inductor added in series with \\(R_d\\) to provide some peaking of the frequency response and thereby increasing the bandwidth of the amplifier. Figure 30.5 (c) shows a Bridge T-coil added between the drain terminal of \\(Q_3\\) and \\(R_d\\). Shekhar, Walling, and Allstot (2006) has a nice overview of the available techniques.\n\n\n\n\n\n\nFigure 30.5: T-Coil-common_source\n\n\n\n\n30.3.1 Common Source Reference Amplifier\nThe common source FET amplifier of Figure 30.5 (a) is analyzed below in order to provide a baseline bandwidth for the common-source configuration. The baseline bandwidth will later be compared to the increased bandwidth obtained by using a Bridged T-coil.\nThe schematic of the reference common source FET amplifier has been redrawn using a voltage controlled current source to model the FET. \\(V_{dd}\\) has been replaced by its high frequency equivalent which is a ground.\n\n\n\n\n\n\nFigure 30.6: RC-common_source ref_amp\n\n\n\nIn the schematic above all the component values are set to one. Later during the numerical analysis phase, actual numerical values will be used. The netlist for the circuit above is entered below.\n\nCS_ref_amp_net_list = '''\n* CS_ref_amp.asc\nR 0 2 1\nC 2 0 1\nV1 1 0 1\nG 0 2 1 0 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(CS_ref_amp_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1}\\)\\(0 = - g v_{1} + v_{2} \\left(C s + \\frac{1}{R}\\right)\\)\\(V_{1} = v_{1}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\nThe network equations for the circuit in Figure 30.6 can be solved symbolically and the node voltages and dependent currents using symbolic notation.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(I_{V1} = 0\\)\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R V_{1} g}{C R s + 1}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{R g}{C R s + 1}\\)\n\n\nMaking the substitutions, we get a numerical transfer function. The load capacitance is set to 100pF and the drain resistor is set to 1k\\(\\Omega\\). The gain of the voltage controlled current source \\(g\\) is set 0.001.\n\nH = H_sym.subs({C:100e-12, R:1000, g:0.001})\nMarkdown('&lt;p&gt;$H(s)={:s}$&lt;/p&gt;'.format(latex(H)))\n\n\n\\(H(s)=\\frac{1.0}{1.0 \\cdot 10^{-7} s + 1}\\)\n\n\n\nAfter converting \\(H(s)\\) to NumPy, we can plot and display the poles, zeros, frequency response and step response.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\n#plt.xlim((-710,-700))\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.4f}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.4f}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz    Poles, Hz\n-----------  ------------\n             -1.59155e+06\n\n\nThe circuit above has just one pole in the voltage transfer function.\n\n# setup\nx_axis = np.logspace(3, 8, 2000, endpoint=False)*2*np.pi\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nref_w, ref_mag, ref_phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n# plot the magnitude and phase\nax1.semilogx(ref_w/(2*np.pi), ref_mag,'-k',label='ref_mag')    # magnitude plot\nax2.semilogx(ref_w/(2*np.pi), ref_phase,':k',label='ref_phase')  # phase plot\n\n#ax1.set_ylim((-40,5))\n\n# position legends\nax1.legend(loc='upper left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAs shown above the frequency response is a low pass filter.\n\n# define the time interval and create a square wave step waveform.\nt = np.linspace(0, .000006, 500, endpoint=False)\nref_sqr_signal = signal.square(2*np.pi*250000*t, duty=0.5) #/20+1/20\n\n# call lsim to generate the response signal\nref_t_step, ref_y_step, ref_x_step = signal.lsim(sys_tf, U=ref_sqr_signal, T=t)\n\nplt.plot(ref_t_step*1e3, ref_sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(ref_t_step*1e3, ref_y_step,'b', linewidth = 1.0, label='output')\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe frequency and step of #fig-t-coil-common_source (a) will be plotted together with the enhancements obtained by use of the Bridge T-coil.\n\n\n30.3.2 Common-Source Amplifier with Bridge T-Coil\nIn Figure 30.7, the FET has been replaced by a current source and the component values are set to one. Later the actual values will be substituted into the design equations.\n\n\n\n\n\n\nFigure 30.7: Common source amplifier with a Bridged T-coil circuit.\n\n\n\nThe circuit was drawn in LTSpice and the exported netlist was copied to the code below.\n\nCS_T_Coil_net_list = '''\n* CS-T-Coil.asc\nL1 2 1 1\nL2 3 2 1\nR 0 3 1\nC1 3 1 1\nC 2 0 1\nI1 0 1 1\nK L1 L2 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(CS_T_Coil_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(I_{1} = C_{1} s v_{1} - C_{1} s v_{3} - I_{L1}\\)\\(0 = C s v_{2} + I_{L1} - I_{L2}\\)\\(0 = - C_{1} s v_{1} + I_{L2} + v_{3} \\left(C_{1} s + \\frac{1}{R}\\right)\\)\\(0 = - I_{L1} L_{1} s - I_{L2} M s - v_{1} + v_{2}\\)\\(0 = - I_{L1} M s - I_{L2} L_{2} s - v_{2} + v_{3}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\nThe network equations for the circuit in Figure 30.7 can be solved symbolically and the node voltages and dependent currents using symbolic notation. At this point we can set \\(L_1=L_2=L\\) and then solve for the node voltages.\n\nL = symbols('L')\nU_sym = solve(NE_sym.subs({L1:L, L2:L}),X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C C_{1} I_{1} L^{2} R s^{4} - C C_{1} I_{1} M^{2} R s^{4} + C I_{1} L^{2} s^{3} + C I_{1} L R s^{2} - C I_{1} M^{2} s^{3} + 2 C_{1} I_{1} L R s^{2} + 2 C_{1} I_{1} M R s^{2} + 2 I_{1} L s + 2 I_{1} M s + I_{1} R}{C C_{1} L^{2} s^{4} + 2 C C_{1} L R s^{3} - C C_{1} M^{2} s^{4} + 2 C C_{1} M R s^{3} + C L s^{2} + C R s + 2 C_{1} L s^{2} + 2 C_{1} M s^{2} + 1}\\)\\(v_{2} = \\frac{2 C_{1} I_{1} L R s^{2} + 2 C_{1} I_{1} M R s^{2} + I_{1} L s + I_{1} M s + I_{1} R}{C C_{1} L^{2} s^{4} + 2 C C_{1} L R s^{3} - C C_{1} M^{2} s^{4} + 2 C C_{1} M R s^{3} + C L s^{2} + C R s + 2 C_{1} L s^{2} + 2 C_{1} M s^{2} + 1}\\)\\(v_{3} = \\frac{C C_{1} I_{1} L^{2} R s^{4} - C C_{1} I_{1} M^{2} R s^{4} - C I_{1} M R s^{2} + 2 C_{1} I_{1} L R s^{2} + 2 C_{1} I_{1} M R s^{2} + I_{1} R}{C C_{1} L^{2} s^{4} + 2 C C_{1} L R s^{3} - C C_{1} M^{2} s^{4} + 2 C C_{1} M R s^{3} + C L s^{2} + C R s + 2 C_{1} L s^{2} + 2 C_{1} M s^{2} + 1}\\)\\(I_{L1} = \\frac{- C C_{1} I_{1} L R s^{3} - C C_{1} I_{1} M R s^{3} - C I_{1} L s^{2} - C I_{1} R s - I_{1}}{C C_{1} L^{2} s^{4} + 2 C C_{1} L R s^{3} - C C_{1} M^{2} s^{4} + 2 C C_{1} M R s^{3} + C L s^{2} + C R s + 2 C_{1} L s^{2} + 2 C_{1} M s^{2} + 1}\\)\\(I_{L2} = \\frac{C C_{1} I_{1} L R s^{3} + C C_{1} I_{1} M R s^{3} + C I_{1} M s^{2} - I_{1}}{C C_{1} L^{2} s^{4} + 2 C C_{1} L R s^{3} - C C_{1} M^{2} s^{4} + 2 C C_{1} M R s^{3} + C L s^{2} + C R s + 2 C_{1} L s^{2} + 2 C_{1} M s^{2} + 1}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{2 C_{1} L R s^{2} + 2 C_{1} M R s^{2} + L s + M s + R}{C C_{1} L^{2} R s^{4} - C C_{1} M^{2} R s^{4} + C L^{2} s^{3} + C L R s^{2} - C M^{2} s^{3} + 2 C_{1} L R s^{2} + 2 C_{1} M R s^{2} + 2 L s + 2 M s + R}\\)\n\n\nThe numerator is a second order polynomial and the denominator is a fourth order polynomial. Generally, the order of the dominator is equal to the number of reactive elements in the circuit; sometimes roots of the numerator will exactly cancel with a root of the denominator polynomial. The roots of the numerator polynomial are called the zeros of the transfer function and the roots of the denominator are called the poles of the transfer function.\n\nH_sym_num, H_sym_denom = fraction(H_sym)\n\nThe numerator polynomial is:\n\nMarkdown('$N(s)={:s}$'.format(latex(H_sym_num.simplify())))\n\n\\(N(s)=2 C_{1} L R s^{2} + 2 C_{1} M R s^{2} + L s + M s + R\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(a_2\\), \\(a_1\\) and \\(a_0\\) in the expression:\n\\(a_2s^{2}+a_1s+a_0\\)\nwhere \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\na2 = H_sym_num.coeff(s**2)\na1 = H_sym_num.coeff(s**1)\na0 = (H_sym_num - a1*s*1 - a2*s**2).expand()\n\nMarkdown('&lt;p&gt;$a_2={:s}$&lt;/p&gt;&lt;p&gt;$a_1={:s}$&lt;/p&gt;&lt;p&gt;$a_0={:s}$&lt;/p&gt;'.format(latex(a2),latex(a1),latex(a0)))\n\n\n\\(a_2=2 C_{1} L R + 2 C_{1} M R\\)\n\n\n\\(a_1=L + M\\)\n\n\n\\(a_0=R\\)\n\n\n\nThe denominator polynomial is:\n\nMarkdown('$D(s)={:s}$'.format(latex(H_sym_denom.collect(s))))\n\n\\(D(s)=R + s^{4} \\left(C C_{1} L^{2} R - C C_{1} M^{2} R\\right) + s^{3} \\left(C L^{2} - C M^{2}\\right) + s^{2} \\left(C L R + 2 C_{1} L R + 2 C_{1} M R\\right) + s \\left(2 L + 2 M\\right)\\)\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(b_3\\), \\(b_2\\), \\(b_1\\) and \\(b_0\\) in the expression:\n\\(b_4s^4+b_3s^3+b_2s^2+b_1s+b_0\\)\nwhere \\(b_4\\), \\(b_3\\), \\(b_2\\), \\(b_1\\) and \\(b_0\\) are:\n\nb4 = H_sym_denom.coeff(s**4)\nb3 = H_sym_denom.coeff(s**3)\nb2 = H_sym_denom.coeff(s**2)\nb1 = H_sym_denom.coeff(s**1)\nb0 = (H_sym_denom - b1*s*1 - b2*s**2 - b3*s**3 - b4*s**4).expand()\nMarkdown('&lt;p&gt;$b_4={:s}$&lt;/p&gt;&lt;p&gt;$b_3={:s}$&lt;/p&gt;&lt;p&gt;$b_2={:s}$&lt;/p&gt;&lt;p&gt;$b_1={:s}$&lt;/p&gt;&lt;p&gt;$b_0={:s}$&lt;/p&gt;'.format(latex(b4),latex(b3),latex(b2),latex(b1),latex(b0)))\n\n\n\\(b_4=C C_{1} L^{2} R - C C_{1} M^{2} R\\)\n\n\n\\(b_3=C L^{2} - C M^{2}\\)\n\n\n\\(b_2=C L R + 2 C_{1} L R + 2 C_{1} M R\\)\n\n\n\\(b_1=2 L + 2 M\\)\n\n\n\\(b_0=R\\)\n\n\n\nThe fourth-order denominator may be expressed as the product of two second-order polynomials, one equal to the numerator, \\(N(s)\\) and another polynomial, \\(ps^2+qs+1\\). Creating two new SymPy symbols, \\(p\\) and \\(q\\), and multiplying the polynomials \\(D(s)=N(s)(ps^2+qs+1)\\) we get:\n\np, q = symbols('p q')\nMarkdown('&lt;p&gt;${:s}$&lt;/p&gt;'.format(latex(H_sym_num*(p*s**2+q*s+1))))\n\n\n\\(\\left(p s^{2} + q s + 1\\right) \\left(2 C_{1} L R s^{2} + 2 C_{1} M R s^{2} + L s + M s + R\\right)\\)\n\n\n\nExpanding and collecting the terms of \\(s\\) we get:\n\nA_sym = (H_sym_num*(p*s**2+q*s+1)).expand().collect(s)\nMarkdown('&lt;p&gt;${:s}$&lt;/p&gt;'.format(latex(A_sym)))\n\n\n\\(R + s^{4} \\cdot \\left(2 C_{1} L R p + 2 C_{1} M R p\\right) + s^{3} \\cdot \\left(2 C_{1} L R q + 2 C_{1} M R q + L p + M p\\right) + s^{2} \\cdot \\left(2 C_{1} L R + 2 C_{1} M R + L q + M q + R p\\right) + s \\left(L + M + R q\\right)\\)\n\n\n\nThe coefficients of each Laplace term can be equated to the variables \\(e_3\\), \\(e_2\\), \\(e_1\\) and \\(e_0\\) in the expression:\n\\(e_4s^4+e_3s^3+e_2s^2+e_1s+e_0\\)\nwhere \\(e_4\\), \\(e_3\\), \\(e_2\\), \\(e_1\\) and \\(e_0\\) are:\n\ne4 = A_sym.coeff(s**4)\ne3 = A_sym.coeff(s**3)\ne2 = A_sym.coeff(s**2)\ne1 = A_sym.coeff(s**1)\ne0 = (A_sym - e1*s*1 - e2*s**2 - e3*s**3 - e4*s**4).expand()\nMarkdown('&lt;p&gt;$e_4={:s}$&lt;/p&gt;&lt;p&gt;$e_3={:s}$&lt;/p&gt;&lt;p&gt;$e_2={:s}$&lt;/p&gt;&lt;p&gt;$e_1={:s}$&lt;/p&gt;&lt;p&gt;$e_0={:s}$&lt;/p&gt;'.format(latex(e4),latex(e3),latex(e2),latex(e1),latex(e0)))\n\n\n\\(e_4=2 C_{1} L R p + 2 C_{1} M R p\\)\n\n\n\\(e_3=2 C_{1} L R q + 2 C_{1} M R q + L p + M p\\)\n\n\n\\(e_2=2 C_{1} L R + 2 C_{1} M R + L q + M q + R p\\)\n\n\n\\(e_1=L + M + R q\\)\n\n\n\\(e_0=R\\)\n\n\n\nThe coefficients for each power of \\(s\\) in \\(D(s)\\) and \\(N(s)(ps^2+qs+1)\\) can be equated and we can solve for \\(p\\), \\(q\\). For example, the coefficients for \\(s^4\\) can be equated and written as their difference which equals zero.\n\nMarkdown('&lt;p&gt;${:s}=0$&lt;/p&gt;'.format(latex(e4 - b4)))\n\n\n\\(- C C_{1} L^{2} R + C C_{1} M^{2} R + 2 C_{1} L R p + 2 C_{1} M R p=0\\)\n\n\n\nWe can solve this system of equations:\n\\(e_4 - b_4 = 0\\)\n\\(e_3 - b_3 = 0\\)\n\\(e_2 - b_2 = 0\\)\n\\(e_1 - b_1 = 0\\)\nThere are four equations and five unknowns, \\(R\\), \\(L\\), \\(C\\), \\(C_1\\) and \\(M\\). \\(R\\) and \\(C\\) are usually given and not something we need to determine during the design procedure. If SymPy is asked to solve for \\(p\\), \\(q\\), \\(L\\) and \\(C_1\\), it returns multiple possible solutions:\n\nB_sym = solve([e4-b4, e3-b3, e2-b2, e1-b1], [p,q,L,C1])\n\ntemp = ''\nfor i in B_sym:\n    temp += '$(p,q,L,C1)={:s}$&lt;br&gt;'.format(latex(i))\n\nMarkdown(temp)\n\n\\((p,q,L,C1)=\\left( - C M, \\  0, \\  - M, \\  0\\right)\\)\\((p,q,L,C1)=\\left( - C M, \\  0, \\  - M, \\  C_{1}\\right)\\)\\((p,q,L,C1)=\\left( C \\left(- 2 M - R \\sqrt{C M}\\right), \\  - \\sqrt{C M}, \\  - M - R \\sqrt{C M}, \\  0\\right)\\)\\((p,q,L,C1)=\\left( C \\left(- 2 M + R \\sqrt{C M}\\right), \\  \\sqrt{C M}, \\  - M + R \\sqrt{C M}, \\  0\\right)\\)\\((p,q,L,C1)=\\left( \\frac{C \\left(C R^{2} - 4 M\\right)}{4}, \\  \\frac{C R}{2}, \\  \\frac{C R^{2}}{2} - M, \\  \\frac{C}{4} - \\frac{M}{R^{2}}\\right)\\)\n\n\nThe variables \\(L\\) and \\(C_1\\) in addition to \\(p\\) and \\(q\\), were chosen to be solved for, since in the numerical example below \\(R\\) and \\(C\\) will be inputs to the design. The last solution provided by SymPy gave non-zero expressions for \\(p\\), \\(q\\), \\(L\\) and \\(C_1\\). So we will use this solution. We can equate the variables as follows:\n\np_sym = B_sym[-1][0]\nq_sym = B_sym[-1][1]\nL_sym = B_sym[-1][2]\nC1_sym = B_sym[-1][3]\nMarkdown('&lt;p&gt;$p={:s}$&lt;/p&gt;&lt;p&gt;$q={:s}$&lt;/p&gt;&lt;p&gt;$L={:s}$&lt;/p&gt;&lt;p&gt;$C_1={:s}$&lt;/p&gt;'.format(latex(p_sym),latex(q_sym),latex(L_sym),latex(C1_sym)))\n\n\n\\(p=\\frac{C \\left(C R^{2} - 4 M\\right)}{4}\\)\n\n\n\\(q=\\frac{C R}{2}\\)\n\n\n\\(L=\\frac{C R^{2}}{2} - M\\)\n\n\n\\(C_1=\\frac{C}{4} - \\frac{M}{R^{2}}\\)\n\n\n\nNow we can get the new denominator of the transfer function, by substituting \\(p\\) and \\(q\\) into \\((ps^2+qs+1)\\), which results after the cancellation of the two of the poles with the zeros.\n\nD_new_sym = (p_sym*s**2+q_sym*s+1).simplify().expand().collect(s)\nMarkdown('&lt;p&gt;$D(s)={:s}$&lt;/p&gt;'.format(latex(D_new_sym)))\n\n\n\\(D(s)=\\frac{C R s}{2} + s^{2} \\left(\\frac{C^{2} R^{2}}{4} - C M\\right) + 1\\)\n\n\n\nThe coefficients of the \\(s\\) terms are:\n\ng2 = D_new_sym.coeff(s**2)\ng1 = D_new_sym.coeff(s**1)\ng0 = (D_new_sym - g1*s*1 - g2*s**2).expand()\n\nMarkdown('&lt;p&gt;$g_2={:s}$&lt;/p&gt;&lt;p&gt;$g_1={:s}$&lt;/p&gt;&lt;p&gt;$g_0={:s}$&lt;/p&gt;'.format(latex(g2),latex(g1),latex(g0)))\n\n\n\\(g_2=\\frac{C^{2} R^{2}}{4} - C M\\)\n\n\n\\(g_1=\\frac{C R}{2}\\)\n\n\n\\(g_0=1\\)\n\n\n\nAfter the cancellation of the two poles with the zeros, we get a two-pole low pass filter, the transfer function of the filter is:\n\\(H(s)=\\frac {\\omega_n^2}{s^2+\\frac {\\omega_n}{Q} s+\\omega_n^2}\\)\nFor this system, when Q &gt; ⁠1/2⁠ (i.e., when the system is under damped), it has two complex conjugate poles that each have a real part of −α. That is, the attenuation parameter α represents the rate of exponential decay of the oscillations (that is, of the output after an impulse) into the system. A higher quality factor implies a lower attenuation rate, and so high-Q systems oscillate for many cycles. For example, high-quality bells have an approximately pure sinusoidal tone for a long time after being struck by a hammer.\nEquating the coefficients:\n\\(\\omega_n^2=\\frac{g_0}{g_2}\\)\nand rearranging the terms:\n\\(\\omega_n=\\sqrt {\\frac{g_0}{g_2}}\\)\n\nomega_n = sqrt(g0/g2).simplify()\nMarkdown('The natural frequency, $\\omega_n={:s}$'.format(latex(omega_n)))\n\nThe natural frequency, \\(\\omega_n=2 \\sqrt{\\frac{1}{C \\left(C R^{2} - 4 M\\right)}}\\)\n\n\nThe coefficient of the \\(s\\) term is:\n\\(\\frac {\\omega_n}{Q}=\\frac {g_1}{g_2}\\)\nand rearranging the terms, we get the quality factor:\n\\(Q=\\frac {g_2 \\omega_n}{g_1}\\)\n\nquality_factor = (g2*omega_n/g1).simplify()\nMarkdown('The quality factor, $Q={:s}$'.format(latex(quality_factor)))\n\nThe quality factor, \\(Q=\\frac{\\sqrt{\\frac{1}{C \\left(C R^{2} - 4 M\\right)}} \\left(C R^{2} - 4 M\\right)}{R}\\)\n\n\nFor second order systems, the quality factor (Q) is a dimensionless parameter that describes the behavior of a system. A higher Q factor indicates less damping, while a lower Q factor indicates more damping.\n\nUnderdamped, \\(Q \\gt 0.5\\) or \\(\\zeta \\lt 0.5\\): The system’s output will oscillate before settling at its final value. A higher Q means the oscillations will be more pronounced and take longer to die out. Think of a plucked guitar string; it vibrates for a long time because it has a high Q.\nCritically Damped, \\(Q=0.5\\) or \\(\\zeta=0.5\\): The system reaches its final value as quickly as possible without any oscillation or overshoot. This is often the desired behavior for control systems, as it provides a fast and stable response.\nOverdamped, \\(Q \\lt 0.5\\) or \\(\\zeta \\gt 0.5\\): The system’s response is sluggish and approaches the final value slowly without any oscillation.\n\n\n\nzeta = (1/(2*quality_factor)).simplify()\nMarkdown('The damping ratio, $\\zeta={:s}$'.format(latex(zeta)))\n\nThe damping ratio, \\(\\zeta=\\frac{R}{2 \\sqrt{\\frac{1}{C \\left(C R^{2} - 4 M\\right)}} \\left(C R^{2} - 4 M\\right)}\\)\n\n\nThe damping ratio (\\(\\zeta\\)) that maximizes the bandwidth of a second-order system is \\(1/\\sqrt{2}\\). This specific value corresponds to a Butterworth response, which is characterized by a maximally flat frequency response in the passband.\nAnother criteria used in Bridged T-coil design is Maximally Flat Envelope Delay (MFED), also known as maximally flat group delay. This occurs when the system’s group delay is as constant or flat as possible over a range of frequencies, typically from zero up to the filter’s cutoff frequency. The damping ratio (\\(\\zeta\\)) that gives a MFED for a second-order system is \\(\\zeta=\\sqrt{3}/2\\). This is the damping ratio of a Bessel filter, which is specifically designed to have a maximally flat group delay in its passband.\nThe choice between maximum bandwidth or maximally flat group delay depends on design goals. If maximum bandwidth is desired, then \\(\\zeta = 1/\\sqrt{2}\\) should be used. If minimal intersymbol interference is the design goal, then \\(\\zeta=\\sqrt{3}/2\\) would be used.\nAt this point we can substitute in some numerical values.\nA \\(\\zeta = \\sqrt{0.5}\\) is used in the design since this will give the maximum rise time and minimal overshoot in the transient response.\nFor \\(\\zeta = \\sqrt{0.5}\\), \\(R=1000\\) and \\(C=100pF\\), solve for \\(M\\).\n\nCn = 100e-12\nRn = 1000\nMn = solve(zeta.subs({C:Cn, R:Rn})-sqrt(1/2), M)[0]\n#Mn = solve(zeta.subs({L:Ln, C:Cn, R:Rn})-1, M)[0]\nMarkdown('M={:.3e}'.format(Mn))\n\nM=1.250e-5\n\n\nNow the other values can be solved for.\n\nC1n=C1_sym.subs({C:Cn, R:Rn, M:Mn})\nLn=L_sym.subs({C:Cn,M:Mn,R:Rn})\n\nMarkdown('&lt;p&gt;$C_1={:.3e}$&lt;/p&gt;&lt;p&gt;$L={:.3e}$&lt;/p&gt;'.format(C1n,Ln))\n\n\n\\(C_1=1.250e-11\\)\n\n\n\\(L=3.750e-5\\)\n\n\n\nThe coupling coefficient, \\(k=\\frac{M}{\\sqrt{L_1L_2}}\\), is:\n\nK = Mn/sqrt(Ln*Ln)\nMarkdown('K={:.3f}'.format(K))\n\nK=0.333\n\n\n\nMaking the substitutions, we get a numerical transfer function.\n\nH = H_sym.subs({L:Ln, C:Cn, C1:C1n, R:Rn, M:Mn})\nMarkdown('&lt;p&gt;$H(s)={:s}$&lt;/p&gt;'.format(latex(H)))\n\n\n\\(H(s)=\\frac{1.25 \\cdot 10^{-12} s^{2} + 5.0 \\cdot 10^{-5} s + 1000}{1.5625 \\cdot 10^{-27} s^{4} + 1.25 \\cdot 10^{-19} s^{3} + 5.0 \\cdot 10^{-12} s^{2} + 0.0001 s + 1000}\\)\n\n\n\nAfter converting \\(H(s)\\) to NumPy, we can plot and display the poles, zeros, frequency response and step response.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\nplt.xlim((-3183200,-3183000))\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.5e}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.5e}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz                  Poles, Hz\n-------------------------  -------------------------\n-3.18310e+06+3.18310e+06j  -3.18310e+06+3.18310e+06j\n-3.18310e+06-3.18310e+06j  -3.18310e+06-3.18310e+06j\n                           -3.18310e+06+3.18310e+06j\n                           -3.18310e+06-3.18310e+06j\n\n\nThe two zeros are slightly different numerically than two of the poles, but close enough to effectively cancel. Also note that all the poles and zeros end up at the same frequency.\n\n# setup\nx_axis = np.logspace(3, 8, 2000, endpoint=False)*2*np.pi\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n# plot the magnitude and phase\nax1.semilogx(w/(2*np.pi), mag,'-b',label='T-coil mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':b',label='T-coil phase')  # phase plot\n\nax1.semilogx(ref_w/(2*np.pi), ref_mag,'-k',alpha=0.5, label='ref_mag')    # magnitude plot\nax2.semilogx(ref_w/(2*np.pi), ref_phase,':k',alpha=0.5, label='ref_phase')  # phase plot\n\nax1.set_ylim((-5,2))\n\n# position legends\nax1.legend(loc='lower left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows the frequency response for the reference amplifier along with the T-coil, in blue. As you can see, the T-coil amplifier has a greater bandwidth.\n\n# define the time interval and create a square wave step waveform.\nt = np.linspace(0, .000006, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*250000*t, duty=0.5) #/20+1/20\n\n# call lsim to generate the response signal\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step,'b', linewidth = 1.0, label='output')\n\n#plt.plot(ref_t_step*1e3, ref_sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(ref_t_step*1e3, ref_y_step,'k',  alpha = 0.5, linewidth = 1.0, label='ref_output')\n\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe increased bandwidth in the frequency response produces a slight overshoot in the step response compared to the reference common source amplifier.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Bridged T Coil</span>"
    ]
  },
  {
    "objectID": "Bridged-T-coil_v2.html#electrostatic-discharge-esd-protection",
    "href": "Bridged-T-coil_v2.html#electrostatic-discharge-esd-protection",
    "title": "30  Bridged T Coil",
    "section": "30.4 Electrostatic Discharge (ESD) Protection",
    "text": "30.4 Electrostatic Discharge (ESD) Protection\nT-coils are also used in Electrostatic Discharge (ESD) protection circuits, as they can effectively match the impedance of ESD devices over a broad band. The schematic shown in Figure 30.8 is representative of a Bridge T-coil with a Transient Voltage Suppressor (TVS) diode, \\(U_1\\). A TVS diode is a type of diode specifically designed to protect electronic circuits from damaging voltage spikes. Think of it as an electronic “safety valve”. When a sudden high-voltage event occures, the TVS diode “clamps” the voltage, diverting the excess current away from the sensitive components to ground. This process happens extremely fast, often in picoseconds, making them ideal for protecting against transients like those caused by lightning strikes, electrostatic discharge (ESD), or the switching of inductive loads. Once the transient has passed and the voltage returns to normal, the diode automatically reverts to its high-impedance, non-conducting state. Most TVS diodes have appear as a capacitive element in the circuit during the off state. In Figure 30.8, \\(U_1\\) can be modeled as a capacitor. The off state capacitance varies widely from less than a 1 pF to 25 pF depending on the specifications of the TVS diode.\n\n\n\n\n\n\nFigure 30.8: T-Coil-TVS schematic.\n\n\n\nIn the circuit above, \\(V_1\\) is the input source voltage to the network, which could also be susceptible to voltage transients, but the off state capacitance of \\(U_1\\) would limit the bandwidth, if it was used without the Bridge T-coil. The component values have been set to one in the schematic, since these will be calculated in the design steps that follows. Figure 30.8 was drawn in LTSpice and the netlist was copied into the code. \\(U_1\\) has been replaced by \\(C\\) in the netlist.\n\nT_Coil_TVS_net_list = '''\n* T-Coil-TVS_v1.asc\nV1 1 0 1\nL1 4 3 1\nL2 2 4 1\nC1 2 3 1\nR2 2 0 1\nC 4 0 1\nR1 3 1 1\nK L1 L2 1\n'''\n\nThe MNA equations are generated from the function SymMNA.smna.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(T_Coil_TVS_net_list)\n\nThe code below assembles the network equations from the MNA matrices and displays the equations.\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# display the equations\ntemp = ''\nfor i in range(shape(NE_sym.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_sym.rhs[i]),latex(NE_sym.lhs[i]))\nMarkdown(temp)\n\n\\(0 = I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}}\\)\\(0 = - C_{1} s v_{3} + I_{L2} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right)\\)\\(0 = - C_{1} s v_{2} - I_{L1} + v_{3} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{1}}\\)\\(0 = C s v_{4} + I_{L1} - I_{L2}\\)\\(V_{1} = v_{1}\\)\\(0 = - I_{L1} L_{1} s - I_{L2} M s - v_{3} + v_{4}\\)\\(0 = - I_{L1} M s - I_{L2} L_{2} s + v_{2} - v_{4}\\)\n\n\nThe free symbols are entered as SymPy variables and the element values are put into a dictionary.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\nelement_values = SymMNA.get_part_values(network_df)\n\nThe network equations for the circuit in Figure 30.8 can be solved symbolically and the node voltages and dependent currents using symbolic notation.\n\nU_sym = solve(NE_sym,X)\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C C_{1} L_{1} L_{2} R_{2} V_{1} s^{4} - C C_{1} M^{2} R_{2} V_{1} s^{4} - C M R_{2} V_{1} s^{2} + C_{1} L_{1} R_{2} V_{1} s^{2} + C_{1} L_{2} R_{2} V_{1} s^{2} + 2 C_{1} M R_{2} V_{1} s^{2} + R_{2} V_{1}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C C_{1} L_{1} L_{2} R_{2} V_{1} s^{4} - C C_{1} M^{2} R_{2} V_{1} s^{4} + C L_{1} L_{2} V_{1} s^{3} + C L_{1} R_{2} V_{1} s^{2} - C M^{2} V_{1} s^{3} + C_{1} L_{1} R_{2} V_{1} s^{2} + C_{1} L_{2} R_{2} V_{1} s^{2} + 2 C_{1} M R_{2} V_{1} s^{2} + L_{1} V_{1} s + L_{2} V_{1} s + 2 M V_{1} s + R_{2} V_{1}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\\(v_{4} = \\frac{C_{1} L_{1} R_{2} V_{1} s^{2} + C_{1} L_{2} R_{2} V_{1} s^{2} + 2 C_{1} M R_{2} V_{1} s^{2} + L_{2} V_{1} s + M V_{1} s + R_{2} V_{1}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C C_{1} L_{1} L_{2} V_{1} s^{4} - C C_{1} L_{1} R_{2} V_{1} s^{3} - C C_{1} L_{2} R_{2} V_{1} s^{3} + C C_{1} M^{2} V_{1} s^{4} - 2 C C_{1} M R_{2} V_{1} s^{3} - C L_{2} V_{1} s^{2} - C R_{2} V_{1} s - C_{1} L_{1} V_{1} s^{2} - C_{1} L_{2} V_{1} s^{2} - 2 C_{1} M V_{1} s^{2} - V_{1}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{- C C_{1} L_{2} R_{2} V_{1} s^{3} - C C_{1} M R_{2} V_{1} s^{3} - C L_{2} V_{1} s^{2} - C R_{2} V_{1} s - V_{1}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\\(I_{L2} = \\frac{C C_{1} L_{1} R_{2} V_{1} s^{3} + C C_{1} M R_{2} V_{1} s^{3} + C M V_{1} s^{2} - V_{1}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\n\n\nThe network transfer function, \\(H(s)=\\frac {v_2(s)}{v_1(s)}\\) is:\n\nH_sym = (U_sym[v2]/U_sym[v1]).cancel()\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C C_{1} L_{1} L_{2} R_{2} s^{4} - C C_{1} M^{2} R_{2} s^{4} - C M R_{2} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{2} s^{2} + R_{2}}{C C_{1} L_{1} L_{2} R_{1} s^{4} + C C_{1} L_{1} L_{2} R_{2} s^{4} + C C_{1} L_{1} R_{1} R_{2} s^{3} + C C_{1} L_{2} R_{1} R_{2} s^{3} - C C_{1} M^{2} R_{1} s^{4} - C C_{1} M^{2} R_{2} s^{4} + 2 C C_{1} M R_{1} R_{2} s^{3} + C L_{1} L_{2} s^{3} + C L_{1} R_{2} s^{2} + C L_{2} R_{1} s^{2} - C M^{2} s^{3} + C R_{1} R_{2} s + C_{1} L_{1} R_{1} s^{2} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} L_{2} R_{2} s^{2} + 2 C_{1} M R_{1} s^{2} + 2 C_{1} M R_{2} s^{2} + L_{1} s + L_{2} s + 2 M s + R_{1} + R_{2}}\\)\n\n\nBoth numerator and denominator are fourth order polynomials.\nMaking some substitutions, \\(L_1=L_2=L\\) and \\(R=R_1=R_2\\).\n\nL, R = symbols('L R')\nH_sym = H_sym.subs({L1:L,L2:L,R1:R,R2:R})\n#H_sym = H_sym.subs({L1:L,L2:L,C:50e-12,R:50})\nMarkdown('$H(s)={:s}$'.format(latex(H_sym)))\n\n\\(H(s)=\\frac{C C_{1} L^{2} R s^{4} - C C_{1} M^{2} R s^{4} - C M R s^{2} + 2 C_{1} L R s^{2} + 2 C_{1} M R s^{2} + R}{2 C C_{1} L^{2} R s^{4} + 2 C C_{1} L R^{2} s^{3} - 2 C C_{1} M^{2} R s^{4} + 2 C C_{1} M R^{2} s^{3} + C L^{2} s^{3} + 2 C L R s^{2} - C M^{2} s^{3} + C R^{2} s + 4 C_{1} L R s^{2} + 4 C_{1} M R s^{2} + 2 L s + 2 M s + 2 R}\\)\n\n\n\\(\\zeta\\) and the symbolic expressions for \\(C1\\) and \\(L\\) from above can be used to calculate the component values for the TVS circuit. For \\(\\zeta = \\sqrt{0.5}\\), \\(R=50\\) and \\(C=10pF\\), solve for \\(M\\).\n\nCn = 10e-12\nRn = 50\nMn = solve(zeta.subs({C:Cn, R:Rn})-sqrt(1/2), M)[0]\nMarkdown('M={:.3e}'.format(Mn))\n\nM=3.125e-9\n\n\nNow the other values can be solved for.\n\nC1n=C1_sym.subs({C:Cn, R:Rn, M:Mn})\nLn=L_sym.subs({C:Cn,M:Mn,R:Rn})\n\nMarkdown('&lt;p&gt;$C_1={:.3e}$&lt;/p&gt;&lt;p&gt;$L={:.3e}$&lt;/p&gt;'.format(C1n,Ln))\n\n\n\\(C_1=1.250e-12\\)\n\n\n\\(L=9.375e-9\\)\n\n\n\nThe coupling coefficient, \\(k=\\frac{M}{\\sqrt{L_1L_2}}\\), is:\n\nK = Mn/sqrt(Ln*Ln)\nMarkdown('K={:.3f}'.format(K))\n\nK=0.333\n\n\n\nMaking the substitutions, we get a numerical transfer function.\n\nH = H_sym.subs({L:Ln, C:Cn, C1:C1n, R:Rn, M:Mn})\nMarkdown('&lt;p&gt;$H(s)={:s}$&lt;/p&gt;'.format(latex(H)))\n\n\n\\(H(s)=\\frac{4.88281249999999 \\cdot 10^{-38} s^{4} - 3.00926553810506 \\cdot 10^{-33} s^{2} + 50}{9.76562499999998 \\cdot 10^{-38} s^{4} + 1.5625 \\cdot 10^{-27} s^{3} + 1.25 \\cdot 10^{-17} s^{2} + 5.0 \\cdot 10^{-8} s + 100}\\)\n\n\n\nAfter converting \\(H(s)\\) to NumPy, we can plot and display the poles, zeros, frequency response and step response.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to NumPy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\n\nsys_tf = signal.TransferFunction(a,b)\n\nThe poles and zeros of the transfer function can easily be obtained with the following code:\n\nsys_zeros = np.roots(sys_tf.num)\nsys_poles = np.roots(sys_tf.den)\n\nThe poles and zeros of the transfer function are plotted on the complex frequency plane with the following code:\n\nplt.plot(np.real(sys_zeros/(2*np.pi)), np.imag(sys_zeros/(2*np.pi)), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles/(2*np.pi)), np.imag(sys_poles/(2*np.pi)), 'xr')\n#plt.xlim((-3183200,-3183000))\nplt.legend(['Zeros', 'Poles'], loc=0)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe code below generates a table that lists the values of the pole and zero locations.\n\ntable_header = ['Zeros, Hz', 'Poles, Hz']\nnum_table_rows = max(len(sys_zeros),len(sys_poles))\ntable_row = []\n\nfor i in range(num_table_rows):\n    if i &lt; len(sys_zeros):\n        z = '{:.5e}'.format(sys_zeros[i]/(2*np.pi))\n    else:\n        z = ''\n    if i &lt; len(sys_poles):\n        p = '{:.5e}'.format(sys_poles[i]/(2*np.pi))\n    else:\n        p = ''\n    table_row.append([z,p])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\nZeros, Hz                  Poles, Hz\n-------------------------  -------------------------\n-6.36620e+08+6.36620e+08j  -6.36620e+08+6.36620e+08j\n-6.36620e+08-6.36620e+08j  -6.36620e+08-6.36620e+08j\n6.36620e+08+6.36620e+08j   -6.36620e+08+6.36620e+08j\n6.36620e+08-6.36620e+08j   -6.36620e+08-6.36620e+08j\n\n\nTwo poles cancel with two zeros, effectively producing an all pass transfer function.\n\n# setup\nx_axis = np.logspace(7, 11, 2000, endpoint=False)*2*np.pi\n\n# plot\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'k'\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nw, mag, phase = signal.bode((a, b), w=x_axis) # returns: rad/s, mag in dB, phase in deg\n\n# plot the magnitude and phase\nax1.semilogx(w/(2*np.pi), mag,'-b',label='T-coil mag')    # magnitude plot\nax2.semilogx(w/(2*np.pi), phase,':b',label='T-coil phase')  # phase plot\n\nax1.set_ylim((-10,0))\n\n# position legends\nax1.legend(loc='lower left')\nax2.legend(loc='upper right')\n\nax1.grid()\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nAs shown in the plot above, the frequency response of Figure 30.8 is flat. There is some insertion loss caused by the voltage divider between \\(R_1\\) and \\(R_2\\).\n\n# define the time interval and create a square wave step waveform.\nt = np.linspace(0, 1e-7, 500, endpoint=False)\nsqr_signal = signal.square(2*np.pi*20e6*t, duty=0.5) #/20+1/20\n\n# call lsim to generate the response signal\nt_step, y_step, x_step = signal.lsim(sys_tf, U=sqr_signal, T=t)\n\nplt.plot(t_step*1e3, sqr_signal, 'r', alpha = 1.0, linewidth=1, label='input')\nplt.plot(t_step*1e3, y_step,'b', linewidth = 1.0, label='output')\n\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\nplt.legend(loc='best')\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\nThe step response shows a small amount of overshoot.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Bridged T Coil</span>"
    ]
  },
  {
    "objectID": "Bridged-T-coil_v2.html#summary",
    "href": "Bridged-T-coil_v2.html#summary",
    "title": "30  Bridged T Coil",
    "section": "30.5 Summary",
    "text": "30.5 Summary\nThis Jupyter notebook chapter describes a circuit called Bridged T-Coil, which can be used to increase bandwidth in some applications. I first encountered the circuit in the book Analog Circuit Design: Art, Science and Personalities edited by Jim Williams. The notebook discusses the history of the circuit, noting its use in oscilloscope amplifiers by Tektronix engineers in the 1960s, where its design was considered a trade secret for many years. Python is used to analyze the circuit with the Modified Nodal Analysis (MNA) method, displaying the resulting symbolic equations and transfer functions for various circuit configurations.\nThe advantages of using bridged T-coils are highlighted, including:\n\nExtending a circuit’s bandwidth.\nServing as an impedance matching circuit in ESD (Electrostatic Discharge) protection circuits.\n\n\n\n\n\nGinzton, E. L., W. R. Hewlett, J. H. Jasberg, and J. D. Noe. 1948. “Distributed Amplification.” Proceedings of the IRE 36 (8): 956–69. https://doi.org/10.1109/JRPROC.1948.231624.\n\n\nParamesh, Jeyanandh, and David J. Allstot. 2006. “Analysis of the Bridged t-Coil Circuit Using the Extra-Element Theorem.” IEEE Transactions on Circuits and Systems II: Express Briefs 53 (12): 1408–12. https://doi.org/10.1109/TCSII.2006.885971.\n\n\nRazavi, Behzad. 2015. “The Bridged t-Coil [a Circuit for All Seasons].” IEEE Solid-State Circuits Magazine 7 (4): 9–13. https://doi.org/10.1109/MSSC.2015.2474258.\n\n\nRoss, Bob. 2011. “T-Coils and Bridged-t Networks.” 2011. https://ibis.org/summits/may11/ross2.pdf.\n\n\nRoss, Bob, and Cong Ling. 2022. “Wang Algebra: From Theory to Practice.” IEEE Open Journal of Circuits and Systems 3: 274–85. https://doi.org/10.1109/OJCAS.2022.3217065.\n\n\nShekhar, S., J. S. Walling, and D. J. Allstot. 2006. “Bandwidth Extension Techniques for CMOS Amplifiers.” IEEE Journal of Solid-State Circuits 41 (11): 2424–39. https://doi.org/10.1109/JSSC.2006.883336.\n\n\nWang, K. T. 1934. “On a New Method of Analysis of Electrical Networks.” Memoirs 2, Nat. Res. Inst. Eng. Academia Sinica, Pp. 1-11, 1934.\n\n\nWilliams, J. 1991. Analog Circuit Design: Art, Science and Personalities. EDN Series for Design Engineers. Elsevier Science.\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley & Sons.",
    "crumbs": [
      "Example Problems",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Bridged T Coil</span>"
    ]
  },
  {
    "objectID": "Validation-tests.html",
    "href": "Validation-tests.html",
    "title": "Validation Tests",
    "section": "",
    "text": "Summary of test results\nBasic validation of the Python code consisted of analyzing simple networks and examining the results. A more comprehensive evaluation of the code was performed by solving test circuits and comparing the results to LTSpice. It is assumed, without offering any mathematical proof, that if the NumPy numerical solution agrees with the LTSpice solution, the SymPy symbolic solution is also correct.\nCode verification often looks at requirements or specifications versus what was implemented. This project didn’t have a formal set of requirements, only a general goal of implementing symbolic MNA using the Python libraries. No formal software or code verification is included.\nThe circuits used in the validation tests are listed below. The validation circuits are a collection of problems from textbooks or large and complex circuits that I made up that include various elements or unique combinations of elements or topologies. The circuits range from simple to large and complex. The largest circuit consists of 32 nodes, 59 branches and multiple instances of all of the supported element types.\nIn LTSpice the series resistance for inductors defaults to 1e-3 Ohms unless set to zero. Leaving the default series inductance at 1e-3 Ohms will cause small numerical differences in the solution obtained by LTSpice.\nLTSpice displays results using 6 digits, with zero to two digits to the left of the decimal point and the remainder of the digits to the right of the decimal point. The Python results can be displayed with 6 digits to the left of the decimal point. So when comparing the numerical results there will be some rounding differences. Most of the test circuits analyzed with the MNA Python code produced numerical results that were identical within rounding, to those obtained from LTSpice. However, there were a few exceptions discussed below.",
    "crumbs": [
      "Validation Tests"
    ]
  },
  {
    "objectID": "Validation-tests.html#summary-of-test-results",
    "href": "Validation-tests.html#summary-of-test-results",
    "title": "Validation Tests",
    "section": "",
    "text": "Test circuit 8\n\nThe circuit shown above is the test circuit for Test 8. This circuit is too large to produce meaningful symbolic solutions. The numeric results obtained from the Python MNA code have larger differences to LTSpice than was typical for the other test circuits. There are small differences at \\(\\omega = 0\\) and \\(\\omega = 1\\) between the Python NMA code and LTSpice solutions; with the differences being less than 0.001. The results for the AC sweep had larger differences. The magnitude and phase results over the frequency range of 0.01 to 10 Hz shows that the magnitude difference was as much as 0.005 and the phase was as much as 0.02 difference. At this time I don’t have an explanation for the differences.\n\n\nTest circuit 12\n\nThe Python MNA code produced node voltage solutions for the AC sweep that were slightly different from those obtained from LTSpice for the test circuit shown above. The magnitude difference was at most 0.001 and the phase difference was as much as 0.175 degrees. I’m not sure why for some circuits there is an almost exact numerical agreement to the LTSpice results and for other circuits there is as much as a 0.001 difference.\n\n\nTest circuit 13\n\nThe circuit constructed for Test 13, shown above, was designed to see how the MNA code would handle such an unusual circuit. A loop of inductors and current sources is not a typical circuit configuration. LTSpice produced an error during the operating point analysis, whereas the Python MNA code would generate network equations without issue. However, the Python code would not produce a solution for all the circuit unknowns; the current in L4 was not determined. To fix this problem a small series resistor was added to L1.\nIf we stop to consider how the circuit is operating at DC, we see that each of the current sources have an inductor in parallel, which at DC, acts as a short circuit. Which means that the node voltages would all be equal, \\(v_1 = v_2 = v_3 = v_{ref}\\). So the solution to the network equations at DC should be \\(v_1 = v_2 = v_3 = 0\\). At a frequency of \\(\\omega = \\infty\\), the inductors would act as an open circuits and the currents flowing into each node would not be equal, because the current sources are not equal or opposite, so Kirchhoff’s current law would be violated. So this is a pathological case and such cases might not be obvious by inspection. Also, without the small series resistor added to L1, the AC analysis results produced by the Python MNA code agreed with the LTSpice results. The conclusion is that some sort of sanity check is needed for the circuit and just because the Python code spits out answers that are correct at some frequencies, it does not mean that the MNA circuit equations are valid at all frequencies.\n\n\nTest circuit 14\n\nThe circuit above was designed to have only one unknown current. The magnitude difference was at most 0.006 and the phase difference was as much as 0.6 degrees between the Python MNA and LTSpice results. It is kind of curious that circuits for Tests 12, 13, and 14 which are all driven by sinusoidal current sources have AC solutions which are slightly different from LTSpice.  \nThe following file types are archived here:\n\n\n\n\n\n\n\nfile name\nDescription\n\n\n\n\ntest_*.asc\nLTSpice circuit schematic\n\n\nreadme.md\na description of the circuit\n\n\ntest_*.ipynb\ntest report Jupyter notebook\n\n\ntest_*.net\nSpice net list\n\n\ntest_*.png\nimage of the schematic for display in the notebook\n\n\ntest_*.csv\ncsv data exported from LTSpice",
    "crumbs": [
      "Validation Tests"
    ]
  },
  {
    "objectID": "test_1.html",
    "href": "test_1.html",
    "title": "31  Test 1",
    "section": "",
    "text": "31.1 Load the netlist\nThe circuit in Figure 31.1 is from Johnson, Hilburn, and Johnson (1978) (Figure 4.8). The circuit has five nodes and nine branches. There are two independent voltage sources, V1 and V2. The value of V2 is 0 volts and the current through V2 is needed for F1, the current controlled current source. There is one independent current source, I1. E1 is a voltage controlled voltage source. The circuit contains four resistors.\nThe netlist for Figure 31.1 was generated by LTSpice and show below:\nThe following Python modules are used in this notebook.\nThe netlist for the circuit is pasted into the code cell below. In Python a triple-quoted string includes whitespace, tabs and newlines. The newlines characters are needed to mark the end of each SPICE statement in the netlist.\nnet_list = '''\nR2 1 2 1\nR3 4 3 1\nR4 2 5 2\nV1 1 0 2\nI1 4 0 9\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_1.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "31  Test 1",
    "section": "31.2 Call the symbolic modified nodal analysis function",
    "text": "31.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nThe network equations for the circuit can be obtained from the A, X and Z values returned from the SMNA function. The A, X and Z are formulated into equations and displayed below. Markdown is an IPython function and latex is a SymPy printing function.\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{F1} + v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} + \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\n\n\n\n31.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 4\nnumber of RLC (passive components): 4\nnumber of inductors: 0\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n31.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 1\\\\0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 1 & -1\\\\- \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{4}} & 0 & 0 & \\frac{1}{R_{4}} & 0 & -1 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1\\end{matrix}\\right]\\)\n\n\n\n\n31.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}\\right]\\)\n\n\n\n\n31.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0\\right]\\)\n\n\n\n\n31.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n3\nR3\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n4\nR4\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nI1\n4\n0\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n6\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n31.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n\n\n\n\n\n\n\n31.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} - \\frac{v_{4}}{R_{1}} = 0\\)\\(I_{F1} + v_{2} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{4}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} + \\frac{v_{3}}{R_{3}} - \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{4}} + \\frac{v_{5}}{R_{4}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\n\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{4}, \\  v_{3}, \\  ea_{1}, \\  I_{1}, \\  R_{2}, \\  R_{1}, \\  I_{Ea1}, \\  I_{V1}, \\  v_{1}, \\  f_{1}, \\  V_{2}, \\  I_{F1}, \\  I_{V2}, \\  v_{5}, \\  R_{4}, \\  R_{3}, \\  v_{2}, \\  V_{1}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#symbolic-solution",
    "href": "test_1.html#symbolic-solution",
    "title": "31  Test 1",
    "section": "31.3 Symbolic solution",
    "text": "31.3 Symbolic solution\nThe network equations can be solved symbolically.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{- R_{2} V_{2} f_{1} + R_{2} V_{2} - R_{4} V_{1}}{R_{2} f_{1} - R_{2} - R_{4}}\\)\\(v_{3} = \\frac{I_{1} R_{1} R_{3} ea_{1} + R_{1} V_{1} ea_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}\\)\\(v_{4} = \\frac{- I_{1} R_{1} R_{3} + R_{1} V_{1} ea_{1} + R_{3} V_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}\\)\\(v_{5} = - V_{2}\\)\\(I_{V1} = \\frac{- I_{1} R_{2} R_{3} f_{1} + I_{1} R_{2} R_{3} + I_{1} R_{3} R_{4} - R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} ea_{1} - R_{1} V_{1} f_{1} + R_{1} V_{1} - R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} ea_{1} - R_{1} V_{2} f_{1} + R_{1} V_{2} - R_{2} V_{1} f_{1} + R_{2} V_{1} - R_{3} V_{1} f_{1} + R_{3} V_{1} - R_{3} V_{2} f_{1} + R_{3} V_{2} + R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}\\)\\(I_{V2} = \\frac{V_{1} + V_{2}}{R_{2} f_{1} - R_{2} - R_{4}}\\)\\(I_{Ea1} = \\frac{- I_{1} R_{1} R_{2} ea_{1} f_{1} + I_{1} R_{1} R_{2} ea_{1} - I_{1} R_{1} R_{2} f_{1} + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{4} ea_{1} + I_{1} R_{1} R_{4} + R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} f_{1} + R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} f_{1} + R_{2} V_{1} f_{1} - R_{2} V_{1} + R_{3} V_{1} f_{1} + R_{3} V_{2} f_{1} - R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}\\)\\(I_{F1} = \\frac{V_{1} f_{1} + V_{2} f_{1}}{R_{2} f_{1} - R_{2} - R_{4}}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#construct-a-dictionary-of-element-values",
    "href": "test_1.html#construct-a-dictionary-of-element-values",
    "title": "31  Test 1",
    "section": "31.4 Construct a dictionary of element values",
    "text": "31.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 2.0\nV2 = 0.0\nR2 = 1.0\nR3 = 1.0\nR4 = 2.0\nI1 = 9.0\nea1 = 2.0\nf1 = 2.0\nR1 = 2.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_1.html#numerical-solution",
    "href": "test_1.html#numerical-solution",
    "title": "31  Test 1",
    "section": "31.5 Numerical solution",
    "text": "31.5 Numerical solution\nSubstitute numerical values in place of the symbolic reference designators.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.5 v_{1} - 1.0 v_{2} - 0.5 v_{4}\\)\\(0 = I_{F1} - 1.0 v_{1} + 1.5 v_{2} - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} + 1.0 v_{3} - 1.0 v_{4}\\)\\(-9.0 = - 0.5 v_{1} - 1.0 v_{3} + 1.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(2.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution. Six significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           4.000000\nv3           6.285714\nv4          -1.142857\nv5           0.000000\nI_V1         0.428571\nI_V2        -2.000000\nI_Ea1      -11.428571\nI_F1        -4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Test 1</span>"
    ]
  },
  {
    "objectID": "test_2.html",
    "href": "test_2.html",
    "title": "32  Test 2",
    "section": "",
    "text": "32.1 Load the net list\nTest circuit number 2 is a network consisting of resistors, voltage sources and current sources and drawn using LTSpice. The nodes are numbered left to right and bottom to top. Only independent sources are in this network. The network has 22 branches and 12 nodes, this will generate a large number of equations to test SymPy and my computer’s ability to generate symbolic solutions.\nThe net list for the circuit was generated by LTSpice and show below:\nThe following Python modules are used in this notebook.\nnet_list = '''\nR1 9 5 5\nR2 5 1 2\nR5 6 2 3\nR6 2 0 5\nR8 8 7 8\nR10 10 9 9\nR11 6 5 4\nR12 2 1 2\nR14 7 6 10\nR15 11 10 5\nV1 9 0 10\nV2 1 0 2\nV3 7 3 3\nV4 7 11 5\nI1 4 0 3\nI2 2 3 1\nI3 10 6 2\nI4 8 12 2\nR7 8 4 10\nR16 3 0 6\nR3 12 11 10\nR4 4 3 3\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_2.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "32  Test 2",
    "section": "32.2 Call the symbolic modified nodal analysis function",
    "text": "32.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{5}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{6}}{R_{5}} - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(v_{4} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = - I_{1}\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{6}}{R_{11}} - \\frac{v_{9}}{R_{1}} = 0\\)\\(v_{6} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{2}}{R_{5}} - \\frac{v_{7}}{R_{14}} - \\frac{v_{5}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{7} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{6}}{R_{14}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}}\\right) - \\frac{v_{7}}{R_{8}} - \\frac{v_{4}}{R_{7}} = - I_{4}\\)\\(I_{V1} + v_{9} \\cdot \\left(\\frac{1}{R_{10}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{10}}{R_{10}} - \\frac{v_{5}}{R_{1}} = 0\\)\\(v_{10} \\cdot \\left(\\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{11}}{R_{15}} - \\frac{v_{9}}{R_{10}} = - I_{3}\\)\\(- I_{V4} + v_{11} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{12}}{R_{3}} - \\frac{v_{10}}{R_{15}} = 0\\)\\(- \\frac{v_{11}}{R_{3}} + \\frac{v_{12}}{R_{3}} = I_{4}\\)\\(v_{9} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(- v_{3} + v_{7} = V_{3}\\)\\(- v_{11} + v_{7} = V_{4}\\)\n\n\nThe MNA method generates 16 equations. Given that this circuit has 12 nodes and is plannar so that 10 loop currents can be defined, it would seem that 10 or 13 equations would be sufficient to characterize the circuit. The generation of extra equations compaired to application of Kirchhoff’s current law (KCL) or Kirchhoff’s voltage law (KVL) requires more work to solve for the unknows.\n\n32.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 22\nnumber of branches: 22\nnumber of nodes: 12\nnumber of unknown currents: 4\nnumber of RLC (passive components): 14\nnumber of inductors: 0\nnumber of independent voltage sources: 4\nnumber of independent current sources: 4\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n32.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{5}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & - \\frac{1}{R_{5}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{5}} + \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\\\0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & - \\frac{1}{R_{8}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & \\frac{1}{R_{10}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{10}} & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{10}} & \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{3}} + \\frac{1}{R_{15}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n32.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}\\right]\\)\n\n\n\n\n32.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  - I_{1}, \\  0, \\  I_{3}, \\  0, \\  - I_{4}, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}\\right]\\)\n\n\n\n\n32.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n9\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n7\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n7\n11\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nR1\n9\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n5\nR2\n5\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n6\nR5\n6\n2\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n7\nR6\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n8\nR8\n8\n7\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n9\nR10\n10\n9\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n10\nR11\n6\n5\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n11\nR12\n2\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n12\nR14\n7\n6\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n13\nR15\n11\n10\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n14\nI1\n4\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n15\nI2\n2\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n16\nI3\n10\n6\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n17\nI4\n8\n12\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n18\nR7\n8\n4\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n19\nR16\n3\n0\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n20\nR3\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n21\nR4\n4\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n32.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n9\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n7\n3\n\n\n3\nV4\n7\n11\n\n\n\n\n\n\n\n\n\n32.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( V_{2}, \\  R_{1}, \\  I_{V2}, \\  v_{6}, \\  R_{14}, \\  I_{V1}, \\  V_{4}, \\  R_{3}, \\  R_{7}, \\  R_{5}, \\  R_{4}, \\  I_{2}, \\  v_{12}, \\  I_{3}, \\  v_{8}, \\  R_{16}, \\  v_{11}, \\  R_{15}, \\  v_{3}, \\  v_{1}, \\  v_{5}, \\  I_{V3}, \\  v_{10}, \\  R_{11}, \\  V_{1}, \\  I_{V4}, \\  v_{4}, \\  R_{8}, \\  v_{9}, \\  V_{3}, \\  R_{12}, \\  R_{6}, \\  R_{10}, \\  I_{4}, \\  I_{1}, \\  R_{2}, \\  v_{2}, \\  v_{7}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#symbolic-solution",
    "href": "test_2.html#symbolic-solution",
    "title": "32  Test 2",
    "section": "32.3 Symbolic solution",
    "text": "32.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#construct-a-dictionary-of-element-values",
    "href": "test_2.html#construct-a-dictionary-of-element-values",
    "title": "32  Test 2",
    "section": "32.4 Construct a dictionary of element values",
    "text": "32.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nV2 = 2.0\nV3 = 3.0\nV4 = 5.0\nR1 = 5.0\nR2 = 2.0\nR5 = 3.0\nR6 = 5.0\nR8 = 8.0\nR10 = 9.0\nR11 = 4.0\nR12 = 2.0\nR14 = 10.0\nR15 = 5.0\nI1 = 3.0\nI2 = 1.0\nI3 = 2.0\nI4 = 2.0\nR7 = 10.0\nR16 = 6.0\nR3 = 10.0\nR4 = 3.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_2.html#numerical-solution",
    "href": "test_2.html#numerical-solution",
    "title": "32  Test 2",
    "section": "32.5 Numerical solution",
    "text": "32.5 Numerical solution\nSubstitute numerical values in place the symbolic reference designators.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{5}\\)\\(-1.0 = - 0.5 v_{1} + 1.03333333333333 v_{2} - 0.333333333333333 v_{6}\\)\\(1.0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(-3.0 = - 0.333333333333333 v_{3} + 0.433333333333333 v_{4} - 0.1 v_{8}\\)\\(0 = - 0.5 v_{1} + 0.95 v_{5} - 0.25 v_{6} - 0.2 v_{9}\\)\\(2.0 = - 0.333333333333333 v_{2} - 0.25 v_{5} + 0.683333333333333 v_{6} - 0.1 v_{7}\\)\\(0 = I_{V3} + I_{V4} - 0.1 v_{6} + 0.225 v_{7} - 0.125 v_{8}\\)\\(-2.0 = - 0.1 v_{4} - 0.125 v_{7} + 0.225 v_{8}\\)\\(0 = I_{V1} - 0.111111111111111 v_{10} - 0.2 v_{5} + 0.311111111111111 v_{9}\\)\\(-2.0 = 0.311111111111111 v_{10} - 0.2 v_{11} - 0.111111111111111 v_{9}\\)\\(0 = - I_{V4} - 0.2 v_{10} + 0.3 v_{11} - 0.1 v_{12}\\)\\(2.0 = - 0.1 v_{11} + 0.1 v_{12}\\)\\(10.0 = v_{9}\\)\\(2.0 = v_{1}\\)\\(3.0 = - v_{3} + v_{7}\\)\\(5.0 = - v_{11} + v_{7}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           1.532489\nv3          -6.665281\nv4         -16.236710\nv5           4.408083\nv6           4.750715\nv7          -3.665281\nv8         -18.141472\nv9          10.000000\nv10         -8.427681\nv11         -8.665281\nv12         11.334719\nI_V1        -3.165903\nI_V2         0.970286\nI_V3         1.079596\nI_V4        -2.047520\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(9):    10  voltage\nV(5):    4.40808     voltage\nV(1):    2   voltage\nV(6):    4.75072     voltage\nV(2):    1.53249     voltage\nV(8):    -18.1415    voltage\nV(7):    -3.66528    voltage\nV(10):   -8.42768    voltage\nV(11):   -8.66528    voltage\nV(3):    -6.66528    voltage\nV(4):    -16.2367    voltage\nV(12):   11.3347     voltage\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   1.11838     device_current\nI(R2):   1.20404     device_current\nI(R5):   1.07274     device_current\nI(R6):   0.306498    device_current\nI(R8):   -1.80952    device_current\nI(R10):  -2.04752    device_current\nI(R11):  0.0856581   device_current\nI(R12):  -0.233756   device_current\nI(R14):  -0.8416     device_current\nI(R15):  -0.0475201  device_current\nI(R7):   -0.190476   device_current\nI(R16):  -1.11088    device_current\nI(R3):   2   device_current\nI(R4):   -3.19048    device_current\nI(V1):   -3.1659     device_current\nI(V2):   0.970286    device_current\nI(V3):   1.0796  device_current\nI(V4):   -2.04752    device_current\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Test 2</span>"
    ]
  },
  {
    "objectID": "test_3.html",
    "href": "test_3.html",
    "title": "33  Test 3",
    "section": "",
    "text": "33.1 Load the net list\nThe circuit in Figure 33.1 is from Johnson, Hilburn, and Johnson (1978) (Figure 4.8), but modified to include a capactior and inductor. AC analysis was performed at 1 rad/sec and also over a range of frequencies. The results are compared to those obtained from LTSpice.\nThe net list for Figure 33.1 was generated by LTSpice and show below:\nnet_list = '''\nR2 2 5 2\nV1 1 0 1\nI1 4 0 9\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\nC1 1 2 1\nL1 4 3 1\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_3.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "33  Test 3",
    "section": "33.2 Call the symbolic modified nodal analysis function",
    "text": "33.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{2} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}} = 0\\)\\(- C_{1} s v_{1} + I_{F1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\\(I_{Ea1} - I_{F1} - I_{L1} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}} = - I_{1}\\)\\(- I_{V2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{5}}{R_{2}} = 0\\)\\(v_{1} = V_{1}\\)\\(- v_{5} = V_{2}\\)\\(- ea_{1} v_{1} + ea_{1} v_{4} + v_{3} = 0\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- I_{L1} L_{1} s - v_{3} + v_{4} = 0\\)\n\n\n\n33.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 5\nnumber of RLC (passive components): 4\nnumber of inductors: 1\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n33.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{1}} & - C_{1} s & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0 & 0\\\\- C_{1} s & C_{1} s + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & -1\\\\- \\frac{1}{R_{1}} & 0 & 0 & \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & - \\frac{1}{R_{2}} & 0 & 0 & \\frac{1}{R_{2}} & 0 & -1 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0\\\\0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & - L_{1} s\\end{matrix}\\right]\\)\n\n\n\n\n33.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}, \\  I_{L1}\\right]\\)\n\n\n\n\n33.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n33.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nI1\n4\n0\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n4\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n6\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nC1\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n8\nL1\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n33.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n4\nL1\n4\n3\n\n\n\n\n\n\n\n\n\n33.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{1}, \\  R_{1}, \\  v_{4}, \\  I_{V2}, \\  V_{1}, \\  I_{1}, \\  L_{1}, \\  I_{Ea1}, \\  v_{1}, \\  v_{3}, \\  ea_{1}, \\  s, \\  f_{1}, \\  V_{2}, \\  v_{5}, \\  I_{F1}, \\  I_{V1}, \\  v_{2}, \\  R_{2}, \\  I_{L1}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#symbolic-solution",
    "href": "test_3.html#symbolic-solution",
    "title": "33  Test 3",
    "section": "33.3 Symbolic solution",
    "text": "33.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{C_{1} R_{2} V_{1} s + V_{2} f_{1} - V_{2}}{C_{1} R_{2} s - f_{1} + 1}\\)\\(v_{3} = \\frac{I_{1} L_{1} R_{1} ea_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)\\(v_{4} = \\frac{- I_{1} L_{1} R_{1} s + L_{1} V_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)\\(v_{5} = - V_{2}\\)\\(I_{V1} = \\frac{- C_{1} I_{1} L_{1} R_{2} s^{2} + C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{1} s^{2} + C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} L_{1} V_{2} s^{2} + C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} ea_{1} s + C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{1} s + C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} s + C_{1} R_{1} V_{2} f_{1} s - C_{1} R_{1} V_{2} s - C_{1} R_{2} V_{1} s + I_{1} L_{1} f_{1} s - I_{1} L_{1} s + V_{1} f_{1} - V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}\\)\\(I_{V2} = \\frac{- C_{1} V_{1} s - C_{1} V_{2} s}{C_{1} R_{2} s - f_{1} + 1}\\)\\(I_{Ea1} = \\frac{- C_{1} I_{1} R_{1} R_{2} ea_{1} s - C_{1} I_{1} R_{1} R_{2} s - C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} f_{1} s + C_{1} R_{2} V_{1} s + I_{1} R_{1} ea_{1} f_{1} - I_{1} R_{1} ea_{1} + I_{1} R_{1} f_{1} - I_{1} R_{1} - V_{1} f_{1} + V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}\\)\\(I_{F1} = \\frac{- C_{1} V_{1} f_{1} s - C_{1} V_{2} f_{1} s}{C_{1} R_{2} s - f_{1} + 1}\\)\\(I_{L1} = \\frac{- I_{1} R_{1} ea_{1} - I_{1} R_{1} + V_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#construct-a-dictionary-of-element-values",
    "href": "test_3.html#construct-a-dictionary-of-element-values",
    "title": "33  Test 3",
    "section": "33.4 Construct a dictionary of element values",
    "text": "33.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 1.0\nV2 = 0.0\nR2 = 2.0\nI1 = 9.0\nea1 = 2.0\nf1 = 2.0\nR1 = 2.0\nC1 = 1.0\nL1 = 1.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_3.html#dc-operating-point",
    "href": "test_3.html#dc-operating-point",
    "title": "33  Test 3",
    "section": "33.5 DC operating point",
    "text": "33.5 DC operating point\nBoth V1 and I1 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 0.5 v_{1} - 0.5 v_{4}\\)\\(0 = I_{F1} + 0.5 v_{2} - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} - I_{L1}\\)\\(-9.0 = I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          1.000000\nv2          0.000000\nv3          0.666667\nv4          0.666667\nv5          0.000000\nI_V1       -0.166667\nI_V2        0.000000\nI_Ea1      -8.833333\nI_F1        0.000000\nI_L1       -8.833333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    -2e-12  voltage\nV(5):    0   voltage\nV(1):    1   voltage\nV(4):    0.666667    voltage\nV(3):    0.666667    voltage\nI(C1):   1e-12   device_current\nI(F1):   2e-12   device_current\nI(L1):   -8.83333    device_current\nI(I1):   9   device_current\nI(R2):   -1e-12  device_current\nI(R1):   0.166667    device_current\nI(E1):   -8.83333    device_current\nI(V1):   -0.166667   device_current\nI(V2):   1e-12   device_current\nThe results from LTSpice agree with the SymPy results.\n\n33.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I1 = 0\n\nelement_values[I1] = 0\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + v_{1} \\cdot \\left(0.5 + 1.0 i\\right) - 1.0 i v_{2} - 0.5 v_{4}\\)\\(0 = I_{F1} - 1.0 i v_{1} + v_{2} \\cdot \\left(0.5 + 1.0 i\\right) - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} - I_{L1}\\)\\(0 = I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = - 1.0 i I_{L1} - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.894427    -26.565051\nv3         0.657596     -9.462322\nv4         0.677834      4.573921\nv5         0.000000    nan\nI_V1       0.294086    -36.027373\nI_V2       0.447214    153.434949\nI_Ea1      0.738882    149.683220\nI_F1       0.894427    153.434949\nI_L1       0.164399     -9.462322\n\n\nThe LTSpice solution is shown below:\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:   0.894427 phase:   -26.5651°  voltage\nV(5):   mag:          0 phase:          0°  voltage\nV(1):   mag:          1 phase:          0°  voltage\nV(4):   mag:   0.677834 phase:    4.57392°  voltage\nV(3):   mag:   0.657596 phase:   -9.46232°  voltage\nI(C1):  mag:   0.447214 phase:    153.435°  device_current\nI(F1):  mag:   0.894427 phase:    153.435°  device_current\nI(L1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(R2):  mag:   0.447214 phase:   -26.5651°  device_current\nI(R1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(E1):  mag:   0.738882 phase:    149.683°  device_current\nI(V1):  mag:   0.294086 phase:   -36.0274°  device_current\nI(V2):  mag:   0.447214 phase:    153.435°  device_current\n\n\n33.5.2 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. Thr frequenct weep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} - 1.0 s v_{2} + v_{1} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{4}\\)\\(0 = I_{F1} - 1.0 s v_{1} + v_{2} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{5}\\)\\(0 = I_{Ea1} - I_{F1} - I_{L1}\\)\\(0 = I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\)\\(0 = - I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\)\\(1.0 = v_{1}\\)\\(0 = - v_{5}\\)\\(0 = - 2.0 v_{1} + v_{3} + 2.0 v_{4}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = - 1.0 I_{L1} s - v_{3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n33.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_3.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-15}\\) and \\(10^{-13}\\) for the phase indicating the numerical difference is very small.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Test 3</span>"
    ]
  },
  {
    "objectID": "test_4.html",
    "href": "test_4.html",
    "title": "34  Test 4",
    "section": "",
    "text": "34.1 Load the net list\nTest circuit number 4 has 26 branches, 13 nodes, 18 resistors, 3 independent voltage sources and 1 independednt current source. There are 4 dependent sources, one of each type. Theere are 18 passive components, all resistors. This circuit will test a large network with at least one of each type of source.\nThe net list generated by LTSpice.\nnet_list = '''\nV4 1 2 10\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR5 4 8 5\nR9 1 9 9\nR1 1 5 3\nR10 8 0 10\nR13 9 11 7\nR14 10 9 10\nR15 0 11 3\nR2 3 5 5\nR6 7 1 2\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_4.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "34  Test 4",
    "section": "34.2 Call the symbolic modified nodal analysis function",
    "text": "34.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V4} + v_{1} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) - \\frac{v_{9}}{R_{9}} - \\frac{v_{7}}{R_{6}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(\\frac{v_{4}}{R_{5}} - \\frac{v_{8}}{R_{5}} = I_{2}\\)\\(I_{F1} - I_{V2} + v_{1} \\left(- \\frac{1}{R_{3}} - \\frac{1}{R_{1}}\\right) + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- g_{1} v_{4} + g_{1} v_{9} + v_{7} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{1}}{R_{6}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} - \\frac{v_{4}}{R_{5}} = 0\\)\\(- I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{1}}{R_{9}} - \\frac{v_{11}}{R_{13}} = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\n\n\n\n34.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 26\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 6\nnumber of RLC (passive components): 18\nnumber of inductors: 0\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n34.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccc}\\frac{1}{R_{9}} + \\frac{1}{R_{6}} + \\frac{1}{R_{3}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} - \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{6}} & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{5}} & 0 & 0 & 0 & - \\frac{1}{R_{5}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{3}} - \\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{6}} & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & \\frac{1}{R_{7}} + \\frac{1}{R_{6}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & - \\frac{1}{R_{5}} & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{5}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & - \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{13}} & 0 & \\frac{1}{R_{16}} + \\frac{1}{R_{15}} + \\frac{1}{R_{13}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n34.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}\\right]\\)\n\n\n\n\n34.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n34.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR5\n4\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n11\nR9\n1\n9\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n12\nR1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n13\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n14\nR13\n9\n11\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n15\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n16\nR15\n0\n11\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n17\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n18\nR6\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n19\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n20\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n21\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n22\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n23\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n24\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n25\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n34.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n\n\n\n\n\n\n\n34.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( R_{5}, \\  I_{V2}, \\  v_{8}, \\  h_{1}, \\  v_{11}, \\  R_{12}, \\  R_{7}, \\  I_{Ea1}, \\  V_{4}, \\  R_{1}, \\  R_{3}, \\  V_{1}, \\  ea_{1}, \\  v_{12}, \\  R_{11}, \\  g_{1}, \\  R_{14}, \\  v_{4}, \\  I_{2}, \\  v_{2}, \\  v_{6}, \\  v_{1}, \\  v_{5}, \\  R_{15}, \\  V_{2}, \\  I_{F1}, \\  v_{13}, \\  R_{18}, \\  R_{17}, \\  R_{4}, \\  R_{6}, \\  v_{10}, \\  v_{3}, \\  R_{13}, \\  R_{8}, \\  v_{9}, \\  R_{16}, \\  f_{1}, \\  I_{H1}, \\  v_{7}, \\  R_{10}, \\  R_{9}, \\  R_{2}, \\  I_{V4}, \\  I_{V1}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#symbolic-solution",
    "href": "test_4.html#symbolic-solution",
    "title": "34  Test 4",
    "section": "34.3 Symbolic solution",
    "text": "34.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#construct-a-dictionary-of-element-values",
    "href": "test_4.html#construct-a-dictionary-of-element-values",
    "title": "34  Test 4",
    "section": "34.4 Construct a dictionary of element values",
    "text": "34.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV4 = 10.0\nV1 = 0.0\nV2 = 0.0\nI2 = 5.0\nf1 = 5.0\nea1 = 3.0\ng1 = 2.0\nh1 = 2.0\nR3 = 10.0\nR4 = 1.0\nR5 = 5.0\nR9 = 9.0\nR1 = 3.0\nR10 = 10.0\nR13 = 7.0\nR14 = 10.0\nR15 = 3.0\nR2 = 5.0\nR6 = 2.0\nR7 = 6.0\nR11 = 5.0\nR12 = 9.0\nR16 = 10.0\nR8 = 5.0\nR17 = 8.0\nR18 = 4.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_4.html#numerical-solution",
    "href": "test_4.html#numerical-solution",
    "title": "34  Test 4",
    "section": "34.5 Numerical solution",
    "text": "34.5 Numerical solution\nSubstitute numerical values in place the symbolic reference designators.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V4} + 1.04444444444444 v_{1} - 0.433333333333333 v_{5} - 0.5 v_{7} - 0.111111111111111 v_{9}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(-5.0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(5.0 = 0.2 v_{4} - 0.2 v_{8}\\)\\(0 = I_{F1} - I_{V2} - 0.433333333333333 v_{1} - 0.2 v_{3} + 0.633333333333333 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 0.5 v_{1} - 1.0 v_{3} - 2.0 v_{4} + 1.66666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.2 v_{4} - 0.166666666666667 v_{7} + 0.666666666666667 v_{8}\\)\\(0 = - I_{F1} - 0.111111111111111 v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.553968253968254 v_{9}\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = 0.576190476190476 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(10.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          -2.528148\nv2         -12.528148\nv3         -26.854161\nv4          18.928828\nv5         -21.885182\nv6         -26.854161\nv7         -14.774289\nv8          -6.071172\nv9          16.675687\nv10          1.207520\nv11          1.418845\nv12        -15.647159\nv13        -21.885182\nI_V4       -12.377360\nI_V1         1.790752\nI_V2         1.559506\nI_F1         8.953758\nI_Ea1      -14.021017\nI_H1       -14.168112\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -2.52815    voltage\nV(2):    -12.5281    voltage\nV(3):    -26.8542    voltage\nV(4):    18.9288     voltage\nV(5):    -21.8852    voltage\nV(9):    16.6757     voltage\nV(12):   -15.6472    voltage\nV(10):   1.20752     voltage\nV(7):    -14.7743    voltage\nV(8):    -6.07117    voltage\nV(11):   1.41885     voltage\nV(6):    -26.8542    voltage\nV(13):   -21.8852    voltage\nI(F1):   8.95376     device_current\nI(H1):   -14.1681    device_current\nI(I2):   5   device_current\nI(R3):   -1.9357     device_current\nI(R4):   -12.0799    device_current\nI(R5):   5   device_current\nI(R9):   -2.13376    device_current\nI(R1):   6.45234     device_current\nI(R10):  -0.607117   device_current\nI(R13):  2.17955     device_current\nI(R14):  -1.54682    device_current\nI(R15):  -0.472948   device_current\nI(R2):   -0.993796   device_current\nI(R6):   -6.12307    device_current\nI(R7):   1.45052     device_current\nI(R11):  -3.09363    device_current\nI(R12):  -0.134169   device_current\nI(R16):  -1.7066     device_current\nI(R8):   -4.1566     device_current\nI(R17):  1.79075     device_current\nI(R18):  1.55951     device_current\nI(G1):   -4.50628    device_current\nI(E1):   -14.021     device_current\nI(V4):   -12.3774    device_current\nI(V1):   1.79075     device_current\nI(V2):   1.55951     device_current\nThe results from LTSpice agree with the SymPy results.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Test 4</span>"
    ]
  },
  {
    "objectID": "test_5.html",
    "href": "test_5.html",
    "title": "35  Test 5",
    "section": "",
    "text": "35.1 Load the net list\nThis test circuit is simular to test 4, but with the addition of inductors and capacitors. This circuit has 26 branches, 13 nodes, 18 passive components, including 2 inductors, 2 capacitors, 4 independednt sources and 4 dependent sources. V1 and V2 are zero volt sources used to measure current through their branches. V4 is the independent voltage source and is set to 20 volts DC when calculating the DC operating point and to 20 volts AC for the AC analysis.\nnet_list = '''\nV4 1 2 20\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR9 4 8 9\nR10 8 0 10\nR13 9 11 7\nR14 10 9 10\nR2 3 5 5\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\nC1 7 1 2\nC2 1 9 5\nL1 1 5 3 \nL2 0 11 8 \n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_5.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "35  Test 5",
    "section": "35.2 Call the symbolic modified nodal analysis function",
    "text": "35.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(\\frac{v_{4}}{R_{9}} - \\frac{v_{8}}{R_{9}} = I_{2}\\)\\(I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{4}}{R_{9}} - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{2} s v_{1} - I_{F1} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{11}}{R_{13}} = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(- I_{L2} + v_{11} \\cdot \\left(\\frac{1}{R_{16}} + \\frac{1}{R_{13}}\\right) - \\frac{v_{12}}{R_{16}} - \\frac{v_{9}}{R_{13}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L2} L_{2} s - v_{11} = 0\\)\n\n\n\n35.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 26\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 8\nnumber of RLC (passive components): 18\nnumber of inductors: 2\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n35.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccccc}C_{1} s + C_{2} s + \\frac{1}{R_{3}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} & 0 & - C_{1} s & 0 & - C_{2} s & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{9}} & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{3}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{1} s & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & - \\frac{1}{R_{9}} & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{9}} + \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{13}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & - \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{13}} & 0 & \\frac{1}{R_{16}} + \\frac{1}{R_{13}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{2} s\\end{array}\\right]\\)\n\n\n\n\n35.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}\\right]\\)\n\n\n\n\n35.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n35.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR9\n4\n8\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n11\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n12\nR13\n9\n11\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n13\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n14\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n15\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n16\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n17\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n18\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n19\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n20\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n21\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n22\nC1\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n23\nC2\n1\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n24\nL1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n25\nL2\n0\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n35.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n6\nL1\n1\n5\n\n\n7\nL2\n0\n11\n\n\n\n\n\n\n\n\n\n35.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{13}, \\  ea_{1}, \\  I_{L2}, \\  v_{6}, \\  I_{V2}, \\  v_{8}, \\  V_{4}, \\  v_{11}, \\  s, \\  R_{16}, \\  v_{9}, \\  v_{2}, \\  R_{18}, \\  V_{1}, \\  v_{5}, \\  I_{V1}, \\  R_{8}, \\  R_{12}, \\  g_{1}, \\  h_{1}, \\  L_{1}, \\  C_{2}, \\  I_{V4}, \\  I_{H1}, \\  I_{F1}, \\  I_{Ea1}, \\  R_{3}, \\  v_{1}, \\  f_{1}, \\  R_{17}, \\  v_{12}, \\  R_{11}, \\  C_{1}, \\  R_{7}, \\  V_{2}, \\  v_{7}, \\  L_{2}, \\  I_{2}, \\  R_{13}, \\  v_{3}, \\  R_{9}, \\  R_{14}, \\  R_{2}, \\  v_{10}, \\  v_{4}, \\  I_{L1}, \\  R_{10}, \\  R_{4}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#symbolic-solution",
    "href": "test_5.html#symbolic-solution",
    "title": "35  Test 5",
    "section": "35.3 Symbolic solution",
    "text": "35.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#construct-a-dictionary-of-element-values",
    "href": "test_5.html#construct-a-dictionary-of-element-values",
    "title": "35  Test 5",
    "section": "35.4 Construct a dictionary of element values",
    "text": "35.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV4 = 20.0\nV1 = 0.0\nV2 = 0.0\nI2 = 5.0\nf1 = 5.0\nea1 = 3.0\ng1 = 2.0\nh1 = 2.0\nR3 = 10.0\nR4 = 1.0\nR9 = 9.0\nR10 = 10.0\nR13 = 7.0\nR14 = 10.0\nR2 = 5.0\nR7 = 6.0\nR11 = 5.0\nR12 = 9.0\nR16 = 10.0\nR8 = 5.0\nR17 = 8.0\nR18 = 4.0\nC1 = 2.0\nC2 = 5.0\nL1 = 3.0\nL2 = 8.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_5.html#dc-operating-point",
    "href": "test_5.html#dc-operating-point",
    "title": "35  Test 5",
    "section": "35.5 DC operating point",
    "text": "35.5 DC operating point\nBoth V4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + 0.1 v_{1} - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(-5.0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(5.0 = 0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 1.0 v_{3} - 2.0 v_{4} + 1.16666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\)\\(0 = - I_{F1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.442857142857143 v_{9}\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = v_{1} - v_{5}\\)\\(0 = - v_{11}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1          -5.020059\nv2         -25.020059\nv3         -40.666907\nv4          26.781121\nv5          -5.020059\nv6         -40.666907\nv7         -32.212572\nv8         -18.218879\nv9          23.720095\nv10          2.417779\nv11          0.000000\nv12        -18.353392\nv13         -5.020059\nI_V4       -20.241983\nI_V1         1.955856\nI_V2        -3.333333\nI_F1         9.779280\nI_Ea1      -17.029166\nI_H1       -22.197839\nI_L1        20.241983\nI_L2        -1.553246\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -5.02006    voltage\nV(2):    -25.0201    voltage\nV(3):    -40.6669    voltage\nV(4):    26.7811     voltage\nV(5):    -5.02006    voltage\nV(9):    23.7201     voltage\nV(12):   -18.3534    voltage\nV(10):   2.41778     voltage\nV(7):    -32.2126    voltage\nV(8):    -18.2189    voltage\nV(11):   0   voltage\nV(6):    -40.6669    voltage\nV(13):   -5.02006    voltage\nI(C1):   -5.4385e-11     device_current\nI(C2):   -1.43701e-10    device_current\nI(F1):   9.77928     device_current\nI(H1):   -22.1978    device_current\nI(L1):   20.242  device_current\nI(L2):   -1.55325    device_current\nI(I2):   5   device_current\nI(R3):   -8.88178e-16    device_current\nI(R4):   -8.45434    device_current\nI(R9):   5   device_current\nI(R10):  -1.82189    device_current\nI(R13):  3.38859     device_current\nI(R14):  -2.13023    device_current\nI(R2):   -7.12937    device_current\nI(R7):   2.33228     device_current\nI(R11):  -4.26046    device_current\nI(R12):  -0.268642   device_current\nI(R16):  -1.83534    device_current\nI(R8):   -4.48961    device_current\nI(R17):  1.95586     device_current\nI(R18):  -3.33333    device_current\nI(G1):   -6.12205    device_current\nI(E1):   -17.0292    device_current\nI(V4):   -20.242     device_current\nI(V1):   1.95586     device_current\nI(V2):   -3.33333    device_current\nThe results from LTSpice agree with the SymPy results.\n\n35.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I2 = 0\n\nelement_values[I2] = 0\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = 0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\)\\(0 = - I_{F1} - 5.0 i v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(0.442857142857143 + 5.0 i\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 i I_{L1} + v_{1} - v_{5}\\)\\(0 = - 8.0 i I_{L2} - v_{11}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          3.599764    -52.169011\nv2         18.017879   -170.920917\nv3          1.855665     65.635428\nv4          1.903808      8.371520\nv5         14.354390     47.295045\nv6          1.855665     65.635428\nv7          4.531708    -16.043028\nv8          1.903808      8.371520\nv9          1.498280    -10.433515\nv10         3.010258   -107.783771\nv11         2.426237   -163.488259\nv12         8.767364    169.347366\nv13        14.354390     47.295045\nI_V4       10.838028   -177.106564\nI_V1        2.387928   -166.271733\nI_V2        5.102027   -154.058091\nI_F1       11.939640   -166.271733\nI_Ea1       3.858821    148.425320\nI_H1        8.504523    179.867890\nI_L1        5.120760    150.658972\nI_L2        0.303280    -73.488259\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    3.59976 phase:    -52.169°  voltage\nV(2):   mag:    18.0179 phase:   -170.921°  voltage\nV(3):   mag:    1.85567 phase:    65.6354°  voltage\nV(4):   mag:    1.90381 phase:    8.37152°  voltage\nV(5):   mag:    14.3544 phase:     47.295°  voltage\nV(9):   mag:    1.49828 phase:   -10.4335°  voltage\nV(12):  mag:    8.76736 phase:    169.347°  voltage\nV(10):  mag:    3.01026 phase:   -107.784°  voltage\nV(7):   mag:    4.53171 phase:    -16.043°  voltage\nV(8):   mag:    1.90381 phase:    8.37152°  voltage\nV(11):  mag:    2.42624 phase:   -163.488°  voltage\nV(6):   mag:    1.85567 phase:    65.6354°  voltage\nV(13):  mag:    14.3544 phase:     47.295°  voltage\nI(C1):  mag:    5.34483 phase:    126.532°  device_current\nI(C2):  mag:    13.3732 phase:    15.9359°  device_current\nI(F1):  mag:    11.9396 phase:   -166.272°  device_current\nI(H1):  mag:    8.50452 phase:    179.868°  device_current\nI(L1):  mag:    5.12076 phase:    150.659°  device_current\nI(L2):  mag:    0.30328 phase:   -73.4883°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:    1.53623 phase:     60.659°  device_current\nI(R4):  mag:    4.64174 phase:    140.656°  device_current\nI(R9):  mag:          0 phase:          0°  device_current\nI(R10): mag:   0.190381 phase:    8.37152°  device_current\nI(R13): mag:   0.546091 phase:    6.28131°  device_current\nI(R14): mag:   0.352995 phase:   -132.679°  device_current\nI(R2):  mag:     2.5213 phase:    -135.36°  device_current\nI(R7):  mag:   0.484448 phase:     148.25°  device_current\nI(R11): mag:   0.705989 phase:   -132.679°  device_current\nI(R12): mag:   0.334473 phase:    72.2162°  device_current\nI(R16): mag:   0.670093 phase:    159.833°  device_current\nI(R8):  mag:   0.360393 phase:    128.347°  device_current\nI(R17): mag:    2.38793 phase:   -166.272°  device_current\nI(R18): mag:    5.10203 phase:   -154.058°  device_current\nI(G1):  mag:    1.36963 phase:   -126.779°  device_current\nI(E1):  mag:    3.85882 phase:    148.425°  device_current\nI(V4):  mag:     10.838 phase:   -177.107°  device_current\nI(V1):  mag:    2.38793 phase:   -166.272°  device_current\nI(V2):  mag:    5.10203 phase:   -154.058°  device_current\n\n\n\n35.5.2 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = 0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\)\\(0 = - I_{F1} - 5.0 s v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(5.0 s + 0.442857142857143\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 I_{L1} s + v_{1} - v_{5}\\)\\(0 = - 8.0 I_{L2} s - v_{11}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n35.5.3 Plot the voltage at node 5\n\nH = U_ac[v5]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_5.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\) and \\(10^{-12}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Test 5</span>"
    ]
  },
  {
    "objectID": "test_6.html",
    "href": "test_6.html",
    "title": "36  Test 6",
    "section": "",
    "text": "36.1 Load the net list\nTest circuit number 6 is similar to test circuit number 5, but with the addition of coupled inductors. This test circuit includes all the element types except for Op Amps. V4 is the independent voltage source and is set to 10 volts DC when calculating the DC operating point and to 20 volts AC for the AC analysis.\nnet_list = '''\nV4 1 2 20\nI2 3 4 5\nF1 5 9 V1 5\nE1 12 3 10 1 3\nG1 7 10 9 4 2\nH1 2 12 V2 2\nR3 5 1 10\nR4 3 7 1\nR10 8 0 10\nR14 10 9 10\nR2 3 5 5\nR7 8 7 6\nR11 10 9 5\nR12 0 10 9\nR16 12 11 10\nR8 3 8 5\nR17 2 6 8\nV1 6 3 0\nV2 13 5 0\nR18 12 13 4\nC1 7 1 2\nC2 1 9 5\nL1 1 5 3\nL2 0 11 8\nL3 9 11 8\nL4 4 8 10\nK1 L3 L4 0.5\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_6.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "36  Test 6",
    "section": "36.2 Call the symbolic modified nodal analysis function",
    "text": "36.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- C_{1} s v_{7} - C_{2} s v_{9} + I_{L1} + I_{V4} + v_{1} \\left(C_{1} s + C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\\(I_{H1} - I_{V4} + \\frac{v_{2}}{R_{17}} - \\frac{v_{6}}{R_{17}} = 0\\)\\(- I_{Ea1} - I_{V1} + v_{3} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{8}}{R_{8}} - \\frac{v_{7}}{R_{4}} - \\frac{v_{5}}{R_{2}} = - I_{2}\\)\\(I_{L4} = I_{2}\\)\\(I_{F1} - I_{L1} - I_{V2} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{1}}{R_{3}} - \\frac{v_{3}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{2}}{R_{17}} + \\frac{v_{6}}{R_{17}} = 0\\)\\(- C_{1} s v_{1} - g_{1} v_{4} + g_{1} v_{9} + v_{7} \\left(C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{8}}{R_{7}} - \\frac{v_{3}}{R_{4}} = 0\\)\\(- I_{L4} + v_{8} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{3}}{R_{8}} - \\frac{v_{7}}{R_{7}} = 0\\)\\(- C_{2} s v_{1} - I_{F1} + I_{L3} + v_{10} \\left(- \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) + v_{9} \\left(C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) = 0\\)\\(g_{1} v_{4} + v_{10} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}}\\right) + v_{9} \\left(- g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}}\\right) = 0\\)\\(- I_{L2} - I_{L3} + \\frac{v_{11}}{R_{16}} - \\frac{v_{12}}{R_{16}} = 0\\)\\(I_{Ea1} - I_{H1} + v_{12} \\cdot \\left(\\frac{1}{R_{18}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{13}}{R_{18}} - \\frac{v_{11}}{R_{16}} = 0\\)\\(I_{V2} - \\frac{v_{12}}{R_{18}} + \\frac{v_{13}}{R_{18}} = 0\\)\\(v_{1} - v_{2} = V_{4}\\)\\(- v_{3} + v_{6} = V_{1}\\)\\(v_{13} - v_{5} = V_{2}\\)\\(I_{F1} - I_{V1} f_{1} = 0\\)\\(ea_{1} v_{1} - ea_{1} v_{10} + v_{12} - v_{3} = 0\\)\\(- I_{V2} h_{1} - v_{12} + v_{2} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{5} = 0\\)\\(- I_{L2} L_{2} s - v_{11} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{1} s - v_{11} + v_{9} = 0\\)\\(- I_{L3} M_{1} s - I_{L4} L_{4} s + v_{4} - v_{8} = 0\\)\n\n\n\n36.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 27\nnumber of branches: 26\nnumber of nodes: 13\nnumber of unknown currents: 10\nnumber of RLC (passive components): 18\nnumber of inductors: 4\nnumber of independent voltage sources: 3\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 1\nnumber of F - CCCS: 1\nnumber of H - CCVS: 1\nnumber of K - Coupled inductors: 1\n\n\n\n\n\n36.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{ccccccccccccccccccccccc}C_{1} s + C_{2} s + \\frac{1}{R_{3}} & 0 & 0 & 0 & - \\frac{1}{R_{3}} & 0 & - C_{1} s & 0 & - C_{2} s & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{8}} + \\frac{1}{R_{4}} + \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{2}} & 0 & - \\frac{1}{R_{4}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\- \\frac{1}{R_{3}} & 0 & - \\frac{1}{R_{2}} & 0 & \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- C_{1} s & 0 & - \\frac{1}{R_{4}} & - g_{1} & 0 & 0 & C_{1} s + \\frac{1}{R_{7}} + \\frac{1}{R_{4}} & - \\frac{1}{R_{7}} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{8}} & 0 & 0 & 0 & - \\frac{1}{R_{7}} & \\frac{1}{R_{8}} + \\frac{1}{R_{7}} + \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\- C_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{2} s + \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & g_{1} & 0 & 0 & 0 & 0 & - g_{1} - \\frac{1}{R_{14}} - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{12}} + \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{16}} & - \\frac{1}{R_{16}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{16}} & \\frac{1}{R_{18}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & \\frac{1}{R_{18}} & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\ea_{1} & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & - ea_{1} & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{2} s & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{1} s\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{4} s\\end{array}\\right]\\)\n\n\n\n\n36.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  I_{V4}, \\  I_{V1}, \\  I_{V2}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}\\right]\\)\n\n\n\n\n36.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  - I_{2}, \\  I_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{4}, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n36.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV4\n1\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n1\nV1\n6\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nV2\n13\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n3\nI2\n3\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nF1\n5\n9\nNaN\nNaN\nNaN\n5.0\nV1\nNaN\nNaN\n\n\n5\nEa1\n12\n3\n10\n1\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n6\nG1\n7\n10\n9\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nH1\n2\n12\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n8\nR3\n5\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n9\nR4\n3\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n10\nR10\n8\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n11\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n12\nR2\n3\n5\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n13\nR7\n8\n7\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n14\nR11\n10\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n15\nR12\n0\n10\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n16\nR16\n12\n11\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n17\nR8\n3\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n18\nR17\n2\n6\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n19\nR18\n12\n13\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n20\nC1\n7\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n21\nC2\n1\n9\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n22\nL1\n1\n5\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n23\nL2\n0\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n24\nL3\n9\n11\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n25\nL4\n4\n8\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n26\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.5\nNaN\nL3\nL4\n\n\n\n\n\n\n\n\n\n36.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV4\n1\n2\n\n\n1\nV1\n6\n3\n\n\n2\nV2\n13\n5\n\n\n3\nF1\n5\n9\n\n\n4\nEa1\n12\n3\n\n\n5\nH1\n2\n12\n\n\n6\nL1\n1\n5\n\n\n7\nL2\n0\n11\n\n\n8\nL3\n9\n11\n\n\n9\nL4\n4\n8\n\n\n\n\n\n\n\n\n\n36.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( C_{2}, \\  R_{2}, \\  I_{L4}, \\  I_{Ea1}, \\  R_{14}, \\  v_{10}, \\  v_{13}, \\  f_{1}, \\  v_{12}, \\  R_{4}, \\  L_{3}, \\  L_{2}, \\  v_{11}, \\  v_{7}, \\  v_{4}, \\  C_{1}, \\  V_{2}, \\  I_{V2}, \\  V_{4}, \\  R_{10}, \\  M_{1}, \\  g_{1}, \\  L_{1}, \\  ea_{1}, \\  v_{2}, \\  R_{8}, \\  R_{7}, \\  h_{1}, \\  I_{H1}, \\  v_{5}, \\  v_{1}, \\  s, \\  R_{3}, \\  I_{F1}, \\  R_{16}, \\  I_{L2}, \\  L_{4}, \\  I_{V1}, \\  I_{V4}, \\  R_{12}, \\  V_{1}, \\  v_{6}, \\  v_{9}, \\  I_{L3}, \\  R_{18}, \\  I_{2}, \\  I_{L1}, \\  v_{8}, \\  R_{17}, \\  v_{3}, \\  R_{11}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#symbolic-solution",
    "href": "test_6.html#symbolic-solution",
    "title": "36  Test 6",
    "section": "36.3 Symbolic solution",
    "text": "36.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#construct-a-dictionary-of-element-values",
    "href": "test_6.html#construct-a-dictionary-of-element-values",
    "title": "36  Test 6",
    "section": "36.4 Construct a dictionary of element values",
    "text": "36.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV4 = 20.0\nV1 = 0.0\nV2 = 0.0\nI2 = 5.0\nf1 = 5.0\nea1 = 3.0\ng1 = 2.0\nh1 = 2.0\nR3 = 10.0\nR4 = 1.0\nR10 = 10.0\nR14 = 10.0\nR2 = 5.0\nR7 = 6.0\nR11 = 5.0\nR12 = 9.0\nR16 = 10.0\nR8 = 5.0\nR17 = 8.0\nR18 = 4.0\nC1 = 2.0\nC2 = 5.0\nL1 = 3.0\nL2 = 8.0\nL3 = 8.0\nL4 = 10.0\nK1 = 0.5\n\n\n\n36.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt; K1 L3 L4 0.5\nK1 identifies the mutual inductance between two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1 = symbols('K1')\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nmutual inductance, M1 = 4.472135955\n\n\n\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  C_{2} : 5.0, \\  I_{2} : 5.0, \\  K_{1} : 0.5, \\  L_{1} : 3.0, \\  L_{2} : 8.0, \\  L_{3} : 8.0, \\  L_{4} : 10.0, \\  M_{1} : 4.47213595499958, \\  R_{10} : 10.0, \\  R_{11} : 5.0, \\  R_{12} : 9.0, \\  R_{14} : 10.0, \\  R_{16} : 10.0, \\  R_{17} : 8.0, \\  R_{18} : 4.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  R_{4} : 1.0, \\  R_{7} : 6.0, \\  R_{8} : 5.0, \\  V_{1} : 0.0, \\  V_{2} : 0.0, \\  V_{4} : 20.0, \\  ea_{1} : 3.0, \\  f_{1} : 5.0, \\  g_{1} : 2.0, \\  h_{1} : 2.0\\right\\}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_6.html#dc-operating-point",
    "href": "test_6.html#dc-operating-point",
    "title": "36  Test 6",
    "section": "36.5 DC operating point",
    "text": "36.5 DC operating point\nBoth V4 and I2 are active.\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + 0.1 v_{1} - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(-5.0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(5.0 = I_{L4}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 1.0 v_{3} - 2.0 v_{4} + 1.16666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\)\\(0 = - I_{F1} + I_{L3} - 0.3 v_{10} + 0.3 v_{9}\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(20.0 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = v_{1} - v_{5}\\)\\(0 = - v_{11}\\)\\(0 = - v_{11} + v_{9}\\)\\(0 = v_{4} - v_{8}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           3.367922\nv2         -16.632078\nv3         -15.060648\nv4          -1.041413\nv5           3.367922\nv6         -15.060648\nv7         -14.843180\nv8          -1.041413\nv9           0.000000\nv10          5.066334\nv11          0.000000\nv12         -9.965411\nv13          3.367922\nI_V4        -6.036903\nI_V1        -0.196429\nI_V2        -3.333333\nI_F1        -0.982144\nI_Ea1       -1.510600\nI_H1        -5.840475\nI_L1         6.036903\nI_L2         0.458785\nI_L3         0.537756\nI_L4         5.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    3.36792     voltage\nV(2):    -16.6321    voltage\nV(3):    -15.0606    voltage\nV(4):    -1.04141    voltage\nV(5):    3.36792     voltage\nV(9):    1.11022e-16     voltage\nV(12):   -9.96541    voltage\nV(10):   5.06633     voltage\nV(7):    -14.8432    voltage\nV(8):    -1.04141    voltage\nV(11):   0   voltage\nV(6):    -15.0606    voltage\nV(13):   3.36792     voltage\nI(C1):   -3.64222e-11    device_current\nI(C2):   1.68396e-11     device_current\nI(F1):   -0.982144   device_current\nI(H1):   -5.84047    device_current\nI(L1):   6.0369  device_current\nI(L2):   0.458785    device_current\nI(L3):   0.537756    device_current\nI(L4):   5   device_current\nI(I2):   5   device_current\nI(R3):   5.32907e-16     device_current\nI(R4):   -0.217468   device_current\nI(R10):  -0.104141   device_current\nI(R14):  0.506633    device_current\nI(R2):   -3.68571    device_current\nI(R7):   2.30029     device_current\nI(R11):  1.01327     device_current\nI(R12):  -0.562926   device_current\nI(R16):  -0.996541   device_current\nI(R8):   -2.80385    device_current\nI(R17):  -0.196429   device_current\nI(R18):  -3.33333    device_current\nI(G1):   2.08283     device_current\nI(E1):   -1.5106     device_current\nI(V4):   -6.0369     device_current\nI(V1):   -0.196429   device_current\nI(V2):   -3.33333    device_current\nThe results from LTSpice agree with the SymPy results.\n\n36.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\nNeed to set I2 = 0 and V4 = 10\n\nelement_values[I2] = 0\nelement_values[V4] = 10\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = I_{L4}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\)\\(0 = - I_{F1} + I_{L3} - 5.0 i v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(0.3 + 5.0 i\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(10 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 i I_{L1} + v_{1} - v_{5}\\)\\(0 = - 8.0 i I_{L2} - v_{11}\\)\\(0 = - 8.0 i I_{L3} - 4.47213595499958 i I_{L4} - v_{11} + v_{9}\\)\\(0 = - 4.47213595499958 i I_{L3} - 10.0 i I_{L4} + v_{4} - v_{8}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.636070    -13.116769\nv2         8.414810   -177.471137\nv3         0.586907     -3.586473\nv4         1.987061     30.488547\nv5         7.659782     29.941452\nv6         0.586907     -3.586473\nv7         1.673460      2.228237\nv8         0.848285      0.506771\nv9         1.767765     29.618572\nv10        0.268017     -3.585934\nv11        0.916416    -90.556353\nv12        3.543942    163.157171\nv13        7.659782     29.941452\nI_V4       5.376987   -165.047830\nI_V1       1.124824   -177.869238\nI_V2       2.602977   -164.421170\nI_F1       5.624122   -177.869238\nI_Ea1      1.485962   -145.541756\nI_H1       4.287481   -161.710238\nI_L1       2.186723    129.745082\nI_L2       0.114552     -0.556353\nI_L3       0.295629    -40.810152\nI_L4       0.000000    nan\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    1.63607 phase:   -13.1168°  voltage\nV(2):   mag:    8.41481 phase:   -177.471°  voltage\nV(3):   mag:   0.586907 phase:   -3.58647°  voltage\nV(4):   mag:    1.98706 phase:    30.4885°  voltage\nV(5):   mag:    7.65978 phase:    29.9415°  voltage\nV(9):   mag:    1.76776 phase:    29.6186°  voltage\nV(12):  mag:    3.54394 phase:    163.157°  voltage\nV(10):  mag:   0.268017 phase:   -3.58593°  voltage\nV(7):   mag:    1.67346 phase:    2.22824°  voltage\nV(8):   mag:   0.848285 phase:   0.506771°  voltage\nV(11):  mag:   0.916416 phase:   -90.5564°  voltage\nV(6):   mag:   0.586907 phase:   -3.58647°  voltage\nV(13):  mag:    7.65978 phase:    29.9415°  voltage\nI(C1):  mag:   0.886817 phase:    169.762°  device_current\nI(C2):  mag:    6.23121 phase:    2.60332°  device_current\nI(F1):  mag:    5.62412 phase:   -177.869°  device_current\nI(H1):  mag:    4.28748 phase:    -161.71°  device_current\nI(L1):  mag:    2.18672 phase:    129.745°  device_current\nI(L2):  mag:   0.114552 phase:  -0.556353°  device_current\nI(L3):  mag:   0.295629 phase:   -40.8102°  device_current\nI(L4):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:   0.656017 phase:    39.7451°  device_current\nI(R4):  mag:    1.09119 phase:   -174.648°  device_current\nI(R10): mag:  0.0848285 phase:   0.506771°  device_current\nI(R14): mag:   0.155047 phase:   -144.949°  device_current\nI(R2):  mag:    1.43557 phase:    -147.47°  device_current\nI(R7):  mag:   0.137659 phase:   -176.004°  device_current\nI(R11): mag:   0.310094 phase:   -144.949°  device_current\nI(R12): mag:  0.0297797 phase:    176.414°  device_current\nI(R16): mag:    0.39014 phase:    150.127°  device_current\nI(R8):  mag:  0.0532384 phase:   -170.438°  device_current\nI(R17): mag:    1.12482 phase:   -177.869°  device_current\nI(R18): mag:    2.60298 phase:   -164.421°  device_current\nI(G1):  mag:   0.442271 phase:    -142.54°  device_current\nI(E1):  mag:    1.48596 phase:   -145.542°  device_current\nI(V4):  mag:    5.37699 phase:   -165.048°  device_current\nI(V1):  mag:    1.12482 phase:   -177.869°  device_current\nI(V2):  mag:    2.60298 phase:   -164.421°  device_current\n\n\n36.5.2 AC Sweep\nLooking at node 10 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\)\\(0 = - I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\)\\(0 = I_{L4}\\)\\(0 = I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\)\\(0 = I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\)\\(0 = - 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\)\\(0 = - I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\)\\(0 = - I_{F1} + I_{L3} - 5.0 s v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(5.0 s + 0.3\\right)\\)\\(0 = 0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\)\\(0 = - I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\)\\(0 = I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\)\\(0 = I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\)\\(10 = v_{1} - v_{2}\\)\\(0 = - v_{3} + v_{6}\\)\\(0 = v_{13} - v_{5}\\)\\(0 = I_{F1} - 5.0 I_{V1}\\)\\(0 = 3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\)\\(0 = - 2.0 I_{V2} - v_{12} + v_{2}\\)\\(0 = - 3.0 I_{L1} s + v_{1} - v_{5}\\)\\(0 = - 8.0 I_{L2} s - v_{11}\\)\\(0 = - 8.0 I_{L3} s - 4.47213595499958 I_{L4} s - v_{11} + v_{9}\\)\\(0 = - 4.47213595499958 I_{L3} s - 10.0 I_{L4} s + v_{4} - v_{8}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n36.5.3 Plot the voltage at node 10\n\nH = U_ac[v10]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 1000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_6.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\) and \\(10^{-11}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Test 6</span>"
    ]
  },
  {
    "objectID": "test_7.html",
    "href": "test_7.html",
    "title": "37  Test 7",
    "section": "",
    "text": "37.1 Load the net list\nThis test circuit shown in Figure 37.1 is a large circuit with 53 branches, 28 nodes and at least two of each element type except for Op Amps. This circuit is designed to stress the Python code with a large number of variables and unknowns.\nThe netlist generated by LTSpice:\nnet_list = '''\nR1 16 8 5\nR2 8 1 2\nR6 2 0 5\nR8 11 10 8\nR10 23 22 9\nR11 9 8 4\nR12 2 1 2\nR14 10 9 10\nR15 24 23 5\nV1 22 0 10 \nV2 1 0 2\nV3 10 3 3\nV4 10 20 5\nI1 5 0 3\nI2 2 3 1\nI3 16 9 2\nI4 12 18 2\nR7 12 5 10\nR16 3 0 6\nR3 26 25 10\nR4 4 3 3\nF1 14 7 V2 2\nE1 15 21 2 7 2\nH1 4 0 V2 3\nG1 11 4 13 12 2\nL1 16 23 1 \nL2 25 9 4 \nV5 20 28 0\nV6 23 27 0\nL3 22 21 2 \nL4 17 11 5 \nC1 23 18 2\nC2 12 11 2\nL5 0 7 1 \nL6 9 2 2 \nF2 0 27 V2 2\nE2 17 26 10 9 2\nH2 27 26 V2 3\nG2 16 28 0 5 2\nV7 24 25 0\nV8 0 6 0\nR9 22 16 3\nR13 15 0 5\nR17 19 13 5\nR18 13 6 2\nR19 23 19 7\nR20 20 19 5\nR21 19 18 3\nR22 14 13 3\nR23 5 4 1\nR24 20 14 3\nR25 23 28 10\nR5 28 0 3\nK1 L1 L2 0.707\nK2 L3 L4 0.707\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_7.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "37  Test 7",
    "section": "37.2 Call the symbolic modified nodal analysis function",
    "text": "37.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}} = - I_{1}\\)\\(- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}} = 0\\)\\(- I_{F1} - I_{L5} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}} = 0\\)\\(- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}} = 0\\)\\(- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}} = 0\\)\\(- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}} = - I_{4}\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}} = 0\\)\\(I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}} = 0\\)\\(I_{Ea1} + \\frac{v_{15}}{R_{13}} = 0\\)\\(I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}} = - I_{3}\\)\\(I_{Ea2} + I_{L4} = 0\\)\\(- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}} = I_{4}\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}} = 0\\)\\(- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}} = 0\\)\\(- I_{Ea1} - I_{L3} = 0\\)\\(I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}} = 0\\)\\(- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}} = 0\\)\\(I_{V7} - \\frac{v_{23}}{R_{15}} + \\frac{v_{24}}{R_{15}} = 0\\)\\(I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{F2} + I_{H2} - I_{V6} = 0\\)\\(- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}} = 0\\)\\(v_{22} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(v_{10} - v_{3} = V_{3}\\)\\(v_{10} - v_{20} = V_{4}\\)\\(v_{20} - v_{28} = V_{5}\\)\\(v_{23} - v_{27} = V_{6}\\)\\(v_{24} - v_{25} = V_{7}\\)\\(- v_{6} = V_{8}\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21} = 0\\)\\(- I_{V2} h_{1} + v_{4} = 0\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22} = 0\\)\\(- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17} = 0\\)\\(- I_{L5} L_{5} s - v_{7} = 0\\)\\(- I_{L6} L_{6} s - v_{2} + v_{9} = 0\\)\\(I_{F2} - I_{V2} f_{2} = 0\\)\\(- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26} = 0\\)\\(- I_{V2} h_{2} - v_{26} + v_{27} = 0\\)\n\n\n\n37.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 55\nnumber of branches: 53\nnumber of nodes: 28\nnumber of unknown currents: 20\nnumber of RLC (passive components): 33\nnumber of inductors: 6\nnumber of independent voltage sources: 8\nnumber of independent current sources: 4\nnumber of Op Amps: 0\nnumber of E - VCVS: 2\nnumber of G - VCCS: 2\nnumber of F - CCCS: 2\nnumber of H - CCVS: 2\nnumber of K - Coupled inductors: 2\n\n\n\n\n\n37.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccccccccccccccccccccccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{23}} & - \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & g_{1} & - g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & - \\frac{1}{R_{23}} & \\frac{1}{R_{7}} + \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{8}} & C_{2} s + \\frac{1}{R_{8}} & - C_{2} s - g_{1} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & - C_{2} s & C_{2} s + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{22}} & \\frac{1}{R_{24}} + \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - g_{2} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{1} s + \\frac{1}{R_{21}} & - \\frac{1}{R_{21}} & 0 & 0 & 0 & - C_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{21}} & \\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{20}} & 0 & 0 & - \\frac{1}{R_{19}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{20}} & \\frac{1}{R_{24}} + \\frac{1}{R_{20}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - C_{1} s & - \\frac{1}{R_{19}} & 0 & 0 & - \\frac{1}{R_{10}} & C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 1\\\\0 & 0 & 0 & 0 & g_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - ea_{1} & 0 & 0 & 0 & 0 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{2} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{2} s & - L_{4} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{5} s & 0 & 0 & 0 & 0\\\\0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{6} s & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ea_{2} & - ea_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & - h_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n37.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  v_{14}, \\  v_{15}, \\  v_{16}, \\  v_{17}, \\  v_{18}, \\  v_{19}, \\  v_{20}, \\  v_{21}, \\  v_{22}, \\  v_{23}, \\  v_{24}, \\  v_{25}, \\  v_{26}, \\  v_{27}, \\  v_{28}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}, \\  I_{V5}, \\  I_{V6}, \\  I_{V7}, \\  I_{V8}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}, \\  I_{L5}, \\  I_{L6}, \\  I_{F2}, \\  I_{Ea2}, \\  I_{H2}\\right]\\)\n\n\n\n\n37.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  0, \\  - I_{1}, \\  0, \\  0, \\  0, \\  I_{3}, \\  0, \\  0, \\  - I_{4}, \\  0, \\  0, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}, \\  V_{5}, \\  V_{6}, \\  V_{7}, \\  V_{8}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n37.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n22\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n10\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n10\n20\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nV5\n20\n28\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n5\nV6\n23\n27\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n6\nV7\n24\n25\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n7\nV8\n0\n6\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n8\nR1\n16\n8\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n9\nR2\n8\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n10\nR6\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n11\nR8\n11\n10\nNaN\nNaN\nNaN\n8.0\nNaN\nNaN\nNaN\n\n\n12\nR10\n23\n22\nNaN\nNaN\nNaN\n9.0\nNaN\nNaN\nNaN\n\n\n13\nR11\n9\n8\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n14\nR12\n2\n1\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n15\nR14\n10\n9\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n16\nR15\n24\n23\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n17\nI1\n5\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n18\nI2\n2\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n19\nI3\n16\n9\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n20\nI4\n12\n18\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n21\nR7\n12\n5\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n22\nR16\n3\n0\nNaN\nNaN\nNaN\n6.0\nNaN\nNaN\nNaN\n\n\n23\nR3\n26\n25\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n24\nR4\n4\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n25\nF1\n14\n7\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n26\nEa1\n15\n21\n2\n7\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n27\nH1\n4\n0\nNaN\nNaN\nNaN\n3.0\nV2\nNaN\nNaN\n\n\n28\nG1\n11\n4\n13\n12\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n29\nL1\n16\n23\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n30\nL2\n25\n9\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n31\nL3\n22\n21\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n32\nL4\n17\n11\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n33\nC1\n23\n18\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n34\nC2\n12\n11\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n35\nL5\n0\n7\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n36\nL6\n9\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n37\nF2\n0\n27\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n38\nEa2\n17\n26\n10\n9\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n39\nH2\n27\n26\nNaN\nNaN\nNaN\n3.0\nV2\nNaN\nNaN\n\n\n40\nG2\n16\n28\n0\n5\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n41\nR9\n22\n16\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n42\nR13\n15\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n43\nR17\n19\n13\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n44\nR18\n13\n6\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n45\nR19\n23\n19\nNaN\nNaN\nNaN\n7.0\nNaN\nNaN\nNaN\n\n\n46\nR20\n20\n19\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n47\nR21\n19\n18\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n48\nR22\n14\n13\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n49\nR23\n5\n4\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n50\nR24\n20\n14\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n51\nR25\n23\n28\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n52\nR5\n28\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n53\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.707\nNaN\nL1\nL2\n\n\n54\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.707\nNaN\nL3\nL4\n\n\n\n\n\n\n\n\n\n37.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n22\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n10\n3\n\n\n3\nV4\n10\n20\n\n\n4\nV5\n20\n28\n\n\n5\nV6\n23\n27\n\n\n6\nV7\n24\n25\n\n\n7\nV8\n0\n6\n\n\n8\nF1\n14\n7\n\n\n9\nEa1\n15\n21\n\n\n10\nH1\n4\n0\n\n\n11\nL1\n16\n23\n\n\n12\nL2\n25\n9\n\n\n13\nL3\n22\n21\n\n\n14\nL4\n17\n11\n\n\n15\nL5\n0\n7\n\n\n16\nL6\n9\n2\n\n\n17\nF2\n0\n27\n\n\n18\nEa2\n17\n26\n\n\n19\nH2\n27\n26\n\n\n\n\n\n\n\n\n\n37.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{19}, \\  M_{1}, \\  L_{5}, \\  I_{Ea2}, \\  R_{14}, \\  R_{13}, \\  I_{L4}, \\  s, \\  h_{1}, \\  v_{18}, \\  I_{V1}, \\  I_{F1}, \\  R_{10}, \\  I_{H2}, \\  I_{V3}, \\  v_{11}, \\  I_{V5}, \\  v_{12}, \\  v_{15}, \\  R_{17}, \\  L_{6}, \\  g_{2}, \\  v_{7}, \\  I_{L6}, \\  v_{9}, \\  V_{7}, \\  v_{3}, \\  I_{F2}, \\  R_{16}, \\  v_{1}, \\  R_{9}, \\  v_{4}, \\  v_{27}, \\  I_{2}, \\  C_{2}, \\  L_{4}, \\  R_{12}, \\  v_{23}, \\  R_{18}, \\  v_{21}, \\  ea_{1}, \\  L_{2}, \\  V_{1}, \\  v_{17}, \\  g_{1}, \\  h_{2}, \\  I_{H1}, \\  I_{V2}, \\  L_{1}, \\  R_{11}, \\  R_{24}, \\  R_{2}, \\  I_{V4}, \\  R_{21}, \\  R_{15}, \\  f_{2}, \\  v_{6}, \\  I_{L5}, \\  R_{19}, \\  V_{3}, \\  R_{1}, \\  I_{1}, \\  f_{1}, \\  I_{Ea1}, \\  v_{10}, \\  I_{V8}, \\  v_{28}, \\  V_{2}, \\  L_{3}, \\  R_{25}, \\  M_{2}, \\  ea_{2}, \\  I_{4}, \\  R_{3}, \\  R_{5}, \\  R_{4}, \\  R_{8}, \\  R_{22}, \\  v_{5}, \\  R_{7}, \\  I_{V7}, \\  v_{26}, \\  V_{6}, \\  v_{25}, \\  R_{6}, \\  v_{8}, \\  R_{23}, \\  v_{2}, \\  v_{13}, \\  v_{22}, \\  R_{20}, \\  V_{4}, \\  I_{L1}, \\  v_{16}, \\  I_{V6}, \\  v_{24}, \\  I_{L2}, \\  v_{20}, \\  V_{8}, \\  C_{1}, \\  V_{5}, \\  I_{3}, \\  I_{L3}, \\  v_{14}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#symbolic-solution",
    "href": "test_7.html#symbolic-solution",
    "title": "37  Test 7",
    "section": "37.3 Symbolic solution",
    "text": "37.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#construct-a-dictionary-of-element-values",
    "href": "test_7.html#construct-a-dictionary-of-element-values",
    "title": "37  Test 7",
    "section": "37.4 Construct a dictionary of element values",
    "text": "37.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nV2 = 2.0\nV3 = 3.0\nV4 = 5.0\nV5 = 0.0\nV6 = 0.0\nV7 = 0.0\nV8 = 0.0\nR1 = 5.0\nR2 = 2.0\nR6 = 5.0\nR8 = 8.0\nR10 = 9.0\nR11 = 4.0\nR12 = 2.0\nR14 = 10.0\nR15 = 5.0\nI1 = 3.0\nI2 = 1.0\nI3 = 2.0\nI4 = 2.0\nR7 = 10.0\nR16 = 6.0\nR3 = 10.0\nR4 = 3.0\nf1 = 2.0\nea1 = 2.0\nh1 = 3.0\ng1 = 2.0\nL1 = 1.0\nL2 = 4.0\nL3 = 2.0\nL4 = 5.0\nC1 = 2.0\nC2 = 2.0\nL5 = 1.0\nL6 = 2.0\nf2 = 2.0\nea2 = 2.0\nh2 = 3.0\ng2 = 2.0\nR9 = 3.0\nR13 = 5.0\nR17 = 5.0\nR18 = 2.0\nR19 = 7.0\nR20 = 5.0\nR21 = 3.0\nR22 = 3.0\nR23 = 1.0\nR24 = 3.0\nR25 = 10.0\nR5 = 3.0\nK1 = 0.707\nK2 = 0.707\n\n\n\n37.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt;K1 L1 L2 0.707\nK2 L3 L4 0.707\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2 = symbols('K1 K2')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nmutual inductance, M1 = 1.414000000\nmutual inductance, M2 = 2.235730306",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_7.html#dc-operating-point",
    "href": "test_7.html#dc-operating-point",
    "title": "37  Test 7",
    "section": "37.5 DC operating point",
    "text": "37.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(-1.0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(1.0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(-3.0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\)\\(2.0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + 0.125 v_{11} - 2.0 v_{12} + 2.0 v_{13}\\)\\(-2.0 = 0.1 v_{12} - 0.1 v_{5}\\)\\(0 = 1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(-2.0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(2.0 = 0.333333333333333 v_{18} - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + 0.553968253968254 v_{23} - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(10.0 = v_{22}\\)\\(2.0 = v_{1}\\)\\(3.0 = v_{10} - v_{3}\\)\\(5.0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = v_{16} - v_{23}\\)\\(0 = v_{25} - v_{9}\\)\\(0 = - v_{21} + v_{22}\\)\\(0 = - v_{11} + v_{17}\\)\\(0 = - v_{7}\\)\\(0 = - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           5.971750\nv3         -10.279202\nv4          13.605119\nv5           8.605119\nv6           0.000000\nv7           0.000000\nv8           7.098329\nv9           5.971750\nv10         -7.279202\nv11        -18.854648\nv12        -11.394881\nv13         -7.101000\nv14        -23.295220\nv15         21.943500\nv16         21.252375\nv17        -18.854648\nv18          8.136867\nv19          2.136867\nv20        -12.279202\nv21         10.000000\nv22         10.000000\nv23         21.252375\nv24          5.971750\nv25          5.971750\nv26          7.647256\nv27         21.252375\nv28        -12.279202\nI_V1         0.612356\nI_V2         4.535040\nI_V3       -10.674641\nI_V4        10.552805\nI_V5         9.764013\nI_V6        -1.761697\nI_V7         3.056125\nI_V8         3.550500\nI_F1         9.070079\nI_Ea1       -4.388700\nI_H1        -4.373678\nI_L1         8.628637\nI_L2         3.223676\nI_L3         4.388700\nI_L4         7.140832\nI_L5        -9.070079\nI_L6         4.180225\nI_F2         9.070079\nI_Ea2       -7.140832\nI_H2         7.308382\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(16):   21.2524     voltage\nV(8):    7.09833     voltage\nV(1):    2   voltage\nV(2):    5.97175     voltage\nV(11):   -18.8546    voltage\nV(10):   -7.2792     voltage\nV(23):   21.2524     voltage\nV(22):   10  voltage\nV(9):    5.97175     voltage\nV(24):   5.97175     voltage\nV(3):    -10.2792    voltage\nV(20):   -12.2792    voltage\nV(5):    8.60512     voltage\nV(12):   -11.3949    voltage\nV(18):   8.13687     voltage\nV(26):   7.64726     voltage\nV(25):   5.97175     voltage\nV(4):    13.6051     voltage\nV(14):   -23.2952    voltage\nV(7):    0   voltage\nV(15):   21.9435     voltage\nV(21):   10  voltage\nV(13):   -7.101  voltage\nV(28):   -12.2792    voltage\nV(27):   21.2524     voltage\nV(17):   -18.8546    voltage\nV(6):    0   voltage\nV(19):   2.13687     voltage\nI(C1):   2.6231e-11  device_current\nI(C2):   1.49195e-11     device_current\nI(F1):   9.07008     device_current\nI(F2):   9.07008     device_current\nI(H1):   -4.37368    device_current\nI(H2):   7.30838     device_current\nI(L1):   8.62864     device_current\nI(L2):   3.22368     device_current\nI(L3):   4.3887  device_current\nI(L4):   7.14083     device_current\nI(L5):   -9.07008    device_current\nI(L6):   4.18022     device_current\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   2.83081     device_current\nI(R2):   2.54916     device_current\nI(R6):   1.19435     device_current\nI(R8):   -1.44693    device_current\nI(R10):  1.25026     device_current\nI(R11):  -0.281645   device_current\nI(R12):  1.98588     device_current\nI(R14):  -1.3251     device_current\nI(R15):  -3.05612    device_current\nI(R7):   -2  device_current\nI(R16):  -1.7132     device_current\nI(R3):   0.167551    device_current\nI(R4):   7.96144     device_current\nI(R9):   -3.75079    device_current\nI(R13):  4.3887  device_current\nI(R17):  1.84757     device_current\nI(R18):  -3.5505     device_current\nI(R19):  2.73079     device_current\nI(R20):  -2.88321    device_current\nI(R21):  -2  device_current\nI(R22):  -5.39807    device_current\nI(R23):  -5  device_current\nI(R24):  3.67201     device_current\nI(R25):  3.35316     device_current\nI(R5):   -4.09307    device_current\nI(G1):   8.58776     device_current\nI(G2):   -17.2102    device_current\nI(E1):   -4.3887     device_current\nI(E2):   -7.14083    device_current\nI(V1):   0.612356    device_current\nI(V2):   4.53504     device_current\nI(V3):   -10.6746    device_current\nI(V4):   10.5528     device_current\nI(V5):   9.76401     device_current\nI(V6):   -1.7617     device_current\nI(V7):   3.05612     device_current\nI(V8):   3.5505  device_current\n\nThe results from LTSpice agree with the SymPy results.\n\n37.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\nV2, V3, V4, I1, I2, I3, I4 are DC sources and are set to zero for AC analysis.\n\nelement_values[V2] = 0\nelement_values[V3] = 0\nelement_values[V4] = 0\nelement_values[I1] = 0\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\)\\(0 = 1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 i I_{L1} - 1.414 i I_{L2} + v_{16} - v_{23}\\)\\(0 = - 1.414 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\)\\(0 = - 2.0 i I_{L3} - 2.23573030573904 i I_{L4} - v_{21} + v_{22}\\)\\(0 = - 2.23573030573904 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\)\\(0 = - 1.0 i I_{L5} - v_{7}\\)\\(0 = - 2.0 i I_{L6} - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          0.000000    nan\nv2          1.269063   -156.737432\nv3          5.563110     92.699863\nv4          5.822884    -82.858298\nv5          5.049515    -83.161299\nv6          0.000000    nan\nv7          3.881923      7.141702\nv8          3.734176    -63.802595\nv9          2.183378   -102.275110\nv10         5.563110     92.699863\nv11         2.699909     95.168114\nv12         2.700976    103.385120\nv13         2.281731     84.349178\nv14         9.719907     94.381715\nv15         5.149976   -119.308730\nv16        15.692738    -57.591025\nv17        10.020727     70.734148\nv18        12.269643    -67.106998\nv19         5.029569    -61.518344\nv20         5.563110     92.699863\nv21         7.926685    -18.560431\nv22        10.000000      0.000000\nv23        12.247990    -72.779714\nv24        10.615913    -41.644709\nv25        10.615913    -41.644709\nv26         6.594170    -63.890173\nv27        12.247990    -72.779714\nv28         5.563110     92.699863\nI_V1        4.873462    -98.660056\nI_V2        1.940961    -82.858298\nI_V3        4.719081     94.525274\nI_V4        5.842672    -86.521779\nI_V5        6.490055    -83.573802\nI_V6        3.704717     80.775839\nI_V7        1.266856   -132.840858\nI_V8        1.140866    -95.650822\nI_F1        3.881923    -82.858298\nI_Ea1       1.029995     60.691270\nI_H1        4.026860     71.937257\nI_L1        3.651246    -84.027986\nI_L2        1.589691   -149.132274\nI_L3        1.029995   -119.308730\nI_L4        1.609380    -11.044380\nI_L5        3.881923     97.141702\nI_L6        0.888344   -156.737432\nI_F2        3.881923    -82.858298\nI_Ea2       1.609380    168.955620\nI_H2        1.093990    -10.267379\n\n\nThe results from LTSpice are shown below and agree with the Python results.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    15.6927 phase:    -57.591°  voltage\nV(8):   mag:    3.73418 phase:   -63.8026°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:    1.26906 phase:   -156.737°  voltage\nV(11):  mag:    2.69991 phase:    95.1681°  voltage\nV(10):  mag:    5.56311 phase:    92.6999°  voltage\nV(23):  mag:     12.248 phase:   -72.7797°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:    2.18338 phase:   -102.275°  voltage\nV(24):  mag:    10.6159 phase:   -41.6447°  voltage\nV(3):   mag:    5.56311 phase:    92.6999°  voltage\nV(20):  mag:    5.56311 phase:    92.6999°  voltage\nV(5):   mag:    5.04951 phase:   -83.1613°  voltage\nV(12):  mag:    2.70098 phase:    103.385°  voltage\nV(18):  mag:    12.2696 phase:    -67.107°  voltage\nV(26):  mag:    6.59417 phase:   -63.8902°  voltage\nV(25):  mag:    10.6159 phase:   -41.6447°  voltage\nV(4):   mag:    5.82288 phase:   -82.8583°  voltage\nV(14):  mag:    9.71991 phase:    94.3817°  voltage\nV(7):   mag:    3.88192 phase:     7.1417°  voltage\nV(15):  mag:    5.14998 phase:   -119.309°  voltage\nV(21):  mag:    7.92669 phase:   -18.5604°  voltage\nV(13):  mag:    2.28173 phase:    84.3492°  voltage\nV(28):  mag:    5.56311 phase:    92.6999°  voltage\nV(27):  mag:     12.248 phase:   -72.7797°  voltage\nV(17):  mag:    10.0207 phase:    70.7341°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    5.02957 phase:   -61.5183°  voltage\nI(C1):  mag:    2.42683 phase:   -70.9646°  device_current\nI(C2):  mag:   0.773901 phase:   -80.8809°  device_current\nI(F1):  mag:    3.88192 phase:   -82.8583°  device_current\nI(F2):  mag:    3.88192 phase:   -82.8583°  device_current\nI(H1):  mag:    4.02686 phase:    71.9373°  device_current\nI(H2):  mag:    1.09399 phase:   -10.2674°  device_current\nI(L1):  mag:    3.65125 phase:    -84.028°  device_current\nI(L2):  mag:    1.58969 phase:   -149.132°  device_current\nI(L3):  mag:       1.03 phase:   -119.309°  device_current\nI(L4):  mag:    1.60938 phase:   -11.0444°  device_current\nI(L5):  mag:    3.88192 phase:    97.1417°  device_current\nI(L6):  mag:   0.888344 phase:   -156.737°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:    2.39746 phase:   -55.6595°  device_current\nI(R2):  mag:    1.86709 phase:   -63.8026°  device_current\nI(R6):  mag:   0.253813 phase:   -156.737°  device_current\nI(R8):  mag:   0.358508 phase:   -89.6236°  device_current\nI(R10): mag:     1.4803 phase:   -118.583°  device_current\nI(R11): mag:   0.609557 phase:    150.054°  device_current\nI(R12): mag:   0.634531 phase:   -156.737°  device_current\nI(R14): mag:   0.769305 phase:    88.4942°  device_current\nI(R15): mag:    1.26686 phase:    47.1591°  device_current\nI(R7):  mag:   0.773901 phase:    99.1191°  device_current\nI(R16): mag:   0.927185 phase:    92.6999°  device_current\nI(R3):  mag:   0.515704 phase:    167.307°  device_current\nI(R4):  mag:    3.79248 phase:   -85.0285°  device_current\nI(R9):  mag:    4.44783 phase:    83.1593°  device_current\nI(R13): mag:       1.03 phase:   -119.309°  device_current\nI(R17): mag:    1.40714 phase:   -72.0029°  device_current\nI(R18): mag:    1.14087 phase:    84.3492°  device_current\nI(R19): mag:    1.05441 phase:   -80.4269°  device_current\nI(R20): mag:    2.06528 phase:     104.93°  device_current\nI(R21): mag:    2.42683 phase:    109.035°  device_current\nI(R22): mag:    2.49454 phase:    97.4264°  device_current\nI(R23): mag:   0.773901 phase:    99.1191°  device_current\nI(R24): mag:    1.38747 phase:   -83.3702°  device_current\nI(R25): mag:    1.76885 phase:   -77.3024°  device_current\nI(R5):  mag:    1.85437 phase:    92.6999°  device_current\nI(G1):  mag:    1.84371 phase:   -22.7819°  device_current\nI(G2):  mag:     10.099 phase:    96.8387°  device_current\nI(E1):  mag:       1.03 phase:    60.6913°  device_current\nI(E2):  mag:    1.60938 phase:    168.956°  device_current\nI(V1):  mag:    4.87346 phase:   -98.6601°  device_current\nI(V2):  mag:    1.94096 phase:   -82.8583°  device_current\nI(V3):  mag:    4.71908 phase:    94.5253°  device_current\nI(V4):  mag:    5.84267 phase:   -86.5218°  device_current\nI(V5):  mag:    6.49005 phase:   -83.5738°  device_current\nI(V6):  mag:    3.70472 phase:    80.7758°  device_current\nI(V7):  mag:    1.26686 phase:   -132.841°  device_current\nI(V8):  mag:    1.14087 phase:   -95.6508°  device_current\n\n\n37.5.2 AC Sweep\nLooking at node 17 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(2.0 s + 0.125\\right) + v_{12} \\left(- 2.0 s - 2.0\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 s v_{11} + v_{12} \\cdot \\left(2.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = 1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = - 2.0 s v_{23} + v_{18} \\cdot \\left(2.0 s + 0.333333333333333\\right) - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 s v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(2.0 s + 0.553968253968254\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 I_{L1} s - 1.414 I_{L2} s + v_{16} - v_{23}\\)\\(0 = - 1.414 I_{L1} s - 4.0 I_{L2} s + v_{25} - v_{9}\\)\\(0 = - 2.0 I_{L3} s - 2.23573030573904 I_{L4} s - v_{21} + v_{22}\\)\\(0 = - 2.23573030573904 I_{L3} s - 5.0 I_{L4} s - v_{11} + v_{17}\\)\\(0 = - 1.0 I_{L5} s - v_{7}\\)\\(0 = - 2.0 I_{L6} s - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n37.5.3 Plot the voltage at node 10\n\nH = U_ac[v17]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 200, endpoint=True)\nx = np.logspace(-2, 0, 1000, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_7.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\) and \\(10^{-11}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Test 7</span>"
    ]
  },
  {
    "objectID": "test_8.html",
    "href": "test_8.html",
    "title": "38  Test 8",
    "section": "",
    "text": "38.1 Load the net list\nThis test circuit shown in Figure 38.1 is the same circuit as Figure 37.1, for the addition of two Op Amps.\n\\(\\large{\\color {red} {\\text{Note for author:}}}\\)\nThe netlist generated by LTSpice:\nnet_list = '''\nR1 16 8 5\nR2 8 1 2\nR6 2 0 5\nR8 11 10 8\nR10 23 22 9\nR11 9 8 4\nR12 2 1 2\nR14 10 9 10\nR15 24 23 5\nV1 22 0 10\nV2 1 0 2\nV3 10 3 3\nV4 10 20 5\nI1 5 0 3\nI2 2 3 1\nI3 16 9 2\nI4 12 18 2\nR7 12 5 10\nR16 3 0 6\nR3 26 25 10\nR4 4 3 3\nF1 14 7 V2 2\nE1 15 21 2 7 2\nH1 4 0 V2 3\nG1 11 4 13 12 2\nL1 16 23 1 \nL2 25 9 4 \nV5 20 28 0\nV6 23 27 0\nL3 22 21 2 \nL4 17 11 5 \nC1 23 18 2\nC2 12 11 2\nL5 0 7 1 \nL6 9 2 2 \nF2 0 27 V2 2\nE2 17 26 10 9 2\nH2 27 26 V2 3\nG2 16 28 0 5 2\nV7 24 25 0\nV8 0 6 0\nR9 22 16 3\nR13 15 0 5\nR17 19 13 5\nR18 13 6 2\nR19 23 19 7\nR20 20 19 5\nR21 19 18 3\nR22 14 13 3\nR23 5 4 1\nR24 20 14 3\nR25 23 28 10\nR5 28 0 3\nR26 32 31 20e3\nR27 30 29 10e3\nR28 13 30 2\nR29 24 32 5\nR30 29 21 20e3\nR31 31 8 10e3\nO1 29 0 30 \nO2 31 0 32 \nK1 L1 L2 0.8\nK2 L3 L4 0.2\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_8.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "38  Test 8",
    "section": "38.2 Call the symbolic modified nodal analysis function",
    "text": "38.2 Call the symbolic modified nodal analysis function\nThe circuit has 32 nodes and 59 branches, which results in 54 network equations. The Python code can generate these equations in about 1 second.\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V2} + v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{8}}{R_{2}} - \\frac{v_{2}}{R_{12}} = 0\\)\\(- I_{L6} + v_{2} \\cdot \\left(\\frac{1}{R_{6}} + \\frac{1}{R_{12}}\\right) - \\frac{v_{1}}{R_{12}} = - I_{2}\\)\\(- I_{V3} + v_{3} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{16}}\\right) - \\frac{v_{4}}{R_{4}} = I_{2}\\)\\(I_{H1} + g_{1} v_{12} - g_{1} v_{13} + v_{4} \\cdot \\left(\\frac{1}{R_{4}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{3}}{R_{4}} - \\frac{v_{5}}{R_{23}} = 0\\)\\(v_{5} \\cdot \\left(\\frac{1}{R_{7}} + \\frac{1}{R_{23}}\\right) - \\frac{v_{12}}{R_{7}} - \\frac{v_{4}}{R_{23}} = - I_{1}\\)\\(- I_{V8} - \\frac{v_{13}}{R_{18}} + \\frac{v_{6}}{R_{18}} = 0\\)\\(- I_{F1} - I_{L5} = 0\\)\\(v_{8} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{31}}{R_{31}} - \\frac{v_{1}}{R_{2}} - \\frac{v_{9}}{R_{11}} - \\frac{v_{16}}{R_{1}} = 0\\)\\(- I_{L2} + I_{L6} + v_{9} \\cdot \\left(\\frac{1}{R_{14}} + \\frac{1}{R_{11}}\\right) - \\frac{v_{10}}{R_{14}} - \\frac{v_{8}}{R_{11}} = I_{3}\\)\\(I_{V3} + I_{V4} + v_{10} \\cdot \\left(\\frac{1}{R_{8}} + \\frac{1}{R_{14}}\\right) - \\frac{v_{11}}{R_{8}} - \\frac{v_{9}}{R_{14}} = 0\\)\\(- I_{L4} + g_{1} v_{13} + v_{11} \\left(C_{2} s + \\frac{1}{R_{8}}\\right) + v_{12} \\left(- C_{2} s - g_{1}\\right) - \\frac{v_{10}}{R_{8}} = 0\\)\\(- C_{2} s v_{11} + v_{12} \\left(C_{2} s + \\frac{1}{R_{7}}\\right) - \\frac{v_{5}}{R_{7}} = - I_{4}\\)\\(v_{13} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{30}}{R_{28}} - \\frac{v_{14}}{R_{22}} - \\frac{v_{6}}{R_{18}} - \\frac{v_{19}}{R_{17}} = 0\\)\\(I_{F1} + v_{14} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{20}}{R_{24}} - \\frac{v_{13}}{R_{22}} = 0\\)\\(I_{Ea1} + \\frac{v_{15}}{R_{13}} = 0\\)\\(I_{L1} - g_{2} v_{5} + v_{16} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{22}}{R_{9}} - \\frac{v_{8}}{R_{1}} = - I_{3}\\)\\(I_{Ea2} + I_{L4} = 0\\)\\(- C_{1} s v_{23} + v_{18} \\left(C_{1} s + \\frac{1}{R_{21}}\\right) - \\frac{v_{19}}{R_{21}} = I_{4}\\)\\(v_{19} \\cdot \\left(\\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}}\\right) - \\frac{v_{18}}{R_{21}} - \\frac{v_{20}}{R_{20}} - \\frac{v_{23}}{R_{19}} - \\frac{v_{13}}{R_{17}} = 0\\)\\(- I_{V4} + I_{V5} + v_{20} \\cdot \\left(\\frac{1}{R_{24}} + \\frac{1}{R_{20}}\\right) - \\frac{v_{14}}{R_{24}} - \\frac{v_{19}}{R_{20}} = 0\\)\\(- I_{Ea1} - I_{L3} + \\frac{v_{21}}{R_{30}} - \\frac{v_{29}}{R_{30}} = 0\\)\\(I_{L3} + I_{V1} + v_{22} \\cdot \\left(\\frac{1}{R_{9}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{16}}{R_{9}} - \\frac{v_{23}}{R_{10}} = 0\\)\\(- C_{1} s v_{18} - I_{L1} + I_{V6} + v_{23} \\left(C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}}\\right) - \\frac{v_{28}}{R_{25}} - \\frac{v_{19}}{R_{19}} - \\frac{v_{24}}{R_{15}} - \\frac{v_{22}}{R_{10}} = 0\\)\\(I_{V7} + v_{24} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{15}}\\right) - \\frac{v_{32}}{R_{29}} - \\frac{v_{23}}{R_{15}} = 0\\)\\(I_{L2} - I_{V7} + \\frac{v_{25}}{R_{3}} - \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{Ea2} - I_{H2} - \\frac{v_{25}}{R_{3}} + \\frac{v_{26}}{R_{3}} = 0\\)\\(- I_{F2} + I_{H2} - I_{V6} = 0\\)\\(- I_{V5} + g_{2} v_{5} + v_{28} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{25}}\\right) - \\frac{v_{23}}{R_{25}} = 0\\)\\(v_{29} \\cdot \\left(\\frac{1}{R_{30}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{21}}{R_{30}} - \\frac{v_{30}}{R_{27}} = 0\\)\\(I_{O1} + v_{30} \\cdot \\left(\\frac{1}{R_{28}} + \\frac{1}{R_{27}}\\right) - \\frac{v_{13}}{R_{28}} - \\frac{v_{29}}{R_{27}} = 0\\)\\(v_{31} \\cdot \\left(\\frac{1}{R_{31}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{8}}{R_{31}} - \\frac{v_{32}}{R_{26}} = 0\\)\\(I_{O2} + v_{32} \\cdot \\left(\\frac{1}{R_{29}} + \\frac{1}{R_{26}}\\right) - \\frac{v_{24}}{R_{29}} - \\frac{v_{31}}{R_{26}} = 0\\)\\(v_{22} = V_{1}\\)\\(v_{1} = V_{2}\\)\\(v_{10} - v_{3} = V_{3}\\)\\(v_{10} - v_{20} = V_{4}\\)\\(v_{20} - v_{28} = V_{5}\\)\\(v_{23} - v_{27} = V_{6}\\)\\(v_{24} - v_{25} = V_{7}\\)\\(- v_{6} = V_{8}\\)\\(I_{F1} - I_{V2} f_{1} = 0\\)\\(- ea_{1} v_{2} + ea_{1} v_{7} + v_{15} - v_{21} = 0\\)\\(- I_{V2} h_{1} + v_{4} = 0\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s + v_{16} - v_{23} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s + v_{25} - v_{9} = 0\\)\\(- I_{L3} L_{3} s - I_{L4} M_{2} s - v_{21} + v_{22} = 0\\)\\(- I_{L3} M_{2} s - I_{L4} L_{4} s - v_{11} + v_{17} = 0\\)\\(- I_{L5} L_{5} s - v_{7} = 0\\)\\(- I_{L6} L_{6} s - v_{2} + v_{9} = 0\\)\\(I_{F2} - I_{V2} f_{2} = 0\\)\\(- ea_{2} v_{10} + ea_{2} v_{9} + v_{17} - v_{26} = 0\\)\\(- I_{V2} h_{2} - v_{26} + v_{27} = 0\\)\\(v_{29} = 0\\)\\(v_{31} = 0\\)\n\n\n\nprint('There are {:d} network equations for this circuit generated by MNA'.format(len(X)))\n\nThere are 54 network equations for this circuit generated by MNA\n\n\n\n38.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 63\nnumber of branches: 59\nnumber of nodes: 32\nnumber of unknown currents: 22\nnumber of RLC (passive components): 39\nnumber of inductors: 6\nnumber of independent voltage sources: 8\nnumber of independent current sources: 4\nnumber of Op Amps: 2\nnumber of E - VCVS: 2\nnumber of G - VCCS: 2\nnumber of F - CCCS: 2\nnumber of H - CCVS: 2\nnumber of K - Coupled inductors: 2\n\n\n\n\n\n38.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{array}{cccccccccccccccccccccccccccccccccccccccccccccccccccccc}\\frac{1}{R_{2}} + \\frac{1}{R_{12}} & - \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{12}} & \\frac{1}{R_{6}} + \\frac{1}{R_{12}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{R_{4}} + \\frac{1}{R_{16}} & - \\frac{1}{R_{4}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{4}} & \\frac{1}{R_{4}} + \\frac{1}{R_{23}} & - \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & g_{1} & - g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & - \\frac{1}{R_{23}} & \\frac{1}{R_{7}} + \\frac{1}{R_{23}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{31}} + \\frac{1}{R_{2}} + \\frac{1}{R_{11}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{11}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{31}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{11}} & \\frac{1}{R_{14}} + \\frac{1}{R_{11}} & - \\frac{1}{R_{14}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{14}} & \\frac{1}{R_{8}} + \\frac{1}{R_{14}} & - \\frac{1}{R_{8}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{8}} & C_{2} s + \\frac{1}{R_{8}} & - C_{2} s - g_{1} & g_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & - C_{2} s & C_{2} s + \\frac{1}{R_{7}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{18}} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{28}} + \\frac{1}{R_{22}} + \\frac{1}{R_{18}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{28}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{22}} & \\frac{1}{R_{24}} + \\frac{1}{R_{22}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{13}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & - g_{2} & 0 & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & C_{1} s + \\frac{1}{R_{21}} & - \\frac{1}{R_{21}} & 0 & 0 & 0 & - C_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{17}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{21}} & \\frac{1}{R_{21}} + \\frac{1}{R_{20}} + \\frac{1}{R_{19}} + \\frac{1}{R_{17}} & - \\frac{1}{R_{20}} & 0 & 0 & - \\frac{1}{R_{19}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{24}} & 0 & 0 & 0 & 0 & - \\frac{1}{R_{20}} & \\frac{1}{R_{24}} + \\frac{1}{R_{20}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{9}} & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{9}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{10}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - C_{1} s & - \\frac{1}{R_{19}} & 0 & 0 & - \\frac{1}{R_{10}} & C_{1} s + \\frac{1}{R_{25}} + \\frac{1}{R_{19}} + \\frac{1}{R_{15}} + \\frac{1}{R_{10}} & - \\frac{1}{R_{15}} & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{15}} & \\frac{1}{R_{29}} + \\frac{1}{R_{15}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{29}} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{3}} & - \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{3}} & \\frac{1}{R_{3}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 1 & 0 & 0\\\\0 & 0 & 0 & 0 & g_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & \\frac{1}{R_{5}} + \\frac{1}{R_{25}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{30}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{30}} + \\frac{1}{R_{27}} & - \\frac{1}{R_{27}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{28}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{27}} & \\frac{1}{R_{28}} + \\frac{1}{R_{27}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{31}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{R_{31}} + \\frac{1}{R_{26}} & - \\frac{1}{R_{26}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{29}} & 0 & 0 & 0 & 0 & 0 & 0 & - \\frac{1}{R_{26}} & \\frac{1}{R_{29}} + \\frac{1}{R_{26}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & - ea_{1} & 0 & 0 & 0 & 0 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{3} s & - M_{2} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - M_{2} s & - L_{4} s & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{5} s & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{6} s & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & - f_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ea_{2} & - ea_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & - h_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\end{array}\\right]\\)\n\n\n\n\n38.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  v_{6}, \\  v_{7}, \\  v_{8}, \\  v_{9}, \\  v_{10}, \\  v_{11}, \\  v_{12}, \\  v_{13}, \\  v_{14}, \\  v_{15}, \\  v_{16}, \\  v_{17}, \\  v_{18}, \\  v_{19}, \\  v_{20}, \\  v_{21}, \\  v_{22}, \\  v_{23}, \\  v_{24}, \\  v_{25}, \\  v_{26}, \\  v_{27}, \\  v_{28}, \\  v_{29}, \\  v_{30}, \\  v_{31}, \\  v_{32}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}, \\  I_{V5}, \\  I_{V6}, \\  I_{V7}, \\  I_{V8}, \\  I_{F1}, \\  I_{Ea1}, \\  I_{H1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}, \\  I_{L5}, \\  I_{L6}, \\  I_{F2}, \\  I_{Ea2}, \\  I_{H2}, \\  I_{O1}, \\  I_{O2}\\right]\\)\n\n\n\n\n38.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  - I_{2}, \\  I_{2}, \\  0, \\  - I_{1}, \\  0, \\  0, \\  0, \\  I_{3}, \\  0, \\  0, \\  - I_{4}, \\  0, \\  0, \\  0, \\  - I_{3}, \\  0, \\  I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}, \\  V_{5}, \\  V_{6}, \\  V_{7}, \\  V_{8}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n38.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n22\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n1\n0\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n10\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n10\n20\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n4\nV5\n20\n28\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nR31\n31\n8\nNaN\nNaN\nNaN\n10000.0\nNaN\nNaN\nNaN\n\n\n59\nO1\n29\n0\nNaN\nNaN\n30\nNaN\nNaN\nNaN\nNaN\n\n\n60\nO2\n31\n0\nNaN\nNaN\n32\nNaN\nNaN\nNaN\nNaN\n\n\n61\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.8\nNaN\nL1\nL2\n\n\n62\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.2\nNaN\nL3\nL4\n\n\n\n\n63 rows × 10 columns\n\n\n\n\n\n38.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n22\n0\n\n\n1\nV2\n1\n0\n\n\n2\nV3\n10\n3\n\n\n3\nV4\n10\n20\n\n\n4\nV5\n20\n28\n\n\n5\nV6\n23\n27\n\n\n6\nV7\n24\n25\n\n\n7\nV8\n0\n6\n\n\n8\nF1\n14\n7\n\n\n9\nEa1\n15\n21\n\n\n10\nH1\n4\n0\n\n\n11\nL1\n16\n23\n\n\n12\nL2\n25\n9\n\n\n13\nL3\n22\n21\n\n\n14\nL4\n17\n11\n\n\n15\nL5\n0\n7\n\n\n16\nL6\n9\n2\n\n\n17\nF2\n0\n27\n\n\n18\nEa2\n17\n26\n\n\n19\nH2\n27\n26\n\n\n20\nO1\n29\n0\n\n\n21\nO2\n31\n0\n\n\n\n\n\n\n\n\n\n38.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( ea_{1}, \\  v_{19}, \\  R_{8}, \\  I_{Ea2}, \\  R_{14}, \\  R_{3}, \\  R_{15}, \\  g_{2}, \\  v_{27}, \\  I_{V8}, \\  V_{5}, \\  V_{8}, \\  h_{2}, \\  V_{6}, \\  I_{V7}, \\  v_{32}, \\  R_{31}, \\  I_{H2}, \\  v_{25}, \\  R_{1}, \\  v_{5}, \\  M_{1}, \\  I_{V1}, \\  R_{19}, \\  I_{1}, \\  I_{V5}, \\  I_{L1}, \\  I_{L4}, \\  v_{7}, \\  R_{18}, \\  R_{16}, \\  R_{25}, \\  v_{20}, \\  v_{8}, \\  R_{4}, \\  s, \\  v_{28}, \\  v_{22}, \\  v_{14}, \\  C_{2}, \\  ea_{2}, \\  v_{24}, \\  v_{16}, \\  I_{O1}, \\  v_{4}, \\  f_{1}, \\  h_{1}, \\  v_{3}, \\  v_{10}, \\  V_{1}, \\  R_{9}, \\  R_{12}, \\  I_{4}, \\  I_{L3}, \\  R_{20}, \\  v_{26}, \\  v_{11}, \\  R_{23}, \\  I_{L6}, \\  v_{31}, \\  v_{9}, \\  g_{1}, \\  I_{3}, \\  V_{3}, \\  I_{V3}, \\  V_{4}, \\  I_{V2}, \\  v_{23}, \\  R_{22}, \\  L_{1}, \\  R_{10}, \\  v_{1}, \\  I_{V4}, \\  R_{6}, \\  v_{13}, \\  R_{21}, \\  L_{2}, \\  I_{L2}, \\  L_{4}, \\  v_{6}, \\  I_{F2}, \\  v_{17}, \\  L_{6}, \\  R_{30}, \\  R_{2}, \\  R_{28}, \\  L_{5}, \\  v_{12}, \\  v_{18}, \\  R_{29}, \\  I_{Ea1}, \\  C_{1}, \\  R_{17}, \\  L_{3}, \\  R_{27}, \\  R_{26}, \\  V_{2}, \\  v_{21}, \\  I_{L5}, \\  v_{2}, \\  V_{7}, \\  R_{5}, \\  v_{29}, \\  f_{2}, \\  I_{2}, \\  I_{F1}, \\  R_{13}, \\  v_{15}, \\  R_{24}, \\  v_{30}, \\  I_{O2}, \\  M_{2}, \\  I_{H1}, \\  R_{7}, \\  R_{11}, \\  I_{V6}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#symbolic-solution",
    "href": "test_8.html#symbolic-solution",
    "title": "38  Test 8",
    "section": "38.3 Symbolic solution",
    "text": "38.3 Symbolic solution\nThe symbolic solution was taking longer than a couple of minutes on my i3-8130U CPU @ 2.20GHz, so I interruped the kernel and commended the code.\n\n#U_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\n#temp = ''\n#for i in U_sym.keys():\n#    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\n#Markdown(temp)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#construct-a-dictionary-of-element-values",
    "href": "test_8.html#construct-a-dictionary-of-element-values",
    "title": "38  Test 8",
    "section": "38.4 Construct a dictionary of element values",
    "text": "38.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nV2 = 2.0\nV3 = 3.0\nV4 = 5.0\nV5 = 0.0\nV6 = 0.0\nV7 = 0.0\nV8 = 0.0\nR1 = 5.0\nR2 = 2.0\nR6 = 5.0\nR8 = 8.0\nR10 = 9.0\nR11 = 4.0\nR12 = 2.0\nR14 = 10.0\nR15 = 5.0\nI1 = 3.0\nI2 = 1.0\nI3 = 2.0\nI4 = 2.0\nR7 = 10.0\nR16 = 6.0\nR3 = 10.0\nR4 = 3.0\nf1 = 2.0\nea1 = 2.0\nh1 = 3.0\ng1 = 2.0\nL1 = 1.0\nL2 = 4.0\nL3 = 2.0\nL4 = 5.0\nC1 = 2.0\nC2 = 2.0\nL5 = 1.0\nL6 = 2.0\nf2 = 2.0\nea2 = 2.0\nh2 = 3.0\ng2 = 2.0\nR9 = 3.0\nR13 = 5.0\nR17 = 5.0\nR18 = 2.0\nR19 = 7.0\nR20 = 5.0\nR21 = 3.0\nR22 = 3.0\nR23 = 1.0\nR24 = 3.0\nR25 = 10.0\nR5 = 3.0\nR26 = 20000.0\nR27 = 10000.0\nR28 = 2.0\nR29 = 5.0\nR30 = 20000.0\nR31 = 10000.0\nO1 = nan\nO2 = nan\nK1 = 0.8\nK2 = 0.2\n\n\n\n38.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit. &gt;K1 L1 L2 0.8\nK2 L3 L4 0.2\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(k = \\frac {M}{\\sqrt{L_1 \\times L_2}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2 = symbols('K1 K2')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] *element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L3] *element_values[L4])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nmutual inductance, M1 = 1.600000000\nmutual inductance, M2 = 0.632455532",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_8.html#dc-operating-point",
    "href": "test_8.html#dc-operating-point",
    "title": "38  Test 8",
    "section": "38.5 DC operating point",
    "text": "38.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(-1.0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(1.0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(-3.0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\)\\(2.0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + 0.125 v_{11} - 2.0 v_{12} + 2.0 v_{13}\\)\\(-2.0 = 0.1 v_{12} - 0.1 v_{5}\\)\\(0 = 1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(-2.0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(2.0 = 0.333333333333333 v_{18} - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + 0.553968253968254 v_{23} - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(0 = - 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\)\\(0 = I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\)\\(0 = 0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\)\\(0 = I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\)\\(10.0 = v_{22}\\)\\(2.0 = v_{1}\\)\\(3.0 = v_{10} - v_{3}\\)\\(5.0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = v_{16} - v_{23}\\)\\(0 = v_{25} - v_{9}\\)\\(0 = - v_{21} + v_{22}\\)\\(0 = - v_{11} + v_{17}\\)\\(0 = - v_{7}\\)\\(0 = - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\\(0 = v_{29}\\)\\(0 = v_{31}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1           2.000000\nv2           5.487985\nv3         -13.447794\nv4          17.339762\nv5          12.339762\nv6           0.000000\nv7           0.000000\nv8          10.071856\nv9           5.487985\nv10        -10.447794\nv11        -13.224949\nv12         -7.660238\nv13         -7.240585\nv14        -28.683952\nv15         20.975971\nv16         35.986371\nv17        -13.224949\nv18         10.795432\nv19          4.795432\nv20        -15.447794\nv21         10.000000\nv22         10.000000\nv23         35.986371\nv24          5.487985\nv25          5.487985\nv26         18.646609\nv27         35.986371\nv28        -15.447794\nv29          0.000000\nv30         -5.000000\nv31          0.000000\nv32        -20.143712\nI_V1         7.353804\nI_V2         5.779921\nI_V3       -13.503818\nI_V4        14.750251\nI_V5        14.386843\nI_V6        -9.751819\nI_V7         0.973338\nI_V8         3.620293\nI_F1        11.559841\nI_Ea1       -4.195194\nI_H1       -14.423214\nI_L1         8.834498\nI_L2         2.289200\nI_L3         4.195694\nI_L4         0.492160\nI_L5       -11.559841\nI_L6         3.841590\nI_F2        11.559841\nI_Ea2       -0.492160\nI_H2         1.808023\nI_O1        -1.119793\nI_O2         5.127347\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(16):   35.9859     voltage\nV(8):    10.0718     voltage\nV(1):    2   voltage\nV(2):    5.48801     voltage\nV(11):   -13.2252    voltage\nV(10):   -10.4477    voltage\nV(23):   35.9859     voltage\nV(22):   10  voltage\nV(9):    5.48801     voltage\nV(24):   5.48801     voltage\nV(3):    -13.4477    voltage\nV(20):   -15.4477    voltage\nV(5):    12.3397     voltage\nV(12):   -7.66035    voltage\nV(18):   10.7954     voltage\nV(26):   18.6462     voltage\nV(25):   5.48801     voltage\nV(4):    17.3397     voltage\nV(14):   -28.6838    voltage\nV(7):    0   voltage\nV(15):   20.976  voltage\nV(21):   10  voltage\nV(13):   -7.24054    voltage\nV(28):   -15.4477    voltage\nV(27):   35.9859     voltage\nV(17):   -13.2252    voltage\nV(6):    0   voltage\nV(19):   4.79535     voltage\nV(32):   -20.1428    voltage\nV(31):   0.000252699     voltage\nV(30):   -4.99994    voltage\nV(29):   3.88014e-05     voltage\nI(C1):   5.03811e-11     device_current\nI(C2):   1.11297e-11     device_current\nI(F1):   11.5598     device_current\nI(F2):   11.5598     device_current\nI(H1):   -14.4228    device_current\nI(H2):   1.80825     device_current\nI(L1):   8.83452     device_current\nI(L2):   2.28924     device_current\nI(L3):   4.1957  device_current\nI(L4):   0.492428    device_current\nI(L5):   -11.5598    device_current\nI(L6):   3.84161     device_current\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   5.18282     device_current\nI(R2):   4.03588     device_current\nI(R6):   1.0976  device_current\nI(R8):   -0.347188   device_current\nI(R10):  2.88732     device_current\nI(R11):  -1.14594    device_current\nI(R12):  1.744   device_current\nI(R14):  -1.59357    device_current\nI(R15):  -6.09957    device_current\nI(R7):   -2  device_current\nI(R16):  -2.24128    device_current\nI(R3):   1.31582     device_current\nI(R4):   10.2625     device_current\nI(R9):   -8.66196    device_current\nI(R13):  4.1952  device_current\nI(R17):  2.40718     device_current\nI(R18):  -3.62027    device_current\nI(R19):  4.45579     device_current\nI(R20):  -4.04861    device_current\nI(R21):  -2  device_current\nI(R22):  -7.14775    device_current\nI(R23):  -5  device_current\nI(R24):  4.41202     device_current\nI(R25):  5.14336     device_current\nI(R5):   -5.14924    device_current\nI(R26):  -0.00100715     device_current\nI(R27):  -0.000499998    device_current\nI(R28):  -1.1203     device_current\nI(R29):  5.12615     device_current\nI(R30):  -0.000499998    device_current\nI(R31):  -0.00100715     device_current\nI(G1):   0.839616    device_current\nI(G2):   -24.6793    device_current\nI(E1):   -4.1952     device_current\nI(E2):   -0.492428   device_current\nI(V1):   7.35358     device_current\nI(V2):   5.77988     device_current\nI(V3):   -13.5037    device_current\nI(V4):   14.7501     device_current\nI(V5):   14.3867     device_current\nI(V6):   -9.75152    device_current\nI(V7):   0.97342     device_current\nI(V8):   3.62027     device_current\nIx(u1:3):    -1.1198     subckt_current\nIx(u2:3):    5.12716     subckt_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n38.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\nV2, V3, V4, I1, I2, I3, I4 are DC sources and are set to zero for AC analysis.\n\nelement_values[V2] = 0\nelement_values[V3] = 0\nelement_values[V4] = 0\nelement_values[I1] = 0\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\)\\(0 = 1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(0 = - 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\)\\(0 = I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\)\\(0 = 0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\)\\(0 = I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 i I_{L1} - 1.6 i I_{L2} + v_{16} - v_{23}\\)\\(0 = - 1.6 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\)\\(0 = - 2.0 i I_{L3} - 0.632455532033676 i I_{L4} - v_{21} + v_{22}\\)\\(0 = - 0.632455532033676 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\)\\(0 = - 1.0 i I_{L5} - v_{7}\\)\\(0 = - 2.0 i I_{L6} - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\\(0 = v_{29}\\)\\(0 = v_{31}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          0.000000    nan\nv2          0.529312   -148.498854\nv3          2.318355    160.462708\nv4          2.716202    -16.110995\nv5          2.274423    -15.079695\nv6          0.000000    nan\nv7          1.810802     73.889005\nv8          2.202609     -5.887185\nv9          0.910663    -94.036532\nv10         2.318355    160.462708\nv11         2.230400    146.370665\nv12         2.194128    152.046037\nv13         1.799206    158.492008\nv14         4.771405    162.040739\nv15         8.166288    -49.821325\nv16        10.488620      0.340133\nv17         3.084191     60.400459\nv18         8.481449     -4.374848\nv19         3.704998     -2.371134\nv20         2.318355    160.462708\nv21         7.507931    -17.093526\nv22        10.000000      0.000000\nv23         8.497267     -9.753103\nv24         4.119822      7.433394\nv25         4.119822      7.433394\nv26         5.805567     -6.783261\nv27         8.497267     -9.753103\nv28         2.318355    160.462708\nv29         0.000000    nan\nv30         3.753966    162.906474\nv31         0.000000    nan\nv32         4.405217    174.112815\nI_V1        1.542202    134.030697\nI_V2        0.905401    -16.110995\nI_V3        2.063669    161.965216\nI_V4        2.338768    -18.698461\nI_V5        2.701207    -15.096706\nI_V6        1.422424   -174.447987\nI_V7        0.931072   -153.824119\nI_V8        0.899603    -21.507992\nI_F1        1.810802    -16.110995\nI_Ea1       1.633258    130.178675\nI_H1        1.484613   -177.450035\nI_L1        2.862976    -26.151162\nI_L2        0.854027   -141.418577\nI_L3        1.633573    -49.814207\nI_L4        0.541202    -73.251389\nI_L5        1.810802    163.889005\nI_L6        0.370519   -148.498854\nI_F2        1.810802    -16.110995\nI_Ea2       0.541202    106.748611\nI_H2        0.717411    -63.158104\nI_O1        0.982866    -13.053681\nI_O2        1.693733      0.548292\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    10.4887 phase:   0.339452°  voltage\nV(8):   mag:    2.20263 phase:    -5.8879°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:   0.529319 phase:   -148.499°  voltage\nV(11):  mag:    2.23038 phase:    146.371°  voltage\nV(10):  mag:    2.31839 phase:    160.462°  voltage\nV(23):  mag:    8.49732 phase:   -9.75384°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:   0.910675 phase:   -94.0363°  voltage\nV(24):  mag:     4.1199 phase:    7.43283°  voltage\nV(3):   mag:    2.31839 phase:    160.462°  voltage\nV(20):  mag:    2.31839 phase:    160.462°  voltage\nV(5):   mag:    2.27445 phase:   -15.0807°  voltage\nV(12):  mag:    2.19411 phase:    152.046°  voltage\nV(18):  mag:     8.4815 phase:   -4.37559°  voltage\nV(26):  mag:    5.80559 phase:   -6.78388°  voltage\nV(25):  mag:     4.1199 phase:    7.43283°  voltage\nV(4):   mag:    2.71624 phase:   -16.1119°  voltage\nV(14):  mag:    4.77144 phase:     162.04°  voltage\nV(7):   mag:    1.81082 phase:    73.8881°  voltage\nV(15):  mag:    8.16625 phase:   -49.8218°  voltage\nV(21):  mag:    7.50792 phase:   -17.0934°  voltage\nV(13):  mag:    1.79919 phase:    158.492°  voltage\nV(28):  mag:    2.31839 phase:    160.462°  voltage\nV(27):  mag:    8.49732 phase:   -9.75384°  voltage\nV(17):  mag:    3.08423 phase:    60.4014°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    3.70502 phase:   -2.37192°  voltage\nV(32):  mag:    4.40507 phase:    174.112°  voltage\nV(31):  mag: 6.0913e-05 phase:   -4.03597°  voltage\nV(30):  mag:    3.75389 phase:    162.907°  voltage\nV(29):  mag: 4.73489e-05 phase:   -16.1831°     voltage\nI(C1):  mag:     1.5935 phase:   -5.92837°  device_current\nI(C2):  mag:   0.444041 phase:   -21.4012°  device_current\nI(F1):  mag:    1.81082 phase:   -16.1119°  device_current\nI(F2):  mag:    1.81082 phase:   -16.1119°  device_current\nI(H1):  mag:    1.48461 phase:   -177.452°  device_current\nI(H2):  mag:   0.717409 phase:   -63.1574°  device_current\nI(L1):  mag:    2.86299 phase:   -26.1518°  device_current\nI(L2):  mag:   0.854034 phase:   -141.418°  device_current\nI(L3):  mag:    1.63357 phase:   -49.8147°  device_current\nI(L4):  mag:   0.541197 phase:   -73.2497°  device_current\nI(L5):  mag:    1.81082 phase:    163.888°  device_current\nI(L6):  mag:   0.370523 phase:   -148.499°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:     1.6605 phase:    1.98853°  device_current\nI(R2):  mag:    1.10131 phase:    -5.8879°  device_current\nI(R6):  mag:   0.105864 phase:   -148.499°  device_current\nI(R8):  mag:  0.0705929 phase:    54.5194°  device_current\nI(R10): mag:   0.241259 phase:   -138.471°  device_current\nI(R11): mag:   0.589029 phase:   -163.163°  device_current\nI(R12): mag:    0.26466 phase:   -148.499°  device_current\nI(R14): mag:   0.270792 phase:    141.553°  device_current\nI(R15): mag:   0.944208 phase:    155.303°  device_current\nI(R7):  mag:   0.444041 phase:    158.599°  device_current\nI(R16): mag:   0.386398 phase:    160.462°  device_current\nI(R3):  mag:   0.207524 phase:   -35.9644°  device_current\nI(R4):  mag:    1.67746 phase:   -17.6897°  device_current\nI(R9):  mag:   0.164149 phase:   -172.751°  device_current\nI(R13): mag:    1.63325 phase:   -49.8218°  device_current\nI(R17): mag:    1.08737 phase:   -8.59974°  device_current\nI(R18): mag:   0.899593 phase:    158.492°  device_current\nI(R19): mag:   0.692348 phase:   -15.3907°  device_current\nI(R20): mag:    1.19191 phase:    171.035°  device_current\nI(R21): mag:     1.5935 phase:    174.072°  device_current\nI(R22): mag:   0.992596 phase:    164.183°  device_current\nI(R23): mag:   0.444041 phase:    158.599°  device_current\nI(R24): mag:   0.818256 phase:   -16.4696°  device_current\nI(R25): mag:    1.07892 phase:   -11.8466°  device_current\nI(R5):  mag:   0.772795 phase:    160.462°  device_current\nI(R26): mag: 0.000220257 phase:    174.112°     device_current\nI(R27): mag: 0.000375394 phase:    162.907°     device_current\nI(R28): mag:   0.982466 phase:   -13.0516°  device_current\nI(R29): mag:     1.6935 phase:   0.548618°  device_current\nI(R30): mag: 0.000375394 phase:    162.907°     device_current\nI(R31): mag: 0.000220257 phase:    174.112°     device_current\nI(G1):  mag:    0.90747 phase:   -54.3873°  device_current\nI(G2):  mag:    4.54891 phase:    164.919°  device_current\nI(E1):  mag:    1.63325 phase:    130.178°  device_current\nI(E2):  mag:   0.541197 phase:     106.75°  device_current\nI(V1):  mag:    1.54213 phase:    134.031°  device_current\nI(V2):  mag:   0.905412 phase:   -16.1119°  device_current\nI(V3):  mag:     2.0637 phase:    161.964°  device_current\nI(V4):  mag:     2.3388 phase:   -18.6996°  device_current\nI(V5):  mag:    2.70125 phase:   -15.0979°  device_current\nI(V6):  mag:    1.42243 phase:    -174.45°  device_current\nI(V7):  mag:   0.931071 phase:   -153.824°  device_current\nI(V8):  mag:   0.899593 phase:   -21.5082°  device_current\nIx(u1:3):   mag:    0.98284 phase:   -13.0531°  subckt_current\nIx(u2:3):   mag:    1.69372 phase:   0.547783°  subckt_current\n\n\n\n38.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\)\\(0 = - I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\)\\(0 = - I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\)\\(0 = I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\)\\(0 = - 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\)\\(0 = - I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\)\\(0 = - I_{F1} - I_{L5}\\)\\(0 = - 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\)\\(0 = - I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\)\\(0 = I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\)\\(0 = - I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(2.0 s + 0.125\\right) + v_{12} \\left(- 2.0 s - 2.0\\right) + 2.0 v_{13}\\)\\(0 = - 2.0 s v_{11} + v_{12} \\cdot \\left(2.0 s + 0.1\\right) - 0.1 v_{5}\\)\\(0 = 1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\)\\(0 = I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\)\\(0 = I_{Ea1} + 0.2 v_{15}\\)\\(0 = I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\)\\(0 = I_{Ea2} + I_{L4}\\)\\(0 = - 2.0 s v_{23} + v_{18} \\cdot \\left(2.0 s + 0.333333333333333\\right) - 0.333333333333333 v_{19}\\)\\(0 = - 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\)\\(0 = - I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\)\\(0 = - I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\)\\(0 = I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\)\\(0 = - I_{L1} + I_{V6} - 2.0 s v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(2.0 s + 0.553968253968254\\right) - 0.2 v_{24} - 0.1 v_{28}\\)\\(0 = I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\)\\(0 = I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\)\\(0 = - I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\)\\(0 = - I_{F2} + I_{H2} - I_{V6}\\)\\(0 = - I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\)\\(0 = - 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\)\\(0 = I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\)\\(0 = 0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\)\\(0 = I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\)\\(10.0 = v_{22}\\)\\(0 = v_{1}\\)\\(0 = v_{10} - v_{3}\\)\\(0 = v_{10} - v_{20}\\)\\(0 = v_{20} - v_{28}\\)\\(0 = v_{23} - v_{27}\\)\\(0 = v_{24} - v_{25}\\)\\(0 = - v_{6}\\)\\(0 = I_{F1} - 2.0 I_{V2}\\)\\(0 = v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\)\\(0 = - 3.0 I_{V2} + v_{4}\\)\\(0 = - 1.0 I_{L1} s - 1.6 I_{L2} s + v_{16} - v_{23}\\)\\(0 = - 1.6 I_{L1} s - 4.0 I_{L2} s + v_{25} - v_{9}\\)\\(0 = - 2.0 I_{L3} s - 0.632455532033676 I_{L4} s - v_{21} + v_{22}\\)\\(0 = - 0.632455532033676 I_{L3} s - 5.0 I_{L4} s - v_{11} + v_{17}\\)\\(0 = - 1.0 I_{L5} s - v_{7}\\)\\(0 = - 2.0 I_{L6} s - v_{2} + v_{9}\\)\\(0 = I_{F2} - 2.0 I_{V2}\\)\\(0 = - 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\)\\(0 = - 3.0 I_{V2} - v_{26} + v_{27}\\)\\(0 = v_{29}\\)\\(0 = v_{31}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n38.5.3 Plot the voltage at node 10\n\nH = U_ac[v21]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 10*2*np.pi, 1000, endpoint=True)\nx = np.logspace(-2, 1, 300, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_8.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other, but not to the same precision as in previous tests.\n\nfrequency[0:-1]\n\narray([0.01      , 0.01023293, 0.01047129, 0.01071519, 0.01096478,\n       0.01122018, 0.01148154, 0.01174898, 0.01202264, 0.01230269,\n       0.01258925, 0.0128825 , 0.01318257, 0.01348963, 0.01380384,\n       0.01412538, 0.0144544 , 0.01479108, 0.01513561, 0.01548817,\n       0.01584893, 0.0162181 , 0.01659587, 0.01698244, 0.01737801,\n       0.01778279, 0.01819701, 0.01862087, 0.01905461, 0.01949845,\n       0.01995262, 0.02041738, 0.02089296, 0.02137962, 0.02187762,\n       0.02238721, 0.02290868, 0.02344229, 0.02398833, 0.02454709,\n       0.02511886, 0.02570396, 0.02630268, 0.02691535, 0.02754229,\n       0.02818383, 0.02884032, 0.02951209, 0.03019952, 0.03090295,\n       0.03162278, 0.03235937, 0.03311311, 0.03388442, 0.03467369,\n       0.03548134, 0.03630781, 0.03715352, 0.03801894, 0.03890451,\n       0.03981072, 0.04073803, 0.04168694, 0.04265795, 0.04365158,\n       0.04466836, 0.04570882, 0.04677351, 0.04786301, 0.04897788,\n       0.05011872, 0.05128614, 0.05248075, 0.05370318, 0.05495409,\n       0.05623413, 0.05754399, 0.05888437, 0.06025596, 0.0616595 ,\n       0.06309573, 0.06456542, 0.06606934, 0.0676083 , 0.0691831 ,\n       0.07079458, 0.0724436 , 0.07413102, 0.07585776, 0.07762471,\n       0.07943282, 0.08128305, 0.08317638, 0.0851138 , 0.08709636,\n       0.08912509, 0.09120108, 0.09332543, 0.09549926, 0.09772372,\n       0.1       , 0.1023293 , 0.10471285, 0.10715193, 0.10964782,\n       0.11220185, 0.11481536, 0.11748976, 0.12022644, 0.12302688,\n       0.12589254, 0.12882496, 0.13182567, 0.13489629, 0.13803843,\n       0.14125375, 0.14454398, 0.14791084, 0.15135612, 0.15488166,\n       0.15848932, 0.16218101, 0.16595869, 0.16982437, 0.17378008,\n       0.17782794, 0.18197009, 0.18620871, 0.19054607, 0.19498446,\n       0.19952623, 0.20417379, 0.20892961, 0.21379621, 0.21877616,\n       0.22387211, 0.22908677, 0.23442288, 0.23988329, 0.24547089,\n       0.25118864, 0.25703958, 0.2630268 , 0.26915348, 0.27542287,\n       0.28183829, 0.28840315, 0.29512092, 0.30199517, 0.30902954,\n       0.31622777, 0.32359366, 0.33113112, 0.33884416, 0.34673685,\n       0.35481339, 0.36307805, 0.37153523, 0.3801894 , 0.38904514,\n       0.39810717, 0.40738028, 0.41686938, 0.42657952, 0.43651583,\n       0.44668359, 0.45708819, 0.46773514, 0.47863009, 0.48977882,\n       0.50118723, 0.51286138, 0.52480746, 0.5370318 , 0.54954087,\n       0.56234133, 0.57543994, 0.58884366, 0.60255959, 0.616595  ,\n       0.63095734, 0.64565423, 0.66069345, 0.67608298, 0.69183097,\n       0.70794578, 0.72443596, 0.74131024, 0.75857758, 0.77624712,\n       0.79432823, 0.81283052, 0.83176377, 0.85113804, 0.87096359,\n       0.89125094, 0.91201084, 0.9332543 , 0.95499259, 0.97723722,\n       1.        , 1.02329299, 1.04712855, 1.07151931, 1.0964782 ,\n       1.12201845, 1.14815362, 1.17489755, 1.20226443, 1.23026877,\n       1.25892541, 1.28824955, 1.31825674, 1.34896288, 1.38038426,\n       1.41253754, 1.44543977, 1.47910839, 1.51356125, 1.54881662,\n       1.58489319, 1.6218101 , 1.65958691, 1.69824365, 1.73780083,\n       1.77827941, 1.81970086, 1.86208714, 1.90546072, 1.9498446 ,\n       1.99526231, 2.04173794, 2.08929613, 2.13796209, 2.18776162,\n       2.23872114, 2.29086765, 2.34422882, 2.39883292, 2.45470892,\n       2.51188643, 2.57039578, 2.63026799, 2.6915348 , 2.7542287 ,\n       2.81838293, 2.8840315 , 2.95120923, 3.01995172, 3.09029543,\n       3.16227766, 3.23593657, 3.31131121, 3.38844156, 3.4673685 ,\n       3.54813389, 3.63078055, 3.71535229, 3.80189396, 3.89045145,\n       3.98107171, 4.07380278, 4.16869383, 4.26579519, 4.36515832,\n       4.46683592, 4.5708819 , 4.67735141, 4.78630092, 4.89778819,\n       5.01187234, 5.12861384, 5.2480746 , 5.37031796, 5.49540874,\n       5.62341325, 5.75439937, 5.88843655, 6.02559586, 6.16595002,\n       6.30957344, 6.45654229, 6.60693448, 6.76082975, 6.91830971,\n       7.07945784, 7.2443596 , 7.41310241, 7.58577575, 7.76247117,\n       7.94328235, 8.12830516, 8.31763771, 8.51138038, 8.7096359 ,\n       8.91250938, 9.12010839, 9.33254301, 9.54992586, 9.77237221])\n\n\n\nw/(2*np.pi)\n\narray([0.01      , 0.01023293, 0.01047129, 0.01071519, 0.01096478,\n       0.01122018, 0.01148154, 0.01174898, 0.01202264, 0.01230269,\n       0.01258925, 0.0128825 , 0.01318257, 0.01348963, 0.01380384,\n       0.01412538, 0.0144544 , 0.01479108, 0.01513561, 0.01548817,\n       0.01584893, 0.0162181 , 0.01659587, 0.01698244, 0.01737801,\n       0.01778279, 0.01819701, 0.01862087, 0.01905461, 0.01949845,\n       0.01995262, 0.02041738, 0.02089296, 0.02137962, 0.02187762,\n       0.02238721, 0.02290868, 0.02344229, 0.02398833, 0.02454709,\n       0.02511886, 0.02570396, 0.02630268, 0.02691535, 0.02754229,\n       0.02818383, 0.02884032, 0.02951209, 0.03019952, 0.03090295,\n       0.03162278, 0.03235937, 0.03311311, 0.03388442, 0.03467369,\n       0.03548134, 0.03630781, 0.03715352, 0.03801894, 0.03890451,\n       0.03981072, 0.04073803, 0.04168694, 0.04265795, 0.04365158,\n       0.04466836, 0.04570882, 0.04677351, 0.04786301, 0.04897788,\n       0.05011872, 0.05128614, 0.05248075, 0.05370318, 0.05495409,\n       0.05623413, 0.05754399, 0.05888437, 0.06025596, 0.0616595 ,\n       0.06309573, 0.06456542, 0.06606934, 0.0676083 , 0.0691831 ,\n       0.07079458, 0.0724436 , 0.07413102, 0.07585776, 0.07762471,\n       0.07943282, 0.08128305, 0.08317638, 0.0851138 , 0.08709636,\n       0.08912509, 0.09120108, 0.09332543, 0.09549926, 0.09772372,\n       0.1       , 0.1023293 , 0.10471285, 0.10715193, 0.10964782,\n       0.11220185, 0.11481536, 0.11748976, 0.12022644, 0.12302688,\n       0.12589254, 0.12882496, 0.13182567, 0.13489629, 0.13803843,\n       0.14125375, 0.14454398, 0.14791084, 0.15135612, 0.15488166,\n       0.15848932, 0.16218101, 0.16595869, 0.16982437, 0.17378008,\n       0.17782794, 0.18197009, 0.18620871, 0.19054607, 0.19498446,\n       0.19952623, 0.20417379, 0.20892961, 0.21379621, 0.21877616,\n       0.22387211, 0.22908677, 0.23442288, 0.23988329, 0.24547089,\n       0.25118864, 0.25703958, 0.2630268 , 0.26915348, 0.27542287,\n       0.28183829, 0.28840315, 0.29512092, 0.30199517, 0.30902954,\n       0.31622777, 0.32359366, 0.33113112, 0.33884416, 0.34673685,\n       0.35481339, 0.36307805, 0.37153523, 0.3801894 , 0.38904514,\n       0.39810717, 0.40738028, 0.41686938, 0.42657952, 0.43651583,\n       0.44668359, 0.45708819, 0.46773514, 0.47863009, 0.48977882,\n       0.50118723, 0.51286138, 0.52480746, 0.5370318 , 0.54954087,\n       0.56234133, 0.57543994, 0.58884366, 0.60255959, 0.616595  ,\n       0.63095734, 0.64565423, 0.66069345, 0.67608298, 0.69183097,\n       0.70794578, 0.72443596, 0.74131024, 0.75857758, 0.77624712,\n       0.79432823, 0.81283052, 0.83176377, 0.85113804, 0.87096359,\n       0.89125094, 0.91201084, 0.9332543 , 0.95499259, 0.97723722,\n       1.        , 1.02329299, 1.04712855, 1.07151931, 1.0964782 ,\n       1.12201845, 1.14815362, 1.17489755, 1.20226443, 1.23026877,\n       1.25892541, 1.28824955, 1.31825674, 1.34896288, 1.38038426,\n       1.41253754, 1.44543977, 1.47910839, 1.51356125, 1.54881662,\n       1.58489319, 1.6218101 , 1.65958691, 1.69824365, 1.73780083,\n       1.77827941, 1.81970086, 1.86208714, 1.90546072, 1.9498446 ,\n       1.99526231, 2.04173794, 2.08929613, 2.13796209, 2.18776162,\n       2.23872114, 2.29086765, 2.34422882, 2.39883292, 2.45470892,\n       2.51188643, 2.57039578, 2.63026799, 2.6915348 , 2.7542287 ,\n       2.81838293, 2.8840315 , 2.95120923, 3.01995172, 3.09029543,\n       3.16227766, 3.23593657, 3.31131121, 3.38844156, 3.4673685 ,\n       3.54813389, 3.63078055, 3.71535229, 3.80189396, 3.89045145,\n       3.98107171, 4.07380278, 4.16869383, 4.26579519, 4.36515832,\n       4.46683592, 4.5708819 , 4.67735141, 4.78630092, 4.89778819,\n       5.01187234, 5.12861384, 5.2480746 , 5.37031796, 5.49540874,\n       5.62341325, 5.75439937, 5.88843655, 6.02559586, 6.16595002,\n       6.30957344, 6.45654229, 6.60693448, 6.76082975, 6.91830971,\n       7.07945784, 7.2443596 , 7.41310241, 7.58577575, 7.76247117,\n       7.94328235, 8.12830516, 8.31763771, 8.51138038, 8.7096359 ,\n       8.91250938, 9.12010839, 9.33254301, 9.54992586, 9.77237221])\n\n\n\nfrequency[0:-1] - w/(2*np.pi)\n\narray([ 0.00000000e+00, -3.98986399e-17,  3.46944695e-18,  3.46944695e-17,\n       -5.03069808e-17, -3.46944695e-17, -2.94902991e-17,  1.73472348e-18,\n       -3.12250226e-17, -1.90819582e-17,  2.42861287e-17, -3.98986399e-17,\n        2.60208521e-17, -3.12250226e-17, -5.03069808e-17, -3.98986399e-17,\n        2.77555756e-17,  2.94902991e-17,  2.08166817e-17, -1.04083409e-17,\n       -3.46944695e-17,  0.00000000e+00, -6.93889390e-18, -4.16333634e-17,\n       -5.55111512e-17, -2.77555756e-17, -3.46944695e-17,  2.42861287e-17,\n        2.77555756e-17, -5.55111512e-17,  0.00000000e+00,  6.93889390e-18,\n        0.00000000e+00, -2.42861287e-17, -3.12250226e-17,  0.00000000e+00,\n       -2.77555756e-17, -2.77555756e-17,  3.46944695e-18, -1.04083409e-17,\n        3.46944695e-18, -4.16333634e-17, -1.73472348e-17, -5.20417043e-17,\n       -5.89805982e-17, -3.12250226e-17, -5.89805982e-17, -5.20417043e-17,\n       -5.89805982e-17, -3.46944695e-18, -9.02056208e-17, -2.77555756e-17,\n       -1.38777878e-17, -5.55111512e-17, -6.24500451e-17, -4.85722573e-17,\n       -4.16333634e-17, -6.24500451e-17, -2.77555756e-17, -4.85722573e-17,\n       -3.46944695e-17, -6.24500451e-17, -4.16333634e-17, -5.55111512e-17,\n       -1.11022302e-16, -9.71445147e-17, -1.11022302e-16, -1.11022302e-16,\n       -1.52655666e-16, -1.17961196e-16, -1.45716772e-16, -8.32667268e-17,\n       -1.59594560e-16, -6.93889390e-17, -1.52655666e-16, -1.11022302e-16,\n       -9.71445147e-17, -9.71445147e-17, -1.80411242e-16, -1.17961196e-16,\n       -1.24900090e-16, -1.66533454e-16, -2.08166817e-16, -1.80411242e-16,\n       -1.24900090e-16, -2.08166817e-16, -1.80411242e-16, -1.80411242e-16,\n       -1.52655666e-16, -1.94289029e-16, -2.35922393e-16, -2.35922393e-16,\n       -1.80411242e-16, -2.77555756e-16, -2.35922393e-16, -2.91433544e-16,\n       -2.63677968e-16, -2.91433544e-16, -2.91433544e-16, -2.63677968e-16,\n       -3.05311332e-16, -4.16333634e-16,  4.16333634e-17, -6.52256027e-16,\n       -5.13478149e-16, -3.60822483e-16, -2.91433544e-16,  2.77555756e-17,\n       -3.19189120e-16, -1.66533454e-16, -7.49400542e-16, -4.16333634e-16,\n       -7.21644966e-16, -3.88578059e-16, -5.27355937e-16, -4.71844785e-16,\n       -7.21644966e-16, -7.21644966e-16, -8.04911693e-16, -1.11022302e-16,\n       -3.33066907e-16, -9.71445147e-16, -1.02695630e-15, -4.16333634e-16,\n       -5.55111512e-16, -3.05311332e-16, -3.60822483e-16, -7.49400542e-16,\n       -7.49400542e-16, -5.82867088e-16, -9.99200722e-16, -9.43689571e-16,\n       -9.71445147e-16, -1.24900090e-15, -1.27675648e-15, -9.71445147e-16,\n       -1.36002321e-15, -1.30451205e-15, -1.11022302e-15, -1.11022302e-15,\n       -1.05471187e-15, -1.33226763e-15, -1.16573418e-15, -1.55431223e-15,\n       -1.60982339e-15, -1.38777878e-15, -1.55431223e-15, -1.55431223e-15,\n       -1.60982339e-15, -1.05471187e-15, -1.94289029e-15, -1.22124533e-15,\n       -1.11022302e-15, -1.55431223e-15, -1.66533454e-15, -1.49880108e-15,\n       -1.38777878e-15, -1.55431223e-15, -2.27595720e-15, -1.66533454e-15,\n       -2.33146835e-15, -1.83186799e-15, -2.55351296e-15, -1.77635684e-15,\n       -2.16493490e-15, -2.27595720e-15, -2.16493490e-15, -2.05391260e-15,\n       -2.27595720e-15, -2.22044605e-15, -2.22044605e-15, -2.77555756e-15,\n       -2.55351296e-15, -2.66453526e-15, -2.55351296e-15, -3.10862447e-15,\n       -2.88657986e-15, -2.99760217e-15, -2.77555756e-15, -3.21964677e-15,\n       -3.33066907e-15, -3.66373598e-15, -4.10782519e-15, -3.88578059e-15,\n       -3.66373598e-15, -3.99680289e-15, -4.32986980e-15, -4.77395901e-15,\n       -4.99600361e-15, -4.99600361e-15, -4.66293670e-15, -4.55191440e-15,\n       -4.88498131e-15, -4.32986980e-15, -4.44089210e-15, -5.44009282e-15,\n       -5.66213743e-15, -4.99600361e-15, -5.88418203e-15, -5.66213743e-15,\n       -5.99520433e-15, -4.66293670e-15, -9.54791801e-15, -7.10542736e-15,\n       -5.10702591e-15, -2.88657986e-15, -2.88657986e-15, -9.10382880e-15,\n       -3.10862447e-15, -1.11022302e-14, -7.54951657e-15, -3.77475828e-15,\n       -7.32747196e-15, -3.33066907e-15, -5.10702591e-15, -4.21884749e-15,\n       -7.99360578e-15, -7.32747196e-15, -8.65973959e-15, -1.13242749e-14,\n       -1.42108547e-14, -9.54791801e-15, -1.13242749e-14, -1.44328993e-14,\n       -1.62092562e-14, -1.26565425e-14, -1.42108547e-14, -7.54951657e-15,\n       -1.84297022e-14, -1.55431223e-14, -1.06581410e-14, -9.76996262e-15,\n       -1.86517468e-14, -1.24344979e-14, -1.15463195e-14, -1.99840144e-14,\n       -1.24344979e-14, -2.30926389e-14, -1.99840144e-14, -2.08721929e-14,\n       -1.95399252e-14, -2.48689958e-14, -2.13162821e-14, -1.68753900e-14,\n       -1.64313008e-14, -2.48689958e-14, -2.53130850e-14, -2.70894418e-14,\n       -2.66453526e-14, -2.17603713e-14, -2.93098879e-14, -2.39808173e-14,\n       -3.10862447e-14, -2.75335310e-14, -2.62012634e-14, -2.66453526e-14,\n       -3.41948692e-14, -2.35367281e-14, -3.28626015e-14, -2.48689958e-14,\n       -3.33066907e-14, -3.64153152e-14, -3.46389584e-14, -3.55271368e-14,\n       -4.08562073e-14, -3.99680289e-14, -4.17443857e-14, -4.08562073e-14,\n       -4.52970994e-14, -4.17443857e-14, -4.44089210e-14, -3.81916720e-14,\n       -4.88498131e-14, -4.70734562e-14, -4.88498131e-14, -5.15143483e-14,\n       -5.24025268e-14, -4.97379915e-14, -5.15143483e-14, -5.24025268e-14,\n       -5.68434189e-14, -5.59552404e-14, -5.68434189e-14, -5.95079541e-14,\n       -5.32907052e-14, -6.03961325e-14, -5.95079541e-14, -6.75015599e-14,\n       -6.57252031e-14, -6.92779167e-14, -6.39488462e-14, -7.46069873e-14,\n       -6.92779167e-14, -7.81597009e-14, -7.46069873e-14, -7.99360578e-14,\n       -7.63833441e-14, -8.34887715e-14, -8.88178420e-14, -9.23705556e-14])\n\n\n\nnp.abs(voltage[0:-1])-10**(mag/20)\n\narray([-1.10671924e-06, -1.12132160e-06, -1.13521907e-06, -1.14837042e-06,\n       -1.16073483e-06, -1.17227210e-06, -1.18294262e-06, -1.19270739e-06,\n       -1.20152808e-06, -1.20936703e-06, -1.21618723e-06, -1.22195234e-06,\n       -1.22662672e-06, -1.23017529e-06, -1.23256359e-06, -1.23375777e-06,\n       -1.23372443e-06, -1.23243067e-06, -1.22984403e-06, -1.22593242e-06,\n       -1.22066405e-06, -1.21400742e-06, -1.20593125e-06, -1.19640444e-06,\n       -1.18539599e-06, -1.17287505e-06, -1.15881078e-06, -1.14317245e-06,\n       -1.12592933e-06, -1.10705074e-06, -1.08650608e-06, -1.06426481e-06,\n       -1.04029657e-06, -1.01457116e-06, -9.87058675e-07, -9.57729588e-07,\n       -9.26554902e-07, -8.93506268e-07, -8.58556142e-07, -8.21678031e-07,\n       -7.82846667e-07, -7.42038322e-07, -6.99231020e-07, -6.54404907e-07,\n       -6.07542555e-07, -5.58629422e-07, -5.07654102e-07, -4.54608985e-07,\n       -3.99490583e-07, -3.42300142e-07, -2.83044123e-07, -2.21734867e-07,\n       -1.58391140e-07, -9.30388975e-08, -2.57118593e-08,  4.35476721e-08,\n        1.14688172e-07,  1.87647997e-07,  2.62354710e-07,  3.38724218e-07,\n        4.16660003e-07,  4.96052209e-07,  5.76776962e-07,  6.58695502e-07,\n        7.41653336e-07,  8.25479569e-07,  9.09986104e-07,  9.94966973e-07,\n        1.08019766e-06,  1.16543452e-06,  1.25041422e-06,  1.33485323e-06,\n        1.41844752e-06,  1.50087211e-06,  1.58178091e-06,  1.66080648e-06,\n        1.73756001e-06,  1.81163126e-06,  1.88258868e-06,  1.94997959e-06,\n        2.01333036e-06,  2.07214677e-06,  2.12591435e-06,  2.17409880e-06,\n        2.21614648e-06,  2.25148491e-06,  2.27952330e-06,  2.29965302e-06,\n        2.31124827e-06,  2.31366646e-06,  2.30624880e-06,  2.28832069e-06,\n        2.25919220e-06,  2.21815830e-06,  2.16449927e-06,  2.09748074e-06,\n        2.01635393e-06,  1.92035553e-06,  1.80870764e-06,  1.68061756e-06,\n        1.53527750e-06,  1.37186406e-06,  1.18953770e-06,  9.87442109e-07,\n        7.64703358e-07,  5.20429049e-07,  2.53707263e-07, -3.63945709e-08,\n       -3.50830838e-07, -6.90579189e-07, -1.05664182e-06, -1.45004715e-06,\n       -1.87185136e-06, -2.32314011e-06, -2.80503044e-06, -3.31867259e-06,\n       -3.86525210e-06, -4.44599193e-06, -5.06215468e-06, -5.71504504e-06,\n       -6.40601236e-06, -7.13645340e-06, -7.90781530e-06, -8.72159888e-06,\n       -9.57936222e-06, -1.04827247e-05, -1.14333715e-05, -1.24330588e-05,\n       -1.34836197e-05, -1.45869710e-05, -1.57451218e-05, -1.69601825e-05,\n       -1.82343771e-05, -1.95700570e-05, -2.09697184e-05, -2.24360236e-05,\n       -2.39718274e-05, -2.55802111e-05, -2.72645240e-05, -2.90284384e-05,\n       -3.08760190e-05, -3.28118145e-05, -3.48409781e-05, -3.69694284e-05,\n       -3.92040674e-05, -4.15530793e-05, -4.40263476e-05, -4.66360462e-05,\n       -4.93974945e-05, -5.23304180e-05, -5.54608493e-05, -5.88240575e-05,\n       -6.24691539e-05, -6.64664225e-05, -7.09188148e-05, -7.59780462e-05,\n       -8.18540343e-05, -8.87210806e-05, -9.57931429e-05, -9.44902692e-05,\n       -5.31137497e-05,  4.50827102e-06,  3.65898637e-05,  5.41971212e-05,\n        6.57180738e-05,  7.44164704e-05,  8.16578091e-05,  8.80886358e-05,\n        9.40491357e-05,  9.97340360e-05,  1.05262621e-04,  1.10712162e-04,\n        1.16135148e-04,  1.21568752e-04,  1.27040312e-04,  1.32570659e-04,\n        1.38176214e-04,  1.43870362e-04,  1.49664377e-04,  1.55568074e-04,\n        1.61590271e-04,  1.67739139e-04,  1.74022472e-04,  1.80447903e-04,\n        1.87023083e-04,  1.93755853e-04,  2.00654386e-04,  2.07727346e-04,\n        2.14984039e-04,  2.22434585e-04,  2.30090107e-04,  2.37962945e-04,\n        2.46066913e-04,  2.54417608e-04,  2.63032771e-04,  2.71932741e-04,\n        2.81141011e-04,  2.90684903e-04,  3.00596428e-04,  3.10913342e-04,\n        3.21680478e-04,  3.32951414e-04,  3.44790582e-04,  3.57275915e-04,\n        3.70502212e-04,  3.84585377e-04,  3.99667801e-04,  4.15925175e-04,\n        4.33575101e-04,  4.52887991e-04,  4.74200765e-04,  4.97934052e-04,\n        5.24613580e-04,  5.54896582e-04,  5.89603865e-04,  6.29758078e-04,\n        6.76628018e-04,  7.31777754e-04,  7.97117381e-04,  8.74948958e-04,\n        9.67996427e-04,  1.07940145e-03,  1.21265870e-03,  1.37145548e-03,\n        1.55937464e-03,  1.77942394e-03,  2.03337695e-03,  2.32096092e-03,\n        2.63900690e-03,  2.98077187e-03,  3.33571053e-03,  3.68995488e-03,\n        4.02760852e-03,  4.33269791e-03,  4.59134992e-03,  4.79363233e-03,\n        4.93459136e-03,  5.01430396e-03,  5.03708520e-03,  5.01020093e-03,\n        4.94247382e-03,  4.84307518e-03,  4.72064936e-03,  4.58279036e-03,\n        4.43581352e-03,  4.28473612e-03,  4.13338407e-03,  3.98455977e-03,\n        3.84022718e-03,  3.70168830e-03,  3.56973811e-03,  3.44479360e-03,\n        3.32699725e-03,  3.21629761e-03,  3.11251086e-03,  3.01536662e-03,\n        2.92454182e-03,  2.83968496e-03,  2.76043342e-03,  2.68642544e-03,\n        2.61730809e-03,  2.55274256e-03,  2.49240722e-03,  2.43599936e-03,\n        2.38323584e-03,  2.33385305e-03,  2.28760638e-03,  2.24426949e-03,\n        2.20363323e-03,  2.16550468e-03,  2.12970593e-03,  2.09607307e-03,\n        2.06445507e-03,  2.03471275e-03,  2.00671787e-03,  1.98035217e-03,\n        1.95550656e-03,  1.93208036e-03,  1.90998057e-03,  1.88912122e-03,\n        1.86942281e-03,  1.85081173e-03,  1.83321976e-03,  1.81658367e-03,\n        1.80084475e-03,  1.78594848e-03,  1.77184417e-03,  1.75848464e-03,\n        1.74582596e-03,  1.73382721e-03,  1.72245017e-03,  1.71165919e-03,\n        1.70142097e-03,  1.69170434e-03,  1.68248016e-03,  1.67372114e-03,\n        1.66540169e-03,  1.65749783e-03,  1.64998704e-03,  1.64284818e-03])\n\n\n\n10**(mag/20)\n\narray([  9.9368309 ,   9.9344965 ,   9.93208447,   9.92959228,\n         9.9270173 ,   9.92435681,   9.92160797,   9.91876785,\n         9.9158334 ,   9.91280145,   9.90966875,   9.90643189,\n         9.90308739,   9.89963161,   9.89606084,   9.89237121,\n         9.88855876,   9.88461942,   9.88054898,   9.87634315,\n         9.87199751,   9.86750756,   9.86286868,   9.85807617,\n         9.85312525,   9.84801103,   9.84272858,   9.83727288,\n         9.83163887,   9.82582143,   9.81981543,   9.81361567,\n         9.80721697,   9.80061414,   9.793802  ,   9.78677538,\n         9.77952917,   9.77205827,   9.76435769,   9.75642247,\n         9.74824776,   9.73982882,   9.73116098,   9.72223973,\n         9.71306068,   9.70361956,   9.69391227,   9.68393484,\n         9.67368346,   9.66315448,   9.65234438,   9.6412498 ,\n         9.62986752,   9.61819442,   9.60622754,   9.59396395,\n         9.58140085,   9.56853546,   9.555365  ,   9.5418867 ,\n         9.52809772,   9.51399514,   9.49957588,   9.48483667,\n         9.46977402,   9.45438411,   9.43866278,   9.42260544,\n         9.40620702,   9.38946189,   9.3723638 ,   9.35490579,\n         9.33708014,   9.31887831,   9.30029079,   9.28130712,\n         9.26191576,   9.24210401,   9.22185797,   9.20116243,\n         9.18000084,   9.15835519,   9.13620596,   9.11353207,\n         9.09031079,   9.06651766,   9.04212648,   9.01710917,\n         8.99143578,   8.96507439,   8.93799106,   8.91014976,\n         8.88151234,   8.85203843,   8.82168543,   8.79040842,\n         8.75816013,   8.72489083,   8.69054834,   8.65507793,\n         8.61842226,   8.58052133,   8.54131243,   8.50073004,\n         8.45870581,   8.41516844,   8.37004367,   8.32325417,\n         8.27471946,   8.22435589,   8.17207649,   8.11779097,\n         8.06140556,   8.00282301,   7.94194245,   7.87865932,\n         7.8128653 ,   7.74444823,   7.67329198,   7.59927641,\n         7.52227726,   7.44216608,   7.35881012,   7.27207224,\n         7.18181087,   7.08787986,   6.99012847,   6.88840121,\n         6.78253782,   6.67237318,   6.55773725,   6.43845495,\n         6.31434621,   6.1852258 ,   6.05090339,   5.9111835 ,\n         5.76586547,   5.61474351,   5.45760681,   5.29423955,\n         5.12442118,   4.94792663,   4.76452673,   4.57398881,\n         4.37607755,   4.17055628,   3.9571888 ,   3.73574227,\n         3.50599152,   3.26772591,   3.02076031,   2.76495377,\n         2.50024204,   2.22669807,   1.94465192,   1.65494965,\n         1.35957568,   1.06337143,   0.77965851,   0.55110752,\n         0.49424884,   0.6765313 ,   0.98713649,   1.35185728,\n         1.74718689,   2.16530403,   2.60326938,   3.05996328,\n         3.53506402,   4.02865089,   4.54103069,   5.07265502,\n         5.62407851,   6.19593709,   6.78893698,   7.40384962,\n         8.0415103 ,   8.70281921,   9.38874413,  10.10032444,\n        10.8386762 ,  11.60499822,  12.40057898,  13.22680451,\n        14.08516713,  14.97727526,  15.90486414,  16.86980772,\n        17.87413175,  18.92002816,  20.00987078,  21.1462327 ,\n        22.33190522,  23.56991858,  24.8635647 ,  26.21642191,\n        27.63238196,  29.11567929,  30.67092275,  32.30312966,\n        34.01776235,  35.82076674,  37.71861285,  39.71833641,\n        41.82758078,  44.05463752,  46.40848352,  48.89881162,\n        51.53605013,  54.33136527,  57.29663783,  60.4444027 ,\n        63.78773547,  67.34006562,  71.11488908,  75.12534556,\n        79.38361718,  83.90009606,  88.68226066,  93.73319743,\n        99.04971053, 104.61998566, 110.42082634, 116.41457419,\n       122.54597091, 128.73941985, 134.89733657, 140.90047865,\n       146.61120247, 151.88036575, 156.55796603, 160.50660464,\n       163.61574972, 165.81400794, 167.07667085, 167.42683301,\n       166.93005034, 165.68413107, 163.80659245, 161.42233677,\n       158.65341023, 155.61174403, 152.39492868, 149.08453393,\n       145.74626873, 142.43128694, 139.17807522, 136.01452316,\n       132.95992594, 130.02678437, 127.22234624, 124.54988153,\n       122.00971055, 119.60001655, 117.31747748, 115.1577502 ,\n       113.11583703, 111.18635946, 109.36376004, 107.6424488 ,\n       106.01690753, 104.48176211, 103.03183092, 101.66215549,\n       100.36801792,  99.14494885,  97.98872851,  96.89538292,\n        95.8611768 ,  94.88260427,  93.95637819,  93.07941877,\n        92.2488418 ,  91.46194705,  90.71620671,  90.00925431,\n        89.33887416,  88.70299121,  88.09966157,  87.52706355,\n        86.98348931,  86.46733704,  85.97710368,  85.51137818,\n        85.06883519,  84.64822921,  84.24838927,  83.86821382,\n        83.50666613,  83.16277001,  82.83560579,  82.52430663,\n        82.2280551 ,  81.94608001,  81.67765346,  81.42208808,\n        81.17873453,  80.94697911,  80.72624158,  80.51597311])\n\n\n\nvoltage[0:-1]\n\narray([ 9.93014466e+00-3.64435752e-01j,  9.92749968e+00-3.72758127e-01j,\n        9.92476347e+00-3.81247326e-01j,  9.92193298e+00-3.89905032e-01j,\n        9.91900507e+00-3.98732851e-01j,  9.91597646e+00-4.07732313e-01j,\n        9.91284377e+00-4.16904864e-01j,  9.90960349e+00-4.26251863e-01j,\n        9.90625200e+00-4.35774574e-01j,  9.90278554e+00-4.45474161e-01j,\n        9.89920024e+00-4.55351684e-01j,  9.89549210e+00-4.65408091e-01j,\n        9.89165699e+00-4.75644210e-01j,  9.88769067e+00-4.86060744e-01j,\n        9.88358874e+00-4.96658265e-01j,  9.87934670e+00-5.07437203e-01j,\n        9.87495993e+00-5.18397842e-01j,  9.87042368e+00-5.29540309e-01j,\n        9.86573309e+00-5.40864568e-01j,  9.86088316e+00-5.52370410e-01j,\n        9.85586881e+00-5.64057447e-01j,  9.85068483e+00-5.75925100e-01j,\n        9.84532595e+00-5.87972594e-01j,  9.83978676e+00-6.00198949e-01j,\n        9.83406179e+00-6.12602969e-01j,  9.82814550e+00-6.25183238e-01j,\n        9.82203227e+00-6.37938109e-01j,  9.81571643e+00-6.50865701e-01j,\n        9.80919225e+00-6.63963889e-01j,  9.80245399e+00-6.77230298e-01j,\n        9.79549586e+00-6.90662304e-01j,  9.78831209e+00-7.04257023e-01j,\n        9.78089690e+00-7.18011312e-01j,  9.77324451e+00-7.31921769e-01j,\n        9.76534920e+00-7.45984730e-01j,  9.75720530e+00-7.60196274e-01j,\n        9.74880718e+00-7.74552224e-01j,  9.74014930e+00-7.89048153e-01j,\n        9.73122622e+00-8.03679394e-01j,  9.72203259e+00-8.18441046e-01j,\n        9.71256319e+00-8.33327989e-01j,  9.70281293e+00-8.48334895e-01j,\n        9.69277688e+00-8.63456249e-01j,  9.68245026e+00-8.78686364e-01j,\n        9.67182843e+00-8.94019406e-01j,  9.66090697e+00-9.09449414e-01j,\n        9.64968161e+00-9.24970332e-01j,  9.63814826e+00-9.40576034e-01j,\n        9.62630304e+00-9.56260359e-01j,  9.61414222e+00-9.72017138e-01j,\n        9.60166226e+00-9.87840239e-01j,  9.58885981e+00-1.00372360e+00j,\n        9.57573163e+00-1.01966126e+00j,  9.56227466e+00-1.03564741e+00j,\n        9.54848593e+00-1.05167644e+00j,  9.53436260e+00-1.06774297e+00j,\n        9.51990185e+00-1.08384189e+00j,  9.50510094e+00-1.09996841e+00j,\n        9.48995709e+00-1.11611809e+00j,  9.47446751e+00-1.13228690e+00j,\n        9.45862928e+00-1.14847125e+00j,  9.44243938e+00-1.16466803e+00j,\n        9.42589455e+00-1.18087461e+00j,  9.40899130e+00-1.19708895e+00j,\n        9.39172583e+00-1.21330954e+00j,  9.37409393e+00-1.22953547e+00j,\n        9.35609097e+00-1.24576648e+00j,  9.33771175e+00-1.26200289e+00j,\n        9.31895052e+00-1.27824569e+00j,  9.29980082e+00-1.29449651e+00j,\n        9.28025544e+00-1.31075762e+00j,  9.26030634e+00-1.32703192e+00j,\n        9.23994457e+00-1.34332294e+00j,  9.21916016e+00-1.35963481e+00j,\n        9.19794208e+00-1.37597225e+00j,  9.17627815e+00-1.39234050e+00j,\n        9.15415492e+00-1.40874531e+00j,  9.13155765e+00-1.42519292e+00j,\n        9.10847019e+00-1.44168992e+00j,  9.08487493e+00-1.45824331e+00j,\n        9.06075269e+00-1.47486034e+00j,  9.03608272e+00-1.49154847e+00j,\n        9.01084253e+00-1.50831533e+00j,  8.98500792e+00-1.52516859e+00j,\n        8.95855285e+00-1.54211589e+00j,  8.93144941e+00-1.55916477e+00j,\n        8.90366777e+00-1.57632254e+00j,  8.87517607e+00-1.59359622e+00j,\n        8.84594045e+00-1.61099241e+00j,  8.81592492e+00-1.62851720e+00j,\n        8.78509134e+00-1.64617602e+00j,  8.75339942e+00-1.66397360e+00j,\n        8.72080658e+00-1.68191379e+00j,  8.68726801e+00-1.69999947e+00j,\n        8.65273653e+00-1.71823241e+00j,  8.61716263e+00-1.73661318e+00j,\n        8.58049441e+00-1.75514096e+00j,  8.54267752e+00-1.77381349e+00j,\n        8.50365515e+00-1.79262686e+00j,  8.46336797e+00-1.81157544e+00j,\n        8.42175416e+00-1.83065167e+00j,  8.37874929e+00-1.84984598e+00j,\n        8.33428637e+00-1.86914661e+00j,  8.28829576e+00-1.88853949e+00j,\n        8.24070520e+00-1.90800802e+00j,  8.19143975e+00-1.92753300e+00j,\n        8.14042176e+00-1.94709241e+00j,  8.08757088e+00-1.96666126e+00j,\n        8.03280403e+00-1.98621141e+00j,  7.97603536e+00-2.00571141e+00j,\n        7.91717628e+00-2.02512633e+00j,  7.85613541e+00-2.04441752e+00j,\n        7.79281861e+00-2.06354248e+00j,  7.72712894e+00-2.08245463e+00j,\n        7.65896671e+00-2.10110311e+00j,  7.58822943e+00-2.11943258e+00j,\n        7.51481189e+00-2.13738302e+00j,  7.43860612e+00-2.15488945e+00j,\n        7.35950145e+00-2.17188178e+00j,  7.27738455e+00-2.18828454e+00j,\n        7.19213943e+00-2.20401663e+00j,  7.10364753e+00-2.21899112e+00j,\n        7.01178776e+00-2.23311494e+00j,  6.91643657e+00-2.24628872e+00j,\n        6.81746802e+00-2.25840642e+00j,  6.71475387e+00-2.26935517e+00j,\n        6.60816367e+00-2.27901493e+00j,  6.49756489e+00-2.28725828e+00j,\n        6.38282298e+00-2.29395011e+00j,  6.26380158e+00-2.29894736e+00j,\n        6.14036258e+00-2.30209874e+00j,  6.01236631e+00-2.30324448e+00j,\n        5.87967169e+00-2.30221601e+00j,  5.74213640e+00-2.29883571e+00j,\n        5.59961707e+00-2.29291665e+00j,  5.45196945e+00-2.28426229e+00j,\n        5.29904863e+00-2.27266621e+00j,  5.14070924e+00-2.25791186e+00j,\n        4.97680567e+00-2.23977227e+00j,  4.80719227e+00-2.21800981e+00j,\n        4.63172363e+00-2.19237593e+00j,  4.45025475e+00-2.16261089e+00j,\n        4.26264133e+00-2.12844351e+00j,  4.06873997e+00-2.08959097e+00j,\n        3.86840843e+00-2.04575850e+00j,  3.66150584e+00-1.99663919e+00j,\n        3.44789295e+00-1.94191374e+00j,  3.22743233e+00-1.88125023e+00j,\n        2.99998860e+00-1.81430388e+00j,  2.76542862e+00-1.74071685e+00j,\n        2.52362166e+00-1.66011793e+00j,  2.27443956e+00-1.57212237e+00j,\n        2.01775690e+00-1.47633159e+00j,  1.75345107e+00-1.37233291e+00j,\n        1.48140236e+00-1.25969930e+00j,  1.20149403e+00-1.13798900e+00j,\n        9.13612295e-01-1.00674526e+00j,  6.17646301e-01-8.65495911e-01j,\n        3.13488046e-01-7.13752947e-01j,  1.03224968e-03-5.51012061e-01j,\n       -3.19823823e-01-3.76752086e-01j, -6.49180602e-01-1.90434374e-01j,\n       -9.87136500e-01+8.49792674e-03j, -1.33378827e+00+2.20620697e-01j,\n       -1.68923143e+00+4.46529800e-01j, -2.05356072e+00+6.86842186e-01j,\n       -2.42687065e+00+9.42197153e-01j, -2.80925611e+00+1.21325781e+00j,\n       -3.20081300e+00+1.50071274e+00j, -3.60163896e+00+1.80527793e+00j,\n       -4.01183409e+00+2.12769898e+00j, -4.43150177e+00+2.46875357e+00j,\n       -4.86074943e+00+2.82925439e+00j, -5.29968935e+00+3.21005230e+00j,\n       -5.74843949e+00+3.61204010e+00j, -6.20712426e+00+4.03615667e+00j,\n       -6.67587515e+00+4.48339171e+00j, -7.15483141e+00+4.95479101e+00j,\n       -7.64414043e+00+5.45146254e+00j, -8.14395808e+00+5.97458310e+00j,\n       -8.65444870e+00+6.52540591e+00j, -9.17578484e+00+7.10526914e+00j,\n       -9.70814658e+00+7.71560530e+00j, -1.02517204e+01+8.35795195e+00j,\n       -1.08066972e+01+9.03396352e+00j, -1.13732704e+01+9.74542454e+00j,\n       -1.19516317e+01+1.04942645e+01j, -1.25419673e+01+1.12825741e+01j,\n       -1.31444518e+01+1.21126239e+01j, -1.37592409e+01+1.29868847e+01j,\n       -1.43864617e+01+1.39080501e+01j, -1.50262016e+01+1.48790620e+01j,\n       -1.56784932e+01+1.59031390e+01j, -1.63432967e+01+1.69838072e+01j,\n       -1.70204774e+01+1.81249353e+01j, -1.77097788e+01+1.93307727e+01j,\n       -1.84107887e+01+2.06059925e+01j, -1.91228991e+01+2.19557381e+01j,\n       -1.98452554e+01+2.33856747e+01j, -2.05766957e+01+2.49020454e+01j,\n       -2.13156765e+01+2.65117328e+01j, -2.20601812e+01+2.82223243e+01j,\n       -2.28076092e+01+3.00421824e+01j, -2.35546409e+01+3.19805178e+01j,\n       -2.42970717e+01+3.40474641e+01j, -2.50296119e+01+3.62541515e+01j,\n       -2.57456410e+01+3.86127752e+01j, -2.64369112e+01+4.11366525e+01j,\n       -2.70931871e+01+4.38402596e+01j, -2.77018112e+01+4.67392353e+01j,\n       -2.82471816e+01+4.98503338e+01j, -2.87101297e+01+5.31913006e+01j,\n       -2.90671842e+01+5.67806387e+01j, -2.92897134e+01+6.06372151e+01j,\n       -2.93429433e+01+6.47796495e+01j, -2.91848625e+01+6.92253997e+01j,\n       -2.87650504e+01+7.39894451e+01j, -2.80234982e+01+7.90824409e+01j,\n       -2.68895534e+01+8.45082046e+01j, -2.52811980e+01+9.02603864e+01j,\n       -2.31049835e+01+9.63182052e+01j, -2.02570849e+01+1.02641209e+02j,\n       -1.66260886e+01+1.09163180e+02j, -1.20982512e+01+1.15785598e+02j,\n       -6.56599046e+00+1.22371504e+02j,  5.98375510e-02+1.28741185e+02j,\n        7.83390002e+00+1.34671712e+02j,  1.67576876e+01+1.39902748e+02j,\n        2.67607906e+01+1.44150888e+02j,  3.76864428e+01+1.47133555e+02j,\n        4.92866464e+01+1.48601035e+02j,  6.12316183e+01+1.48371977e+02j,\n        7.31354694e+01+1.46364732e+02j,  8.45953480e+01+1.42616090e+02j,\n        9.52364709e+01+1.37281327e+02j,  1.04752893e+02+1.30614627e+02j,\n        1.12935023e+02+1.22934819e+02j,  1.19679300e+02+1.14585156e+02j,\n        1.24980932e+02+1.05896254e+02j,  1.28914709e+02+9.71585621e+01j,\n        1.31610428e+02+8.86068182e+01j,  1.33228639e+02+8.04154962e+01j,\n        1.33940378e+02+7.27023271e+01j,  1.33912391e+02+6.55365258e+01j,\n        1.33297784e+02+5.89488641e+01j,  1.32231147e+02+5.29416272e+01j,\n        1.30826941e+02+4.74973540e+01j,  1.29180005e+02+4.25859215e+01j,\n        1.27367257e+02+3.81699485e+01j,  1.25449956e+02+3.42087092e+01j,\n        1.23476099e+02+3.06608327e+01j,  1.21482703e+02+2.74860673e+01j,\n        1.19497860e+02+2.46463564e+01j,  1.17542499e+02+2.21064279e+01j,\n        1.15631878e+02+1.98340498e+01j,  1.13776797e+02+1.78000677e+01j,\n        1.11984588e+02+1.59783050e+01j,  1.10259911e+02+1.43453840e+01j,\n        1.08605379e+02+1.28805050e+01j,  1.07022059e+02+1.15652100e+01j,\n        1.05509857e+02+1.03831468e+01j,  1.04067827e+02+9.31984288e+00j,\n        1.02694403e+02+8.36249510e+00j,  1.01387586e+02+7.49977708e+00j,\n        1.00145078e+02+6.72166566e+00j,  9.89643970e+01+6.01928575e+00j,\n        9.78429531e+01+5.38477261e+00j,  9.67781121e+01+4.81115026e+00j,\n        9.57672414e+01+4.29222443e+00j,  9.48077429e+01+3.82248866e+00j,\n        9.38970783e+01+3.39704196e+00j,  9.30327855e+01+3.01151673e+00j,\n        9.22124904e+01+2.66201572e+00j,  9.14339142e+01+2.34505680e+00j,\n        9.06948777e+01+2.05752474e+00j,  8.99933025e+01+1.79662889e+00j,\n        8.93272112e+01+1.55986611e+00j,  8.86947260e+01+1.34498836e+00j,\n        8.80940660e+01+1.14997409e+00j,  8.75235444e+01+9.73003272e-01j,\n        8.69815646e+01+8.12435303e-01j,  8.64666169e+01+6.66789610e-01j,\n        8.59772741e+01+5.34728519e-01j,  8.55121875e+01+4.15042144e-01j,\n        8.50700834e+01+3.06635007e-01j,  8.46497584e+01+2.08514209e-01j,\n        8.42500760e+01+1.19778925e-01j,  8.38699629e+01+3.96110911e-02j,\n        8.35084055e+01-3.27328823e-02j,  8.31644462e+01-9.79294848e-02j,\n        8.28371802e+01-1.56594681e-01j,  8.25257529e+01-2.09289776e-01j,\n        8.22293564e+01-2.56526663e-01j,  8.19472271e+01-2.98772513e-01j,\n        8.16786430e+01-3.36453982e-01j,  8.14229213e+01-3.69960980e-01j,\n        8.11794162e+01-3.99650064e-01j,  8.09475165e+01-4.25847480e-01j,\n        8.07266437e+01-4.48851911e-01j,  8.05162504e+01-4.68936944e-01j])\n\n\n\nnp.abs(voltage[0:-1])\n\narray([  9.93682979,   9.93449538,   9.93208334,   9.92959113,\n         9.92701614,   9.92435564,   9.92160679,   9.91876666,\n         9.9158322 ,   9.91280024,   9.90966753,   9.90643067,\n         9.90308616,   9.89963038,   9.89605961,   9.89236998,\n         9.88855753,   9.88461818,   9.88054775,   9.87634192,\n         9.87199629,   9.86750634,   9.86286747,   9.85807498,\n         9.85312406,   9.84800986,   9.84272742,   9.83727173,\n         9.83163774,   9.82582033,   9.81981434,   9.8136146 ,\n         9.80721593,   9.80061313,   9.79380101,   9.78677443,\n         9.77952824,   9.77205738,   9.76435683,   9.75642165,\n         9.74824698,   9.73982807,   9.73116028,   9.72223908,\n         9.71306007,   9.703619  ,   9.69391176,   9.68393438,\n         9.67368306,   9.66315414,   9.6523441 ,   9.64124958,\n         9.62986736,   9.61819433,   9.60622751,   9.593964  ,\n         9.58140097,   9.56853564,   9.55536526,   9.54188704,\n         9.52809814,   9.51399564,   9.49957646,   9.48483733,\n         9.46977476,   9.45438494,   9.43866369,   9.42260644,\n         9.4062081 ,   9.38946306,   9.37236505,   9.35490712,\n         9.33708156,   9.31887981,   9.30029237,   9.28130878,\n         9.26191749,   9.24210582,   9.22185985,   9.20116438,\n         9.18000285,   9.15835726,   9.13620809,   9.11353425,\n         9.090313  ,   9.06651991,   9.04212876,   9.01711147,\n         8.99143809,   8.96507671,   8.93799337,   8.91015205,\n         8.88151459,   8.85204065,   8.82168759,   8.79041052,\n         8.75816214,   8.72489275,   8.69055015,   8.65507961,\n         8.61842379,   8.5805227 ,   8.54131362,   8.50073103,\n         8.45870657,   8.41516896,   8.37004393,   8.32325413,\n         8.27471911,   8.2243552 ,   8.17207544,   8.11778952,\n         8.06140369,   8.00282069,   7.94193964,   7.878656  ,\n         7.81286144,   7.74444378,   7.67328692,   7.59927069,\n         7.52227086,   7.44215895,   7.35880221,   7.27206352,\n         7.18180129,   7.08786938,   6.99011703,   6.88838877,\n         6.78252434,   6.6723586 ,   6.5577215 ,   6.43843799,\n         6.31432797,   6.18520623,   6.05088243,   5.91116106,\n         5.76584149,   5.61471793,   5.45757954,   5.29421052,\n         5.1243903 ,   4.94789381,   4.76449188,   4.57395184,\n         4.37603835,   4.17051472,   3.95714477,   3.73569563,\n         3.50594213,   3.26767358,   3.02070485,   2.76489495,\n         2.50017957,   2.2266316 ,   1.944581  ,   1.65487367,\n         1.35949382,   1.06328271,   0.77956271,   0.55101303,\n         0.49419572,   0.67653581,   0.98717308,   1.35191148,\n         1.74725261,   2.16537845,   2.60335104,   3.06005137,\n         3.53515807,   4.02875062,   4.54113595,   5.07276573,\n         5.62419464,   6.19605866,   6.78906402,   7.40398219,\n         8.04164848,   8.70296308,   9.3888938 ,  10.10048001,\n        10.83883779,  11.60516596,  12.40075301,  13.22698496,\n        14.08535416,  14.97746902,  15.90506479,  16.87001544,\n        17.87434674,  18.92025059,  20.01010087,  21.14647066,\n        22.33215128,  23.570173  ,  24.86382773,  26.21669384,\n        27.6326631 ,  29.11596998,  30.67122334,  32.30344057,\n        34.01808403,  35.82109969,  37.71895764,  39.71869369,\n        41.82795129,  44.0550221 ,  46.40888319,  48.89922754,\n        51.53648371,  54.33181816,  57.29711203,  60.44490063,\n        63.78826008,  67.34062052,  71.11547868,  75.12597531,\n        79.38429381,  83.90082784,  88.68305777,  93.73407238,\n        99.05067853, 104.62106507, 110.422039  , 116.41594564,\n       122.54753028, 128.74119927, 134.89936995, 140.90279961,\n       146.61384148, 151.88334652, 156.56130174, 160.5102946 ,\n       163.61977733, 165.81834064, 167.0812622 , 167.43162664,\n       166.93498493, 165.68914538, 163.81162953, 161.42734698,\n       158.65835271, 155.6165871 , 152.39964933, 149.08911672,\n       145.75070454, 142.43557168, 139.18220861, 136.01850772,\n       132.96376616, 130.03048605, 127.22591598, 124.55332632,\n       122.01303754, 119.60323285, 117.32058999, 115.16076557,\n       113.11876157, 111.18919914, 109.36652047, 107.64513523,\n       106.01952484, 104.48431485, 103.03432333, 101.66459149,\n       100.37040115,  99.1472827 ,  97.99101611,  96.89762719,\n        95.86338043,  94.88476978,  93.9585079 ,  93.08151484,\n        92.25090626,  91.46398177,  90.71821342,  90.01123466,\n        89.34082967,  88.70492329,  88.10157155,  87.52895267,\n        86.98535873,  86.46918785,  85.9789369 ,  85.51319477,\n        85.07063603,  84.65001516,  84.25016111,  83.8699723 ,\n        83.50841196,  83.16450384,  82.83732824,  82.52601829,\n        82.22975652,  81.94777172,  81.67933594,  81.4237618 ,\n        81.18039993,  80.94863661,  80.72789157,  80.51761595])",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Test 8</span>"
    ]
  },
  {
    "objectID": "test_9.html",
    "href": "test_9.html",
    "title": "39  Test 9",
    "section": "",
    "text": "39.1 Load the net list\nFigure 39.1, contains only current sources. The circuit is from Hayt and Kemmerly (1978) (problem 20, Figure 2-39, page 61). Find the power absorbed by each source in the circuit. Added R1 to keep LTSpice happy.\nThe net list for the circuit was generated by LTSpice and show below:\nR1 is commented out.\nnet_list = '''\nG1 0 1 1 0 0.6\nI1 0 1 10\nG2 1 0 1 0 0.8\n*R1 1 0 100e6\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_9.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "39  Test 9",
    "section": "39.2 Call the symbolic modified nodal analysis function",
    "text": "39.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\left(- g_{1} + g_{2}\\right) = I_{1}\\)\n\n\n\n39.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 3\nnumber of branches: 3\nnumber of nodes: 1\nnumber of unknown currents: 0\nnumber of RLC (passive components): 0\nnumber of inductors: 0\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 2\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n39.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}- g_{1} + g_{2}\\end{matrix}\\right]\\)\n\n\n\n\n39.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}\\right]\\)\n\n\n\n\n39.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{1}\\right]\\)\n\n\n\n\n39.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nG1\n0\n1\n1\n0\nNaN\n0.6\nNaN\nNaN\nNaN\n\n\n1\nI1\n0\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nG2\n1\n0\n1\n0\nNaN\n0.8\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n39.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n\n\n\n\n\n\n\n39.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{1}, \\  v_{1}, \\  g_{2}, \\  g_{1}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#symbolic-solution",
    "href": "test_9.html#symbolic-solution",
    "title": "39  Test 9",
    "section": "39.3 Symbolic solution",
    "text": "39.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = - \\frac{I_{1}}{g_{1} - g_{2}}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#construct-a-dictionary-of-element-values",
    "href": "test_9.html#construct-a-dictionary-of-element-values",
    "title": "39  Test 9",
    "section": "39.4 Construct a dictionary of element values",
    "text": "39.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\ng1 = 0.6\nI1 = 10.0\ng2 = 0.8",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_9.html#numerical-solution",
    "href": "test_9.html#numerical-solution",
    "title": "39  Test 9",
    "section": "39.5 Numerical solution",
    "text": "39.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(10.0 = 0.2 v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1         50.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n\n  --- Operating Point ---\nV(1): 50 voltage I(I1): 10 device_current I(R1): 5e-07 device_current I(G1): 30 device_current I(G2): 40 device_current\nThe results from LTSpice agree with the SymPy results.\n\nFind the power absorbed by each source in the circuit.  \nThe results from LTSpice agree with the SymPy results.\n\nelement_values[g1]*U[v1]**2 # power through G1\n\n\\(\\displaystyle 1500.0\\)\n\n\n\nelement_values[g2]*U[v1]**2 # power through G2\n\n\\(\\displaystyle 2000.0\\)\n\n\n\nelement_values[I1]*U[v1] # power through I1\n\n\\(\\displaystyle 500.0\\)\n\n\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Test 9</span>"
    ]
  },
  {
    "objectID": "test_10.html",
    "href": "test_10.html",
    "title": "40  Test 10",
    "section": "",
    "text": "40.1 Load the net list\nFigure 40.1, contains independednt current and voltage sources in series and parallel. The circuit is from Hayt and Kemmerly (1978) (problem 34, Figure 2-51, page 65). This test examines a network with only sources.\na) Find the power supplied by the -5V source\nb) To what value should the 4A source be changed to reduce the supply supplied by the -5V source to zero?\nThe net list for the circuit was generated by LTSpice and show below:\nnet_list = '''\nI1 3 2 2\nI2 0 1 -3\nI3 4 0 4\nV1 2 3 -5\nV2 2 0 3\nV3 3 4 4\nV4 2 1 12\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_10.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "40  Test 10",
    "section": "40.2 Call the symbolic modified nodal analysis function",
    "text": "40.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- I_{V4} = I_{2}\\)\\(I_{V1} + I_{V2} + I_{V4} = I_{1}\\)\\(- I_{V1} + I_{V3} = - I_{1}\\)\\(- I_{V3} = - I_{3}\\)\\(v_{2} - v_{3} = V_{1}\\)\\(v_{2} = V_{2}\\)\\(v_{3} - v_{4} = V_{3}\\)\\(- v_{1} + v_{2} = V_{4}\\)\n\n\n\n40.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 7\nnumber of branches: 7\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 0\nnumber of inductors: 0\nnumber of independent voltage sources: 4\nnumber of independent current sources: 3\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n40.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\\\\0 & 0 & 0 & 0 & 1 & 1 & 0 & 1\\\\0 & 0 & 0 & 0 & -1 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\0 & 1 & -1 & 0 & 0 & 0 & 0 & 0\\\\0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 1 & -1 & 0 & 0 & 0 & 0\\\\-1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\end{matrix}\\right]\\)\n\n\n\n\n40.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}, \\  I_{V2}, \\  I_{V3}, \\  I_{V4}\\right]\\)\n\n\n\n\n40.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{2}, \\  I_{1}, \\  - I_{1}, \\  - I_{3}, \\  V_{1}, \\  V_{2}, \\  V_{3}, \\  V_{4}\\right]\\)\n\n\n\n\n40.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n2\n3\nNaN\nNaN\nNaN\n-5.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n2\n0\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n2\nV3\n3\n4\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n3\nV4\n2\n1\nNaN\nNaN\nNaN\n12.0\nNaN\nNaN\nNaN\n\n\n4\nI1\n3\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nI2\n0\n1\nNaN\nNaN\nNaN\n-3.0\nNaN\nNaN\nNaN\n\n\n6\nI3\n4\n0\nNaN\nNaN\nNaN\n4.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n40.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n2\n3\n\n\n1\nV2\n2\n0\n\n\n2\nV3\n3\n4\n\n\n3\nV4\n2\n1\n\n\n\n\n\n\n\n\n\n40.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V4}, \\  I_{1}, \\  V_{2}, \\  I_{2}, \\  V_{1}, \\  I_{3}, \\  v_{2}, \\  I_{V1}, \\  v_{3}, \\  V_{3}, \\  V_{4}, \\  I_{V2}, \\  v_{1}, \\  I_{V3}, \\  v_{4}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#symbolic-solution",
    "href": "test_10.html#symbolic-solution",
    "title": "40  Test 10",
    "section": "40.3 Symbolic solution",
    "text": "40.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(I_{V1} = I_{1} + I_{3}\\)\\(I_{V2} = I_{2} - I_{3}\\)\\(I_{V3} = I_{3}\\)\\(I_{V4} = - I_{2}\\)\\(v_{1} = V_{2} - V_{4}\\)\\(v_{2} = V_{2}\\)\\(v_{3} = - V_{1} + V_{2}\\)\\(v_{4} = - V_{1} + V_{2} - V_{3}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#construct-a-dictionary-of-element-values",
    "href": "test_10.html#construct-a-dictionary-of-element-values",
    "title": "40  Test 10",
    "section": "40.4 Construct a dictionary of element values",
    "text": "40.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = -5.0\nV2 = 3.0\nV3 = 4.0\nV4 = 12.0\nI1 = 2.0\nI2 = -3.0\nI3 = 4.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_10.html#numerical-solution",
    "href": "test_10.html#numerical-solution",
    "title": "40  Test 10",
    "section": "40.5 Numerical solution",
    "text": "40.5 Numerical solution\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-3.0 = - I_{V4}\\)\\(2.0 = I_{V1} + I_{V2} + I_{V4}\\)\\(-2.0 = - I_{V1} + I_{V3}\\)\\(-4.0 = - I_{V3}\\)\\(-5.0 = v_{2} - v_{3}\\)\\(3.0 = v_{2}\\)\\(4.0 = v_{3} - v_{4}\\)\\(12.0 = - v_{1} + v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU = solve(NE,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nI_V1        6.000000\nI_V2       -7.000000\nI_V3        4.000000\nI_V4        3.000000\nv1         -9.000000\nv2          3.000000\nv3          8.000000\nv4          4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\nV(3):    8   voltage\nV(2):    3   voltage\nV(1):    -9  voltage\nV(4):    4   voltage\nI(I1):   2   device_current\nI(I2):   -3  device_current\nI(I3):   4   device_current\nI(V1):   6   device_current\nI(V2):   -7  device_current\nI(V3):   4   device_current\nI(V4):   3   device_current\nThe results from LTSpice agree with the SymPy results.\nFind the power absorbed by each source in the circuit.\nLooking at equation I_V1 = I₁ + I₃, set I_V1 to zero\n\nelement_values[I1] + element_values[I3] - 0\n\n\\(\\displaystyle 6.0\\)\n\n\nBy inspection a value of I3 = -2 will make I_V1 = 0\n\nelement_values[I1] + (-2) - 0\n\n\\(\\displaystyle 0.0\\)\n\n\nanswer is -2\nText book’s answers are: (a) 30W; (b) -2A\n\n\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd Edition. McGraw-Hill.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Test 10</span>"
    ]
  },
  {
    "objectID": "test_11.html",
    "href": "test_11.html",
    "title": "41  Test 11",
    "section": "",
    "text": "41.1 Load the net list\nFigure 41.1 is from Johnson, Hilburn, and Johnson (1978) (page 444, problem 16.15). The circuit was drawn in LTSpice and the circuit nodes are labeled. Find the network function, H(s)=V2(s)/V3(s). I made some changes to the values, phases of the windings and coupling constants.\n29 Nov 2023:\nProblem - When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to it’s position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts. Solution - added code to move voltage source types to the beginning of the net list data frame before any calculations are performed.\nNeed to verify during testing that independednt current sources, type I, do not also need this fix.\nThe netlist generated by LTSpice:\nSee notes at the end for debugging steps.\nnet_list = '''\nL1 1 0 10 \nL2 0 2 20 \nL3 4 0 30\nR2 2 0 5\nR3 4 0 10\nR1 1 3 2\nV1 3 0 10\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_11.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "41  Test 11",
    "section": "41.2 Call the symbolic modified nodal analysis function",
    "text": "41.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L2} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{V1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(I_{L3} + \\frac{v_{4}}{R_{3}} = 0\\)\\(v_{3} = V_{1}\\)\\(- I_{L1} L_{1} s - I_{L2} M_{1} s - I_{L3} M_{2} s + v_{1} = 0\\)\\(- I_{L1} M_{1} s - I_{L2} L_{2} s - I_{L3} M_{3} s - v_{2} = 0\\)\\(- I_{L1} M_{2} s - I_{L2} M_{3} s - I_{L3} L_{3} s + v_{4} = 0\\)\n\n\n\n41.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 7\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 6\nnumber of inductors: 3\nnumber of independent voltage sources: 1\nnumber of independent current sources: 0\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 3\n\n\n\n\n\n41.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & - \\frac{1}{R_{1}} & 0 & 0 & 1 & 0 & 0\\\\0 & \\frac{1}{R_{2}} & 0 & 0 & 0 & 0 & -1 & 0\\\\- \\frac{1}{R_{1}} & 0 & \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0\\\\0 & 0 & 0 & \\frac{1}{R_{3}} & 0 & 0 & 0 & 1\\\\0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & - L_{1} s & - M_{1} s & - M_{2} s\\\\0 & -1 & 0 & 0 & 0 & - M_{1} s & - L_{2} s & - M_{3} s\\\\0 & 0 & 0 & 1 & 0 & - M_{2} s & - M_{3} s & - L_{3} s\\end{matrix}\\right]\\)\n\n\n\n\n41.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{V1}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}\\right]\\)\n\n\n\n\n41.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  0, \\  V_{1}, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n41.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n3\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n1\nL1\n1\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nL2\n0\n2\nNaN\nNaN\nNaN\n20.0\nNaN\nNaN\nNaN\n\n\n3\nL3\n4\n0\nNaN\nNaN\nNaN\n30.0\nNaN\nNaN\nNaN\n\n\n4\nR2\n2\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n5\nR3\n4\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n6\nR1\n1\n3\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nK1\nNaN\nNaN\nNaN\nNaN\nNaN\n0.2\nNaN\nL1\nL2\n\n\n8\nK2\nNaN\nNaN\nNaN\nNaN\nNaN\n0.8\nNaN\nL1\nL3\n\n\n9\nK3\nNaN\nNaN\nNaN\nNaN\nNaN\n0.5\nNaN\nL2\nL3\n\n\n\n\n\n\n\n\n\n41.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n3\n0\n\n\n1\nL1\n1\n0\n\n\n2\nL2\n0\n2\n\n\n3\nL3\n4\n0\n\n\n\n\n\n\n\n\n\n41.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{V1}, \\  R_{1}, \\  R_{2}, \\  v_{2}, \\  M_{1}, \\  v_{4}, \\  I_{L3}, \\  M_{2}, \\  I_{L2}, \\  M_{3}, \\  v_{1}, \\  R_{3}, \\  s, \\  v_{3}, \\  L_{1}, \\  I_{L1}, \\  L_{2}, \\  V_{1}, \\  L_{3}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#symbolic-solution",
    "href": "test_11.html#symbolic-solution",
    "title": "41  Test 11",
    "section": "41.3 Symbolic solution",
    "text": "41.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{L_{1} L_{2} L_{3} V_{1} s^{3} + L_{1} L_{2} R_{3} V_{1} s^{2} + L_{1} L_{3} R_{2} V_{1} s^{2} - L_{1} M_{3}^{2} V_{1} s^{3} + L_{1} R_{2} R_{3} V_{1} s - L_{2} M_{2}^{2} V_{1} s^{3} - L_{3} M_{1}^{2} V_{1} s^{3} - M_{1}^{2} R_{3} V_{1} s^{2} + 2 M_{1} M_{2} M_{3} V_{1} s^{3} - M_{2}^{2} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{2} = \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(v_{3} = V_{1}\\)\\(v_{4} = \\frac{L_{2} M_{2} R_{3} V_{1} s^{2} - M_{1} M_{3} R_{3} V_{1} s^{2} + M_{2} R_{2} R_{3} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{V1} = \\frac{- L_{2} L_{3} V_{1} s^{2} - L_{2} R_{3} V_{1} s - L_{3} R_{2} V_{1} s + M_{3}^{2} V_{1} s^{2} - R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L1} = \\frac{L_{2} L_{3} V_{1} s^{2} + L_{2} R_{3} V_{1} s + L_{3} R_{2} V_{1} s - M_{3}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L2} = \\frac{- L_{3} M_{1} V_{1} s^{2} - M_{1} R_{3} V_{1} s + M_{2} M_{3} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)\\(I_{L3} = \\frac{- L_{2} M_{2} V_{1} s^{2} + M_{1} M_{3} V_{1} s^{2} - M_{2} R_{2} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#construct-a-dictionary-of-element-values",
    "href": "test_11.html#construct-a-dictionary-of-element-values",
    "title": "41  Test 11",
    "section": "41.4 Construct a dictionary of element values",
    "text": "41.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nV1 = 10.0\nL1 = 10.0\nL2 = 20.0\nL3 = 30.0\nR2 = 5.0\nR3 = 10.0\nR1 = 2.0\nK1 = 0.2\nK2 = 0.8\nK3 = 0.5\n\n\n\n41.4.1 Mutual inductance\nIn the netlist, the line below specifies that L3 and L4 are connected by a magnetic circuit.\n\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nA coupled inductor has two or more windings that are connected by a magnetic circuit. Coupled inductors transfer energy from one winding to a different winding usually through a commonly used core. The efficiency of the magnetic coupling between both the windings is defined by the coupling factor k or by mutual inductance.\nThe coupling constant and the mutual inductance are related by the equation:\n\\(M_1 = K1 \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = K2 \\times {\\sqrt{L_1 \\times L_3}}\\)\n\\(M_3 = K3 \\times {\\sqrt{L_2 \\times L_3}}\\)\nWhere k is the coupling coefficient and in spice the value of k can be from -1 to +1 to account for a a negative phase relation. Phase dots are drawn on the schematic to indicate the relative direction of the windings. In LTspice the phase dots are associated with the negative terminal of the winding.\n\nK1, K2, K3 = symbols('K1 K2 K3')\n\n# calculate the coupling constant from the mutual inductance\nelement_values[M1] = element_values[K1]*np.sqrt(element_values[L1] * element_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(element_values[M1]))\n\nelement_values[M2] = element_values[K2]*np.sqrt(element_values[L1] * element_values[L3])\nprint('mutual inductance, M2 = {:.9f}'.format(element_values[M2]))\n\nelement_values[M3] = element_values[K3]*np.sqrt(element_values[L2] * element_values[L3])\nprint('mutual inductance, M3 = {:.9f}'.format(element_values[M3]))\n\nmutual inductance, M1 = 2.828427125\nmutual inductance, M2 = 13.856406461\nmutual inductance, M3 = 12.247448714",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_11.html#dc-operating-point",
    "href": "test_11.html#dc-operating-point",
    "title": "41  Test 11",
    "section": "41.5 DC operating point",
    "text": "41.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\)\\(0 = - I_{L2} + 0.2 v_{2}\\)\\(0 = I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\)\\(0 = I_{L3} + 0.1 v_{4}\\)\\(10.0 = v_{3}\\)\\(0 = v_{1}\\)\\(0 = - v_{2}\\)\\(0 = v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          0.000000\nv3         10.000000\nI_V1       -5.000000\nI_L1        5.000000\nv2          0.000000\nI_L2        0.000000\nv4          0.000000\nI_L3        0.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    0   voltage\nV(2):    0   voltage\nV(4):    0   voltage\nV(3):    10  voltage\nI(L1):   5   device_current\nI(L2):   0   device_current\nI(L3):   0   device_current\nI(R2):   0   device_current\nI(R3):   0   device_current\nI(R1):   -5  device_current\nI(V1):   -5  device_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n41.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\)\\(0 = - I_{L2} + 0.2 v_{2}\\)\\(0 = I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\)\\(0 = I_{L3} + 0.1 v_{4}\\)\\(10.0 = v_{3}\\)\\(0 = - 10.0 i I_{L1} - 2.82842712474619 i I_{L2} - 13.856406460551 i I_{L3} + v_{1}\\)\\(0 = - 2.82842712474619 i I_{L1} - 20.0 i I_{L2} - 12.2474487139159 i I_{L3} - v_{2}\\)\\(0 = - 13.856406460551 i I_{L1} - 12.2474487139159 i I_{L2} - 30.0 i I_{L3} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown          mag    phase, deg\n---------  ---------  ------------\nv1          8.002110     16.522966\nv2          1.369735     15.274587\nv3         10.000000      0.000000\nv4          7.724137    -19.105758\nI_V1        1.627911    135.653713\nI_L1        1.627911    -44.346287\nI_L2        0.273947     15.274587\nI_L3        0.772414    160.894242\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\n\n41.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\)\\(0 = - I_{L2} + 0.2 v_{2}\\)\\(0 = I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\)\\(0 = I_{L3} + 0.1 v_{4}\\)\\(10.0 = v_{3}\\)\\(0 = - 10.0 I_{L1} s - 2.82842712474619 I_{L2} s - 13.856406460551 I_{L3} s + v_{1}\\)\\(0 = - 2.82842712474619 I_{L1} s - 20.0 I_{L2} s - 12.2474487139159 I_{L3} s - v_{2}\\)\\(0 = - 13.856406460551 I_{L1} s - 12.2474487139159 I_{L2} s - 30.0 I_{L3} s + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n41.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 10*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 1, 300, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_11.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-14}\\) and \\(10^{-13}\\) for the phase indicating the numerical difference is very small.\n\n\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric Circuit Analysis. Prentice-Hall, Inc.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Test 11</span>"
    ]
  },
  {
    "objectID": "test_12.html",
    "href": "test_12.html",
    "title": "42  Test 12",
    "section": "",
    "text": "42.1 Load the net list\nThe circuit in Figure 42.1 is a 7th order low pass filter, Chebyshev response, 0.1 dB of ripple from Zverev (1967). This test circuit is a ladder filter realization of a Chebyshev filter.\nThe netlist generated by LTSpice:\nnet_list = '''\nC3 2 0 3.7642\nI1 0 1 1\nC5 3 0 4.015\nC7 4 0 3.0182\nL2 1 2 0.7529\nL4 2 3 0.9276\nL6 3 4 0.9142\nRs 1 0 0.5\nRl 4 0 1\nC1 1 0 1.5948\n\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_12.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "42  Test 12",
    "section": "42.2 Call the symbolic modified nodal analysis function",
    "text": "42.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L2} + v_{1} \\left(C_{1} s + \\frac{1}{Rs}\\right) = I_{1}\\)\\(C_{3} s v_{2} - I_{L2} + I_{L4} = 0\\)\\(C_{5} s v_{3} - I_{L4} + I_{L6} = 0\\)\\(- I_{L6} + v_{4} \\left(C_{7} s + \\frac{1}{Rl}\\right) = 0\\)\\(- I_{L2} L_{2} s + v_{1} - v_{2} = 0\\)\\(- I_{L4} L_{4} s + v_{2} - v_{3} = 0\\)\\(- I_{L6} L_{6} s + v_{3} - v_{4} = 0\\)\n\n\n\n42.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 10\nnumber of branches: 10\nnumber of nodes: 4\nnumber of unknown currents: 3\nnumber of RLC (passive components): 9\nnumber of resistors: 2\nnumber of capacitors: 4\nnumber of inductors: 3\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n42.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{Rs} & 0 & 0 & 0 & 1 & 0 & 0\\\\0 & C_{3} s & 0 & 0 & -1 & 1 & 0\\\\0 & 0 & C_{5} s & 0 & 0 & -1 & 1\\\\0 & 0 & 0 & C_{7} s + \\frac{1}{Rl} & 0 & 0 & -1\\\\1 & -1 & 0 & 0 & - L_{2} s & 0 & 0\\\\0 & 1 & -1 & 0 & 0 & - L_{4} s & 0\\\\0 & 0 & 1 & -1 & 0 & 0 & - L_{6} s\\end{matrix}\\right]\\)\n\n\n\n\n42.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{L2}, \\  I_{L4}, \\  I_{L6}\\right]\\)\n\n\n\n\n42.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ I_{1}, \\  0, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n42.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nC3\n2\n0\nNaN\nNaN\nNaN\n3.7642\nNaN\nNaN\nNaN\n\n\n1\nI1\n0\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n2\nC5\n3\n0\nNaN\nNaN\nNaN\n4.015\nNaN\nNaN\nNaN\n\n\n3\nC7\n4\n0\nNaN\nNaN\nNaN\n3.0182\nNaN\nNaN\nNaN\n\n\n4\nL2\n1\n2\nNaN\nNaN\nNaN\n0.7529\nNaN\nNaN\nNaN\n\n\n5\nL4\n2\n3\nNaN\nNaN\nNaN\n0.9276\nNaN\nNaN\nNaN\n\n\n6\nL6\n3\n4\nNaN\nNaN\nNaN\n0.9142\nNaN\nNaN\nNaN\n\n\n7\nRs\n1\n0\nNaN\nNaN\nNaN\n0.5\nNaN\nNaN\nNaN\n\n\n8\nRl\n4\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n9\nC1\n1\n0\nNaN\nNaN\nNaN\n1.5948\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n42.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL2\n1\n2\n\n\n1\nL4\n2\n3\n\n\n2\nL6\n3\n4\n\n\n\n\n\n\n\n\n\n42.2.7 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L4}, \\  Rl, \\  L_{6}, \\  C_{7}, \\  Rs, \\  v_{1}, \\  C_{3}, \\  I_{L2}, \\  L_{2}, \\  I_{1}, \\  C_{1}, \\  s, \\  C_{5}, \\  I_{L6}, \\  v_{4}, \\  L_{4}, \\  v_{3}, \\  v_{2}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#symbolic-solution",
    "href": "test_12.html#symbolic-solution",
    "title": "42  Test 12",
    "section": "42.3 Symbolic solution",
    "text": "42.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{C_{3} C_{5} C_{7} I_{1} L_{2} L_{4} L_{6} Rl Rs s^{6} + C_{3} C_{5} I_{1} L_{2} L_{4} L_{6} Rs s^{5} + C_{3} C_{5} I_{1} L_{2} L_{4} Rl Rs s^{4} + C_{3} C_{7} I_{1} L_{2} L_{4} Rl Rs s^{4} + C_{3} C_{7} I_{1} L_{2} L_{6} Rl Rs s^{4} + C_{3} I_{1} L_{2} L_{4} Rs s^{3} + C_{3} I_{1} L_{2} L_{6} Rs s^{3} + C_{3} I_{1} L_{2} Rl Rs s^{2} + C_{5} C_{7} I_{1} L_{2} L_{6} Rl Rs s^{4} + C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{4} + C_{5} I_{1} L_{2} L_{6} Rs s^{3} + C_{5} I_{1} L_{2} Rl Rs s^{2} + C_{5} I_{1} L_{4} L_{6} Rs s^{3} + C_{5} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{2} Rl Rs s^{2} + C_{7} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{2} Rs s + I_{1} L_{4} Rs s + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{2} = \\frac{C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{4} + C_{5} I_{1} L_{4} L_{6} Rs s^{3} + C_{5} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{4} Rl Rs s^{2} + C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{4} Rs s + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{3} = \\frac{C_{7} I_{1} L_{6} Rl Rs s^{2} + I_{1} L_{6} Rs s + I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(v_{4} = \\frac{I_{1} Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L2} = \\frac{C_{3} C_{5} C_{7} I_{1} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} I_{1} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} I_{1} L_{4} Rl Rs s^{3} + C_{3} C_{7} I_{1} L_{4} Rl Rs s^{3} + C_{3} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{3} I_{1} L_{4} Rs s^{2} + C_{3} I_{1} L_{6} Rs s^{2} + C_{3} I_{1} Rl Rs s + C_{5} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{5} I_{1} L_{6} Rs s^{2} + C_{5} I_{1} Rl Rs s + C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L4} = \\frac{C_{5} C_{7} I_{1} L_{6} Rl Rs s^{3} + C_{5} I_{1} L_{6} Rs s^{2} + C_{5} I_{1} Rl Rs s + C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\\(I_{L6} = \\frac{C_{7} I_{1} Rl Rs s + I_{1} Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#construct-a-dictionary-of-element-values",
    "href": "test_12.html#construct-a-dictionary-of-element-values",
    "title": "42  Test 12",
    "section": "42.4 Construct a dictionary of element values",
    "text": "42.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nC3 = 3.7642\nI1 = 1.0\nC5 = 4.015\nC7 = 3.0182\nL2 = 0.7529\nL4 = 0.9276\nL6 = 0.9142\nRs = 0.5\nRl = 1.0\nC1 = 1.5948",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#dc-operating-point",
    "href": "test_12.html#dc-operating-point",
    "title": "42  Test 12",
    "section": "42.5 DC operating point",
    "text": "42.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(1.0 = I_{L2} + 2.0 v_{1}\\)\\(0 = - I_{L2} + I_{L4}\\)\\(0 = - I_{L4} + I_{L6}\\)\\(0 = - I_{L6} + 1.0 v_{4}\\)\\(0 = v_{1} - v_{2}\\)\\(0 = v_{2} - v_{3}\\)\\(0 = v_{3} - v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown         mag\n---------  --------\nv1         0.333333\nv2         0.333333\nv3         0.333333\nv4         0.333333\nI_L2       0.333333\nI_L4       0.333333\nI_L6       0.333333\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(2):    0.333333    voltage\nV(1):    0.333333    voltage\nV(3):    0.333333    voltage\nV(4):    0.333333    voltage\nI(C3):   1.25473e-12     device_current\nI(C5):   1.33833e-12     device_current\nI(C7):   1.00607e-12     device_current\nI(C1):   5.316e-13   device_current\nI(L2):   0.333333    device_current\nI(L4):   0.333333    device_current\nI(L6):   0.333333    device_current\nI(I1):   1   device_current\nI(Rs):   0.666667    device_current\nI(Rl):   0.333333    device_current\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n42.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(1.0 = I_{L2} + v_{1} \\cdot \\left(2.0 + 1.5948 i\\right)\\)\\(0 = - I_{L2} + I_{L4} + 3.7642 i v_{2}\\)\\(0 = - I_{L4} + I_{L6} + 4.015 i v_{3}\\)\\(0 = - I_{L6} + v_{4} \\cdot \\left(1.0 + 3.0182 i\\right)\\)\\(0 = - 0.7529 i I_{L2} + v_{1} - v_{2}\\)\\(0 = - 0.9276 i I_{L4} + v_{2} - v_{3}\\)\\(0 = - 0.9142 i I_{L6} + v_{3} - v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.247674     43.979099\nv2         0.596900   -119.590485\nv3         0.467235     71.054634\nv4         0.235668    -81.486420\nI_L2       1.112227    -34.389344\nI_L4       1.142319    155.081675\nI_L6       0.749319     -9.817657\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:     0.5969 phase:    -119.59°  voltage\nV(1):   mag:   0.247674 phase:    43.9791°  voltage\nV(3):   mag:   0.467235 phase:    71.0546°  voltage\nV(4):   mag:   0.235668 phase:   -81.4864°  voltage\nI(C3):  mag:    2.24685 phase:   -29.5905°  device_current\nI(C5):  mag:    1.87595 phase:    161.055°  device_current\nI(C7):  mag:   0.711294 phase:    8.51358°  device_current\nI(C1):  mag:   0.394991 phase:    133.979°  device_current\nI(L2):  mag:    1.11223 phase:   -34.3893°  device_current\nI(L4):  mag:    1.14232 phase:    155.082°  device_current\nI(L6):  mag:   0.749319 phase:   -9.81766°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(Rs):  mag:   0.495349 phase:    43.9791°  device_current\nI(Rl):  mag:   0.235668 phase:   -81.4864°  device_current\n\n\n\n42.5.2 AC Sweep\nLooking at node 4 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(1.0 = I_{L2} + v_{1} \\cdot \\left(1.5948 s + 2.0\\right)\\)\\(0 = - I_{L2} + I_{L4} + 3.7642 s v_{2}\\)\\(0 = - I_{L4} + I_{L6} + 4.015 s v_{3}\\)\\(0 = - I_{L6} + v_{4} \\cdot \\left(3.0182 s + 1.0\\right)\\)\\(0 = - 0.7529 I_{L2} s + v_{1} - v_{2}\\)\\(0 = - 0.9276 I_{L4} s + v_{2} - v_{3}\\)\\(0 = - 0.9142 I_{L6} s + v_{3} - v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n42.5.3 Plot the voltage at node 2\n\nH = U_ac[v4]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.01*2*np.pi, 1*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-2, 0, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_12_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfrequency[0]\n\n\\(\\displaystyle 0.01\\)\n\n\n\nfrequency[-1]\n\n\\(\\displaystyle 1.0\\)\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1]) - 10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2)*180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response difference')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other, but not to the same precision as in previous tests.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#poles-and-zeros-of-the-transfer-function",
    "href": "test_12.html#poles-and-zeros-of-the-transfer-function",
    "title": "42  Test 12",
    "section": "42.6 Poles and zeros of the transfer function",
    "text": "42.6 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)\n\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)\n\n\n42.6.0.1 Low pass filter pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 7\n-0.01+0.16j Hz\n-0.01-0.16j Hz\n-0.04+0.12j Hz\n-0.04-0.12j Hz\n-0.05+0.07j Hz\n-0.05-0.07j Hz\n-0.06+0.00j Hz",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_12.html#impulse-and-step-response",
    "href": "test_12.html#impulse-and-step-response",
    "title": "42  Test 12",
    "section": "42.7 Impulse and step response",
    "text": "42.7 Impulse and step response\nUse the SciPy functions impulse and step to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\n42.7.1 Low pass filter group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w),'-',label='group delay')\n\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley & Sons.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Test 12</span>"
    ]
  },
  {
    "objectID": "test_13.html",
    "href": "test_13.html",
    "title": "43  Test 13",
    "section": "",
    "text": "43.1 Load the net list\nThe circuit in Figure 43.1 is a ring of current sources and inductors. It turns out that this circuit is a pathological case, which generates four unknown currents steming from the four inductors and four known currents steming from the independednt current sources. When I entered this circuit into LTSpice, an error was generated saying, “the inductor L3 is in a loop involving inductor L1 and other voltage sources and/or inductors making an overdefined circuit matrix. You will need to correct the circuit or add some series resistance.” So to keep LTSpice happy, I set the series resistance of L3 to 1e-20 ohms. However, the Python code did not complain about about the netlist being ill formed until I attempted to solve the circuit equations at DC, \\(s=0\\). The current though L4 could not be dertermined. The Python code was able to generate AC solutions that agreed to LTSpice for \\(s \\ne 0\\) without the need to add a series resistance to L3.\nThe netlist generated by LTSpice:\nUsing the orginal circuit with the series resistance in L1 set to a small value, the phase of the currents in L2 and L4 didn’t agree with the Python results. So the netlist was modified to put the small series resistance in L3, which allowed the phase in L2 and L3 to agree.\nThe new LTSpice net list with Rser=1e-20 added to L1.\nNode 5 added manually along with R1 = 1e-20 ohms in series with L1.\nnet_list = '''\nL1 2 4 5\nR1 4 3 1e-20\nI1 1 2 2 \nL2 0 3 3 \nL3 2 1 1 \nL4 1 0 1 \nI2 0 1 1\nI3 3 0 5\nI4 2 3 3\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_13.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "43  Test 13",
    "section": "43.2 Call the symbolic modified nodal analysis function",
    "text": "43.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(- I_{L3} + I_{L4} = - I_{1} + I_{2}\\)\\(I_{L1} + I_{L3} = I_{1} - I_{4}\\)\\(- I_{L2} + \\frac{v_{3}}{R_{1}} - \\frac{v_{4}}{R_{1}} = - I_{3} + I_{4}\\)\\(- I_{L1} - \\frac{v_{3}}{R_{1}} + \\frac{v_{4}}{R_{1}} = 0\\)\\(- I_{L1} L_{1} s + v_{2} - v_{4} = 0\\)\\(- I_{L2} L_{2} s - v_{3} = 0\\)\\(- I_{L3} L_{3} s - v_{1} + v_{2} = 0\\)\\(- I_{L4} L_{4} s + v_{1} = 0\\)\n\n\n\n43.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 4\nnumber of unknown currents: 4\nnumber of RLC (passive components): 5\nnumber of inductors: 4\nnumber of independent voltage sources: 0\nnumber of independent current sources: 4\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n43.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0 & 0 & -1 & 1\\\\0 & 0 & 0 & 0 & 1 & 0 & 1 & 0\\\\0 & 0 & \\frac{1}{R_{1}} & - \\frac{1}{R_{1}} & 0 & -1 & 0 & 0\\\\0 & 0 & - \\frac{1}{R_{1}} & \\frac{1}{R_{1}} & -1 & 0 & 0 & 0\\\\0 & 1 & 0 & -1 & - L_{1} s & 0 & 0 & 0\\\\0 & 0 & -1 & 0 & 0 & - L_{2} s & 0 & 0\\\\-1 & 1 & 0 & 0 & 0 & 0 & - L_{3} s & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & - L_{4} s\\end{matrix}\\right]\\)\n\n\n\n\n43.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  I_{L1}, \\  I_{L2}, \\  I_{L3}, \\  I_{L4}\\right]\\)\n\n\n\n\n43.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1} + I_{2}, \\  I_{1} - I_{4}, \\  - I_{3} + I_{4}, \\  0, \\  0, \\  0, \\  0, \\  0\\right]\\)\n\n\n\n\n43.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nL1\n2\n4\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n4\n3\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nI1\n1\n2\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nL2\n0\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n4\nL3\n2\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n5\nL4\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n6\nI2\n0\n1\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n7\nI3\n3\n0\nNaN\nNaN\nNaN\n5.0\nNaN\nNaN\nNaN\n\n\n8\nI4\n2\n3\nNaN\nNaN\nNaN\n3.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n43.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL1\n2\n4\n\n\n1\nL2\n0\n3\n\n\n2\nL3\n2\n1\n\n\n3\nL4\n1\n0\n\n\n\n\n\n\n\n\n\n43.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( I_{L4}, \\  I_{L1}, \\  L_{3}, \\  L_{2}, \\  v_{1}, \\  L_{1}, \\  I_{1}, \\  I_{L3}, \\  v_{3}, \\  R_{1}, \\  v_{2}, \\  L_{4}, \\  I_{2}, \\  s, \\  I_{3}, \\  I_{4}, \\  I_{L2}, \\  v_{4}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#symbolic-solution",
    "href": "test_13.html#symbolic-solution",
    "title": "43  Test 13",
    "section": "43.3 Symbolic solution",
    "text": "43.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- I_{1} L_{3} L_{4} s^{2} + I_{2} L_{1} L_{4} s^{2} + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{3} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{2} L_{4} s^{2} - I_{4} L_{1} L_{4} s^{2} - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{2} = \\frac{I_{1} L_{1} L_{3} s^{2} + I_{1} L_{2} L_{3} s^{2} + I_{1} L_{3} R_{1} s + I_{2} L_{1} L_{4} s^{2} + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} - I_{4} L_{1} L_{3} s^{2} - I_{4} L_{1} L_{4} s^{2} - I_{4} L_{3} R_{1} s - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{3} = \\frac{I_{1} L_{2} L_{3} s^{2} + I_{2} L_{2} L_{4} s^{2} - I_{3} L_{1} L_{2} s^{2} - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} - I_{3} L_{2} R_{1} s + I_{4} L_{1} L_{2} s^{2} + I_{4} L_{2} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(v_{4} = \\frac{I_{1} L_{2} L_{3} s^{2} + I_{1} L_{3} R_{1} s + I_{2} L_{2} L_{4} s^{2} + I_{2} L_{4} R_{1} s - I_{3} L_{1} L_{2} s^{2} - I_{3} L_{2} L_{3} s^{2} - I_{3} L_{2} L_{4} s^{2} + I_{4} L_{1} L_{2} s^{2} - I_{4} L_{3} R_{1} s - I_{4} L_{4} R_{1} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L1} = \\frac{I_{1} L_{3} s + I_{2} L_{4} s + I_{3} L_{2} s - I_{4} L_{2} s - I_{4} L_{3} s - I_{4} L_{4} s}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L2} = \\frac{- I_{1} L_{3} s - I_{2} L_{4} s + I_{3} L_{1} s + I_{3} L_{3} s + I_{3} L_{4} s + I_{3} R_{1} - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L3} = \\frac{I_{1} L_{1} s + I_{1} L_{2} s + I_{1} L_{4} s + I_{1} R_{1} - I_{2} L_{4} s - I_{3} L_{2} s - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)\\(I_{L4} = \\frac{- I_{1} L_{3} s + I_{2} L_{1} s + I_{2} L_{2} s + I_{2} L_{3} s + I_{2} R_{1} - I_{3} L_{2} s - I_{4} L_{1} s - I_{4} R_{1}}{L_{1} s + L_{2} s + L_{3} s + L_{4} s + R_{1}}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#construct-a-dictionary-of-element-values",
    "href": "test_13.html#construct-a-dictionary-of-element-values",
    "title": "43  Test 13",
    "section": "43.4 Construct a dictionary of element values",
    "text": "43.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nL1 = 5.0\nR1 = 1e-20\nI1 = 2.0\nL2 = 3.0\nL3 = 1.0\nL4 = 1.0\nI2 = 1.0\nI3 = 5.0\nI4 = 3.0",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_13.html#dc-operating-point",
    "href": "test_13.html#dc-operating-point",
    "title": "43  Test 13",
    "section": "43.5 DC operating point",
    "text": "43.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = - I_{L3} + I_{L4}\\)\\(-1.0 = I_{L1} + I_{L3}\\)\\(-2.0 = - I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = v_{2} - v_{4}\\)\\(0 = - v_{3}\\)\\(0 = - v_{1} + v_{2}\\)\\(0 = v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          0.000000\nv2          0.000000\nv3          0.000000\nv4          0.000000\nI_L1        0.000000\nI_L2        2.000000\nI_L3       -1.000000\nI_L4       -2.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(2):    0   voltage\nV(3):    0   voltage\nV(1):    0   voltage\nI(L1):   -1  device_current\nI(L2):   3   device_current\nI(L3):   0   device_current\nI(L4):   -1  device_current\nI(I1):   2   device_current\nI(I2):   1   device_current\nI(I3):   5   device_current\nI(I4):   3   device_current\n\n\n43.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nelement_values[I2] = 0\nelement_values[I3] = 0\nelement_values[I4] = 0\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(-2.0 = - I_{L3} + I_{L4}\\)\\(2.0 = I_{L1} + I_{L3}\\)\\(0 = - I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - 5.0 i I_{L1} + v_{2} - v_{4}\\)\\(0 = - 3.0 i I_{L2} - v_{3}\\)\\(0 = - 1.0 i I_{L3} - v_{1} + v_{2}\\)\\(0 = - 1.0 i I_{L4} + v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.200000    -90.000000\nv2         1.600000     90.000000\nv3         0.600000     90.000000\nv4         0.600000     90.000000\nI_L1       0.200000      0.000000\nI_L2       0.200000   -180.000000\nI_L3       1.800000     -0.000000\nI_L4       0.200000   -180.000000\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: -5.15662e-19°    device_current\nI(L2):  mag:        0.2 phase:        180°  device_current\nI(L3):  mag:        1.8 phase: 5.72958e-20°     device_current\nI(L4):  mag:        0.2 phase:        180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\n\nThere are some small numeric differences in some node voltages and phases because of the series resistance. Also note the the phase of the current for L2 and L4 from LTSpice is -180 vs +180 as calculated by SymPy.\n\n\n43.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-2.0 = - I_{L3} + I_{L4}\\)\\(2.0 = I_{L1} + I_{L3}\\)\\(0 = - I_{L2} + 1.0 \\cdot 10^{20} v_{3} - 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - I_{L1} - 1.0 \\cdot 10^{20} v_{3} + 1.0 \\cdot 10^{20} v_{4}\\)\\(0 = - 5.0 I_{L1} s + v_{2} - v_{4}\\)\\(0 = - 3.0 I_{L2} s - v_{3}\\)\\(0 = - 1.0 I_{L3} s - v_{1} + v_{2}\\)\\(0 = - 1.0 I_{L4} s + v_{1}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n43.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\n#x = np.linspace(0.1*2*np.pi, 10*2*np.pi, 2000, endpoint=True)\nx = np.logspace(-1, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_13.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(voltage[0:-1])-10**(mag/20),'-r')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(voltage[0:-1])/2) *180/np.pi - phase,':',color=color)  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-13}\\). There is no difference in the phase results.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Test 13</span>"
    ]
  },
  {
    "objectID": "test_14.html",
    "href": "test_14.html",
    "title": "44  Test 14",
    "section": "",
    "text": "44.1 Load the net list\nThis test circuit has one unknown current source. This circuit was design to test a bug fix during generation of the A matrix where the C matrix didn’t get included if there was only one unknown current.\nnet_list = '''\nI1 1 0 1 \nR1 1 0 0.05\nL1 1 2 0.025\nC1 2 0 0.25\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_14.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "44  Test 14",
    "section": "44.2 Call the symbolic modified nodal analysis function",
    "text": "44.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{L1} + \\frac{v_{1}}{R_{1}} = - I_{1}\\)\\(C_{1} s v_{2} - I_{L1} = 0\\)\\(- I_{L1} L_{1} s + v_{1} - v_{2} = 0\\)\n\n\n\n44.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 4\nnumber of branches: 4\nnumber of nodes: 2\nnumber of unknown currents: 1\nnumber of RLC (passive components): 3\nnumber of inductors: 1\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n44.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{1}} & 0 & 1\\\\0 & C_{1} s & -1\\\\1 & -1 & - L_{1} s\\end{matrix}\\right]\\)\n\n\n\n\n44.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  I_{L1}\\right]\\)\n\n\n\n\n44.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1}, \\  0, \\  0\\right]\\)\n\n\n\n\n44.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nI1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n1\n0\nNaN\nNaN\nNaN\n0.05\nNaN\nNaN\nNaN\n\n\n2\nL1\n1\n2\nNaN\nNaN\nNaN\n0.025\nNaN\nNaN\nNaN\n\n\n3\nC1\n2\n0\nNaN\nNaN\nNaN\n0.25\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n44.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nL1\n1\n2\n\n\n\n\n\n\n\n\n\n44.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( L_{1}, \\  I_{1}, \\  v_{2}, \\  R_{1}, \\  I_{L1}, \\  v_{1}, \\  C_{1}, \\  s\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#symbolic-solution",
    "href": "test_14.html#symbolic-solution",
    "title": "44  Test 14",
    "section": "44.3 Symbolic solution",
    "text": "44.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C_{1} I_{1} L_{1} R_{1} s^{2} - I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)\\(v_{2} = - \\frac{I_{1} R_{1}}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)\\(I_{L1} = - \\frac{C_{1} I_{1} R_{1} s}{C_{1} L_{1} s^{2} + C_{1} R_{1} s + 1}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#construct-a-dictionary-of-element-values",
    "href": "test_14.html#construct-a-dictionary-of-element-values",
    "title": "44  Test 14",
    "section": "44.4 Construct a dictionary of element values",
    "text": "44.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nI1 = 1.0\nR1 = 0.05\nL1 = 0.025\nC1 = 0.25",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_14.html#dc-operating-point",
    "href": "test_14.html#dc-operating-point",
    "title": "44  Test 14",
    "section": "44.5 DC operating point",
    "text": "44.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = I_{L1} + 20.0 v_{1}\\)\\(0 = - I_{L1}\\)\\(0 = v_{1} - v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1         -0.050000\nv2         -0.050000\nI_L1        0.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -0.05   voltage\nV(2):    -0.05   voltage\nI(C1):   -1.25e-14   device_current\nI(L1):   -1.24345e-14    device_current\nI(I1):   1   device_current\nI(R1):   -1  device_current\n\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n44.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = I_{L1} + 20.0 v_{1}\\)\\(0 = - I_{L1} + 0.25 i v_{2}\\)\\(0 = - 0.025 i I_{L1} + v_{1} - v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         0.049996    179.279336\nv2         0.050310    179.279336\nI_L1       0.012578    -90.720664\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:   0.049996 phase:    179.279°  voltage\nV(2):   mag:  0.0503105 phase:    179.279°  voltage\nI(C1):  mag:  0.0125776 phase:   -90.7207°  device_current\nI(L1):  mag:  0.0125776 phase:   -90.7207°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.999921 phase:    179.279°  device_current\n\n\n\n44.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = I_{L1} + 20.0 v_{1}\\)\\(0 = - I_{L1} + 0.25 s v_{2}\\)\\(0 = - 0.025 I_{L1} s + v_{1} - v_{2}\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n44.5.3 Plot the voltage at node 2\n\nH = U_ac[v2]\n\n\nH\n\n\\(\\displaystyle - \\frac{8.0}{s^{2} + 2.0 s + 160.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_14.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2)[0:-1]),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.unwrap(2*np.angle(V_2)[0:-1]/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(V_2[0:-1]) - 10**(mag/20),'-k')\n#plt.semilogx(frequency[0:-1], 20*np.log10(np.abs(V_2[0:-1]))-mag,'-k')\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_2[0:-1])*180/np.pi-phase,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results have small error, but not to the same precision as in previous tests.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Test 14</span>"
    ]
  },
  {
    "objectID": "test_15.html",
    "href": "test_15.html",
    "title": "45  Test 15",
    "section": "",
    "text": "45.1 Load the net list\nThe circuit in Figure 45.1 has no unknown current sources. The Python code generates the following empty matrices: B, C, D, J, Ev.\nnet_list = '''\nI1 1 0 1\nR1 1 0 10\nR2 2 1 10\nR3 3 2 1000\nC1 2 0 0.01\nC2 3 0 0.002\n'''",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "test_15.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "45  Test 15",
    "section": "45.2 Call the symbolic modified nodal analysis function",
    "text": "45.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = SymMNA.smna(net_list)\n\nDisplay the equations\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(v_{1} \\cdot \\left(\\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{2}}{R_{2}} = - I_{1}\\)\\(v_{2} \\left(C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{3}}{R_{3}} - \\frac{v_{1}}{R_{2}} = 0\\)\\(v_{3} \\left(C_{2} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{2}}{R_{3}} = 0\\)\n\n\n\n45.2.1 Netlist statistics\n\nprint(report)\n\nNet list report\nnumber of lines in netlist: 6\nnumber of branches: 6\nnumber of nodes: 3\nnumber of unknown currents: 0\nnumber of RLC (passive components): 5\nnumber of inductors: 0\nnumber of independent voltage sources: 0\nnumber of independent current sources: 1\nnumber of Op Amps: 0\nnumber of E - VCVS: 0\nnumber of G - VCCS: 0\nnumber of F - CCCS: 0\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\n\n\n45.2.2 Connectivity Matrix\n\nA\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{1}{R_{2}} + \\frac{1}{R_{1}} & - \\frac{1}{R_{2}} & 0\\\\- \\frac{1}{R_{2}} & C_{1} s + \\frac{1}{R_{3}} + \\frac{1}{R_{2}} & - \\frac{1}{R_{3}}\\\\0 & - \\frac{1}{R_{3}} & C_{2} s + \\frac{1}{R_{3}}\\end{matrix}\\right]\\)\n\n\n\n\n45.2.3 Unknown voltages and currents\n\nX\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}\\right]\\)\n\n\n\n\n45.2.4 Known voltages and currents\n\nZ\n\n\\(\\displaystyle \\left[ - I_{1}, \\  0, \\  0\\right]\\)\n\n\n\n\n45.2.5 Network dataframe\n\nnetwork_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nI1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nR1\n1\n0\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n1\nNaN\nNaN\nNaN\n10.0\nNaN\nNaN\nNaN\n\n\n3\nR3\n3\n2\nNaN\nNaN\nNaN\n1000.0\nNaN\nNaN\nNaN\n\n\n4\nC1\n2\n0\nNaN\nNaN\nNaN\n0.01\nNaN\nNaN\nNaN\n\n\n5\nC2\n3\n0\nNaN\nNaN\nNaN\n0.002\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n45.2.6 Unknown current dataframe\n\ni_unk_df\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n\n\n\n\n\n\n\n45.2.7 Build the network equations\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\nTurn the free symbols into SymPy variables.\n\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( v_{2}, \\  R_{1}, \\  R_{2}, \\  s, \\  I_{1}, \\  v_{1}, \\  R_{3}, \\  C_{2}, \\  C_{1}, \\  v_{3}\\right)\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#symbolic-solution",
    "href": "test_15.html#symbolic-solution",
    "title": "45  Test 15",
    "section": "45.3 Symbolic solution",
    "text": "45.3 Symbolic solution\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = \\frac{- C_{1} C_{2} I_{1} R_{1} R_{2} R_{3} s^{2} - C_{1} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{2} s - C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)\\(v_{2} = \\frac{- C_{2} I_{1} R_{1} R_{3} s - I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)\\(v_{3} = - \\frac{I_{1} R_{1}}{C_{1} C_{2} R_{1} R_{3} s^{2} + C_{1} C_{2} R_{2} R_{3} s^{2} + C_{1} R_{1} s + C_{1} R_{2} s + C_{2} R_{1} s + C_{2} R_{2} s + C_{2} R_{3} s + 1}\\)",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#construct-a-dictionary-of-element-values",
    "href": "test_15.html#construct-a-dictionary-of-element-values",
    "title": "45  Test 15",
    "section": "45.4 Construct a dictionary of element values",
    "text": "45.4 Construct a dictionary of element values\n\nelement_values = SymMNA.get_part_values(network_df)\n\n# display the component values\nfor k,v in element_values.items():\n    print('{:s} = {:s}'.format(str(k), str(v)))\n\nI1 = 1.0\nR1 = 10.0\nR2 = 10.0\nR3 = 1000.0\nC1 = 0.01\nC2 = 0.002",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "test_15.html#dc-operating-point",
    "href": "test_15.html#dc-operating-point",
    "title": "45  Test 15",
    "section": "45.5 DC operating point",
    "text": "45.5 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = 0.2 v_{1} - 0.1 v_{2}\\)\\(0 = - 0.1 v_{1} + 0.101 v_{2} - 0.001 v_{3}\\)\\(0 = - 0.001 v_{2} + 0.001 v_{3}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown           mag\n---------  ----------\nv1         -10.000000\nv2         -10.000000\nv3         -10.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    -10     voltage\nV(2):    -10     voltage\nV(3):    -10     voltage\nI(C1):   -1e-13  device_current\nI(C2):   -2e-14  device_current\nI(I1):   1   device_current\nI(R1):   -1  device_current\nI(R2):   1.20082e-13     device_current\nI(R3):   2e-14   device_current\n\nThe results from LTSpice are slightly different in some cases starting at the 2nd decimal place.\n\n45.5.1 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j. V1 is the AC source, magnitude of 10\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = 0.2 v_{1} - 0.1 v_{2}\\)\\(0 = - 0.1 v_{1} + v_{2} \\cdot \\left(0.101 + 0.01 i\\right) - 0.001 v_{3}\\)\\(0 = - 0.001 v_{2} + v_{3} \\cdot \\left(0.001 + 0.002 i\\right)\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\nSix significant digits are displayed so that results can be compared to LTSpice.\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         9.771261    174.320654\nv2         9.642525    168.430028\nv3         4.312268    104.995079\n\n\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    9.77126 phase:    174.321°  voltage\nV(2):   mag:    9.64252 phase:     168.43°  voltage\nV(3):   mag:    4.31227 phase:    104.995°  voltage\nI(C1):  mag:  0.0964252 phase:    -101.57°  device_current\nI(C2):  mag: 0.00862454 phase:   -165.005°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(R1):  mag:   0.977126 phase:    174.321°  device_current\nI(R2):  mag:   0.100579 phase:    74.0313°  device_current\nI(R3):  mag: 0.00862454 phase:    14.9951°  device_current\n\n\n\n\n45.5.2 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\n\nNE = NE_sym.subs(element_values)\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE.rhs[i]),latex(NE.lhs[i]))\n\nMarkdown(temp)\n\n\\(-1.0 = 0.2 v_{1} - 0.1 v_{2}\\)\\(0 = - 0.1 v_{1} + v_{2} \\cdot \\left(0.01 s + 0.101\\right) - 0.001 v_{3}\\)\\(0 = - 0.001 v_{2} + v_{3} \\cdot \\left(0.002 s + 0.001\\right)\\)\n\n\nSolve for voltages and currents.\n\nU_ac = solve(NE,X)\n\n\n\n45.5.3 Plot the voltage at node 3\n\nH = U_ac[v3]\nH\n\n\\(\\displaystyle - \\frac{250.0}{10.0 s^{2} + 56.0 s + 25.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem = (a, b)\n\n\nx = np.logspace(-2, 2, 400, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(system, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nfn = 'test_15.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',',skip_header=1)\n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nV_1 = np.zeros(len(LTSpice_data)).astype(complex)\nV_2 = np.zeros(len(LTSpice_data)).astype(complex)\nV_3 = np.zeros(len(LTSpice_data)).astype(complex)\n\n\n# convert the csv data to complex numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    V_1[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n    V_2[i] = LTSpice_data[i][3] + LTSpice_data[i][4]*1j\n    V_3[i] = LTSpice_data[i][5] + LTSpice_data[i][6]*1j\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the phase plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(V_3)),'-r')    # Bode magnitude plot\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.unwrap(2*np.angle(V_3)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude difference')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency[0:-1], np.abs(V_3[0:-1])-10**(mag/20),'-k')    # Bode magnitude plot\n#plt.semilogx(w/(2*np.pi), mag_v3,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency[0:-1], np.angle(V_3[0:-1])*180/np.pi-phase,':',color=color,label='phase')  # Bode phase plot\n#plt.semilogx(w/(2*np.pi), phase_v3,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase difference, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('Difference between LTSpice and Python results')\nplt.show()\n\n\n\n\n\n\n\n\nThe SymPy and LTSpice results overlay each other. The scale for the magnitude is \\(10^{-14}\\) and \\(10^{-13}\\) for the phase indicating the numerical difference is very small.",
    "crumbs": [
      "Validation Tests",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Test 15</span>"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "References",
    "section": "",
    "text": "Akbaba, Mehmet, Omar Dakkak, Byung-Seo Kim, Adnan Cora, and Shahrudin\nAwang Nor. 2022. “Electric Circuit-Based Modeling and Analysis of\nthe Translational, Rotational Mechanical and Electromechanical Systems\nDynamics.” IEEE Access. https://doi.org/10.1109/ACCESS.2022.3185422.\n\n\nAntoniou, Andreas. 1969. “Realization of Gyrators Using\nOperational Amplifiers and Their Use in RC-Active-Network\nSynthesis.” In. https://api.semanticscholar.org/CorpusID:64381922.\n\n\nBasso, Christophe. 2016. “Introduction to Fast Analytical\nTechniques: Application to Small-Signal Modeling.” 2016. https://www.powersimtof.com/Downloads/PPTs/Chris%20Basso%20APEC%20seminar%202016.pdf.\n\n\nBruton, L. 1978. “Multiple-Amplifier RC-Active Filter Design with\nEmphasis on GIC Realizations (Invited Paper).” IEEE\nTransactions on Circuits and Systems.\n\n\nBudak, A. 1974. Passive and Active Network Analysis and\nSynthesis. Houghton Mifflin.\n\n\nCheever, E. 2022. “Linear Physical Systems Analysis.” https://lpsa.swarthmore.edu/LPSAHelp/LPSA_HelpAll.html#Welcome.\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The\nCircuits and Filters Handbook, 3rd Edition. CRC Press. https://www.gbv.de/dms/ilmenau/toc/585302871.PDF.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of\nAnalog Circuits Through Symbolic Analysis. https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis.\n\n\nFranc. 2023. “User Profile.” https://electronics.stackexchange.com/users/347817/franc?tab=profile.\n\n\nFranco, Sergio. 2002. Design with Operational Amplifiers and Analog\nIntegrated Circuits, 3rd Edition. McGraw-Hill.\n\n\nGinzton, E. L., W. R. Hewlett, J. H. Jasberg, and J. D. Noe. 1948.\n“Distributed Amplification.” Proceedings of the\nIRE 36 (8): 956–69. https://doi.org/10.1109/JRPROC.1948.231624.\n\n\nHayes, M. 2022. “Lcapy: Symbolic Linear Circuit Analysis with\nPython.” https://doi.org/10.7717/peerj-cs.875.\n\n\nHayt, W., and J. Kemmerly. 1978. Engineering Circuit Analysis, 3rd\nEdition. McGraw-Hill.\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal\nApproach to Network Analysis.” IEEE Transactions on Circuits\nand Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.\n\n\nJohnson, D., J. Hilburn, and J. Johnson. 1978. Basic Electric\nCircuit Analysis. Prentice-Hall, Inc.\n\n\nLees, Andrew. 2023. “Solution of Electrical Network Where\nArbitrary Initial Conditions Cannot Be Assigned.” 2023. https://electronics.stackexchange.com/questions/682634/solution-of-electrical-network-where-arbitrary-initial-conditions-cannot-be-assi.\n\n\nMalek, Ihdene. 2020. “Eliminating Ideal Voltage Source for Node\nAnalysis.” Electrical Engineering Stack Exchange. https://electronics.stackexchange.com/q/479528.\n\n\nMarki Microwave. 2025. “LC Filter Design Tool.” Marki\nMicrowave. 2025. https://markimicrowave.com/technical-resources/tools/lc-filter-design-tool/.\n\n\nMiddlebrook, R. D. 1991. “Low-Entropy Expressions: The Key to\nDesign-Oriented Analysis.” In Proceedings Frontiers in\nEducation Twenty-First Annual Conference. Engineering Education in a New\nWorld Order, 399–403. https://doi.org/10.1109/FIE.1991.187513.\n\n\n———. 1992. “Methods of Design-Oriented Analysis: The Quadratic\nEquation Revisited.” In Proceedings. Twenty-Second Annual\nConference Frontiers in Education, 95–102. https://doi.org/10.1109/FIE.1992.683365.\n\n\nMiddlebrook, R. D., V. Vorperian, and J. Lindal. 1998. “The n\nExtra Element Theorem.” IEEE Transactions on Circuits and\nSystems I: Fundamental Theory and Applications 45 (9): 919–35. https://doi.org/10.1109/81.721258.\n\n\nPalusinski, O. 2005. “Automatic Formulation of Circuit\nEquations.” https://www2.engr.arizona.edu/~ece570/session3.pdf.\n\n\nParamesh, Jeyanandh, and David J. Allstot. 2006. “Analysis of the\nBridged t-Coil Circuit Using the Extra-Element Theorem.” IEEE\nTransactions on Circuits and Systems II: Express Briefs 53 (12):\n1408–12. https://doi.org/10.1109/TCSII.2006.885971.\n\n\nPress, W. 1992. Numerical Recipes in c: The Art of Scientific\nComputing. Numerical Recipes in c Book Set. Cambridge University\nPress.\n\n\nRazavi, Behzad. 2015. “The Bridged t-Coil [a Circuit for All\nSeasons].” IEEE Solid-State Circuits Magazine 7 (4):\n9–13. https://doi.org/10.1109/MSSC.2015.2474258.\n\n\nRoss, Bob. 2011. “T-Coils and Bridged-t Networks.” 2011. https://ibis.org/summits/may11/ross2.pdf.\n\n\nRoss, Bob, and Cong Ling. 2022. “Wang Algebra: From Theory to\nPractice.” IEEE Open Journal of Circuits and Systems 3:\n274–85. https://doi.org/10.1109/OJCAS.2022.3217065.\n\n\nSedra, A., and J. Espinoza. 1975. “Sensitivity and Frequency\nLimitations of Biquadratic Active Filters.” IEEE Transactions\non Circuits and Systems.\n\n\nShekhar, S., J. S. Walling, and D. J. Allstot. 2006. “Bandwidth\nExtension Techniques for CMOS Amplifiers.” IEEE Journal of\nSolid-State Circuits 41 (11): 2424–39. https://doi.org/10.1109/JSSC.2006.883336.\n\n\nStout, D. 1976. Handbook of Operational Amplifier Circuit\nDesign. McGraw-Hill.\n\n\nTow, J. 1968. “Active RC Filters a State-Space\nRealization.” Proceedings of the IEEE 56 (6): 1137–39.\nhttps://doi.org/10.1109/PROC.1968.6502.\n\n\nuser15174. 2023. “How to Find Transfer Function for This Pi-Filter\nUsing FACTS Method with 6 Reactive Elements?” https://electronics.stackexchange.com/questions/681002/how-to-find-transfer-function-for-this-pi-filter-using-facts-method-with-6-react/681087#681087.\n\n\nuser349644. 2023. “Transfer Function of the Below Circuit.”\nhttps://electronics.stackexchange.com/questions/682389/transfer-function-of-the-below-circuit.\n\n\nVorpérian, Vatché. 2002. Fast Analytical Techniques for Electrical\nand Electronic Circuits. Cambridge University Press. https://www.cambridge.org/core/books/fast-analytical-techniques-for-electrical-and-electronic-circuits/17845BA88A05A1645A8409D6739A475A#fndtn-information.\n\n\nWang, K. T. 1934. “On a New Method of Analysis of Electrical\nNetworks.” Memoirs 2, Nat. Res. Inst. Eng. Academia Sinica,\nPp. 1-11, 1934.\n\n\nWilliams, A., and F. Taylor. 1995. Electronic Filter Design\nHandbook, Third Edition. McGraw-Hill Education.\n\n\nWilliams, J. 1991. Analog Circuit Design: Art, Science and\nPersonalities. EDN Series for Design Engineers. Elsevier Science.\n\n\nZverev, A. 1967. Handbook of Filter Synthesis. John Wiley &\nSons.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "SymMNA_py.html",
    "href": "SymMNA_py.html",
    "title": "Appendix A — SymMNA.py",
    "section": "",
    "text": "The code listing below is for the Python functions that implement the MNA algorithm.\n\"\"\"Symbolic modified nodal analysis\nLast update: 29 Jun 2024\n\nDescription:\nThe modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear \ncircuit analysis.\n\nMy code started initially by following Erik Cheever's Analysis of Resistive Circuits [1], which used Matlab code \nto generate modified nodal equations. I somewhat followed his MATLAB file for resistors, capacitors, Op Amps and independent sources. \nThe naming of the matrices follows his convention. The preprocessor and parser code was converted from my old C code. \nThe use of pandas for a data frame is new and SymPy is used to do the math and the use of element \nstamps are from [2].\n\nInductors are being addressed in the D matrix. Erik's code puts inductors into the G matrix as 1/s/L.  \nMy code puts the inductor contribution into the D matrix and the unknown current from the inductor into \nthe B and C matrices.  Coupled inductors also affect the D matrix, so it makes sense to allow the inductors \nto be in the D matrix rather than the G matrix.\n\nReferences:\n1. [Analysis of  Resistive Circuits](http://www.swarthmore.edu/NatSci/echeeve1/Ref/mna/MNA1.html), retrieved October 6, 2017  \n2. [ECE 570 Session 3](http://www2.engr.arizona.edu/~ece570/session3.pdf), Computer Aided Engineering for Integrated Circuits, retrieved November 13, 2023  \n\nReferences use in the debugging of the Op Amp stamp:   \n3. [Design of Analog Circuits Through Symbolic Analysis](https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis) edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fernandez, retrieved June29, 2024 \n4. [Computer Aided Design and Design Automation](https://www.gbv.de/dms/ilmenau/toc/585302871.PDF), edited by Wai-Kai Chen, retrieved June 29, 2024\n\nExample usage:  See SMNA_func_test.py\n\"\"\"\n\nfrom sympy import *\nimport numpy as np\nimport pandas as pd\n\ndef get_part_values(net_df):\n    \"\"\" construct a dictionary of element values from the netlist dataframe: value_dict, get_part_values\n    Parameters\n    ----------\n    net_df: pandas dataframe\n        the network dataframe returned by the smna function below\n    Returns\n    -------\n    element values: Python dictionary\n        the element values from the netlist\n    \"\"\"\n\n    # initialize variables\n    element_value_keys = []\n    element_value_values = []\n\n    for i in range(len(net_df)):\n        if net_df.iloc[i]['element'][0] == 'F' or net_df.iloc[i]['element'][0] == 'E' or net_df.iloc[i]['element'][0] == 'G' or net_df.iloc[i]['element'][0] == 'H':\n            element_value_keys.append(var(net_df.iloc[i]['element'].lower()))\n            element_value_values.append(net_df.iloc[i]['value'])\n        else:\n            element_value_keys.append(var(net_df.iloc[i]['element']))\n            element_value_values.append(net_df.iloc[i]['value'])\n\n    return dict(zip(element_value_keys, element_value_values))\n\ndef smna(net_list):\n    \"\"\"Symbolic modified nodal analysis\n    Parameters\n    ----------\n    net_list: str\n        The circuit net list, needs a \\n at the end of each line\n    Returns\n    -------\n    report: text string\n            The net list report.\n    df: pandas dataframe\n            circuit net list info loaded into a dataframe\n    df2: pandas dataframe\n            branches with unknown currents\n    A: SymPy matrix\n            The A matrix is (m+n) by (m+n) and is the combination of 4 smaller matrices, G, B, C, and D.\n            The G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections\n            between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, \n            where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage \n            sources, current controlling elements, etc. In Python row and columns are: G[row, column]\n            The B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes\n            and m is the number of current unknowns, i_unk. There is one column for each unknown current.\n            The code loop through all the branches and process elements that have stamps for the B matrix: \n            The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).\n            The code is similar to the B matrix code, except the indices are swapped. The code loops through \n            all the branches and process elements that have stamps for the C matrix: \n            The D matrix is an m by m matrix, where m is the number of unknown currents. \n    X: list\n            The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages \n            and the currents through the independent voltage sources). The top n elements are the n node \n            voltages. The bottom m elements represent the currents through the m independent voltage \n            sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix \n            is m by 1 and holds the unknown currents through the voltage sources\n    Z: list\n            The Z matrix holds the independent voltage and current sources and is the combination\n            of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, \n            and m is the number of independent voltage sources. The I matrix is n by 1 and contains \n            the sum of the currents through the passive elements into the corresponding node (either \n            zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the \n            values of the independent voltage sources.\n    \"\"\"\n\n    # initialize variables\n    num_rlc = 0 # number of passive elements\n    num_res = 0 # number of resistors\n    num_cap = 0 # number of capacitors\n    num_ind = 0 # number of inductors\n    num_v = 0    # number of independent voltage sources\n    num_i = 0    # number of independent current sources\n    i_unk = 0  # number of current unknowns\n    num_opamps = 0   # number of Op Amps\n    num_vcvs = 0     # number of controlled sources of various types\n    num_vccs = 0\n    num_cccs = 0\n    num_ccvs = 0\n    num_cpld_ind = 0 # number of coupled inductors\n\n    content = net_list.splitlines()\n\n    content = [x.strip() for x in content]  #remove leading and trailing white space\n    # remove empty lines\n    while '' in content:\n        content.pop(content.index(''))\n\n    # remove comment lines, these start with a asterisk *\n    content = [n for n in content if not n.startswith('*')]\n    # remove other comment lines, these start with a semicolon ;\n    content = [n for n in content if not n.startswith(';')]\n    # remove spice directives, these start with a period, .\n    content = [n for n in content if not n.startswith('.')]\n    # converts 1st letter to upper case\n    #content = [x.upper() for x in content] &lt;- this converts all to upper case\n    content = [x.capitalize() for x in content]\n    # removes extra spaces between entries\n    content = [' '.join(x.split()) for x in content]\n\n    line_cnt = len(content) # number of lines in the netlist\n    branch_cnt = 0  # number of branches in the netlist\n    # check number of entries on each line, count each element type\n    for i in range(line_cnt):\n        x = content[i][0]\n        tk_cnt = len(content[i].split()) # split the line into a list of words\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_rlc += 1\n            branch_cnt += 1\n            if x == 'R':\n                num_res += 1            \n            if x == 'C':\n                num_cap += 1            \n            if x == 'L':\n                num_ind += 1\n        elif x == 'V':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_v += 1\n            branch_cnt += 1\n        elif x == 'I':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_i += 1\n            branch_cnt += 1\n        elif x == 'O':\n            if tk_cnt != 4:\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_opamps += 1\n        elif x == 'E':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vcvs += 1\n            branch_cnt += 1\n        elif x == 'G':\n            if (tk_cnt != 6):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 6\".format(tk_cnt))\n            num_vccs += 1\n            branch_cnt += 1\n        elif x == 'F':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_cccs += 1\n            branch_cnt += 1\n        elif x == 'H':\n            if (tk_cnt != 5):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 5\".format(tk_cnt))\n            num_ccvs += 1\n            branch_cnt += 1\n        elif x == 'K':\n            if (tk_cnt != 4):\n                raise Exception(\"branch {:d} not formatted correctly, {:s} \".format(i,content[i]),\n                \"had {:d} items and should only be 4\".format(tk_cnt))\n            num_cpld_ind += 1\n        else:\n            raise Exception(\"unknown element type in branch {:d}: {:s}\".format(i,content[i]))\n\n\n    ''' The parser performs the following operations.\n     1. puts branch elements into data frame  \n     2. counts number of nodes  \n\n     data frame labels:\n     - element: type of element  \n     - p node: positive node  \n     - n node: negative node, for a current source, the arrow point terminal, LTSpice \n     puts the inductor phasing dot on this terminal  \n     - cp node: controlling positive node of branch  \n     - cn node: controlling negative node of branch  \n     - Vout: Op Amp output node  \n     - value: value of element or voltage  \n     - Vname: voltage source through which the controlling current flows. Need to \n     add a zero volt voltage source to the controlling branch.  \n     - Lname1: name of coupled inductor 1  \n     - Lname2: name of coupled inductor 2'''  \n\n    # build the pandas data frame\n    df = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n        'Vout','value','Vname','Lname1','Lname2'])\n\n    # this data frame is for branches with unknown currents\n    df2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n    # ### Functions to load branch elements into data frame and check for gaps in node numbering\n\n    # loads voltage or current sources into branch structure\n    def indep_source(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads passive elements into branch structure\n    def rlc_element(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # loads multi-terminal elements into branch structure\n    # O - Op Amps\n    def opamp_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vout'] = int(tk[3])\n\n    # G - VCCS\n    def vccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # E - VCVS\n    # in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\n    def vcvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'cp node'] = int(tk[3])\n        df.loc[line_nu,'cn node'] = int(tk[4])\n        df.loc[line_nu,'value'] = float(tk[5])\n\n    # F - CCCS\n    def cccs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # H - CCVS\n    def ccvs_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'p node'] = int(tk[1])\n        df.loc[line_nu,'n node'] = int(tk[2])\n        df.loc[line_nu,'Vname'] = tk[3].capitalize()\n        df.loc[line_nu,'value'] = float(tk[4])\n\n    # K - Coupled inductors\n    def cpld_ind_sub_network(line_nu):\n        tk = content[line_nu].split()\n        df.loc[line_nu,'element'] = tk[0]\n        df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n        df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n        df.loc[line_nu,'value'] = float(tk[3])\n\n    # function to scan df and get largest node number\n    def count_nodes():\n        # need to check that nodes are consecutive\n        # fill array with node numbers\n        p = np.zeros(line_cnt+1)\n        for i in range(line_cnt):\n            # need to skip coupled inductor 'K' statements\n            if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n                p[df['p node'][i]] = df['p node'][i]\n                p[df['n node'][i]] = df['n node'][i]\n\n        # find the largest node number\n        if df['n node'].max() &gt; df['p node'].max():\n            largest = df['n node'].max()\n        else:\n            largest =  df['p node'].max()\n\n        largest = int(largest)\n        # check for unfilled elements, skip node 0\n        for i in range(1,largest):\n            if p[i] == 0:\n                raise Exception('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n        return largest\n\n    # load branch info into data frame\n    for i in range(line_cnt):\n        x = content[i][0]\n\n        if (x == 'R') or (x == 'L') or (x == 'C'):\n            rlc_element(i)\n        elif (x == 'V') or (x == 'I'):\n            indep_source(i)\n        elif x == 'O':\n            opamp_sub_network(i)\n        elif x == 'E':\n            vcvs_sub_network(i)\n        elif x == 'G':\n            vccs_sub_network(i)\n        elif x == 'F':\n            cccs_sub_network(i)\n        elif x == 'H':\n            ccvs_sub_network(i)\n        elif x == 'K':\n            cpld_ind_sub_network(i)\n        else:\n            raise Exception(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n    '''29 Nov 2023:  When the D matrix is built, independent voltage sources are processed\n    in the data frame order when building the D matrix. If the voltage source followed element\n    L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different\n    row in relation to its position in the Ev matrix. This would cause the node attached to \n    the terminal of the voltage source to be zero volts.  \n    Solution - The following block of code was added to move voltage source types to the \n    beginning of the net list dataframe before any calculations are performed.''' \n\n    # Check for position of voltage sources in the dataframe.\n    source_index = [] # keep track of voltage source row number\n    other_index = [] # make a list of all other types\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V'):\n            source_index.append(i)\n        else:\n            other_index.append(i)\n\n    df = df.reindex(source_index+other_index,copy=True) # reorder the data frame\n    df.reset_index(drop=True, inplace=True) # renumber the index\n\n    # count number of nodes\n    num_nodes = count_nodes()\n\n    # Build df2: consists of branches with current unknowns, used for C & D matrices\n    # walk through data frame and find these parameters\n    count = 0\n    for i in range(len(df)):\n        # process all the elements creating unknown currents\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n            df2.loc[count,'element'] = df.loc[i,'element']\n            df2.loc[count,'p node'] = df.loc[i,'p node']\n            df2.loc[count,'n node'] = df.loc[i,'n node']\n            count += 1\n\n    # print the netlist report\n    report = 'Net list report\\n'\n    report = report+('number of lines in netlist: {:d}\\n'.format(line_cnt))\n    report = report+'number of branches: {:d}\\n'.format(branch_cnt)\n    report = report+'number of nodes: {:d}\\n'.format(num_nodes)\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are current unknows\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\n    report = report+'number of unknown currents: {:d}\\n'.format(i_unk)\n    report = report+'number of RLC (passive components): {:d}\\n'.format(num_rlc)\n    report = report+'number of resistors: {:d}\\n'.format(num_res)    \n    report = report+'number of capacitors: {:d}\\n'.format(num_cap)    \n    report = report+'number of inductors: {:d}\\n'.format(num_ind)\n    report = report+'number of independent voltage sources: {:d}\\n'.format(num_v)\n    report = report+'number of independent current sources: {:d}\\n'.format(num_i)\n    report = report+'number of Op Amps: {:d}\\n'.format(num_opamps)\n    report = report+'number of E - VCVS: {:d}\\n'.format(num_vcvs)\n    report = report+'number of G - VCCS: {:d}\\n'.format(num_vccs)\n    report = report+'number of F - CCCS: {:d}\\n'.format(num_cccs)\n    report = report+'number of H - CCVS: {:d}\\n'.format(num_ccvs)\n    report = report+'number of K - Coupled inductors: {:d}\\n'.format(num_cpld_ind)\n\n    # initialize some symbolic matrix with zeros\n    # A is formed by [[G, C] [B, D]]\n    # Z = [I,E]\n    # X = [V, J]\n    V = zeros(num_nodes,1)\n    I = zeros(num_nodes,1)\n    G = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\n    s = Symbol('s')  # the Laplace variable\n\n    # count the number of element types that affect the size of the B, C, D, E and J arrays\n    # these are element types that have unknown currents\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    # if i_unk == 0, just generate empty arrays\n    B = zeros(num_nodes,i_unk)\n    C = zeros(i_unk,num_nodes)\n    D = zeros(i_unk,i_unk)\n    Ev = zeros(i_unk,1)\n    J = zeros(i_unk,1)\n\n    ''' The G matrix is n by n, where n is the number of nodes. \n    The matrix is formed by the interconnections between the resistors, \n    capacitors and VCCS type elements.  In the original paper G is called Yr, \n    where Yr is a reduced form of the nodal matrix excluding the contributions \n    due to voltage sources, current controlling elements, etc.  In Python row \n    and columns are: G[row, column]'''\n    for i in range(len(df)):  # process each row in the data frame\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node']\n        cn2 = df.loc[i,'cn node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'R':\n            g = 1/sympify(df.loc[i,'element'])\n        if x == 'C':\n            g = s*sympify(df.loc[i,'element'])\n        if x == 'G':   #vccs type element\n            g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n        if (x == 'R') or (x == 'C'):\n            # If neither side of the element is connected to ground\n            # then subtract it from the appropriate location in the matrix.\n            if (n1 != 0) and (n2 != 0):\n                G[n1-1,n2-1] += -g\n                G[n2-1,n1-1] += -g\n\n            # If node 1 is connected to ground, add element to diagonal of matrix\n            if n1 != 0:\n                G[n1-1,n1-1] += g\n\n            # same for for node 2\n            if n2 != 0:\n                G[n2-1,n2-1] += g\n\n        if x == 'G':    #vccs type element\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0 and cn1 != 0:\n                G[n1-1,cn1-1] += g\n\n            if n2 != 0 and cn2 != 0:\n                G[n2-1,cn2-1] += g\n\n            if n1 != 0 and cn2 != 0:\n                G[n1-1,cn2-1] -= g\n\n            if n2 != 0 and cn1 != 0:\n                G[n2-1,cn1-1] -= g\n\n    '''The B matrix is an n by m matrix with only 0, 1 and -1 elements, where \n    n = number of nodes and m is the number of current unknowns, i_unk. There is \n    one column for each unknown current. The code loop through all the branches \n    and process elements that have stamps for the B matrix:  \n     - Voltage sources (V)  \n     - Op Amps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)    \n\n    The order of the columns is as they appear in the netlist.  CCCS (F) does not get\n    its own column because the controlling current is through a zero volt voltage source,\n    called Vname and is already in the net list.'''\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'O':  # Op Amp type, output connection of the Op Amp goes in the B matrix\n            B[n_vout-1,sn] = 1\n            sn += 1   # increment source count\n        if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    B[n1-1,sn] = 1\n                if n2 != 0:\n                    B[n2-1,sn] = -1\n            else:\n                if n1 != 0:\n                    B[n1-1] = 1\n                if n2 != 0:\n                    B[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\n    ''' The C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources).  \n    The code is similar to the B matrix code, except the indices are swapped.   The code loops through \n    all the branches and process elements that have stamps for the C matrix:  \n     - Voltage sources (V)  \n     - Opamps (O)  \n     - CCVS (H)  \n     - CCCS (F)  \n     - VCVS (E)  \n     - Inductors (L)  \n\n     Op Amp elements\n     The Op Amp element is assumed to be an ideal Op Amp and use of this component is valid only when \n     used in circuits with a DC path (a short or a resistor) from the output terminal to the negative \n     input terminal of the Op Amp. No error checking is provided and if the condition is violated, \n     the results likely will be erroneous. See [3][4].   \n\n     Find the the column position in the C and D matrix for controlled sources\n     needs to return the node numbers and branch number of controlling branch'''\n    def find_vname(name):\n        # need to walk through data frame and find these parameters\n        for i in range(len(df2)):\n            # process all the elements creating unknown currents\n            if name == df2.loc[i,'element']:\n                n1 = df2.loc[i,'p node']\n                n2 = df2.loc[i,'n node']\n                return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n        raise Exception('failed to find matching branch element in find_vname')\n\n    # generate the C Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        cn2 = df.loc[i,'cn node']\n        n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n        # process elements with input to B matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, V\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n        if x == 'O':  # Op Amp type, input connections of the opamp go into the C matrix\n            # C[sn,n_vout-1] = 1\n            if i_unk &gt; 1:  #is B greater than 1 by n?, O\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   # increment source count\n\n        if x == 'F':  # need to count F (cccs) types\n            sn += 1   #increment source count\n        if x == 'H':  # H: ccvs\n            if i_unk &gt; 1:  #is B greater than 1 by n?, H\n                # check to see if any terminal is grounded\n                # then stamp the matrix\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n        if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n            if i_unk &gt; 1:  #is B greater than 1 by n?, E\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n                # add entry for cp and cn of the controlling voltage\n                if cn1 != 0:\n                    C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n                if cn2 != 0:\n                    C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n                vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n                if vn1 != 0:\n                    C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n                if vn2 != 0:\n                    C[vn2-1] = sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is B greater than 1 by n?, L\n                if n1 != 0:\n                    C[sn,n1-1] = 1\n                if n2 != 0:\n                    C[sn,n2-1] = -1\n            else:\n                if n1 != 0:\n                    C[n1-1] = 1\n                if n2 != 0:\n                    C[n2-1] = -1\n            sn += 1   #increment source count\n\n    # check source count\n    if sn != i_unk:\n        raise Exception('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\n    ''' The D matrix is an m by m matrix, where m is the number of unknown currents.  \n    m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n    Stamps that affect the D matrix are: inductor, ccvs and cccs  \n    inductors: minus sign added to keep current flow convention consistent  \n\n    Coupled inductors notes:  \n    Can the K statement be anywhere in the net list, even before Lx and Ly?   \n    12/6/2017 doing some debugging on with coupled inductors  \n    LTSpice seems to put the phasing dot on the neg node when it generates the netlist   \n    This code uses M for mutual inductance, LTSpice uses k for the coupling coefficient.'''  \n\n    # generate the D Matrix\n    sn = 0   # count source number as code walks through the data frame\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n        #cn2 = df.loc[i,'cn node']\n        #n_vout = df.loc[i,'Vout'] # node connected to Op Amp output\n\n        # process elements with input to D matrix\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n            sn += 1   #increment source count\n\n        if x == 'L':\n            if i_unk &gt; 1:  #is D greater than 1 by 1?\n                D[sn,sn] += -s*sympify(df.loc[i,'element'])\n            else:\n                D[sn] += -s*sympify(df.loc[i,'element'])\n            sn += 1   #increment source count\n\n        if x == 'H':  # H: ccvs\n            # if there is a H type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            sn += 1   #increment source count\n\n        if x == 'F':  # F: cccs\n            # if there is a F type, D is m by m\n            # need to find the vn for Vname\n            # then stamp the matrix\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n            D[sn,sn] = 1\n            sn += 1   #increment source count\n\n        if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n            # if there is a K type, D is m by m\n            vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n            vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n            # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n            D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n            D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n    ''' The V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.  \n    Maybe make small v's v_1 so as not to confuse v1 with V1.'''\n    # generate the V matrix\n    for i in range(num_nodes):\n        V[i] = sympify('v{:d}'.format(i+1))\n\n    ''' The J matrix is an m by 1 matrix, where m is the number of unknown currents.\n    i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n    The J matrix is an m by 1 matrix, with one entry for each i_unk from a source'''\n    for i in range(len(df2)):\n        # process all the unknown currents\n        J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\n    ''' The I matrix is an n by 1 matrix, where n is the number of nodes. The value\n    of each element of I is determined by the sum of current sources into the \n    corresponding node. If there are no current sources connected to the node, the value is zero.'''\n\n    # generate the I matrix, current sources have n2 = arrow end of the element\n    for i in range(len(df)):\n        n1 = df.loc[i,'p node']\n        n2 = df.loc[i,'n node']\n        # process all the passive elements, save conductance to temp value\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'I':\n            g = sympify(df.loc[i,'element'])\n            # sum the current into each node\n            if n1 != 0:\n                I[n1-1] -= g\n            if n2 != 0:\n                I[n2-1] += g\n\n    # The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n    sn = 0   # count source number\n    for i in range(len(df)):\n        # process all the passive elements\n        x = df.loc[i,'element'][0]   #get 1st letter of element name\n        if x == 'V':\n            Ev[sn] = sympify(df.loc[i,'element'])\n            sn += 1\n\n\n    ''' The Z matrix holds the independent voltage and current sources and is the combination of 2\n    smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the\n    number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents\n    through the passive elements into the corresponding node (either zero, or the sum of independent\n    current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.'''\n    Z = I[:] + Ev[:]  # the + operator in Python concatenates the lists\n\n\n    ''' The X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through\n    the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the\n    currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages.\n    The J matrix is m by 1 and holds the unknown currents through the voltage sources '''\n    X = V[:] + J[:]  # the + operator in Python concatenates the lists\n\n    # The A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n    n = num_nodes\n    m = i_unk\n    A = zeros(m+n,m+n)\n    for i in range(n):\n        for j in range(n):\n            A[i,j] = G[i,j]\n\n    if i_unk &gt; 1:\n        for i in range(n):\n            for j in range(m):\n                A[i,n+j] = B[i,j]\n                A[n+j,i] = C[j,i]\n\n        for i in range(m):\n            for j in range(m):\n                A[n+i,n+j] = D[i,j]\n\n    if i_unk == 1:\n        for i in range(n):\n            A[i,n] = B[i]\n            A[n,i] = C[i]\n        A[n,n] = D[0] # added 1/7/2024 while debugging source free circuit with one inductor\n\n    return report, df, df2, A, X, Z",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>SymMNA.py</span>"
    ]
  },
  {
    "objectID": "Change-log.html",
    "href": "Change-log.html",
    "title": "Appendix B — Change Log",
    "section": "",
    "text": "B.1 MNA Code Change History\nThe following table is a history of the Python MNA code development.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  },
  {
    "objectID": "Change-log.html#mna-code-change-history",
    "href": "Change-log.html#mna-code-change-history",
    "title": "Appendix B — Change Log",
    "section": "",
    "text": "Table B.1: Code change log\n\n\n\n\n\n\n\n\n\nDate\nEvent\n\n\n\n\n7/1/2015\nPython coding started, derived from my network.c code\n\n\n8/18/2017\nchanged approach, now implementing a modified nodal analysis\n\n\n8/19/2017\nWrote some code to generate symbolic matrices, works OK, so heading down the SymPy path. Basic debugging finished, but I still need to verify some circuits using Ls and Cs.\n\n\n8/30/2017\nStarted to add code for Op Amps\n\n\n9/1/2017\nCode added to process Op Amps\n\n\n9/3/2017\nAdded code to remove SPICE directives. Fixed orientation of current sources in the I matrix. N2 is the arrow end of the current source.\n\n\n9/5/2017\nAfter doing some verification testing with inductors and capacitors, it seems that inductors are not being treated correctly. According to some research, inductor stamps affect the B,C and D arrays. Erik Cheever’s code puts inductors into the G matrix as 1/s/L. LTSpice results are different from the Python code. Capacitors seem to work OK. Plan is to add controlled sources, then get inductors working.\n\n\n9/6/2017\nOp Amp_test_circuit_426 is not working. Results not the same as LTSpice Chebyshev_LPF_1dB_4pole: cut off frequency not correct, other features look OK still need to debug Op Amps and inductors Adding: VCCS = G type branch element: G needs to be modified CCVS = H type branch element: B, C and D need to be modified\n\n\n9/10/2017\nresearching formulation of B matrix what about a network with only 1 current source? The B, C and D matrix would be 0 by 0. Think about changing the name of the G matrix to Yr, to keep same as used in Ho, Ruehli, and Brennan (1975).CCVS = H type branch element: B, C and D need to be modifiedCCCS = F type branch element: B, C and D need to be modifiedVCCS = G type branch element: G needs to be modifiedVCVS = E type branch element: B and C need to be modifiedFor CCCS = F type branch elements and CCVS = H type branch elements, need to add a zero volt voltage source to the net list through which the current flows. It is necessary to add to the net list one extra voltage source for every F and H type element.\n\n\n9/12/2017\nstill working on the B matrix\n\n\n9/18/2017\nstill debugging B matrix, looks like we don’t need find_vname() or df2. This is because a zero volt voltage source is added to the netlist in SPICE. need to add CCCS type to the list of i_unk. Filled out some B matrices by hand and got the same answer as the code.\n\n\n9/30/2017\ndebugging B, C & D matricesVCVS is a E type element and SymPy didn’t like it, but fixed the problem in parser by changing the label E to Ea. Also changed the E matrix name to Ev. Code seems to run, just need to verify it. Need to find a new name for func1.\n\n\n10/1/2017\nCleaning up comments and notes.\n\n\n10/4/2017\nFixed incrementing of sn in D matrix. The D matrix needs to count all i_unks. In find_vnam() fixed col_num to return just the row number in df2.\n\n\n10/5/2017\nFixed E type in matrix C. Added CCCS to i_unk count. Fixed E type in D. Fixed J matrix. I need to look at the equations next, they don’t look correct.\n\n\n10/7/2017\nUpdates to the comments. Verifying equations with hand generated KCL equations. Fixed H type in D.\n\n\n10/9/2017\nStill verifying code. Fixed F type in C. Still need to verify Op Amps, inductors and capacitors.\n\n\n11/19/2017\nFixing some documentation.\n\n\n11/30/2017\nFixing the C matrix for Op Amps, one test case ran OKChen (2018) and Fakhfakh, Tlelo-Cuautle, and Fernandez (2012) were consulted during the debugging of the Op Amp stamp.\n\n\n12/2/2017\nAdded code for coupled inductors, not tested yet.\n\n\n12/6/2017\nTesting code for coupled inductors. Changes made to D matrix code. test_circuit_9 seems to give the correct results.\n\n\n18 Feb 2022\nNoticed a bug when the independent voltage source is the last line in the netlist, moving to the 1st line in the netlist generates what seems like correct equations. Investigation continues. For now, ordering the net list with sources first seems to work. Problem is with generation of the Ev and J matrices. In this version, I corrected some grammar and spelling errors.\n\n\n11/14/2023\nNew version of SymPy does not support non-Expr objects in a Matrix. Code to generate the circuit equations towards the end of the notebook produced an error. This line generated the error: \\(equ[i] = Eq(eq\\_temp,Z[i])\\). See the note here for details. In SymPy 1.8 and earlier versions it was possible to put non-Expr elements in a Matrix and the matrix elements could be any arbitrary Python object. Corrections have been made in this notebook. At the time of debugging this issue, I’m running sympy.__version__ = ‘1.11.1’\n\n\n29 Nov 2023\nProblem - When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.Solution - added code to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n\n1/9/2024\nCode for building matrix A was not including matrix D if i_unk == 1. The following line of code is new: \\(A[n,n] = D[0]\\) also with a comment. Added verification tests test_14 and test_15 for the case of i_unk == 1 and 0.\n\n\n1/16/2024\ncreated a function to implement SMNA, replaced warning print statements with raise Exception()\n\n\n7/31/2024\nadded code to count number of resistors and capacitors in network and include count in report",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  },
  {
    "objectID": "Change-log.html#book-change-history",
    "href": "Change-log.html#book-change-history",
    "title": "Appendix B — Change Log",
    "section": "B.2 Book Change History",
    "text": "B.2 Book Change History\nThe following table is a history of updates to the book project.\n\n\n\nTable B.2: Book project change log\n\n\n\n\n\n\n\n\n\nDate\nEvent\n\n\n\n\n9/1/2023\nAround this time, testing Quarto, started this book project\n\n\n12/1/2023\nAround this time, posting numerous test/draft versions to GitHub pages\n\n\n5/1/2024\nAdded chapter on mechanical system analog\n\n\n5/15/2024\nIncremental changes to many chapters\n\n\n6/03/2024\nIncremental updates\n\n\n6/30/2024\nSMNA_example - correcting spelling, grammar and updating comments.SymMNA - correcting spelling, grammar and updating comments.Introduction - added example circuit and schematic.references.bib - added url to two references.2nd_order_BRF - rewrite, now calling the smna function.Two Amplifier RIAA Pre-amp - correcting spelling, grammar and updating comments.Various chapters - displaying network equations using LaTex vs. printing a SymPy matrix.\n\n\n11/20/2024\nAdded: Future example problems, added reference to online tools for running Python and schematic capture (Google Colab and EasyEDA schematic editor).\n\n\n12/6/2024\nAdded Klon Centaur parts 2, 3 chapter place holders; see note at end of part 1. Added place holders for future chapters. The place holders will make pushing changes to github.io easier.Fixed broken link in Mechanical systems chapter.\n\n\n8/16/2025\nSciPy functions impulse2 and step2 changed to impulse and step because in SciPy 1.13.0 impulse2 and step2 were removed.Added appendix D and E.Updates to Klon Centaur Parts 1, 2 & 3.Updates to Chapter 2.Updates to About This Book and Gemini generated cover art.Added Wien Bridge Oscillator\n\n\n8/17/2025\nBridged T-coil (added out of cycle)\n\n\n12/20/2025\nArchive to Github prior to project re-org\n\n\n12/26/2025\n* Reorganized the project. Prior version archived with date 20_dec_2025 in book_backup folder.* Rewrite of Preface, Introduction* Changed About to Welcome with rewrite of index.qmd* Added chapters: Basic Concepts, Modified Nodal Analysis, SMNA Code, Resistive Networks, RLC Networks, Transfer Function, Transient Analysis, Mutual Inductance, Initial Conditions and History of Electric Circuit Analysis.* Removed chapters: Transient circuit, Transistor circuit, Boost converter, Phasor analysis* Added Table B.3.* Fixed outer loop index for calculation of inverse Laplace in Transient_analysis.ipynb.* Updates to state space narrative in state variable filter.* Moved validation tests to after example problems.* Updated Chapter 4 matrix generation description.* Updating numerious chapters to add clarification and fix typos.* Project updates now being pushed to GitHub pages by git.\n\n\n1/15/2026",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  },
  {
    "objectID": "Change-log.html#verification-of-embedded-links",
    "href": "Change-log.html#verification-of-embedded-links",
    "title": "Appendix B — Change Log",
    "section": "B.3 Verification of Embedded Links",
    "text": "B.3 Verification of Embedded Links\nThe following is a table of embedded links. External links can break and this table shows the last date accessed.\n\n\n\nTable B.3: Embedded links\n\n\n\n\n\n\n\n\n\n\nDocument\nInline Link\nLast Access\n\n\n\n\nindex.qmd\nPython\n9/25/2025\n\n\n\n\n\n\n\n\n\n\n\nChen, W. 2018. Computer Aided Design and Design Automation. The Circuits and Filters Handbook, 3rd Edition. CRC Press. https://www.gbv.de/dms/ilmenau/toc/585302871.PDF.\n\n\nFakhfakh, M., E. Tlelo-Cuautle, and F. Fernandez. 2012. Design of Analog Circuits Through Symbolic Analysis. https://www.researchgate.net/publication/230617925_Design_of_Analog_Circuits_through_Symbolic_Analysis.\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Change Log</span>"
    ]
  },
  {
    "objectID": "Google Colab.html",
    "href": "Google Colab.html",
    "title": "Appendix C — Google Colab",
    "section": "",
    "text": "Google’s Colab is a good choice for a web based tool that has a free tier and easy to use. Since it is web based, there is nothing to install. Colab can be used to run the Jupyter notebooks contained in this book. Colab can be useful to obtain symbolic solutions for large or complex networks that would take a long time to run on a typical home desktop or laptop. For example, in Chapter 16, obtaining a symbolic solution took a few seconds running in Colab, compared to several hours on my laptop.\nGoogle Colab (short for Google Colaboratory) is a free cloud service provided by Google that allows users to write and execute Python code in a browser-based environment. A gmail account is needed to run Colab. There is a free tier of service which is sutable for running the Jupyter notebooks in this book, however the computing enviroment is not saved between sessions. \nThe basic steps to open and run a Jupyter notebook are as follows:\n\nOpen colab at the url: https://colab.research.google.com/.\nUpload a Jupyter notebook from Google drive, github or local storage.\n\nOn the left hand side pane, select the file icon, then select upload to session storage, then upload SymMNA.py. This needs to be done at the beginning of each session.\n\nCells for qmd and some markdown commands are not supported, but they can be ignored. Links to images will not work and need to be inserted using the menu at the top of the text cell (these broken links for the images can also be ignored).\nColab creates a new folder in your Google drive called “Colab Notebooks”.\nThe Colab computing enviroment is not saved in the free tier.\n\nThere are alternatives to Colab such as Kaggle, Cocalc, GitHub Codespaces, Anaconda Cloud and Deepnote which can be used if the limitiations of Google’s free or paid tiers are not acceptable.\nGoogle Colab can be run on a mobile device such as a mobile phone. Appendix D is an example of a Jupyter notebook that can be uploaded to Colab and run to perform symbolic circuit analsys on a mobile device. Of course internet connectivity is required. The circuit shown in Figure E.1 is used in Appendix D.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Google Colab</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html",
    "href": "SMNA_mobile.html",
    "title": "Appendix D — SMNA Mobile",
    "section": "",
    "text": "D.1 Load the net list\nThis appendix is a template notebook for running SMNA using Google Colab on a mobile device, such as a phone. When using the free version of Colab, it’s somewhat inconvenient to import the SymMNA.py functions, so in this notebook these functions are inserted in line. Running a schematic capture program on a mobile phone is not very practical, so when analyzing new circuits, the netlist will need to be generated and intered by hand.\nThe file SymMNA.py was copied into the cell below. Click on the lable to expose the code.\nThe netlist can be exported from a schematic capture program or generated by hand. The input node is labled as node 1 and the output node is labled as node 2, but any node ordering is acceptable with adjustments to the code below.\nnet_list = '''\nR1 1 3 1\nR2 0 2 1\nL1 3 4 1\nL2 4 2 1\nC1 0 4 2\nV1 1 0 1\n'''",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#call-the-symbolic-modified-nodal-analysis-function",
    "href": "SMNA_mobile.html#call-the-symbolic-modified-nodal-analysis-function",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.2 Call the symbolic modified nodal analysis function",
    "text": "D.2 Call the symbolic modified nodal analysis function\n\nreport, network_df, i_unk_df, A, X, Z = smna(net_list)\n\nDisplay the MNA equations:\n\n# reform X and Z into Matrix type for printing\nXp = Matrix(X)\nZp = Matrix(Z)\ntemp = ''\nfor i in range(len(X)):\n    temp += '${:s}$&lt;br&gt;'.format(latex(Eq((A*Xp)[i:i+1][0],Zp[i])))\n\nMarkdown(temp)\n\n\\(I_{V1} + \\frac{v_{1}}{R_{1}} - \\frac{v_{3}}{R_{1}} = 0\\)\\(- I_{L2} + \\frac{v_{2}}{R_{2}} = 0\\)\\(I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{3}}{R_{1}} = 0\\)\\(C_{1} s v_{4} - I_{L1} + I_{L2} = 0\\)\\(v_{1} = V_{1}\\)\\(- I_{L1} L_{1} s + v_{3} - v_{4} = 0\\)\\(- I_{L2} L_{2} s - v_{2} + v_{4} = 0\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#build-the-network-equation-matrix",
    "href": "SMNA_mobile.html#build-the-network-equation-matrix",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.3 Build the network equation matrix",
    "text": "D.3 Build the network equation matrix\n\n# Put matrices into SymPy \nX = Matrix(X)\nZ = Matrix(Z)\n\nNE_sym = Eq(A*X,Z)\n\n\n# turn the free symbols into SymPy variables\nvar(str(NE_sym.free_symbols).replace('{','').replace('}',''))\n\n\\(\\displaystyle \\left( V_{1}, \\  C_{1}, \\  L_{2}, \\  R_{1}, \\  v_{4}, \\  v_{2}, \\  L_{1}, \\  R_{2}, \\  v_{3}, \\  s, \\  I_{L1}, \\  I_{L2}, \\  I_{V1}, \\  v_{1}\\right)\\)\n\n\nBuild a dictionary of element values:\n\nelement_values = get_part_values(network_df)\nelement_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 2.0, \\  L_{1} : 1.0, \\  L_{2} : 1.0, \\  R_{1} : 1.0, \\  R_{2} : 1.0, \\  V_{1} : 1.0\\right\\}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#symbolic-solution",
    "href": "SMNA_mobile.html#symbolic-solution",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.4 Symbolic solution",
    "text": "D.4 Symbolic solution\nThe network equations can be solved symbolically using the SymPy function, solve.\n\nU_sym = solve(NE_sym,X)\n\nDisplay the symbolic solution:\n\ntemp = ''\nfor i in U_sym.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U_sym[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = V_{1}\\)\\(v_{2} = \\frac{R_{2} V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(v_{3} = \\frac{C_{1} L_{1} L_{2} V_{1} s^{3} + C_{1} L_{1} R_{2} V_{1} s^{2} + L_{1} V_{1} s + L_{2} V_{1} s + R_{2} V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(v_{4} = \\frac{L_{2} V_{1} s + R_{2} V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(I_{V1} = \\frac{- C_{1} L_{2} V_{1} s^{2} - C_{1} R_{2} V_{1} s - V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(I_{L1} = \\frac{C_{1} L_{2} V_{1} s^{2} + C_{1} R_{2} V_{1} s + V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\\(I_{L2} = \\frac{V_{1}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#transfer-function",
    "href": "SMNA_mobile.html#transfer-function",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.5 Transfer function",
    "text": "D.5 Transfer function\nAssuming node 1 is the input source node and node 2 is the output node of the transfer function.\n\nH_sym = (U_sym[v2]/U_sym[v1]).nsimplify().simplify().expand().together()\nH_sym\n\n\\(\\displaystyle \\frac{R_{2}}{C_{1} L_{1} L_{2} s^{3} + C_{1} L_{1} R_{2} s^{2} + C_{1} L_{2} R_{1} s^{2} + C_{1} R_{1} R_{2} s + L_{1} s + L_{2} s + R_{1} + R_{2}}\\)\n\n\n\nH_sym_num, H_sym_denom = fraction(H_sym) #returns numerator and denominator\n\nSolve for the roon of the numerator.\n\nH_sym_num_roots = solve(H_sym_num,s)\n\nDisplay the first solution.\n\n#H_sym_num_roots[0]\n\nSolve for the roots of the denominator.\n\nH_sym_denom_roots = solve(H_sym_denom,s)\n\nDisplay the first solution.\n\nH_sym_denom_roots[0]\n\n\\(\\displaystyle - \\frac{\\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{2}}{L_{1}^{2} L_{2}^{2}} - \\frac{3 \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1} L_{2}}}{3 \\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{2}}{L_{1}^{2} L_{2}^{2}} - \\frac{3 \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1} L_{2}}\\right)^{3} + \\left(\\frac{2 \\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1}^{2} L_{2}^{2}}\\right)^{2}}}{2} + \\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{2 C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{2 C_{1} L_{1}^{2} L_{2}^{2}}}} - \\frac{\\sqrt[3]{\\frac{\\sqrt{- 4 \\left(\\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{2}}{L_{1}^{2} L_{2}^{2}} - \\frac{3 \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1} L_{2}}\\right)^{3} + \\left(\\frac{2 \\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{C_{1} L_{1}^{2} L_{2}^{2}}\\right)^{2}}}{2} + \\frac{\\left(L_{1} R_{2} + L_{2} R_{1}\\right)^{3}}{L_{1}^{3} L_{2}^{3}} + \\frac{27 \\left(R_{1} + R_{2}\\right)}{2 C_{1} L_{1} L_{2}} - \\frac{9 \\left(L_{1} R_{2} + L_{2} R_{1}\\right) \\left(C_{1} R_{1} R_{2} + L_{1} + L_{2}\\right)}{2 C_{1} L_{1}^{2} L_{2}^{2}}}}{3} - \\frac{L_{1} R_{2} + L_{2} R_{1}}{3 L_{1} L_{2}}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#numerical-solution",
    "href": "SMNA_mobile.html#numerical-solution",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.6 Numerical solution",
    "text": "D.6 Numerical solution\n\nNE = NE_sym.subs(element_values)\nU = solve(NE,X)\n\ntemp = ''\nfor i in U.keys():\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(i),latex(U[i]))\n\nMarkdown(temp)\n\n\\(v_{1} = 1.0\\)\\(v_{2} = \\frac{1}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(v_{3} = \\frac{2.0 s^{3} + 2.0 s^{2} + 2.0 s + 1.0}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(v_{4} = \\frac{1}{2.0 s^{2} + 2.0 s + 2.0}\\)\\(I_{V1} = \\frac{- 2.0 s^{2} - 2.0 s - 1.0}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(I_{L1} = \\frac{2.0 s^{2} + 2.0 s + 1.0}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)\\(I_{L2} = \\frac{1}{2.0 s^{3} + 4.0 s^{2} + 4.0 s + 2.0}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#dc-operating-point",
    "href": "SMNA_mobile.html#dc-operating-point",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.7 DC operating point",
    "text": "D.7 DC operating point\n\nNE = NE_sym.subs(element_values)\nNE_dc = NE.subs({s:0})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_dc.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_dc.rhs[i]),latex(NE_dc.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\)\\(0 = - I_{L2} + 1.0 v_{2}\\)\\(0 = I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\)\\(0 = - I_{L1} + I_{L2}\\)\\(1.0 = v_{1}\\)\\(0 = v_{3} - v_{4}\\)\\(0 = - v_{2} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_dc = solve(NE_dc,X)\n\nDisplay the numerical solution\n\ntable_header = ['unknown', 'mag']\ntable_row = []\n\nfor name, value in U_dc.items():\n    table_row.append([str(name),float(value)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f')))\n\nunknown          mag\n---------  ---------\nv1          1.000000\nv2          0.500000\nv3          0.500000\nv4          0.500000\nI_V1       -0.500000\nI_L1        0.500000\nI_L2        0.500000",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#ac-analysis",
    "href": "SMNA_mobile.html#ac-analysis",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.8 AC analysis",
    "text": "D.8 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\n# calculate Hz and radians\nomega = 1 # frequency in radians per second\nprint('omega of {:.1f} rad/sec = {:.3f} Hz'.format(omega,omega/(2*np.pi)))\n\nfreq = 1 # frequency in cycles per second, Hz\nprint('frequency of {:.1f} Hz = {:.3f} rad/sec'.format(freq,freq*2*np.pi))\n\nomega of 1.0 rad/sec = 0.159 Hz\nfrequency of 1.0 Hz = 6.283 rad/sec\n\n\n\nNE = NE_sym.subs(element_values)\nNE_w1 = NE.subs({s:1j})\n\nDisplay the equations with numeric values.\n\ntemp = ''\nfor i in range(shape(NE_w1.lhs)[0]):\n    temp += '${:s} = {:s}$&lt;br&gt;'.format(latex(NE_w1.rhs[i]),latex(NE_w1.lhs[i]))\n\nMarkdown(temp)\n\n\\(0 = I_{V1} + 1.0 v_{1} - 1.0 v_{3}\\)\\(0 = - I_{L2} + 1.0 v_{2}\\)\\(0 = I_{L1} - 1.0 v_{1} + 1.0 v_{3}\\)\\(0 = - I_{L1} + I_{L2} + 2.0 i v_{4}\\)\\(1.0 = v_{1}\\)\\(0 = - 1.0 i I_{L1} + v_{3} - v_{4}\\)\\(0 = - 1.0 i I_{L2} - v_{2} + v_{4}\\)\n\n\nSolve for voltages and currents.\n\nU_w1 = solve(NE_w1,X)\n\nDisplay the numerical solution\n\ntable_header = ['unknown', 'mag','phase, deg']\ntable_row = []\n\nfor name, value in U_w1.items():\n    table_row.append([str(name),float(abs(value)),float(arg(value)*180/np.pi)])\n\nprint(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal'),tablefmt=\"simple\",floatfmt=('5s','.6f','.6f')))\n\nunknown         mag    phase, deg\n---------  --------  ------------\nv1         1.000000      0.000000\nv2         0.353553   -135.000000\nv3         0.353553     45.000000\nv4         0.500000    -90.000000\nI_V1       0.790569    161.565051\nI_L1       0.790569    -18.434949\nI_L2       0.353553   -135.000000",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#transfer-function-1",
    "href": "SMNA_mobile.html#transfer-function-1",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.9 Transfer function",
    "text": "D.9 Transfer function\n\nH = (U[v2]/U[v1]).nsimplify().simplify().expand().together()\nH\n\n\\(\\displaystyle \\frac{1}{2 \\left(s^{3} + 2 s^{2} + 2 s + 1\\right)}\\)\n\n\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_num, H_denom = fraction(H) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(H_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(H_denom, s).all_coeffs(), dtype=float)\nsys = signal.TransferFunction(a,b)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#poles-and-zeros-of-the-transfer-function",
    "href": "SMNA_mobile.html#poles-and-zeros-of-the-transfer-function",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.10 Poles and zeros of the transfer function",
    "text": "D.10 Poles and zeros of the transfer function\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\nsys_zeros = np.roots(sys.num)\nsys_poles = np.roots(sys.den)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#pole-zero-plot",
    "href": "SMNA_mobile.html#pole-zero-plot",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.11 Pole zero plot",
    "text": "D.11 Pole zero plot\n\nplt.plot(np.real(sys_zeros), np.imag(sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(sys_poles), np.imag(sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=1)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(sys_zeros)))\nfor i in sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(sys_poles)))\nfor i in sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 3\n-0.16+0.00j Hz\n-0.08+0.14j Hz\n-0.08-0.14j Hz",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#bode-plot",
    "href": "SMNA_mobile.html#bode-plot",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.12 Bode plot",
    "text": "D.12 Bode plot\n\nx = np.logspace(-2, 1, 200, endpoint=False)*2*np.pi\nw, mag, phase = signal.bode(sys, w=x) # returns: rad/s, mag in dB, phase in deg\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Magnitude and phase response')\nplt.show()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "SMNA_mobile.html#impulse-and-step-response",
    "href": "SMNA_mobile.html#impulse-and-step-response",
    "title": "Appendix D — SMNA Mobile",
    "section": "D.13 Impulse and step response",
    "text": "D.13 Impulse and step response\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step(sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# show plot\nplt.show()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>SMNA Mobile</span>"
    ]
  },
  {
    "objectID": "EasyEDA_schematic_editor.html",
    "href": "EasyEDA_schematic_editor.html",
    "title": "Appendix E — EasyEDA",
    "section": "",
    "text": "Generating a netlist from a schematic can be facilitated by a schematic editor program. EasyEDA is an example of a web based schematic editor that is free and easy to use. Since it it web based, there is nothing to install.\nEasyEDA is an Electronic Design Automation (EDA) tool that enables hardware engineers to design, simulate, share - publicly and privately - and discuss schematics, simulations and printed circuit boards. EasyEDA allows the creation and editing of schematic diagrams, SPICE simulation of mixed analogue and digital circuits. A subscription-free membership is offered for public projects plus a limited number of private projects. The company is based in Shenzhen, China.\nA tutorial and User Guide is available that explains how to draw a schematic and export a netlist.\nThe schematic in Figure E.1 was drawn using using a web browser on EasyEDA.com. The nodes were labled with net ports and the ground node name was changed from “GND” to 0.\n\n\n\n\n\n\nFigure E.1: EasyEDA schematic\n\n\n\nThe LTSpice netlist for the schematic was exported with the command:\n/file/export Net List/LTSPice for This sheet\nto obtain the following netlist:\n** easyedaspiceNetlist **\nR1 1 3 1\nR2 0 2 1\nL1 3 4 1\nL2 4 2 1\nC1 0 4 2\nV1 1 0 1\n.tran 10m\nThe net list can be copied into a Jypyter Notebook to be analized as shown in Appendix D.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>EasyEDA</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html",
    "href": "History_of_Electric_Circuit_Analysis.html",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "",
    "text": "F.1 Ancient Understanding of Electricity and Magnetism\nStudying the history of science is essential because it reveals that scientific “truth” is not a static collection of facts, but a dynamic, self-correcting process of human discovery. By tracing the evolution of ideas - from the ancient belief in “vital souls” within magnets to the modern precision of quantum electrodynamics - we gain a deeper appreciation for the intellectual courage required to challenge prevailing dogmas.\nUnderstanding the historical context of discoveries allows us to see the “scaffolding” of modern technology; for instance, we cannot fully grasp the complexity of today’s global power grid without understanding the 19th-century debates between AC and DC power. Moreover, the history of science humanizes the field, showing that progress is often born from “productive failures,” accidents, and the diverse perspectives of global civilizations. It teaches us scientific literacy, reminding us that our current models are the best available explanations for now, but remain open to refinement by the next generation of thinkers.\nWhy the History of Science Matters\nWrite a paragraph describing ancient Greek, Roman Chinese etc. understanding of static electricity and magnetism.\nIn antiquity, civilizations across the Mediterranean and East Asia independently observed the “mysterious” attractions of static electricity and magnetism, often attributing these forces to natural spirits or the fundamental balance of the universe. The ancient Greeks, led by the philosopher Thales of Miletus around 600 BCE, noticed that rubbing amber (fossilized tree resin) with fur allowed it to attract light objects like feathers—a phenomenon they called the “amber effect.” Because the Greek word for amber is elektron, this observation eventually gave us the word electricity. Thales famously speculated that the amber and naturally magnetic rocks called lodestones (magnetite) possessed a “soul” or life-force because they could cause motion.\nWhile the Greeks and Romans largely viewed these phenomena through a philosophical lens, the ancient Chinese were the first to apply them technologically. By the Han Dynasty (206 BCE – 220 CE), Chinese scholars had described how lodestones could attract iron and noted that a suspended magnet would always align itself on a north-south axis. They conceptualized this as a response to the invisible flow of qi (energy) and created the world’s first compass: a lodestone spoon balanced on a bronze plate. Though initially used for divination and feng shui to align buildings with the Earth’s energy, by the Song Dynasty, they had developed magnetized needles for maritime navigation, a leap in understanding that wouldn’t reach Europe for centuries.\nWrite a paragraph describing medieval period understanding of static electricity and magnetism.\nIn the medieval period, the understanding of magnetism shifted from mystical wonder to practical science, while static electricity remained a poorly understood curiosity. The most significant advancement came from the 13th-century scholar Petrus Peregrinus de Maricourt, who wrote the Epistola de Magnete (1269), the first systematic European treatise on magnetism. Peregrinus was the first to use the term “poles” to describe the ends of a magnet and correctly identified the laws of attraction and repulsion—noting that like poles repel and opposite poles attract. He even experimented with breaking magnets, discovering that each piece became a new, complete magnet with its own poles. Despite this empirical progress, magnetic force was still often framed within a “vitalist” or “celestial” worldview; many believed magnets pointed north because they were “in love” with the Pole Star or influenced by celestial energy.\nStatic electricity, meanwhile, saw little theoretical development during the Middle Ages. It was largely distinguished from magnetism by the observation that amber had to be rubbed to work and attracted many types of light objects (like straw or dust), whereas lodestones required no friction and only attracted iron. Figures like Thomas Aquinas categorized these effects as “occult” forces—hidden powers of nature that were real but beyond human reason. This era also popularized colorful myths, such as the belief that garlic could “de-magnetize” a compass needle, a superstition so persistent that some ship captains reportedly banned the vegetable from their vessels to protect their navigation.\nWrite a paragraph describing how medieval ideas about electricity and magnetism were eventually challenged during the Scientific Revolution by figures like William Gilbert.\nThe transition from medieval mysticism to modern science was spearheaded by the English physician William Gilbert, whose 1600 masterwork De Magnete effectively dismantled centuries of superstition. Before Gilbert, the medieval understanding of magnetism was a cocktail of “occult” beliefs—such as the idea that garlic could neutralize a compass or that lodestones pointed north because they were “in love” with the Pole Star. Gilbert challenged these notions through systematic experimentation, famously creating a “terrella” (a small, spherical magnet) to demonstrate that the Earth itself acted as a giant magnet. This shifted the source of magnetic force from the heavens to the planet’s core. Furthermore, Gilbert was the first to rigorously distinguish between the “electric” force (the attraction of rubbed amber) and the “magnetic” force (the attraction of lodestones). He proved that while magnetism was a permanent property of specific minerals, “electrics” required friction to manifest and could attract a wide variety of materials, not just iron.\nGilbert’s work was revolutionary because it replaced “vitalist” explanations—the idea that objects had souls—with the concept of physical fields. He coined the New Latin term electricus (“like amber”), which gave us the word electricity. By insisting that scientific claims must be verifiable through repeatable experiments, he cleared the way for future thinkers like Robert Boyle and Benjamin Franklin to treat electricity as a measurable physical fluid rather than a magical curiosity.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html#ancient-understanding-of-electricity-and-magnetism",
    "href": "History_of_Electric_Circuit_Analysis.html#ancient-understanding-of-electricity-and-magnetism",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "",
    "text": "Table F.1: Key Medieval Milestones\n\n\n\n\n\n\n\n\n\n\nFeature\nMagnetism\nStatic Electricity\n\n\n\n\nPrimary Tool\nNavigational Compass\nRubbed Amber (Elektron)\n\n\nKey Thinker\nPetrus Peregrinus\nThomas Aquinas (Theological view)\n\n\nCore Belief\nCelestial alignment / Polar attraction\n“Occult” properties of materials\n\n\nCommon Myth\nGarlic can disable a magnet\nCan be used to test a spouse’s fidelity",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html#the-shift-in-thinking",
    "href": "History_of_Electric_Circuit_Analysis.html#the-shift-in-thinking",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "F.2 The Shift in Thinking",
    "text": "F.2 The Shift in Thinking\n\n\n\nTable F.2: The Shift in Thinking\n\n\n\n\n\n\n\n\n\nMedieval Belief\nGilbert’s Scientific Challenge\n\n\n\n\nSource: Magnets are pulled by the Pole Star.\nDiscovery: The Earth itself is a giant magnet with its own poles.\n\n\nInterference: Garlic or diamonds can disable a magnet.\nProof: Repeated experiments showed these had no effect on magnetic flux.\n\n\nNature: Electricity and magnetism are the same “hidden” power.\nDistinction: Only certain materials are “electrics”; magnetism is a distinct force.\n\n\nMethod: Reliance on ancient texts and folklore.\nMethod: The Experimental Method (Empiricism).\n\n\n\n\n\n\nWhat was the ancient Chinese understanding of static electricity and magnetism.\nIn ancient China, the understanding of static electricity and magnetism was deeply rooted in the concept of qi (vital energy) and the balance of Yin and Yang. Rather than viewing these as separate physical forces, Chinese scholars saw them as “affinities” or “sympathetic responses” between natural substances.\n\nF.2.1 Magnetism and the First Compass\nThe Chinese were the first to move beyond mere observation of magnetism to practical application. As early as the 4th century BCE, texts like the Book of the Devil Valley Master recorded that “the lodestone attracts iron.” By the Han Dynasty (206 BCE – 220 CE), this led to the invention of the si nan (south-governor), a lodestone spoon balanced on a bronze plate.\n\nThe Theory: Philosophers explained that the lodestone possessed a “genuine” power that allowed it to influence iron because their qi was compatible.\nThe Application: Unlike the Greeks, who primarily debated the “soul” of the magnet, the Chinese utilized magnetism for geomancy (feng shui) to align buildings with the Earth’s energy, and by the 11th century, for maritime navigation.\n\n\n\nF.2.2 Static Electricity and “The Amber Effect”\nStatic electricity was documented with similar curiosity, often categorized alongside magnetism as a “mysterious contact.” In the 1st century CE, the philosopher Wang Chong noted in the Lunheng that “amber picks up mustard seeds” (the equivalent of the Greek amber-and-fur experiment).\n\nYin and Yang: Static attraction was often explained through the lens of Yin and Yang—the idea that rubbing a material “excited” its energy, creating an imbalance that sought to be neutralized by attracting other light objects.\nLightning: While many cultures saw lightning as divine wrath, some Chinese scholars like Wang Chong were among the first to argue that lightning was actually a form of fire caused by the friction and collision of Yin and Yang energies in the atmosphere.\n\n\n\n\nTable F.3: Comparison of Concepts\n\n\n\n\n\n\n\n\n\n\nPhenomenon\nAncient Chinese Explanation\nPrimary Material\n\n\n\n\nMagnetism\nMutual response of qi between lodestone and iron.\nLodestone (Magnetite)\n\n\nStatic Electricity\nFriction-induced imbalance of Yin and Yang.\nAmber (often with mustard seeds)\n\n\nLightning\nAtmospheric friction/collision of “breath” (qi).\nThunderclouds\n\n\n\n\n\n\nwrite a paragraph describing the development of the modern upstanding of electricity and magnetism.\nThe modern understanding of electricity and magnetism represents a journey from viewing them as two unrelated “occult” forces to recognizing them as a single, unified phenomenon called electromagnetism. This transition began in earnest during the Scientific Revolution with William Gilbert, who in 1600 finally distinguished between the “amber effect” (static electricity) and magnetism. The 18th century brought quantitative rigor, with Charles-Augustin de Coulomb formulating the inverse-square law for electrical attraction and Benjamin Franklin famously proving that lightning was electrical. However, the true breakthrough occurred in 1820, when Hans Christian Ørsted accidentally discovered that an electric current could move a compass needle, proving for the first time that electricity and magnetism were linked.\nFollowing Ørsted’s discovery, the field exploded with activity. André-Marie Ampère mathematically described the force between current-carrying wires, while Michael Faraday—perhaps the greatest experimentalist in history—demonstrated electromagnetic induction in 1831, showing that a moving magnet could generate an electric current. Faraday’s work laid the foundation for the electric motor and generator, but it was James Clerk Maxwell who achieved the “Second Great Unification” in physics. In the 1860s, Maxwell published a set of four elegant equations that mathematically unified electricity, magnetism, and light into a single electromagnetic field theory. This intellectual triumph not only predicted the existence of radio waves but also paved the way for the technological revolution of the 20th century.\n\n\n\nTable F.4: Timeline of the “Great Unification”\n\n\n\n\n\n\n\n\n\n\nYear\nScientist\nKey Discovery / Contribution\n\n\n\n\n1600\nWilliam Gilbert\nDistinguished static electricity from magnetism.\n\n\n1785\nCharles Coulomb\nDeveloped the law for the force between charges.\n\n\n1800\nAlessandro Volta\nInvented the first battery (Voltaic pile).\n\n\n1820\nHans Ørsted\nDiscovered that electricity creates magnetism.\n\n\n1831\nMichael Faraday\nDiscovered induction (magnetism creates electricity).\n\n\n1865\nJames Clerk Maxwell\nUnified electricity, magnetism, and light mathematically.\n\n\n\n\n\n\nWould you like me to break down one of Maxwell’s four equations to explain how they connect these forces in plain English?\nMake a list of notable historical figures associated with electricity and magnetism.\nThe history of electricity and magnetism is defined by a series of “unifications”—moments where brilliant minds realized that seemingly different forces were actually parts of a single whole.\nHere are the most notable figures categorized by their specific impact on the field:\n\n\nF.2.3 The Pioneers of Observation (Ancient – 17th Century)\n\nThales of Miletus (c. 600 BCE): The first recorded person to describe static electricity (by rubbing amber) and magnetism (lodestones).\nPetrus Peregrinus (1269): Wrote the first detailed treatise on magnets, identifying magnetic “poles” and the rules of attraction and repulsion.\nWilliam Gilbert (1600): Often called the “Father of Electricity.” He was the first to distinguish between the “amber effect” (static electricity) and magnetism in his seminal work, De Magnete.\n\n\n\nF.2.4 The Enlightenment & Defining Charge (18th Century)\n\nStephen Gray (1729): Discovered the difference between conductors (materials electricity flows through) and insulators.\nBenjamin Franklin (1752): Famous for his kite experiment; he established that lightning is electrical and coined the terms positive and negative charge.\nCharles-Augustin de Coulomb (1785): Formulated Coulomb’s Law, which mathematically defined the force between two electrical charges.\n\n\n\nF.2.5 The Great Unifiers (19th Century)\n\nAlessandro Volta (1800): Invented the Voltaic Pile (the first battery), providing the first steady source of continuous electric current.\nHans Christian Ørsted (1820): Accidentally discovered that an electric current creates a magnetic field, the first proof that the two forces are linked.\nAndré-Marie Ampère (1820s): Developed the mathematical foundation for electromagnetism (Electrodynamics) and explained how currents interact with magnets.\nMichael Faraday (1831): Discovered electromagnetic induction—showing that a moving magnet can generate electricity. This discovery made modern power generators and motors possible.\nJames Clerk Maxwell (1865): Unified electricity, magnetism, and light into a single set of four elegant equations (Maxwell’s Equations), arguably the greatest achievement in 19th-century physics.\n\n\n\nF.2.6 The War of Currents & Modern Application (Late 19th – 20th Century)\n\nNikola Tesla: The visionary champion of Alternating Current (AC); he invented the induction motor and the Tesla coil, enabling the long-distance transmission of power.\nThomas Edison: Developed the first practical incandescent light bulb and the first industrial research lab; he famously fought for Direct Current (DC) systems.\nHeinrich Hertz (1887): Proved the existence of electromagnetic waves (radio waves), confirming Maxwell’s theoretical predictions.\n\nWrite a paragraph describing the point in history when the science of electricity and magnetism became electrical engineering.\nThe transition from theoretical physics to the formal discipline of electrical engineering occurred in the late 19th century, triggered by the commercialization of the electric telegraph and the invention of the incandescent light bulb. While scientists like Maxwell and Faraday provided the mathematical and experimental bedrock, the field “engineered” itself into existence when the need for large-scale power distribution and global communication systems outpaced the capacity of general physicists. This professionalization reached its climax in 1882, a landmark year when Thomas Edison opened the Pearl Street Station in New York—the first central power plant—and the Technische Universität Darmstadt in Germany established the world’s first chair of electrical engineering. Shortly thereafter, institutions like MIT and Cornell launched the first dedicated degree programs, shifting the focus from exploring the nature of “invisible fluids” to the systematic design of dynamos, motors, and transcontinental cable networks.\n\n\n\nTable F.5: The Professionalization Timeline\n\n\n\n\n\n\n\n\n\n\nYear\nMilestone\nImpact\n\n\n\n\n1830s-40s\nCommercial Telegraphy\nFirst large-scale “engineering” application of electricity.\n\n\n1882\nFirst EE Faculty (Darmstadt)\nElectrical Engineering is recognized as a distinct academic field.\n\n\n1882\nPearl Street Station Opens\nMarks the birth of the modern electric utility industry.\n\n\n1884\nFounding of the AIEE\nThe precursor to the IEEE is formed to set professional standards.\n\n\n1888\nTesla’s AC Patents\nEnables long-distance power transmission, requiring specialized engineers.\n\n\n\n\n\n\nWould you like to see a breakdown of the core curriculum taught to those first electrical engineering students in the 1880s?\nIn the 1880s, the first electrical engineering students faced a rigorous curriculum that merged classical Newtonian mechanics with the brand-new world of “applied electricity.” Since the field was emerging from the shadows of telegraphy and lighthouse illumination, the early coursework focused heavily on the physical construction and efficiency of machinery. Students had to master Dynamo-Electric Machinery, which involved the design of generators that could convert mechanical rotation into steady current, and Direct Current (DC) Power Distribution, which taught the physics of resistance and voltage drop over copper wires.\n\n\nF.2.7 The 1880s Curriculum: Core Subjects\n\nApplied Magnetism: Moving beyond philosophy to calculate “magnetic flux” and “permeability”—essential for building better iron cores for motors.\nTelegraphic Engineering: Studying signal attenuation, battery chemistry, and the underwater insulation of cables.\nThe Physics of Illumination: Calculating the lifespan and energy consumption of arc lamps and the new incandescent bulbs.\nPrecision Measurement: Learning to use the Wheatstone Bridge and early galvanometers to measure resistance, as there were no digital multimeters yet.\nSteam Engineering: Because electricity was produced by steam engines, early electrical engineers had to be experts in thermodynamics and boiler mechanics.\n\nBy the end of the decade, as the “War of Currents” intensified, the curriculum shifted rapidly to include Alternating Current (AC) Theory. This introduced students to complex mathematics like calculus-based wave analysis and the study of transformers, which allowed power to be stepped up to high voltages for long-distance travel.\nWould you like me to explain the specific “War of Currents” between Edison and Tesla that forced these students to choose between DC and AC systems?",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html#history-of-circuit-analysis",
    "href": "History_of_Electric_Circuit_Analysis.html#history-of-circuit-analysis",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "F.3 History of Circuit Analysis",
    "text": "F.3 History of Circuit Analysis\nThe understanding and analysis of electrical circuits represent a cornerstone of modern technology, underpinning everything from power grids to microprocessors. The journey to current sophisticated analytical techniques began with rudimentary observations of natural phenomena, gradually progressing through rigorous scientific inquiry to the formulation of fundamental physical laws. This historical trajectory reveals a continuous drive towards more precise, quantitative, and ultimately, automated methods for comprehending and designing increasingly complex electrical systems.\n\nF.3.1 Early Electrical Discoveries and Phenomena\nThe earliest recorded observations of electrical phenomena date back to ancient times. Around 600 BC, Thales of Miletus noted that rubbing amber (known as “elektron” in Greek) with fur caused it to attract light objects, a foundational discovery of static electricity that lent its name to the field. Parallel to these electrical observations, magnetic phenomena were also being explored. Petrus Peregrinus, in 1269, documented that natural magnets, or lodestones, possessed two poles that would align needles along specific lines, providing an early conceptualization of magnetic fields.\nThe scientific exploration of these forces gained momentum in the 17th century. William Gilbert, in 1600, not only coined the term “electricity” but also offered explanations for Earth’s magnetism and introduced concepts such as “electric force” and “magnetic pole”. This period marked a crucial transition from passive observation to active, controlled experimentation. Otto von Guericke, in 1660, invented the first machine capable of generating static electricity, enabling scientists to produce and manipulate electrical charges more systematically. Concurrently, Robert Boyle demonstrated that electric force could traverse a vacuum and observed both attractive and repulsive electrical interactions. This shift towards active experimentation was vital; without the ability to generate and control electrical phenomena reliably, the systematic study required to establish foundational laws of circuit analysis would have been severely limited.\nFurther advancements in the 17th and 18th centuries laid more groundwork. Stephen Gray, in 1675, made the significant distinction between materials that conduct electrical charges and those that do not, a fundamental concept for understanding current flow. The 18th century saw the discovery of two distinct types of electricity, termed “resinous” and “vitreous” (later identified as negative and positive), by Charles Francois du Fay in 1733. A pivotal invention during this era was the Leyden jar, the first electric capacitor, independently developed by Pieter van Musschenbroek and Georg Von Kleist around 1745-46. This device provided a means to store electrical energy, further enabling experimental manipulation.\nBenjamin Franklin’s work in 1747, including his one-fluid theory of electricity and his famous kite experiment linking static electricity to lightning, solidified the understanding of electrical charge. Towards the close of the 18th century, Henry Cavendish conceptualized resistance and capacitance, though his findings remained unpublished for decades. Charles Augustin Coulomb, in 1785, provided a critical quantitative relationship by using a torsion balance to verify the inverse square law for electric force. The invention of the electric battery, or Voltaic pile, by Alessandro Volta in 1800, marked a paradigm shift. This device provided the first continuous source of electric current, which was indispensable for subsequent experiments and practical applications, fundamentally enabling the quantitative study of electrical circuits. The parallel development of electrical and magnetic studies, even without a unified theory, suggested an inherent connection between these forces, a connection that would later be formalized by Maxwell’s equations and become central to circuit analysis.\n\n\nF.3.2 Development of the Telegraph\nWrite a paragraph describing the development of the telegraph and circuit analysis and theory.\nThe development of the electric telegraph in the mid-19th century—pioneered by figures such as Samuel Morse, Charles Wheatstone, and William Cooke—served as the primary catalyst for the formalization of circuit analysis and theory. While early experimenters like Joseph Henry used intuitive trial-and-error to improve electromagnets, the practical challenge of signal degradation over hundreds of miles necessitated a more rigorous mathematical framework. This led to the widespread application of Ohm’s Law (\\(V=IR\\)) to calculate the resistance of long-distance iron and copper wires and the “intensity” required to drive remote relays. As systems grew more complex, Gustav Kirchhoff introduced his fundamental circuit laws in 1845, using graph theory to describe the flow of current and voltage in networked lines. By the late 1800s, the “telegrapher’s equations” developed by Oliver Heaviside integrated Maxwell’s electromagnetic field theory with circuit variables, establishing the foundation for modern transmission line theory and ensuring that messages could travel across oceans without being lost to induction or capacitance.\n\nKey Milestones in Telegraphy and Circuit Theory\n\n\n\n\n\n\n\nEra\nMilestone\nImpact on Theory\n\n\n\n\n1827\nOhm’s Law\nProvided the first mathematical relationship between voltage, current, and resistance.\n\n\n1830s\nJoseph Henry’s Relays\nIntroduced the concept of “intensity” vs. “quantity” circuits (series vs. parallel).\n\n\n1845\nKirchhoff’s Laws\nEstablished rules for current and voltage in complex networked circuits.\n\n\n1880s\nTelegrapher’s Equations\nHeaviside modeled signal propagation, accounting for resistance, inductance, and capacitance.\n\n\n\n\nWrite a paragraph describing how Heaviside’s work specifically solved the problem of “signal blurring” in undersea telegraph cables.\nOliver Heaviside solved the critical problem of “signal blurring” (now known as dispersion) in undersea cables by identifying that the issue was not just a loss of signal strength, but a lack of inductance. Early transatlantic cables, modeled by Lord Kelvin using a “diffusion” theory similar to heat flow, ignored inductance, which caused different frequency components of a signal to travel at different speeds. As a result, the sharp “dots” and “dashes” of Morse code would spread out and overlap, often requiring operators to wait several minutes for a single character to clear. In 1887, Heaviside formulated the Heaviside Condition (\\(G/C=R/L\\)), which proved that if the ratio of leakage conductance (G) to capacitance (C) equaled the ratio of resistance (R) to inductance (L), all frequencies would travel at the same velocity, creating a distortionless line. To achieve this balance in practice, he proposed “loading” the cables by adding series inductors—a counterintuitive solution at the time, as engineers typically tried to maximize insulation and minimize all forms of “interference.”\n\nThe Heaviside Condition for Distortionless Transmission\n\n\n\n\n\n\n\n\nParameter\nSymbol\nRole in “Blurring”\nHeaviside’s Solution\n\n\n\n\nInductance\nL\nMissing in early models; causes frequency lag.\nIncrease  L using induction/loading coils.\n\n\nCapacitance\nC\nCauses signal to “bleed” and spread over time.\nBalance with L to fix velocity.\n\n\nResistance\nR\nCauses energy loss (attenuation).\nAccept loss, but fix shape through balance.\n\n\nLeakage\nG\nSmall current loss through insulation.\nBalance  G with R to maintain signal shape.\n\n\n\n\nWrite a paragraph describing the mathematical struggle between Heaviside and the “practical men” of the 19th century.\nThe mathematical struggle between Oliver Heaviside and the “practical men” of the late 19th century—led by the powerful Post Office Chief Engineer William Preece—was a bitter culture war between abstract theory and empirical intuition. Preece and his contemporaries relied on the “KR Law,” a simplified model that treated telegraph cables like long, leaky pipes where only resistance and capacitance mattered. They viewed self-induction as a “choking” enemy to be purged. Heaviside, a self-taught genius who lived in reclusive poverty, used his “abstruse” mathematical tools to prove the opposite: that adding induction (loading) would actually clarify signals. Preece, who famously stated that “true theory does not require the language of mathematics,” used his political clout to block Heaviside’s publications and dismiss his work as “mathematical gymnastics.” This feud delayed the implementation of high-speed long-distance telephony for decades, ending only when the “practical” failures of undersea cables became so undeniable that engineers were forced to adopt Heaviside’s operational calculus and vector analysis to save the industry.\n\nThe Clash of Philosophies\n\n\n\n\n\n\n\nFeature\nThe “Practical Men” (Preece)\nThe “Maxwellians” (Heaviside)\n\n\n\n\nView of Math\nA “needless abstraction” for simple electrical work.\nThe “experimental” foundation of physical truth.\n\n\nInductance (L)\nAn “enemy” that slows down current flow.\nA necessary “balance” to stop signal blurring.\n\n\nCore Model\nThe KR Law: Focuses only on K (capacitance) and (resistance).\nTelegrapher’s Equations: Includes L (inductance) and G (leakage).\n\n\nUltimate Result\nSlow, distorted long-distance communication.\nClear, high-speed transoceanic telephony.\n\n\n\nHeaviside’s victory eventually redefined the field of electrical engineering.\n\nWrite a paragraph describing how Heaviside simplified the original 20 Maxwell’s Equations.\nOliver Heaviside simplified the original 20 equations of James Clerk Maxwell by “throwing overboard” the complex use of potentials and quaternions, which he found to be unnecessarily abstract and physically opaque. Maxwell’s original 1865 formulation relied on a system of 20 simultaneous equations written in , , and components, largely focused on the magnetic vector potential (A) as the central physical reality. Heaviside, working independently in the 1880s, discarded the potentials in favor of the electric (E) and magnetic (H) fields themselves, arguing that only these fields represented observable physical states. To do this, he independently co-developed vector calculus, introducing the now-standard operators of divergence (\\(\\nabla \\cdot\\)) and curl (\\(\\nabla \\times\\)). This allowed him to condense Maxwell’s sprawling list into four elegant, symmetric partial differential equations that describe how charges and currents produce fields, and how changing fields produce one another. By recasting the theory in this “duplex” form, Heaviside transformed a dense mathematical treatise into a practical toolset that could be used by engineers to design everything from transoceanic cables to radio antennas.\n\nThe Simplification Proce\n\n\n\n\n\n\nOriginal Maxwellian Form (1865)\nHeaviside’s Vector Form (1884)\n\n\n\n\n20 Equations in 20 variables.\n4 Equations in 2 variables (E and H).\n\n\nWritten in Quaternions and component scalars.\nWritten in Vector Calculus (Divergence and Curl).\n\n\nCentered on Magnetic Vector Potential (A).\nCentered on Measurable Fields (E, H).\n\n\nDifficult to solve for practical engineering.\nFoundation for Operational Calculus and circuit design.\n\n\n\n\n\n\nF.3.3 Development of the Radio\nWrite a paragraph describing the development of the radio and circuit analysis and theory.\nThe transition from the wired telegraph to wireless radio in the late 19th and early 20th centuries forced circuit analysis to move beyond steady-state currents into the high-frequency realm of oscillatory dynamics. While early radio pioneers like Guglielmo Marconi initially relied on “brute force” spark-gap transmitters, the need for selective tuning led to the refinement of the resonant RLC circuit (Resistor-Inductor-Capacitor). This era saw the emergence of frequency-domain analysis, as engineers realized that a circuit’s behavior changed radically at its resonant frequency (\\(f=\\frac{1}{2\\pi \\sqrt{LC}}\\)). The invention of the vacuum tube (Audion) by Lee de Forest and its application in Edwin Armstrong’s regenerative and superheterodyne circuits introduced the concept of active circuit theory, where components could provide gain and feedback rather than just dissipating energy. These advancements required a new mathematical vocabulary involving complex impedance and transfer functions, transforming circuit theory from a branch of static physics into a sophisticated engineering discipline capable of manipulating invisible electromagnetic waves.\n\nRadio’s Impact on Circuit Theory\n\n\n\n\n\n\n\nInnovation\nKey Contributor\nTheoretical Advancement\n\n\n\n\nResonant Tuning\nOliver Lodge / Marconi\nDeveloped selective filtering and the concept of “tuning” to specific frequencies.\n\n\nTriode Vacuum Tube\nLee de Forest\nIntroduced active elements that could amplify signals (non-passive theory).\n\n\nRegeneration\nEdwin Armstrong\nFormalized positive feedback and high-gain oscillation theory.\n\n\nSuperheterodyne\nEdwin Armstrong\nAdvanced frequency conversion (mixing) and intermediate frequency (IF) analysis.\n\n\n\n\n\nF.3.4 Development of Electric Power Distribution and Lighting\n\nWrite a paragraph describing the Development of Electric Power Distribution and Lighting\nThe development of electric power distribution and lighting in the late 19th century transformed circuit analysis from a laboratory curiosity into an industrial necessity, fueled by the intense competition between Thomas Edison and Nikola Tesla. Edison’s 1882 Pearl Street Station pioneered the first commercial utility using Direct Current (DC), but it was limited by the ** power loss** inherent in low-voltage transmission, which required power plants to be located within a mile of the consumer. This “War of Currents” necessitated a deeper understanding of parallel circuit design to ensure that turning off one light bulb didn’t blow out the rest—a practical application of Kirchhoff’s Current Law. The tide shifted toward Alternating Current (AC) when Tesla and George Westinghouse utilized the transformer, an application of Faraday’s Law of Induction, to “step up” voltages for efficient long-distance travel. This shift forced engineers to move beyond simple resistive models to phasor analysis and complex power theory, accounting for the phase shifts between voltage and current caused by the inductance of massive generators and the capacitance of the growing grid.\n\nThe Evolution of Power Systems and Circuit Analysis\n\n\n\n\n\n\n\n\nSystem Type\nKey Proponent\nPrimary Constraint\nTheoretical Breakthrough\n\n\n\n\nDirect Current (DC)\nThomas Edison\nVoltage Drop: Limited to short distances due to wire resistance (R).\nRefined Ohm’s Law and Parallel Loading for domestic use.\n\n\nAlternating Current (AC)\nNikola Tesla\nReactance: Inductive and capacitive loads (L, C) affect efficiency.\nIntroduced Phasors and 3-Phase Power for high-efficiency motors.\n\n\nArc Lighting\nCharles Brush\nHigh Voltage: Required series connections; dangerous for indoor use.\nAdvanced Series Circuit Analysis for high-intensity municipal grids.\n\n\nIncandescent Lighting\nThomas Edison\nFilament Life: Required stable, low-voltage parallel circuits.\nOptimized High-Resistance Filaments to minimize current draw (I).\n\n\n\nThe 1895 opening of the Niagara Falls power plant proved that AC could power an entire region, effectively ending the War of Currents.\n\n\nF.3.5 Ohm’s Law\nThe transition from qualitative observations to quantitative analysis in circuit theory was profoundly marked by the work of Georg Ohm. In 1827, Ohm published his seminal treatise, Die galvanische Kette, mathematisch bearbeitet (“The galvanic circuit investigated mathematically”), which established the fundamental relationship between voltage, current, and resistance. This work was the culmination of experiments conducted in 1825 and 1826.\nOhm’s experimental methodology was meticulous. He initially used voltaic piles but later opted for a thermocouple, recognizing its superior stability as a voltage source. Employing a galvanometer to measure current, he systematically varied the length, diameter, and material of test wires in his circuits. His data revealed a consistent relationship, which he modeled with the equation \\(x = a / (b + l)\\), where \\(x\\) was the reading from the galvanometer, \\(l\\) was the length of the test conductor, \\(a\\) depended on the thermocouple junction temperature, and \\(b\\) was a constant of the entire setup. From this, Ohm determined his law of proportionality and published his results. A formulation that modern notation translates to \\(I = E / (r + R)\\), where \\(R\\) represents the resistance of the test wire.\nDespite the profound importance of his discovery, Ohm’s law initially encountered significant opposition. Critics dismissed his work as “a web of naked fancies,” and the Minister of Education famously declared that “a professor who preached such heresies was unworthy to teach science”. This resistance stemmed partly from the prevailing scientific philosophy in Germany at the time, which prioritized deductive reasoning over experimental evidence, believing that nature’s order could be fully understood through pure thought. The challenges faced by Ohm underscore a historical tension in scientific development, where empirical findings, even when rigorously derived, can be met with skepticism if they challenge established intellectual frameworks. The eventual widespread acceptance of Ohm’s law by the 1840s and 1850s validated the critical role of experimental validation in establishing fundamental scientific principles.\nThe underlying physical explanation for Ohm’s macroscopic law would not emerge until much later. The discovery of the electron by J. J. Thomson in 1897, followed by Paul Drude’s classical Drude model of electrical conduction in 1900, provided a microscopic basis for the relationship Ohm had observed. This model, later refined by quantum mechanics in the 1920s, explained how the average drift velocity of electrons is proportional to the electric field, thereby deriving Ohm’s law from first principles. This progression illustrates that the understanding of circuit phenomena often evolves in layers: initial laws provide practical predictive power, while subsequent scientific discoveries offer deeper, more fundamental explanations, enabling more sophisticated analysis and material engineering.\n\n\nF.3.6 Fundamental Network Laws\nBuilding upon Ohm’s foundational work, Gustav Kirchhoff provided the essential framework for analyzing complex electrical networks. In 1845, Kirchhoff formulated two fundamental equalities that govern current and potential difference in electrical circuits, now universally known as Kirchhoff’s Circuit Laws or Kirchhoff’s rules. These laws generalized Ohm’s work and preceded Maxwell’s comprehensive equations, establishing the bedrock for systematic network analysis.\nKirchhoff’s Current Law (KCL), also referred to as Kirchhoff’s first law or the junction rule, states that the algebraic sum of all currents entering and exiting any node (junction) in an electrical circuit must be zero. This law is a direct consequence of the fundamental principle of the conservation of electric charge. Its applicability extends to any lumped network, regardless of its linearity, passivity, or whether it includes unilateral or bilateral components. KCL forms the basis for nodal analysis and is a core component of most modern circuit simulation software, such as SPICE.\nKirchhoff’s Voltage Law (KVL), also known as Kirchhoff’s second law or the loop rule, states that the directed sum of potential differences (voltages) around any closed loop in a circuit must equal zero. This law is a corollary of Maxwell’s equations in the low-frequency limit, effectively embodying the principle of energy conservation within a closed electrical path.\nCombined with Ohm’s law, Kirchhoff’s laws became indispensable to network theory, enabling engineers and scientists to solve increasingly complex networks, including intricate bridge circuits. The development of these laws highlights a critical principle in engineering: the effective use of ideal models and abstractions to simplify complex systems for analysis. Kirchhoff’s laws rely on the “lumped-element model,” which approximates circuit components as discrete entities with ideal connections. While this model has limitations, it provided immensely powerful tools for practical design and analysis for over a century, before high-frequency effects became a significant concern. The deep connection of KCL to charge conservation and KVL to energy conservation provides a robust theoretical foundation, ensuring the reliability and broad applicability of these laws across various circuit configurations within the lumped-element model’s validity.\nHowever, it is crucial to recognize the inherent limitations of Kirchhoff’s laws, as they are predicated on the lumped-element model. Their accuracy diminishes in high-frequency AC circuits where the wavelengths of electromagnetic radiation become comparable to the circuit dimensions. In such scenarios, electric fields between circuit parts can become non-negligible due to capacitive coupling, or time-varying magnetic fields may not be entirely confined to individual components, leading to inductive coupling. In these cases, the assumption of constant charge density in conductors may no longer hold, necessitating direct field simulation or the inclusion of parasitic components in the circuit model.\n\n\nF.3.7 Classical Circuit Analysis Methods\nWith the fundamental laws established, the next phase in the history of circuit analysis involved the development of systematic methods for applying these laws to solve circuit problems manually. These classical methods formed the bedrock of circuit design for decades, even as circuit complexity began to grow.\n\nF.3.7.1 Mesh Analysis\nMesh analysis, identified with Kirchhoff’s Voltage Law (KVL), stands as one of the earliest systematic methods for formulating equations for electrical circuits. Its conceptual roots can be traced back to Maxwell’s idea of “cyclic current”. The method involves defining each mesh, or closed loop, within a circuit and assigning a corresponding unknown current to it. To ensure consistency and ease of application, these unknown currents are often defined in a uniform direction, such as clockwise.\nOnce the mesh currents are defined, KVL is applied to each loop that does not contain a current source. This process generates a system of linear equations, which can then be solved to determine the unknown mesh currents. For a circuit characterized by n meshes and m current sources, mesh analysis typically requires solving a system of n-m equations. The development of mesh analysis, building on Maxwell’s work and KVL, signified a crucial step towards a systematic, repeatable approach to solving circuit problems, moving beyond ad-hoc methods. This early recognition of the need for formalized procedures was essential for scaling circuit design and analysis beyond trivial examples, even if the computational burden remained significant for human analysts.\n\n\nF.3.7.2 Nodal Analysis\nNodal analysis emerged as a powerful alternative and a “topological dual” to mesh analysis, identified primarily with Kirchhoff’s Current Law (KCL). It quickly became a mainstay for analyzing larger electrical systems due to several inherent advantages over its mesh counterpart.\nThe methodology of nodal analysis involves a structured, step-by-step procedure:\n\nNode Definition: All distinct connected conductive segments within the circuit are identified and designated as nodes.\n\nGround Node Selection: A reference node, typically designated as ground, is chosen, and its voltage is set to zero. This strategic choice effectively reduces the number of unknown voltages in the system by one.\n\nVariable Assignment: A unique voltage variable is assigned to each non-reference node whose voltage is unknown.\n\nEquation Construction: For each non-reference node not directly connected to a voltage source, KCL is applied. This involves summing all currents entering and exiting the node, with each current expressed in terms of node voltages using Ohm’s Law, and setting the sum to zero.\n\nSupernode Formation: In cases where a voltage source connects two nodes with unknown voltages, a “supernode” can be conceptually formed. This approach combines the KCL equations for the two interconnected nodes into a single equation, supplemented by an additional equation that defines the voltage relationship across the source.\n\nSystem Solution: The resulting system of simultaneous linear equations is then solved to determine all unknown node voltages.\n\nNodal analysis offered two significant advantages that contributed to its popularity : First, it effectively eliminated the complexities associated with crossovers in nonplanar networks, thereby obviating the need for intricate tree-graph theory required by mesh analysis in such scenarios. Second, the number of equations typically required for nodal analysis is generally smaller than for mesh analysis, largely because the number of nodes in a network is often less than the number of branches. The development of nodal analysis as a “topological dual” to mesh analysis illustrates that different mathematical or conceptual frameworks can offer more efficient solutions for particular problems. While both methods are theoretically valid, nodal analysis often reduces the number of equations, especially for networks with many branches but fewer nodes. This highlights the practical importance of selecting the most efficient analytical tool, a consideration that became increasingly critical as circuit complexity grew and foreshadowed the later drive for computational efficiency in computer-aided design.\n\n\n\nF.3.8 Limitations of Manual Methods\nDespite the systematic improvements offered by nodal and mesh analysis, the inherent limitations of applying these classical methods manually became increasingly apparent as electrical circuits grew in complexity. These challenges ultimately paved the way for the necessity of automated solutions.\nA significant inefficiency of traditional nodal analysis was its cumbersome handling of voltage sources. When a voltage source was not directly tied to the reference (ground) node, or when it spanned between two non-reference nodes, it complicated the direct application of KCL. This often necessitated the use of “supernodes” or required transformations, such as replacing independent voltage sources with Norton equivalent current sources, which added layers of complexity to the equation formulation.\nFurthermore, the basic nodal method struggled to incorporate current-dependent circuit elements—whether linear or nonlinear—in a simple and efficient manner. This posed a growing problem as active components and more intricate device models became prevalent. Another practical drawback was the difficulty in obtaining branch currents directly from the output of traditional nodal analysis. While node voltages were readily solved, determining individual branch currents often required additional, post-solution calculations, adding to the manual effort.\nPast attempts to generalize the nodal method to address these limitations frequently introduced new complications. For instance, some programs resorted to introducing extremely small or negative resistances to accommodate current dependencies, which could lead to numerical instability. While nodal analysis was generally more efficient than mesh analysis for many circuits, both methods became prohibitively complex and time-consuming for large networks. The sheer number of equations and variables in such circuits made manual calculation impractical, if not impossible. These limitations—the inefficiency with certain elements, the difficulty in obtaining all desired variables, and the overwhelming scale of calculations—all pointed to a fundamental bottleneck: the human capacity for manual computation and error management. As electronic designs became more intricate, particularly with the advent of integrated circuits, these manual methods became unsustainable, directly establishing the critical need for computer-aided analysis.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html#oliver-heaviside",
    "href": "History_of_Electric_Circuit_Analysis.html#oliver-heaviside",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "F.4 Oliver Heaviside",
    "text": "F.4 Oliver Heaviside\nThe Laplace transform, which uses the Laplace variable \\(s\\), was introduced into electrical circuit analysis by the self taught British engineer and physicist Oliver Heaviside in the late 19th century. Heaviside developed a method he called “operational calculus” to solve the differential equations of electric circuits. Heaviside’s operational calculus, published in the 1890s, used an operator \\(p\\) which he defined as \\(\\frac{d}{dt}\\). He applied algebraic rules to this operator to solve for circuit responses to transients. This was essentially an intuitive, non-rigorous version of the Laplace transform. The mathematical community later proved that Heaviside’s powerful but informal methods could be rigorously justified using the Laplace transform. This was largely done by engineers and mathematicians like John R. Carson and Thomas Bromwich in the 1920s and 1930s. The modern, widespread use of the Laplace transform as a standard tool in electrical engineering came about after World War II. It replaced Heaviside’s operational calculus in engineering curricula and textbooks, solidifying its place as the primary method for analyzing linear, time-invariant systems in the frequency domain.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html#charles-proteus-steinmetz",
    "href": "History_of_Electric_Circuit_Analysis.html#charles-proteus-steinmetz",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "F.5 Charles Proteus Steinmetz",
    "text": "F.5 Charles Proteus Steinmetz\nPhasor analysis, a critical tool for AC circuits, was first used in the late 19th century. Its introduction is credited to Charles Proteus Steinmetz, an electrical engineer working for General Electric. In 1893, he proposed the use of phasor notation, which was then rapidly adopted for AC circuit analysis. He was a professor at Union College and a key figure in the development of alternating current (AC) at General Electric, where he served as a consulting engineer. His work was crucial for the expansion of the electric power industry in the United States. In 1893, he introduced the use of complex numbers (phasors) to simplify the analysis of AC circuits. This method transformed complex, time-consuming calculus into simpler algebraic calculations.\nPhasor analysis was first introduced in 1893 when he presented a paper titled “Complex Quantities and Their Use in Electrical Engineering” at the International Electrical Congress in Chicago. This work revolutionized AC circuit analysis by transforming the complex calculus-based methods used at the time into much simpler algebraic operations using complex numbers. Before phasors, analyzing alternating current (AC) circuits was mathematically complex, as it involved solving differential equations for sinusoidal waveforms. Steinmetz’s method simplified this process immensely. By representing sinusoidal voltages and currents as complex numbers (phasors), the differential equations that govern AC circuits were transformed into much simpler algebraic equations. This allowed engineers to use familiar algebraic rules and Ohm’s Law in the frequency domain. The simplification offered by phasor analysis was so profound that it became the standard method for analyzing AC power systems and is still a fundamental concept taught in electrical engineering today.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "History_of_Electric_Circuit_Analysis.html#development-of-modified-nodal-analysis",
    "href": "History_of_Electric_Circuit_Analysis.html#development-of-modified-nodal-analysis",
    "title": "Appendix F — History of Electric Circuit Analysis",
    "section": "F.6 Development of Modified Nodal Analysis",
    "text": "F.6 Development of Modified Nodal Analysis\nThe limitations of traditional nodal analysis and the increasing demands of computer-aided design for complex circuits necessitated a more robust and versatile equation formulation. Modified Nodal Analysis (MNA) emerged as the definitive solution, becoming the foundational method for modern circuit simulation software.\nIn 1975, Ho, Ruehli, and Brennan (1975) published a paper titled, The Modified Nodal Approach to Network Analysis. This was the original scholarly paper on the subject. The analysis method they presented allows for the ability to process voltage sources and current-dependent circuit elements in a simple and efficient manner. The paper describes the formulation of the matrices, the use of stamps and a pivot ordering strategy. The authors compare their algorithm to the tableau method, a circuit analysis technique, which was an analysis technique being described in scholarly papers at the time. At the time of this publication, the authors were affiliated with the IBM Thomas J. Watson Research Center in Yorktown Heights, N.Y.\nThe development of MNA was driven by the critical need for efficient circuit equation formulation in computer-aided design programs, particularly for integrated circuits. While the traditional nodal approach offered flexibility and efficiency for manual analysis, its inherent limitations—especially concerning the treatment of voltage sources and current-dependent elements—demanded a more generalized and computationally friendly method. This highlights a pattern of industry-driven innovation; the practical demands of integrated circuit design within a leading industrial research center directly spurred this fundamental analytical advancement.\nThe timing of MNA’s publication in 1975 was opportune, coinciding with the maturation of digital computing capabilities, which enabled its rapid and widespread adoption as the computational infrastructure became ready to fully leverage its algorithmic advantages. If MNA had been proposed much earlier, the computational resources might not have been sufficient to efficiently handle the large matrices generated. By 1975, digital computers had advanced to a point where MNA’s sophisticated matrix operations and iterative solutions became practically feasible and efficient. This technological readiness allowed MNA’s inherent algorithmic advantages to be fully exploited, leading to its rapid integration into circuit simulation software and its eventual dominance.\nAcademic institutions are increasingly integrating MNA into undergraduate circuit theory courses to enhance students’ understanding of analysis techniques that are directly implementable on computers.\n\n\n\n\nHo, C., A. Ruehli, and P. Brennan. 1975. “The Modified Nodal Approach to Network Analysis.” IEEE Transactions on Circuits and Systems 22 (6): 504–9. https://doi.org/10.1109/TCS.1975.1084079.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>History of Electric Circuit Analysis</span>"
    ]
  },
  {
    "objectID": "Quick_ref.html",
    "href": "Quick_ref.html",
    "title": "Appendix G — Quick Reference",
    "section": "",
    "text": "G.1 Schematic Symbols\nThis chapter is a quick reference to some basic information used throughout this book.\nThe following symbols can be used in in LTSpice to draw schematics that will produce SPICE netlists for the MNA Python code.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Quick Reference</span>"
    ]
  },
  {
    "objectID": "Quick_ref.html#schematic-symbols",
    "href": "Quick_ref.html#schematic-symbols",
    "title": "Appendix G — Quick Reference",
    "section": "",
    "text": "Table G.1: Schematic symbols\n\n\n\n\n\n\n\n\n\nSchematic Symbol\nExample lines in the netlist\n\n\n\n\n\nPassive componentsR1 1 2 1e3C1 1 2 0.1e-6L1 1 2 0.1e-3\n\n\n\nIndependent sourcesI1 1 2 0.5V1 3 4 3\n\n\n\nDependent sourcesVCVS: E1 1 2 3 4 ECCCS: F1 5 6 V1 FVCCS: G1 7 8 9 10 GCCVS: H1 11 12 V1 H\\(V_1\\) defines the branch controlling the current\n\n\n\nOp AmpO1 1 2 3\n\n\n\nCoupled inductorsL1 1 2 2L2 3 4 3K1 L1 L2 0.5",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Quick Reference</span>"
    ]
  },
  {
    "objectID": "Quick_ref.html#si-units",
    "href": "Quick_ref.html#si-units",
    "title": "Appendix G — Quick Reference",
    "section": "G.2 SI Units",
    "text": "G.2 SI Units\nVoltage, also known as (electrical) potential difference is the difference in electric potential between two points. In the context of circuit analysis, the fundamental quantities are current, voltage and resistance.\n\n\n\n\n\n\n\n\n\nQuantity\nUnit (SI)\nSymbol\nDefines/Measures\n\n\n\n\nElectric Current\nAmpere\nA (or \\(I\\))\nThe rate of flow of electric charge.\n\n\nElectric Potential Difference (Voltage)\nVolt\nV (or \\(E\\) or \\(U\\))\nThe electrical “pressure” that drives the current.\n\n\nElectrical Resistance\nOhm\n\\(\\Omega\\) (Omega)\nThe opposition a material offers to the flow of electric current.\n\n\n\nThese three units are intrinsically linked by Ohm’s Law: \\(V = I \\times R\\). Beyond the core three, several other quantities are crucial in circuit analysis:\n\n\n\n\n\n\n\n\n\n\nQuantity\nUnit (SI)\nSymbol\nRelationship/Formula\nMeasures\n\n\n\n\nElectric Power\nWatt\nW\n\\(P = V \\times I\\)\nThe rate at which electrical energy is transferred or converted.\n\n\nCapacitance\nFarad\nF\n\\(C = Q / V\\)\nA component’s ability to store an electric charge.\n\n\nInductance\nHenry\nH\n\\(V = L \\frac{di}{dt}\\)\nA conductor’s ability to oppose a change in current.\n\n\nFrequency\nHertz\nHz\n\\(Hz = s^{-1}\\)\nThe number of cycles (e.g., of an AC waveform) per second.\n\n\nElectrical Energy\nJoule (or kWH for practical use)\nJ (or kWh)\n\\(E = P \\times t\\)\nThe work done by electrical forces.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Quick Reference</span>"
    ]
  },
  {
    "objectID": "Quick_ref.html#prefixes-to-units",
    "href": "Quick_ref.html#prefixes-to-units",
    "title": "Appendix G — Quick Reference",
    "section": "G.3 Prefixes to Units",
    "text": "G.3 Prefixes to Units\nElectrical quantities often cover an enormous range from very small to very large. SI prefixes are used to simplify notation:\n\n\n\nPrefix\nSymbol\nPower of 10\nExample\n\n\n\n\nTera\nT\n\\(10^{12}\\)\n1 TW (1 trillion Watts)\n\n\nGiga\nG\n\\(10^9\\)\n1 GHz (1 billion Hertz)\n\n\nMega\nM\n\\(10^6\\)\n1 M\\(\\Omega\\) (1 million Ohms)\n\n\nkilo\nk\n\\(10^3\\)\n1 kV (1 thousand Volts)\n\n\nmilli\nm\n\\(10^{-3}\\)\n1 mA (one-thousandth of an Ampere)\n\n\nmicro\n\\(\\mu\\)\n\\(10^{-6}\\)\n1 \\(\\mu\\)F (one-millionth of a Farad)\n\n\nnano\nn\n\\(10^{-9}\\)\n1 nF (one-billionth of a Farad)\n\n\npico\np\n\\(10^{-12}\\)\n1 pF (one-trillionth of a Farad)\n\n\nfemto\nf\n\\(10^{-15}\\)\n1 fs (one-quadrillionth of a second)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Quick Reference</span>"
    ]
  },
  {
    "objectID": "Quick_ref.html#variable-names",
    "href": "Quick_ref.html#variable-names",
    "title": "Appendix G — Quick Reference",
    "section": "G.4 Variable names",
    "text": "G.4 Variable names\nI’ve tried to be consistent with the use of variable names throughout the Jupyter notebooks. Resistors, capacitors and inductors use R, L and C as reference designators. The names chosen for the other variables are listed in Table G.2.\nThis table needs an update.\n\n\n\nTable G.2: Variable names\n\n\n\n\n\n\n\n\n\nVariable name\ndefinition\n\n\n\n\nNE_sym\nNetwork equations, symbolic\n\n\nNE\nNetwork equations with component values\n\n\nNE_dc\nNetwork equations with \\(s=0\\)\n\n\nNE_w1\nNetwork equations with \\(s=j \\omega\\) and \\(\\omega\\) equal to a numeric value\n\n\nU_sym\nThe solution to the symbolic network equations\n\n\nU\nThe solution to network equations with component values\n\n\nU_ac\nThe solution to network equations at some frequency\n\n\nH_sym\nsystem transfer function, symbolic\n\n\nH\nSystem transfer function with component values\n\n\n\\(V_1, V_2,\\) …\nCapital letter V for independent voltage sources\n\n\n\\(v_1, v_2,\\) …\nSmall letter v for the node voltages\n\n\n\\(I_1, I_2,\\) …\nCapital letter I for independent current sources\n\n\n\\(R_1, R_2,\\) …\nCapital letter R for resistors\n\n\n\\(L_1, L_2,\\) …\nCapital letter L for inductors\n\n\n\\(C_1, C_2,\\) …\nCapital letter C for capacitors\n\n\n\\(E_1, E_2,\\) …\nVoltage controlled voltage source (VCVS)\n\n\n\\(F_1, F_2,\\) …\nCurrent controlled current source (CCCS)\n\n\n\\(G_1, G_2,\\) …\nVoltage controlled current source (VCCS)\n\n\n\\(H_1, H_2,\\) …\nCurrent controlled voltage source (CCVS)\n\n\n\\(K_1, K_2,\\) …\nInductor coupling coefficients\n\n\n\\(M_1, M_2,\\) …\nMutual inductance\n\n\n\\(O_1, O_2,\\) …\nOp Amp components\n\n\nA\nConnectivity matrix\n\n\nX\nUnknown voltages and currents vector\n\n\nZ\nKnown voltages and currents vector",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Quick Reference</span>"
    ]
  },
  {
    "objectID": "Quick_ref.html#common-laplace-transform-pairs",
    "href": "Quick_ref.html#common-laplace-transform-pairs",
    "title": "Appendix G — Quick Reference",
    "section": "G.5 Common Laplace Transform Pairs",
    "text": "G.5 Common Laplace Transform Pairs\nThe Laplace transform is a powerful integral transform used to switch a function from the time domain (t) to the complex frequency domain (s). This is particularly useful for solving linear differential equations by turning them into algebraic equations.\nThe general definition of the Laplace transform is:\n\\[F(s)=\\mathcal{L}\\{f(t)\\}  \\int_{0^{-}}^{\\infty} e^{-st}  dt\\]\nThe table below lists the most frequently used transforms for engineering and physics. Note that u(t) represents the unit step function, and all functions are assumed to be zero for t &lt; 0.\n\n\n\n\n\n\n\n\nFunction Name\nf(t)\nF(s)\n\n\n\n\nUnit Impulse\n\\(\\delta(t)\\)\n1\n\n\nUnit Step\n1 or u(t)\n\\(\\frac{1}{s}\\)\n\n\nRamp\nt\n\\(\\frac{1}{s^2}\\)\n\n\nn-th Power\n\\(t^n\\)\n\\(\\frac{n!}{s^{n+1}}\\)\n\n\nExponential Decay\n\\(e^{-at}\\)\n\\(\\frac{1}{s+a}\\)\n\n\nSine Wave\n\\(\\sin(\\omega t)\\)\n\\(\\frac{\\omega}{s^2 + \\omega^2}\\)\n\n\nCosine Wave\n\\(\\cos(\\omega t)\\)\n\\(\\frac{s}{s^2 + \\omega^2}\\)\n\n\nDamped Sine\n\\(e^{-at}\\sin(\\omega t)\\)\n\\(\\frac{\\omega}{(s+a)^2 + \\omega^2}\\)\n\n\nDamped Cosine\n\\(e^{-at}\\cos(\\omega t)\\)\n\\(\\frac{s+a}{(s+a)^2 + \\omega^2}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Quick Reference</span>"
    ]
  }
]