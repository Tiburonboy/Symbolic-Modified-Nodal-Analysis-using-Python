[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Symbolic Modified Nodal Analysis",
    "section": "",
    "text": "About this book\nThis is the website for the Symbolic Modified Nodal Analysis using Python.\nIn this book, you will …\nThis website is and will always be free, licensed under the CC BY-NC-ND 3.0 License.\nIf you’d like a physical copy of the book, maybe one day it will be available on Amazon.\n\n\nUpdate History\nThis website will be updated periodically as new early release content becomes available, and post-publication for errata fixes.\nPython module verions\n\n\n\nenvironment\nversion\n\n\n\n\nprocessor\nx86_64\n\n\ndistribution\nLinux Mint 21.1\n\n\npython\n3.10.9\n\n\nnumpy\n1.23.5\n\n\nsympy\n1.11.1\n\n\nscipy\n1.10.0\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8\n\n\n\n\n\n\ndate\ndescription\n\n\n\n\n29 Dec 2023\ntest version\n\n\n1 Jan 2024\nanother update"
  },
  {
    "objectID": "Front-Matter.html",
    "href": "Front-Matter.html",
    "title": "Front Matter",
    "section": "",
    "text": "Dedication\nA dedication page in a book is found at the beginning, before the story starts, and it is a space for the author to – that’s right – dedicate the book to someone. The dedication normally isn’t long, sometimes only a sentence or two, and is a sweet, heartfelt way to honor someone in the life of the author.\n\n\nAcknowledgements\nAn acknowledgement page is (usually) a one to two page section in the front matter of a book (though sometimes it’s located in the back of the book), and its focus is thanking and bringing attention to instrumental persons who helped the book become realized, written, and published. This page is different than the dedication; the acknowledgements page is broader and includes more people. The dedication is normally to one person, or two at most, and is more of a memorialization than a thank you."
  },
  {
    "objectID": "Preface.html",
    "href": "Preface.html",
    "title": "Preface",
    "section": "",
    "text": "modern computer codes\ncomputer algebra\nobjectives, purpose and what is being acomplished\nbackground required\nwhat does the book cover\n\nThe nodal analysis code started as a translation from some C code to generate a nodal admittance matrix that I had written in 1988. I wrote this code for two reasons. Free versions of Spice for the PC didn’t exist at the time and I wanted to use some of the code from the Numerical Recipes in C Book. The original C code worked well and calculated numeric solutions. I then started writing some C code to generate the matrices with symbolic values and then intended to use LISP to symbolically solve the equations. I didn’t get too far with this effort. The LISP code would generate huge symbolic strings with no simplification. The output was a big pile of trash that was not in the least bit useful or decipherable.\nIn 2014, I started to use python for my little coding projects and engineering calculations. There are some nice python libraries for numeric and symbolic calculations (such as numpy and sympy), so I decided to try writing a python script to generate the node equations based on the old C code I had written many years before. Part way into this project I discovered that there is a new nodal analysis technique being taught today in engineering school called The modified nodal approach to network analysis. My motivation for reviving this coding project is my continued interest in circuit analysis and synthesis.\nThe modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Some of my younger colleagues at work were taught this method, but I never heard of it until a short time ago. These days, I never really analyze a circuit by hand, unless it’s so simple that you can almost do it by inspection. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. LTSpice is the version of spice that I use, since it’s free and does a good job converging when analyzing switching circuits.\nMy code started initially by following Erik Cheever’s Analysis of Resistive Circuits MATLAB code, to generate modified nodal equations. I somewhat followed his MATLAB file for resistors, capacitors, opamps and independent sources. The naming of the matrices follows his convention. The preprocessor and parser code was converted from my old C code. The use of Pandas for a data frame is new and SymPy is used to do the math and the use of element stamps is from ECE 570 Session 3, Computer Aided Engineering for Integrated Circuits .\nInductors are being addressed in the D matrix, which is different than the way Erik Cheever’s code works. Erik’s code puts inductors into the G matrix as 1/s/L. My code puts the inductor contribution into the D matrix. Coupled inductors also affect the D matrix, so it makes sense to allow the inductors to be in the D matrix rather than the G matrix.\nSurvey of other symbolic circuit analysis code: The python code presented in this notebook is somewhat unique since python is open source, free and runs on a variety of platforms, the code presented in this ipython notebook is portable. As described below, this code is made available under a public domain licence and archived in a github repository.\nThere are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, TINA and Maple.\nSLiCAP is a symbolic linear analysis tool. SLiCAP runs in MATLAB.\nTINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some symbolic analysis capability.\nMaple is a mathematical package and there is an application notes available describing it use in symbolic circuit analysis. The application note presents an method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.\nSymbolic Circuit Analysis is a web page devoted to symbolic circuit analysis.\nSAPWIN is a windows program package for symbolic and numerical simulation of analog circuits.\nLcapy is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics."
  },
  {
    "objectID": "Introduction.html#what-you-will-learn",
    "href": "Introduction.html#what-you-will-learn",
    "title": "1  Introduction",
    "section": "1.1 What you will learn",
    "text": "1.1 What you will learn"
  },
  {
    "objectID": "Introduction.html#how-this-book-is-organized",
    "href": "Introduction.html#how-this-book-is-organized",
    "title": "1  Introduction",
    "section": "1.2 How this book is organized",
    "text": "1.2 How this book is organized"
  },
  {
    "objectID": "Introduction.html#what-you-wont-learn",
    "href": "Introduction.html#what-you-wont-learn",
    "title": "1  Introduction",
    "section": "1.3 What you won’t learn",
    "text": "1.3 What you won’t learn\nThere are several important topics that this book doesn’t cover. We believe it’s important to stay ruthlessly focused on the essentials so you can get up and running as quickly as possible. That means this book can’t cover every important topic.\n\n1.3.1 Modeling\nModeling is super important for data science, but it’s a big topic, and unfortunately, we just don’t have the space to give it the coverage it deserves here. To learn more about modeling, we highly recommend Tidy Modeling with R by our colleagues Max Kuhn and Julia Silge. This book will teach you the tidymodels family of packages, which, as you might guess from the name, share many conventions with the tidyverse packages we use in this book.\n\n\n1.3.2 Big data\nThis book proudly and primarily focuses on small, in-memory datasets. This is the right place to start because you can’t tackle big data unless you have experience with small data. The tools you’ll learn throughout the majority of this book will easily handle hundreds of megabytes of data, and with a bit of care, you can typically use them to work with a few gigabytes of data. We’ll also show you how to get data out of databases and parquet files, both of which are often used to store big data. You won’t necessarily be able to work with the entire dataset, but that’s not a problem because you only need a subset or subsample to answer the question that you’re interested in.\nIf you’re routinely working with larger data (10–100 GB, say), we recommend learning more about data.table. We don’t teach it here because it uses a different interface than the tidyverse and requires you to learn some different conventions. However, it is incredibly faster, and the performance payoff is worth investing some time in learning it if you’re working with large data.\n\n\n1.3.3 Python, Julia, and friends\nIn this book, you won’t learn anything about Python, Julia, or any other programming language useful for data science. This isn’t because we think these tools are bad. They’re not! And in practice, most data science teams use a mix of languages, often at least R and Python. But we strongly believe that it’s best to master one tool at a time, and R is a great place to start."
  },
  {
    "objectID": "Introduction.html#prerequisites",
    "href": "Introduction.html#prerequisites",
    "title": "1  Introduction",
    "section": "1.5 Prerequisites",
    "text": "1.5 Prerequisites"
  },
  {
    "objectID": "Introduction.html#footnotes",
    "href": "Introduction.html#footnotes",
    "title": "1  Introduction",
    "section": "",
    "text": "If you’d like a comprehensive overview of all of RStudio’s features, see the RStudio User Guide at https://docs.posit.co/ide/user.↩︎"
  },
  {
    "objectID": "Verification.html#validation-test-circuits",
    "href": "Verification.html#validation-test-circuits",
    "title": "Code Verification",
    "section": "Validation Test Circuits",
    "text": "Validation Test Circuits\nThis folder contains the test circuits used to validate the network analysis code. The code was validated under the following enviroment:\nmight want new names rather than test_1\nBasic validation of the code consisted of analyzing simple networks and examining the results. A more comprehensive evaluation of the code was performed by solving test circuits and comparing the results to LTSpice. As of October 2023 all the element types have been tested. The validation circuits range from simple to large and complex. The largest validation circuit consist of 32 nodes, 59 branches and multiple instances all of the element types. For this large test circuit, there are small numerical differences between the Python MNA code results and the LTSpice solution, which are describe in the JupyterLab notebooks.\nThe table below lists the test circuits used to validate and test the code. Each test circuit has it’s own folder with the support files. The test circuits are a collection of problems from text books or large and complex circuits that I made up that include various elements or unique combinations of elements or topologies. In LTSpice the series resistance for inductors defaults to 1e-3 Ohms unless set to zero. Leaving the default series inductance at 1e-3 Ohms will cause small numerical differences in the solution obtained by LTSpice.\n\n\n\n\n\n\n\n\nTest file\nCircuit Description\nnotes\n\n\n\n\ntest_1\nResistors, independent and dependent sources\nDC analysis\n\n\ntest_2\nResistors and independent sources\nDC analysis\n\n\ntest_3\nSame circuit as test_1, but with R2 replaced with C2 and R3 replaced with L1.\nAC analysis\n\n\ntest_4\nResistors and one of each type of source\nAC analysis\n\n\ntest_5\nRLC and one of each type of source\nAC analysis\n\n\ntest_6\nRLC, coupled inductors and one of each type of source\nAC analysis\n\n\ntest_7\nLarge circuit and two or more of each element type w/o Op Amps\nAC analysis\n\n\ntest_8\nTest_7 w/ op amps included\nAC analysis\n\n\ntest_9\nCurrent sources only dependent and independent\nDC analysis\n\n\ntest_10\nCurrent and voltage sources only, no LRCs\nDC analysis\n\n\ntest_11\nThree coupled inductors\nAC analysis\n\n\ntest_12\nLC ladder low pass filter\nAC analysis\n\n\ntest_13\nRing of current sources and inductors\nAC analysis\n\n\n\n\\(\\large{\\color {red} {\\text{Spelling and grammer of the jupyter notebooks has not been completed}}}\\)\nThe following file types are in each folder:\n\n\n\nfile name\nDescription\n\n\n\n\ntest_*.asc\nLTSpice circuit schematic\n\n\nreadme.md\na description of the circuit\n\n\ntest_*.ipynb\ntest report Jupyter notebook\n\n\ntest_*.net\nSpice net list\n\n\ntest_*.png\nimage of the schematic for display in the notebook\n\n\ntest_*.csv\ncsv data exported from LTSpice"
  },
  {
    "objectID": "Problems.html",
    "href": "Problems.html",
    "title": "Problems",
    "section": "",
    "text": "In the Jupyter notebooks, don’t manually number headings, since these are auto numbered in a quarto book. What about a we page? No. \nCould rename page to Examples.\n\n\n\n\n\n\n\nCircuit Description\nnotes\n\n\n\n\nState variable filter: LP, HP, BP\nSee filter handbook, design a filter with normalized values, do the analysis and then scale the values and re-analyze. Need to re-order net list with V1 and op amp first still need to compare with LTSpice\n\n\nActive filters\nSeveral of these started Sallen–Key topology https://en.wikipedia.org/wiki/Sallen%E2%80%93Key_topology\n\n\nActive inductor Nullors, Gyrators, NICs, Current Conveyor\nWhere are these used? Controlled Sources, Nullors, Active Gain Devices, Impedance Converters and Inverters (Gyrators, NICs, Current Conveyors) See Op Amp circuit #2 or #2HP See Haydak Chapter 13, for RC-NIC and RC gyrator filters\n\n\nTwo amplifier RIAA Phone Preamp\nInclude error budget look at synthesis from transfer functio\n\n\nWien bridge oscillator\nhttps://en.wikipedia.org/wiki/Wien_bridge_oscillator Simple circuit not so easy to make osc in LTSpice. Notebook started\n\n\nChua’s circuit\nSee circuit analysis folder under jupyterlab https://en.wikipedia.org/wiki/Chua’s_circuit\n\n\nSwitched mode power supply\nDo the LED driver fly back circuit, see Analog Devices power management tools, https://www.analog.com/en/design-center/design-tools-and-calculators/power-management-tools.html\n\n\nPi filter transfer function\n\n\n\nBridge-T network analysis\n\n\n\nT-coil circuit\nSee papers in download folder\n\n\nDiode circuit\nGet network equations with R in place of diode and then substitute equations for diode in python\n\n\nTransistor circuit\nGet network equations with R’s in place of transistor and then substitute equations in python Or look at an Op Amp model that can have C in the feed back loop\n\n\nTone control circuit of link\nhttps://sound-au.com/project27.htm"
  },
  {
    "objectID": "Appendices.html",
    "href": "Appendices.html",
    "title": "Appendices",
    "section": "",
    "text": "Appendices: In the creative arts and scientific literature, an acknowledgement (also spelled acknowledgment in American and Canadian English[1]) is an expression of gratitude for assistance in creating an original work."
  },
  {
    "objectID": "Acknowledgments.html",
    "href": "Acknowledgments.html",
    "title": "20  Acknowledgments",
    "section": "",
    "text": "Acknowledgments: In the creative arts and scientific literature, an acknowledgement (also spelled acknowledgment in American and Canadian English[1]) is an expression of gratitude for assistance in creating an original work."
  },
  {
    "objectID": "Bibliography.html",
    "href": "Bibliography.html",
    "title": "21  Bibliography",
    "section": "",
    "text": "Bibliography: When you are gathering book sources, be sure to make note of the following bibliographic items: the author name(s), other contributors such as translators or editors, the book’s title, editions of the book, the publication date, the publisher, and the pagination."
  },
  {
    "objectID": "test_1.html#symbolic-solution",
    "href": "test_1.html#symbolic-solution",
    "title": "4  test_1",
    "section": "4.1 Symbolic solution",
    "text": "4.1 Symbolic solution\n\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- I_{1} R_{1} R_{2} ea_{1} f_{1} + I_{1} R_{1} R_{2} ea_{1} - I_{1} R_{1} R_{2} f_{1} + I_{1} R_{1} R_{2} + I_{1} R_{1} R_{4} ea_{1} + I_{1} R_{1} R_{4} + R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} f_{1} + R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} f_{1} + R_{2} V_{1} f_{1} - R_{2} V_{1} + R_{3} V_{1} f_{1} + R_{3} V_{2} f_{1} - R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}, \\  I_{F1} : \\frac{V_{1} f_{1} + V_{2} f_{1}}{R_{2} f_{1} - R_{2} - R_{4}}, \\  I_{V1} : \\frac{- I_{1} R_{2} R_{3} f_{1} + I_{1} R_{2} R_{3} + I_{1} R_{3} R_{4} - R_{1} V_{1} ea_{1} f_{1} + R_{1} V_{1} ea_{1} - R_{1} V_{1} f_{1} + R_{1} V_{1} - R_{1} V_{2} ea_{1} f_{1} + R_{1} V_{2} ea_{1} - R_{1} V_{2} f_{1} + R_{1} V_{2} - R_{2} V_{1} f_{1} + R_{2} V_{1} - R_{3} V_{1} f_{1} + R_{3} V_{1} - R_{3} V_{2} f_{1} + R_{3} V_{2} + R_{4} V_{1}}{R_{1} R_{2} ea_{1} f_{1} - R_{1} R_{2} ea_{1} + R_{1} R_{2} f_{1} - R_{1} R_{2} - R_{1} R_{4} ea_{1} - R_{1} R_{4} + R_{2} R_{3} f_{1} - R_{2} R_{3} - R_{3} R_{4}}, \\  I_{V2} : \\frac{V_{1} + V_{2}}{R_{2} f_{1} - R_{2} - R_{4}}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{- R_{2} V_{2} f_{1} + R_{2} V_{2} - R_{4} V_{1}}{R_{2} f_{1} - R_{2} - R_{4}}, \\  v_{3} : \\frac{I_{1} R_{1} R_{3} ea_{1} + R_{1} V_{1} ea_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}, \\  v_{4} : \\frac{- I_{1} R_{1} R_{3} + R_{1} V_{1} ea_{1} + R_{3} V_{1}}{R_{1} ea_{1} + R_{1} + R_{3}}, \\  v_{5} : - V_{2}\\right\\}\\)\n\n\n\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\nv₁ = V₁\n     -R₂⋅V₂⋅f₁ + R₂⋅V₂ - R₄⋅V₁\nv₂ = ─────────────────────────\n          R₂⋅f₁ - R₂ - R₄     \n     I₁⋅R₁⋅R₃⋅ea₁ + R₁⋅V₁⋅ea₁\nv₃ = ────────────────────────\n         R₁⋅ea₁ + R₁ + R₃    \n     -I₁⋅R₁⋅R₃ + R₁⋅V₁⋅ea₁ + R₃⋅V₁\nv₄ = ─────────────────────────────\n            R₁⋅ea₁ + R₁ + R₃      \nv₅ = -V₂\n       -I₁⋅R₂⋅R₃⋅f₁ + I₁⋅R₂⋅R₃ + I₁⋅R₃⋅R₄ - R₁⋅V₁⋅ea₁⋅f₁ + R₁⋅V₁⋅ea₁ - R₁⋅V₁⋅f\nI_V1 = ───────────────────────────────────────────────────────────────────────\n                                                          R₁⋅R₂⋅ea₁⋅f₁ - R₁⋅R₂\n\n₁ + R₁⋅V₁ - R₁⋅V₂⋅ea₁⋅f₁ + R₁⋅V₂⋅ea₁ - R₁⋅V₂⋅f₁ + R₁⋅V₂ - R₂⋅V₁⋅f₁ + R₂⋅V₁ - R\n──────────────────────────────────────────────────────────────────────────────\n⋅ea₁ + R₁⋅R₂⋅f₁ - R₁⋅R₂ - R₁⋅R₄⋅ea₁ - R₁⋅R₄ + R₂⋅R₃⋅f₁ - R₂⋅R₃ - R₃⋅R₄        \n\n₃⋅V₁⋅f₁ + R₃⋅V₁ - R₃⋅V₂⋅f₁ + R₃⋅V₂ + R₄⋅V₁\n──────────────────────────────────────────\n                                          \n           V₁ + V₂    \nI_V2 = ───────────────\n       R₂⋅f₁ - R₂ - R₄\n        -I₁⋅R₁⋅R₂⋅ea₁⋅f₁ + I₁⋅R₁⋅R₂⋅ea₁ - I₁⋅R₁⋅R₂⋅f₁ + I₁⋅R₁⋅R₂ + I₁⋅R₁⋅R₄⋅ea\nI_Ea1 = ──────────────────────────────────────────────────────────────────────\n                                                       R₁⋅R₂⋅ea₁⋅f₁ - R₁⋅R₂⋅ea\n\n₁ + I₁⋅R₁⋅R₄ + R₁⋅V₁⋅ea₁⋅f₁ + R₁⋅V₁⋅f₁ + R₁⋅V₂⋅ea₁⋅f₁ + R₁⋅V₂⋅f₁ + R₂⋅V₁⋅f₁ - \n──────────────────────────────────────────────────────────────────────────────\n₁ + R₁⋅R₂⋅f₁ - R₁⋅R₂ - R₁⋅R₄⋅ea₁ - R₁⋅R₄ + R₂⋅R₃⋅f₁ - R₂⋅R₃ - R₃⋅R₄           \n\nR₂⋅V₁ + R₃⋅V₁⋅f₁ + R₃⋅V₂⋅f₁ - R₄⋅V₁\n───────────────────────────────────\n                                   \n        V₁⋅f₁ + V₂⋅f₁ \nI_F1 = ───────────────\n       R₂⋅f₁ - R₂ - R₄"
  },
  {
    "objectID": "test_1.html#numeric-solution",
    "href": "test_1.html#numeric-solution",
    "title": "4  test_1",
    "section": "4.2 Numeric solution",
    "text": "4.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nelement_values = {R1:2,R2:1,R3:1,R4:2,V1:2,V2:0,I1:9,f1:2,ea1:2}\nequ1a = equ.subs(element_values)\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + \\frac{3 v_{1}}{2} - v_{2} - \\frac{v_{4}}{2}\\\\I_{F1} - v_{1} + \\frac{3 v_{2}}{2} - \\frac{v_{5}}{2}\\\\I_{Ea1} - I_{F1} + v_{3} - v_{4}\\\\- \\frac{v_{1}}{2} - v_{3} + \\frac{3 v_{4}}{2}\\\\- I_{V2} - \\frac{v_{2}}{2} + \\frac{v_{5}}{2}\\\\v_{1}\\\\- v_{5}\\\\- 2 v_{1} + v_{3} + 2 v_{4}\\\\I_{F1} - 2 I_{V2}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\-9\\\\0\\\\2\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve the equations for voltages and currents.\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : - \\frac{80}{7}, \\  I_{F1} : -4, \\  I_{V1} : \\frac{3}{7}, \\  I_{V2} : -2, \\  v_{1} : 2, \\  v_{2} : 4, \\  v_{3} : \\frac{44}{7}, \\  v_{4} : - \\frac{8}{7}, \\  v_{5} : 0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:s}: {:f}'.format(str(name),float(value)))\n    #print(name,value)\n\nv1: 2.000000\nv2: 4.000000\nv3: 6.285714\nv4: -1.142857\nv5: 0.000000\nI_V1: 0.428571\nI_V2: -2.000000\nI_Ea1: -11.428571\nI_F1: -4.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n       --- Operating Point ---\n\nV(1):    2      voltage\nV(2):    4      voltage\nV(4):    -1.14286   voltage\nV(3):    6.28571    voltage\nV(5):    0      voltage\nI(F1):   -4     device_current\nI(I1):   9      device_current\nI(R2):   -2     device_current\nI(R3):   -7.42857   device_current\nI(R4):   2      device_current\nI(R1):   1.57143    device_current\nI(E1):   -11.4286   device_current\nI(V1):   0.428571   device_current\nI(V2):   -2     device_current\nThe results from LTSpice agree with the SymPy results.\nCurrents through the resistors must be calculated by hand. For example:\n\nprint('I(R1): {:f}'.format(float((ans[v1]-ans[v4])/element_values[R1])))\n\nI(R1): 1.571429"
  },
  {
    "objectID": "test_2.html#symbolic-solution",
    "href": "test_2.html#symbolic-solution",
    "title": "5  test_2",
    "section": "5.1 Symbolic solution",
    "text": "5.1 Symbolic solution\nSymbolic solution for this test case takes too long.\nans = solve(equ,X) ans\nleft_side = list(ans.keys()) right_side = list(ans.values())\nfor i in range(len(ans)): pprint(Eq(left_side[i],right_side[i]))"
  },
  {
    "objectID": "test_2.html#numeric-solution",
    "href": "test_2.html#numeric-solution",
    "title": "5  test_2",
    "section": "5.2 Numeric solution",
    "text": "5.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nequ1a = equ.subs({\n    R1:5.000000,\n    R2:2.000000,\n    R5:3.000000,\n    R6:5.000000,\n    R8:8.000000,\n    R10:9.000000,\n    R11:4.000000,\n    R12:2.000000,\n    R14:10.000000,\n    R15:5.000000,\n    V1:10.000000,\n    V2:2.000000,\n    V3:3.000000,\n    V4:5.000000,\n    I1:3.000000,\n    I2:1.000000,\n    I3:2.000000,\n    I4:2.000000,\n    R7:10.000000,\n    R16:6.000000,\n    R3:10.000000,\n    R4:3.000000})\n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{5}\\\\- 0.5 v_{1} + 1.03333333333333 v_{2} - 0.333333333333333 v_{6}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\- 0.333333333333333 v_{3} + 0.433333333333333 v_{4} - 0.1 v_{8}\\\\- 0.5 v_{1} + 0.95 v_{5} - 0.25 v_{6} - 0.2 v_{9}\\\\- 0.333333333333333 v_{2} - 0.25 v_{5} + 0.683333333333333 v_{6} - 0.1 v_{7}\\\\I_{V3} + I_{V4} - 0.1 v_{6} + 0.225 v_{7} - 0.125 v_{8}\\\\- 0.1 v_{4} - 0.125 v_{7} + 0.225 v_{8}\\\\I_{V1} - 0.111111111111111 v_{10} - 0.2 v_{5} + 0.311111111111111 v_{9}\\\\0.311111111111111 v_{10} - 0.2 v_{11} - 0.111111111111111 v_{9}\\\\- I_{V4} - 0.2 v_{10} + 0.3 v_{11} - 0.1 v_{12}\\\\- 0.1 v_{11} + 0.1 v_{12}\\\\v_{9}\\\\v_{1}\\\\- v_{3} + v_{7}\\\\- v_{11} + v_{7}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\-1.0\\\\1.0\\\\-3.0\\\\0\\\\2.0\\\\0\\\\-2.0\\\\0\\\\-2.0\\\\0\\\\2.0\\\\10.0\\\\2.0\\\\3.0\\\\5.0\\end{matrix}\\right]\\)\n\n\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{V1} : -3.16590349152627, \\  I_{V2} : 0.970285941816191, \\  I_{V3} : 1.07959596749632, \\  I_{V4} : -2.0475200955628, \\  v_{1} : 2.0, \\  v_{10} : -8.4276808600652, \\  v_{11} : -8.6652813378792, \\  v_{12} : 11.3347186621208, \\  v_{2} : 1.53248886344972, \\  v_{3} : -6.6652813378792, \\  v_{4} : -16.2367099093078, \\  v_{5} : 4.40808302018266, \\  v_{6} : 4.75071547669412, \\  v_{7} : -3.6652813378792, \\  v_{8} : -18.1414718140697, \\  v_{9} : 10.0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:5s}: {:11.5f}'.format(str(name),float(value)))\n    #print(name,value)\n\nv1   :     2.00000\nv2   :     1.53249\nv3   :    -6.66528\nv4   :   -16.23671\nv5   :     4.40808\nv6   :     4.75072\nv7   :    -3.66528\nv8   :   -18.14147\nv9   :    10.00000\nv10  :    -8.42768\nv11  :    -8.66528\nv12  :    11.33472\nI_V1 :    -3.16590\nI_V2 :     0.97029\nI_V3 :     1.07960\nI_V4 :    -2.04752\n\n\nThe results agree with the LTSpice answers.\n       --- Operating Point ---\n\nV(9):    10  voltage\nV(5):    4.40808     voltage\nV(1):    2   voltage\nV(6):    4.75072     voltage\nV(2):    1.53249     voltage\nV(8):    -18.1415    voltage\nV(7):    -3.66528    voltage\nV(10):   -8.42768    voltage\nV(11):   -8.66528    voltage\nV(3):    -6.66528    voltage\nV(4):    -16.2367    voltage\nV(12):   11.3347     voltage\nI(I1):   3   device_current\nI(I2):   1   device_current\nI(I3):   2   device_current\nI(I4):   2   device_current\nI(R1):   1.11838     device_current\nI(R2):   1.20404     device_current\nI(R5):   1.07274     device_current\nI(R6):   0.306498    device_current\nI(R8):   -1.80952    device_current\nI(R10):  -2.04752    device_current\nI(R11):  0.0856581   device_current\nI(R12):  -0.233756   device_current\nI(R14):  -0.8416     device_current\nI(R15):  -0.0475201  device_current\nI(R7):   -0.190476   device_current\nI(R16):  -1.11088    device_current\nI(R3):   2   device_current\nI(R4):   -3.19048    device_current\nI(V1):   -3.1659     device_current\nI(V2):   0.970286    device_current\nI(V3):   1.0796  device_current\nI(V4):   -2.04752    device_current"
  },
  {
    "objectID": "Theory.html",
    "href": "Theory.html",
    "title": "2  Theory",
    "section": "",
    "text": "what is circuit analysis?\nhistory of circuit analysis\ntypes of circuit analysis\nMNA\nSymbolic MNA\n\nNetwork analysis (electrical circuits)\nIn electrical engineering and electronics, a network is a collection of interconnected components. Network analysis is the process of finding the voltages across, and the currents through, all network components. There are many techniques for calculating these values; however, for the most part, the techniques assume linear components. Except where stated, the methods described in this article are applicable only to linear network analysis.\nKirchhoff’s circuit laws Kirchhoff’s circuit laws are two equalities that deal with the current and potential difference (commonly known as voltage) in the lumped element model of electrical circuits. They were first described in 1845 by German physicist Gustav Kirchhoff.[1] This generalized the work of Georg Ohm and preceded the work of James Clerk Maxwell. Widely used in electrical engineering, they are also called Kirchhoff’s rules or simply Kirchhoff’s laws. These laws can be applied in time and frequency domains and form the basis for network analysis.\nMesh analysis Mesh analysis (or the mesh current method) is a circuit analysis method for planar circuits. Planar circuits are circuits that can be drawn on a plane surface with no wires crossing each other. A more general technique, called loop analysis (with the corresponding network variables called loop currents) can be applied to any circuit, planar or not[citation needed]. Mesh analysis and loop analysis both make systematic use of Kirchhoff’s voltage law to arrive at a set of equations guaranteed to be solvable if the circuit has a solution.[1] Mesh analysis is usually easier to use when the circuit is planar, compared to loop analysis.[2]\nCircuit topology (electrical) The circuit topology of an electronic circuit is the form taken by the network of interconnections of the circuit components. Different specific values or ratings of the components are regarded as being the same topology. Topology is not concerned with the physical layout of components in a circuit, nor with their positions on a circuit diagram; similarly to the mathematical concept of topology, it is only concerned with what connections exist between the components. There may be numerous physical layouts and circuit diagrams that all amount to the same topology.\nModified nodal analysis\nIn electrical engineering, modified nodal analysis[1] or MNA is an extension of nodal analysis which not only determines the circuit’s node voltages (as in classical nodal analysis), but also some branch currents. Modified nodal analysis was developed as a formalism to mitigate the difficulty of representing voltage-defined components in nodal analysis (e.g. voltage-controlled voltage sources). It is one such formalism. Others, such as sparse tableau formulation,[2] are equally general and related via matrix transformations.\nThe Modified Nodal Approach to Network Analysis\nChung-Wen Ho, A. Ruehli and P. Brennan, “The modified nodal approach to network analysis,” in IEEE Transactions on Circuits and Systems, vol. 22, no. 6, pp. 504-509, June 1975, doi: 10.1109/TCS.1975.1084079.\nAbstract: The nodal method has been widely used for formulating circuit equations in computer-aided network analysis and design programs. However, several limitations exist in this method including the inability to process voltage sources and current-dependent circuit elements in a simple and efficient manner. A modified nodal analysis (MNA) method is proposed here which retains the simplicity and other advantages of nodal analysis while removing its limitations. A simple and effective pivoting scheme is also given. Numerical examples are used to compare the MNA method with the tableau method. Favorable results are observed for the MNA method in terms of the dimension, number of nonzeros, and fill-ins for comparable circuit matrices.\nReferences\nHo, Ruehli, and Brennan (April 1974). “The Modified Nodal Approach to Network Analysis”. Proc. 1974 Int. Symposium on Circuits and Systems, San Francisco. pp. 505–509. doi:10.1109/TCS.1975.1084079.\nHachtel, G., Brayton, R, and Gustavson, F. (January 1971). “The Sparse Tableau Approach to Network Analysis and Design”. IEEE Transactions on Circuit Theory. 18 (1): 101–113. doi:10.1109/TCT.1971.1083223.\nCheng, Chung-Kuan. Lecture Notes for CSE245: Computer-Aided Circuit Simulation and Verification. Spring 2006. Lecture 1.\nModified Nodal Analysis Behind SLiCAP\nOn the modified nodal approach to network analysis\nKirchhoff’s Current Law (KCL) is also known as Kirchhoff’s first law,\nHow to Use Mesh Current Analysis"
  },
  {
    "objectID": "SMNA_example.html#abstract",
    "href": "SMNA_example.html#abstract",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "Abstract",
    "text": "Abstract\nThis JupyterLab notebook uses the SymPy, NumPy,SciPy and the Python programming language libraries to analyize an electrical circuit. A circuit analysis method called the Modified Nodal Analysis was used to derive the symbolic circuit equations and Python libraries were used to solve the equations. The purpose of this analysis is to demonstrate the capability of using the Python libraries in electrical engineering circuit analysis. A link to my Jupyter Notebook rendered as a web page is here."
  },
  {
    "objectID": "SMNA_example.html#circuit-description",
    "href": "SMNA_example.html#circuit-description",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.1 Circuit description",
    "text": "3.1 Circuit description\nThe schematic of the circuit is shown below with each node explicity annotated. The circuit has 9 lines in netlist, 9 branches and 5 unknown currents.\n\nThe net list for this circuit is:\nR2 2 5 2\nV1 1 0 1\nI1 4 0 0\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\nC1 1 2 1\nL1 4 3 1\nI1 has been set to zero for the AC analysis.\n\nimport os\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\nimport pandas as pd\ninit_printing()"
  },
  {
    "objectID": "SMNA_example.html#symbolic-mna-code",
    "href": "SMNA_example.html#symbolic-mna-code",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.2 Symbolic MNA code",
    "text": "3.2 Symbolic MNA code\n\n# initialize variables\nnum_rlc = 0 # number of passive elements\nnum_ind = 0 # number of inductors\nnum_v = 0    # number of independent voltage sources\nnum_i = 0    # number of independent current sources\ni_unk = 0  # number of current unknowns\nnum_opamps = 0   # number of op amps\nnum_vcvs = 0     # number of controlled sources of various types\nnum_vccs = 0\nnum_cccs = 0\nnum_ccvs = 0\nnum_cpld_ind = 0 # number of coupled inductors"
  },
  {
    "objectID": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "href": "SMNA_example.html#read-the-net-list-and-preprocess-it",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.3 Read the net list and preprocess it",
    "text": "3.3 Read the net list and preprocess it\nThe following steps are performed:\n\nremove blank lines and comments\n\nconvert first letter of element name to upper case\n\nremoves extra spaces between entries\n\ncount number of entries on each line, make sure the count is correct, count each element type\n\n\nexample_net_list = '''R2 2 5 2\nV1 1 0 1\nI1 4 0 0\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 V2 2\nR1 1 4 2\nC1 1 2 1\nL1 4 3 1'''\n\n\ncontent = example_net_list.splitlines()\n\ncontent = [x.strip() for x in content]  #remove leading and trailing white space\n# remove empty lines\nwhile '' in content:\n    content.pop(content.index(''))\n\n# remove comment lines, these start with a asterisk *\ncontent = [n for n in content if not n.startswith('*')]\n# remove other comment lines, these start with a semicolon ;\ncontent = [n for n in content if not n.startswith(';')]\n# remove spice directives, these start with a period, .\ncontent = [n for n in content if not n.startswith('.')]\n# converts 1st letter to upper case\n#content = [x.upper() for x in content] &lt;- this converts all to upper case\ncontent = [x.capitalize() for x in content]\n# removes extra spaces between entries\ncontent = [' '.join(x.split()) for x in content]\n\n\nfor i in content:\n    print(i)\n\nR2 2 5 2\nV1 1 0 1\nI1 4 0 0\nV2 0 5 0\nE1 3 0 1 4 2\nF1 2 3 v2 2\nR1 1 4 2\nC1 1 2 1\nL1 4 3 1\n\n\n\nline_cnt = len(content) # number of lines in the netlist\nbranch_cnt = 0  # number of branches in the netlist\n# check number of entries on each line, count each element type\nfor i in range(line_cnt):\n    x = content[i][0]\n    tk_cnt = len(content[i].split()) # split the line into a list of words\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_rlc += 1\n        branch_cnt += 1\n        if x == 'L':\n            num_ind += 1\n    elif x == 'V':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_v += 1\n        branch_cnt += 1\n    elif x == 'I':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_i += 1\n        branch_cnt += 1\n    elif x == 'O':\n        if tk_cnt != 4:\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_opamps += 1\n    elif x == 'E':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vcvs += 1\n        branch_cnt += 1\n    elif x == 'G':\n        if (tk_cnt != 6):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 6\".format(tk_cnt))\n        num_vccs += 1\n        branch_cnt += 1\n    elif x == 'F':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_cccs += 1\n        branch_cnt += 1\n    elif x == 'H':\n        if (tk_cnt != 5):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 5\".format(tk_cnt))\n        num_ccvs += 1\n        branch_cnt += 1\n    elif x == 'K':\n        if (tk_cnt != 4):\n            print(\"branch {:d} not formatted correctly, {:s}\".format(i,content[i]))\n            print(\"had {:d} items and should only be 4\".format(tk_cnt))\n        num_cpld_ind += 1\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))"
  },
  {
    "objectID": "SMNA_example.html#parser",
    "href": "SMNA_example.html#parser",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.4 Parser",
    "text": "3.4 Parser\nThe parser performs the following operations.\n\nputs branch elements into data frame\n\ncounts number of nodes\n\ndata frame labels:\n\nelement: type of element\n\np node: positive node\n\nn node: negative node, for a current source, the arrow point terminal, LTspice puts the inductor phasing dot on this terminal\n\ncp node: controlling positive node of branch\n\ncn node: controlling negative node of branch\n\nVout: opamp output node\n\nvalue: value of element or voltage\n\nVname: voltage source through which the controlling current flows. Need to add a zero volt voltage source to the controlling branch.\n\nLname1: name of coupled inductor 1\n\nLname2: name of coupled inductor 2\n\n\n# build the pandas data frame\ndf = pd.DataFrame(columns=['element','p node','n node','cp node','cn node',\n    'Vout','value','Vname','Lname1','Lname2'])\n\n# this data frame is for branches with unknown currents\ndf2 = pd.DataFrame(columns=['element','p node','n node'])\n\n\n3.4.1 Functions to load branch elements into data frame and check for gaps in node numbering\n\n# loads voltage or current sources into branch structure\ndef indep_source(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads passive elements into branch structure\ndef rlc_element(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# loads multi-terminal elements into branch structure\n# O - Op Amps\ndef opamp_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vout'] = int(tk[3])\n\n# G - VCCS\ndef vccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# E - VCVS\n# in sympy E is the number 2.718, replacing E with Ea otherwise, sympify() errors out\ndef vcvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0].replace('E', 'Ea')\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'cp node'] = int(tk[3])\n    df.loc[line_nu,'cn node'] = int(tk[4])\n    df.loc[line_nu,'value'] = float(tk[5])\n\n# F - CCCS\ndef cccs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# H - CCVS\ndef ccvs_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'p node'] = int(tk[1])\n    df.loc[line_nu,'n node'] = int(tk[2])\n    df.loc[line_nu,'Vname'] = tk[3].capitalize()\n    df.loc[line_nu,'value'] = float(tk[4])\n\n# K - Coupled inductors\ndef cpld_ind_sub_network(line_nu):\n    tk = content[line_nu].split()\n    df.loc[line_nu,'element'] = tk[0]\n    df.loc[line_nu,'Lname1'] = tk[1].capitalize()\n    df.loc[line_nu,'Lname2'] = tk[2].capitalize()\n    df.loc[line_nu,'value'] = float(tk[3])\n\n# function to scan df and get largest node number\ndef count_nodes():\n    # need to check that nodes are consecutive\n    # fill array with node numbers\n    p = np.zeros(line_cnt+1)\n    for i in range(line_cnt):\n        # need to skip coupled inductor 'K' statements\n        if df.loc[i,'element'][0] != 'K': #get 1st letter of element name\n            p[df['p node'][i]] = df['p node'][i]\n            p[df['n node'][i]] = df['n node'][i]\n\n    # find the largest node number\n    if df['n node'].max() &gt; df['p node'].max():\n        largest = df['n node'].max()\n    else:\n        largest =  df['p node'].max()\n\n    largest = int(largest)\n    # check for unfilled elements, skip node 0\n    for i in range(1,largest):\n        if p[i] == 0:\n            print('nodes not in continuous order, node {:.0f} is missing'.format(p[i-1]+1))\n\n    return largest\n\n\n\n3.4.2 Load circuit netlist into the data frames\n\n# load branch info into data frame\nfor i in range(line_cnt):\n    x = content[i][0]\n\n    if (x == 'R') or (x == 'L') or (x == 'C'):\n        rlc_element(i)\n    elif (x == 'V') or (x == 'I'):\n        indep_source(i)\n    elif x == 'O':\n        opamp_sub_network(i)\n    elif x == 'E':\n        vcvs_sub_network(i)\n    elif x == 'G':\n        vccs_sub_network(i)\n    elif x == 'F':\n        cccs_sub_network(i)\n    elif x == 'H':\n        ccvs_sub_network(i)\n    elif x == 'K':\n        cpld_ind_sub_network(i)\n    else:\n        print(\"unknown element type in branch {:d}, {:s}\".format(i,content[i]))\n\n29 Nov 2023: When the D matrix is built, independent voltage sources are processed in the data frame order when building the D matrix. If the voltage source followed element L, H, F, K types in the netlist, a row was inserted that put the voltage source in a different row in relation to its position in the Ev matrix. This would cause the node attached to the terminal of the voltage source to be zero volts.\nSolution - The following block of code was added to move voltage source types to the beginning of the net list dataframe before any calculations are performed.\n\n# Check for position of voltages sources in the dataframe.\nsource_index = [] # keep track of voltage source row number\nother_index = [] # make a list of all other types\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V'):\n        source_index.append(i)\n    else:\n        other_index.append(i)\n\ndf = df.reindex(source_index+other_index,copy=True) # re-order the data frame\ndf.reset_index(drop=True, inplace=True) # renumber the index\n\n\n# count number of nodes\nnum_nodes = count_nodes()\n\n# Build df2: consists of branches with current unknowns, used for C & D matrices\n# walk through data frame and find these parameters\ncount = 0\nfor i in range(len(df)):\n    # process all the elements creating unknown currents\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'L') or (x == 'V') or (x == 'O') or (x == 'E') or (x == 'H') or (x == 'F'):\n        df2.loc[count,'element'] = df.loc[i,'element']\n        df2.loc[count,'p node'] = df.loc[i,'p node']\n        df2.loc[count,'n node'] = df.loc[i,'n node']\n        count += 1"
  },
  {
    "objectID": "SMNA_example.html#print-net-list-report",
    "href": "SMNA_example.html#print-net-list-report",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.5 Print net list report",
    "text": "3.5 Print net list report\n\n# print a report\nprint('Net list report')\nprint('number of lines in netlist: {:d}'.format(line_cnt))\nprint('number of branches: {:d}'.format(branch_cnt))\nprint('number of nodes: {:d}'.format(num_nodes))\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are current unknows\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_cccs+num_ind\nprint('number of unknown currents: {:d}'.format(i_unk))\nprint('number of RLC (passive components): {:d}'.format(num_rlc))\nprint('number of inductors: {:d}'.format(num_ind))\nprint('number of independent voltage sources: {:d}'.format(num_v))\nprint('number of independent current sources: {:d}'.format(num_i))\nprint('number of op amps: {:d}'.format(num_opamps))\nprint('number of E - VCVS: {:d}'.format(num_vcvs))\nprint('number of G - VCCS: {:d}'.format(num_vccs))\nprint('number of F - CCCS: {:d}'.format(num_cccs))\nprint('number of H - CCVS: {:d}'.format(num_ccvs))\nprint('number of K - Coupled inductors: {:d}'.format(num_cpld_ind))\n\nNet list report\nnumber of lines in netlist: 9\nnumber of branches: 9\nnumber of nodes: 5\nnumber of unknown currents: 5\nnumber of RLC (passive components): 4\nnumber of inductors: 1\nnumber of independent voltage sources: 2\nnumber of independent current sources: 1\nnumber of op amps: 0\nnumber of E - VCVS: 1\nnumber of G - VCCS: 0\nnumber of F - CCCS: 1\nnumber of H - CCVS: 0\nnumber of K - Coupled inductors: 0\n\n\n\ndf\n\n\n\n\n\n\n\n\nelement\np node\nn node\ncp node\ncn node\nVout\nvalue\nVname\nLname1\nLname2\n\n\n\n\n0\nV1\n1\n0\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n1\nV2\n0\n5\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n2\nR2\n2\n5\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n3\nI1\n4\n0\nNaN\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\n\n\n4\nEa1\n3\n0\n1\n4\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n5\nF1\n2\n3\nNaN\nNaN\nNaN\n2.0\nV2\nNaN\nNaN\n\n\n6\nR1\n1\n4\nNaN\nNaN\nNaN\n2.0\nNaN\nNaN\nNaN\n\n\n7\nC1\n1\n2\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n8\nL1\n4\n3\nNaN\nNaN\nNaN\n1.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\nelement\np node\nn node\n\n\n\n\n0\nV1\n1\n0\n\n\n1\nV2\n0\n5\n\n\n2\nEa1\n3\n0\n\n\n3\nF1\n2\n3\n\n\n4\nL1\n4\n3\n\n\n\n\n\n\n\n\n# store the data frame as a pickle file\n# df.to_pickle(fn+'.pkl')  # &lt;- uncomment if needed\n\n\n# initialize some symbolic matrix with zeros\n# A is formed by [[G, C] [B, D]]\n# Z = [I,E]\n# X = [V, J]\nV = zeros(num_nodes,1)\nI = zeros(num_nodes,1)\nG = zeros(num_nodes,num_nodes)  # also called Yr, the reduced nodal matrix\ns = Symbol('s')  # the Laplace variable\n\n# count the number of element types that affect the size of the B, C, D, E and J arrays\n# these are element types that have unknown currents\ni_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n# if i_unk == 0, just generate empty arrays\nB = zeros(num_nodes,i_unk)\nC = zeros(i_unk,num_nodes)\nD = zeros(i_unk,i_unk)\nEv = zeros(i_unk,1)\nJ = zeros(i_unk,1)\n\n\n3.5.0.1 some debugging notes:\nIs it possible to have i_unk == 0 ?, what about a network with only current sources? This would make B = 0 for example. Did one test, need to run others\nIs there a valid op amp case where B is n by 1?"
  },
  {
    "objectID": "SMNA_example.html#g-matrix",
    "href": "SMNA_example.html#g-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.6 G matrix",
    "text": "3.6 G matrix\nThe G matrix is n by n, where n is the number of nodes. The matrix is formed by the interconnections between the resistors, capacitors and VCCS type elements. In the original paper G is called Yr, where Yr is a reduced form of the nodal matrix excluding the contributions due to voltage sources, current controlling elements, etc. In python row and columns are: G[row, column]\n\n# G matrix\nfor i in range(len(df)):  # process each row in the data frame\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node']\n    cn2 = df.loc[i,'cn node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'R':\n        g = 1/sympify(df.loc[i,'element'])\n    if x == 'C':\n        g = s*sympify(df.loc[i,'element'])\n    if x == 'G':   #vccs type element\n        g = sympify(df.loc[i,'element'].lower())  # use a symbol for gain value\n\n    if (x == 'R') or (x == 'C'):\n        # If neither side of the element is connected to ground\n        # then subtract it from the appropriate location in the matrix.\n        if (n1 != 0) and (n2 != 0):\n            G[n1-1,n2-1] += -g\n            G[n2-1,n1-1] += -g\n\n        # If node 1 is connected to ground, add element to diagonal of matrix\n        if n1 != 0:\n            G[n1-1,n1-1] += g\n\n        # same for for node 2\n        if n2 != 0:\n            G[n2-1,n2-1] += g\n\n    if x == 'G':    #vccs type element\n        # check to see if any terminal is grounded\n        # then stamp the matrix\n        if n1 != 0 and cn1 != 0:\n            G[n1-1,cn1-1] += g\n\n        if n2 != 0 and cn2 != 0:\n            G[n2-1,cn2-1] += g\n\n        if n1 != 0 and cn2 != 0:\n            G[n1-1,cn2-1] -= g\n\n        if n2 != 0 and cn1 != 0:\n            G[n2-1,cn1-1] -= g\n\nG  # display the G matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{1}} & - C_{1} s & 0 & - \\frac{1}{R_{1}} & 0\\\\- C_{1} s & C_{1} s + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{2}}\\\\0 & 0 & 0 & 0 & 0\\\\- \\frac{1}{R_{1}} & 0 & 0 & \\frac{1}{R_{1}} & 0\\\\0 & - \\frac{1}{R_{2}} & 0 & 0 & \\frac{1}{R_{2}}\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#b-matrix",
    "href": "SMNA_example.html#b-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.7 B Matrix",
    "text": "3.7 B Matrix\nThe B matrix is an n by m matrix with only 0, 1 and -1 elements, where n = number of nodes and m is the number of current unknowns, i_unk. There is one column for each unknown current. The code loop through all the branches and process elements that have stamps for the B matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\nThe order of the columns is as they appear in the netlist. CCCS (F) does not get its own column because the controlling current is through a zero volt voltage source, called Vname and is already in the net list.\n\n# generate the B Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'O':  # op amp type, output connection of the opamp goes in the B matrix\n        B[n_vout-1,sn] = 1\n        sn += 1   # increment source count\n    if (x == 'H') or (x == 'F'):  # H: ccvs, F: cccs,\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H, F\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, only ik column is altered at n1 and n2\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                B[n1-1,sn] = 1\n            if n2 != 0:\n                B[n2-1,sn] = -1\n        else:\n            if n1 != 0:\n                B[n1-1] = 1\n            if n2 != 0:\n                B[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix B'.format(sn,i_unk))\n\nB   # display the B matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 1 & 0\\\\0 & 0 & 1 & -1 & -1\\\\0 & 0 & 0 & 0 & 1\\\\0 & -1 & 0 & 0 & 0\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#c-matrix",
    "href": "SMNA_example.html#c-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.8 C matrix",
    "text": "3.8 C matrix\nThe C matrix is an m by n matrix with only 0, 1 and -1 elements (except for controlled sources). The code is similar to the B matrix code, except the indices are swapped. The code loops through all the branches and process elements that have stamps for the C matrix:\n\nVoltage sources (V)\n\nOpamps (O)\n\nCCVS (H)\n\nCCCS (F)\n\nVCVS (E)\n\nInductors (L)\n\n\n3.8.1 Op Amp elements\nThe op amp element is assumed to be an ideal op amp and use of this component is valid only when used in circuits with a DC path (a short or a resistor) from the output terminal to the negative input terminal of the op amp. No error checking is provided and if the condition is violated, the results likely will be erroneous.\nReferences use in the debugging of the opamp stamp:\n\nDesign of Analog Circuits Through Symbolic Analysis, edited by Mourad Fakhfakh, Esteban Tlelo-Cuautle, Francisco V. Fernández\n\nComputer Aided Design and Design Automation, edited by Wai-Kai Chen\n\n\n# find the the column position in the C and D matrix for controlled sources\n# needs to return the node numbers and branch number of controlling branch\ndef find_vname(name):\n    # need to walk through data frame and find these parameters\n    for i in range(len(df2)):\n        # process all the elements creating unknown currents\n        if name == df2.loc[i,'element']:\n            n1 = df2.loc[i,'p node']\n            n2 = df2.loc[i,'n node']\n            return n1, n2, i  # n1, n2 & col_num are from the branch of the controlling element\n\n    print('failed to find matching branch element in find_vname')\n\n\n# generate the C Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    cn2 = df.loc[i,'cn node']\n    n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to B matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, V\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n    if x == 'O':  # op amp type, input connections of the opamp go into the C matrix\n        # C[sn,n_vout-1] = 1\n        if i_unk &gt; 1:  #is B greater than 1 by n?, O\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   # increment source count\n\n    if x == 'F':  # need to count F (cccs) types\n        sn += 1   #increment source count\n    if x == 'H':  # H: ccvs\n        if i_unk &gt; 1:  #is B greater than 1 by n?, H\n            # check to see if any terminal is grounded\n            # then stamp the matrix\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n    if x == 'E':   # vcvs type, ik column is altered at n1 and n2, cn1 & cn2 get value\n        if i_unk &gt; 1:  #is B greater than 1 by n?, E\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n            # add entry for cp and cn of the controlling voltage\n            if cn1 != 0:\n                C[sn,cn1-1] = -sympify(df.loc[i,'element'].lower())\n            if cn2 != 0:\n                C[sn,cn2-1] = sympify(df.loc[i,'element'].lower())\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n            vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n            if vn1 != 0:\n                C[vn1-1] = -sympify(df.loc[i,'element'].lower())\n            if vn2 != 0:\n                C[vn2-1] = sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is B greater than 1 by n?, L\n            if n1 != 0:\n                C[sn,n1-1] = 1\n            if n2 != 0:\n                C[sn,n2-1] = -1\n        else:\n            if n1 != 0:\n                C[n1-1] = 1\n            if n2 != 0:\n                C[n2-1] = -1\n        sn += 1   #increment source count\n\n# check source count\nif sn != i_unk:\n    print('source number, sn={:d} not equal to i_unk={:d} in matrix C'.format(sn,i_unk))\n\nC   # display the C matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1\\\\- ea_{1} & 0 & 1 & ea_{1} & 0\\\\0 & 0 & 0 & 0 & 0\\\\0 & 0 & -1 & 1 & 0\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#d-matrix",
    "href": "SMNA_example.html#d-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.9 D matrix",
    "text": "3.9 D matrix\nThe D matrix is an m by m matrix, where m is the number of unknown currents.\n&gt; m = i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\nStamps that affect the D matrix are: inductor, ccvs and cccs\ninductors: minus sign added to keep current flow convention consistent\nCoupled inductors notes:\nCan the K statement be anywhere in the net list, even before Lx and Ly?\n12/6/2017 doing some debugging on with coupled inductors\nLTspice seems to put the phasing dot on the neg node when it generates the netlist\nThis code uses M for mutual inductance, LTspice uses k for the coupling coefficient.\n\n# generate the D Matrix\nsn = 0   # count source number as code walks through the data frame\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    #cn1 = df.loc[i,'cp node'] # nodes for controlled sources\n    #cn2 = df.loc[i,'cn node']\n    #n_vout = df.loc[i,'Vout'] # node connected to op amp output\n\n    # process elements with input to D matrix\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if (x == 'V') or (x == 'O') or (x == 'E'):  # need to count V, E & O types\n        sn += 1   #increment source count\n\n    if x == 'L':\n        if i_unk &gt; 1:  #is D greater than 1 by 1?\n            D[sn,sn] += -s*sympify(df.loc[i,'element'])\n        else:\n            D[sn] += -s*sympify(df.loc[i,'element'])\n        sn += 1   #increment source count\n\n    if x == 'H':  # H: ccvs\n        # if there is a H type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        sn += 1   #increment source count\n\n    if x == 'F':  # F: cccs\n        # if there is a F type, D is m by m\n        # need to find the vn for Vname\n        # then stamp the matrix\n        vn1, vn2, df2_index = find_vname(df.loc[i,'Vname'])\n        D[sn,df2_index] += -sympify(df.loc[i,'element'].lower())\n        D[sn,sn] = 1\n        sn += 1   #increment source count\n\n    if x == 'K':  # K: coupled inductors, KXX LYY LZZ value\n        # if there is a K type, D is m by m\n        vn1, vn2, ind1_index = find_vname(df.loc[i,'Lname1'])  # get i_unk position for Lx\n        vn1, vn2, ind2_index = find_vname(df.loc[i,'Lname2'])  # get i_unk position for Ly\n        # enter sM on diagonals = value*sqrt(LXX*LZZ)\n\n        D[ind1_index,ind2_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # s*Mxx\n        D[ind2_index,ind1_index] += -s*sympify('M{:s}'.format(df.loc[i,'element'].lower()[1:]))  # -s*Mxx\n\n# display the The D matrix\nD\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0\\\\0 & - f_{1} & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & - L_{1} s\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#v-matrix",
    "href": "SMNA_example.html#v-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.10 V matrix",
    "text": "3.10 V matrix\nThe V matrix is an n by 1 matrix formed of the node voltages, where n is the number of nodes. Each element in V corresponds to the voltage at the node.\nMaybe make small v’s v_1 so as not to confuse v1 with V1.\n\n# generate the V matrix\nfor i in range(num_nodes):\n    V[i] = sympify('v{:d}'.format(i+1))\n\nV  # display the V matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\\\v_{5}\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#j-matrix",
    "href": "SMNA_example.html#j-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.11 J matrix",
    "text": "3.11 J matrix\nThe J matrix is an m by 1 matrix, where m is the number of unknown currents. &gt;i_unk = num_v+num_opamps+num_vcvs+num_ccvs+num_ind+num_cccs\n\n# The J matrix is an mx1 matrix, with one entry for each i_unk from a source\n#sn = 0   # count i_unk source number\n#oan = 0   #count op amp number\nfor i in range(len(df2)):\n    # process all the unknown currents\n    J[i] = sympify('I_{:s}'.format(df2.loc[i,'element']))\n\nJ  # diplay the J matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1}\\\\I_{V2}\\\\I_{Ea1}\\\\I_{F1}\\\\I_{L1}\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#i-matrix",
    "href": "SMNA_example.html#i-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.12 I matrix",
    "text": "3.12 I matrix\nThe I matrix is an n by 1 matrix, where n is the number of nodes. The value of each element of I is determined by the sum of current sources into the corresponding node. If there are no current sources connected to the node, the value is zero.\n\n# generate the I matrix, current sources have n2 = arrow end of the element\nfor i in range(len(df)):\n    n1 = df.loc[i,'p node']\n    n2 = df.loc[i,'n node']\n    # process all the passive elements, save conductance to temp value\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'I':\n        g = sympify(df.loc[i,'element'])\n        # sum the current into each node\n        if n1 != 0:\n            I[n1-1] -= g\n        if n2 != 0:\n            I[n2-1] += g\n\nI  # display the I matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\0\\\\0\\\\- I_{1}\\\\0\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#ev-matrix",
    "href": "SMNA_example.html#ev-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.13 Ev matrix",
    "text": "3.13 Ev matrix\nThe Ev matrix is mx1 and holds the values of the independent voltage sources.\n\n# generate the E matrix\nsn = 0   # count source number\nfor i in range(len(df)):\n    # process all the passive elements\n    x = df.loc[i,'element'][0]   #get 1st letter of element name\n    if x == 'V':\n        Ev[sn] = sympify(df.loc[i,'element'])\n        sn += 1\n\nEv   # display the E matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#z-matrix",
    "href": "SMNA_example.html#z-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.14 Z matrix",
    "text": "3.14 Z matrix\nThe Z matrix holds the independent voltage and current sources and is the combination of 2 smaller matrices I and Ev. The Z matrix is (m+n) by 1, n is the number of nodes, and m is the number of independent voltage sources. The I matrix is n by 1 and contains the sum of the currents through the passive elements into the corresponding node (either zero, or the sum of independent current sources). The Ev matrix is m by 1 and holds the values of the independent voltage sources.\n\nZ = I[:] + Ev[:]  # the + operator in python concatenates the lists\nZ  # display the Z matrix\n\n\\(\\displaystyle \\left[ 0, \\  0, \\  0, \\  - I_{1}, \\  0, \\  V_{1}, \\  V_{2}, \\  0, \\  0, \\  0\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#x-matrix",
    "href": "SMNA_example.html#x-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.15 X matrix",
    "text": "3.15 X matrix\nThe X matrix is an (n+m) by 1 vector that holds the unknown quantities (node voltages and the currents through the independent voltage sources). The top n elements are the n node voltages. The bottom m elements represent the currents through the m independent voltage sources in the circuit. The V matrix is n by 1 and holds the unknown voltages. The J matrix is m by 1 and holds the unknown currents through the voltage sources\n\nX = V[:] + J[:]  # the + operator in python concatenates the lists\nX  # display the X matrix\n\n\\(\\displaystyle \\left[ v_{1}, \\  v_{2}, \\  v_{3}, \\  v_{4}, \\  v_{5}, \\  I_{V1}, \\  I_{V2}, \\  I_{Ea1}, \\  I_{F1}, \\  I_{L1}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#a-matrix",
    "href": "SMNA_example.html#a-matrix",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.16 A matrix",
    "text": "3.16 A matrix\nThe A matrix is (m+n) by (m+n) and will be developed as the combination of 4 smaller matrices, G, B, C, and D.\n\nn = num_nodes\nm = i_unk\nA = zeros(m+n,m+n)\nfor i in range(n):\n    for j in range(n):\n        A[i,j] = G[i,j]\n\nif i_unk &gt; 1:\n    for i in range(n):\n        for j in range(m):\n            A[i,n+j] = B[i,j]\n            A[n+j,i] = C[j,i]\n\n    for i in range(m):\n        for j in range(m):\n            A[n+i,n+j] = D[i,j]\n\nif i_unk == 1:\n    for i in range(n):\n        A[i,n] = B[i]\n        A[n,i] = C[i]\n\nA  # display the A matrix\n\n\\(\\displaystyle \\left[\\begin{matrix}C_{1} s + \\frac{1}{R_{1}} & - C_{1} s & 0 & - \\frac{1}{R_{1}} & 0 & 1 & 0 & 0 & 0 & 0\\\\- C_{1} s & C_{1} s + \\frac{1}{R_{2}} & 0 & 0 & - \\frac{1}{R_{2}} & 0 & 0 & 0 & 1 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 & -1\\\\- \\frac{1}{R_{1}} & 0 & 0 & \\frac{1}{R_{1}} & 0 & 0 & 0 & 0 & 0 & 1\\\\0 & - \\frac{1}{R_{2}} & 0 & 0 & \\frac{1}{R_{2}} & 0 & -1 & 0 & 0 & 0\\\\1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0\\\\- ea_{1} & 0 & 1 & ea_{1} & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & - f_{1} & 0 & 1 & 0\\\\0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 & 0 & - L_{1} s\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "SMNA_example.html#generate-the-circuit-equations",
    "href": "SMNA_example.html#generate-the-circuit-equations",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.17 generate the circuit equations",
    "text": "3.17 generate the circuit equations\n\nequ = Eq(A*Matrix(X),Matrix(Z))\nequ\n\n\\(\\displaystyle \\left[\\begin{matrix}- C_{1} s v_{2} + I_{V1} + v_{1} \\left(C_{1} s + \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{R_{1}}\\\\- C_{1} s v_{1} + I_{F1} + v_{2} \\left(C_{1} s + \\frac{1}{R_{2}}\\right) - \\frac{v_{5}}{R_{2}}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - \\frac{v_{1}}{R_{1}} + \\frac{v_{4}}{R_{1}}\\\\- I_{V2} - \\frac{v_{2}}{R_{2}} + \\frac{v_{5}}{R_{2}}\\\\v_{1}\\\\- v_{5}\\\\- ea_{1} v_{1} + ea_{1} v_{4} + v_{3}\\\\I_{F1} - I_{V2} f_{1}\\\\- I_{L1} L_{1} s - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\- I_{1}\\\\0\\\\V_{1}\\\\V_{2}\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nBuilt a python dictionary of element values\n\nelement_value_keys = []\nelement_value_values = []\n\nfor i in range(len(df)):\n    if df.iloc[i]['element'][0] == 'F' or df.iloc[i]['element'][0] == 'E' or df.iloc[i]['element'][0] == 'G' or df.iloc[i]['element'][0] == 'H':\n        element_value_keys.append(var(df.iloc[i]['element'].lower()))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:f},'.format(df.iloc[i]['element'].lower(),df.iloc[i]['value']))\n    else:\n        element_value_keys.append(var(df.iloc[i]['element']))\n        element_value_values.append(df.iloc[i]['value'])\n        #print('{:s}:{:.4e},'.format(df.iloc[i]['element'],df.iloc[i]['value']))\n\nelement_values = dict(zip(element_value_keys, element_value_values))"
  },
  {
    "objectID": "SMNA_example.html#symbolic-solution",
    "href": "SMNA_example.html#symbolic-solution",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.18 Symbolic solution",
    "text": "3.18 Symbolic solution\n\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- C_{1} I_{1} R_{1} R_{2} ea_{1} s - C_{1} I_{1} R_{1} R_{2} s - C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} f_{1} s + C_{1} R_{2} V_{1} s + I_{1} R_{1} ea_{1} f_{1} - I_{1} R_{1} ea_{1} + I_{1} R_{1} f_{1} - I_{1} R_{1} - V_{1} f_{1} + V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}, \\  I_{F1} : \\frac{- C_{1} V_{1} f_{1} s - C_{1} V_{2} f_{1} s}{C_{1} R_{2} s - f_{1} + 1}, \\  I_{L1} : \\frac{- I_{1} R_{1} ea_{1} - I_{1} R_{1} + V_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  I_{V1} : \\frac{- C_{1} I_{1} L_{1} R_{2} s^{2} + C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{1} s^{2} + C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} L_{1} V_{2} s^{2} + C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} ea_{1} s + C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{1} s + C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} s + C_{1} R_{1} V_{2} f_{1} s - C_{1} R_{1} V_{2} s - C_{1} R_{2} V_{1} s + I_{1} L_{1} f_{1} s - I_{1} L_{1} s + V_{1} f_{1} - V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}, \\  I_{V2} : \\frac{- C_{1} V_{1} s - C_{1} V_{2} s}{C_{1} R_{2} s - f_{1} + 1}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{C_{1} R_{2} V_{1} s + V_{2} f_{1} - V_{2}}{C_{1} R_{2} s - f_{1} + 1}, \\  v_{3} : \\frac{I_{1} L_{1} R_{1} ea_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  v_{4} : \\frac{- I_{1} L_{1} R_{1} s + L_{1} V_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  v_{5} : - V_{2}\\right\\}\\)"
  },
  {
    "objectID": "SMNA_example.html#numeric-solution",
    "href": "SMNA_example.html#numeric-solution",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.19 Numeric solution",
    "text": "3.19 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\nequ1a = equ.subs(element_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 1.0 s v_{2} + v_{1} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{4}\\\\I_{F1} - 1.0 s v_{1} + v_{2} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 I_{L1} s - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- 2.0 s^{2} - 10.0 s - 1.0}{2.0 s^{2} + 11.0 s - 6.0}, \\  I_{F1} : - \\frac{2.0 s}{2.0 s - 1.0}, \\  I_{L1} : \\frac{1}{s + 6.0}, \\  I_{V1} : \\frac{s^{2} + 4.0 s + 1.0}{2.0 s^{2} + 11.0 s - 6.0}, \\  I_{V2} : - \\frac{s}{2.0 s - 1.0}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{2.0 s}{2.0 s - 1.0}, \\  v_{3} : \\frac{4.0}{s + 6.0}, \\  v_{4} : \\frac{s + 4.0}{s + 6.0}, \\  v_{5} : 0.0\\right\\}\\)"
  },
  {
    "objectID": "SMNA_example.html#ac-analysis",
    "href": "SMNA_example.html#ac-analysis",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.20 AC analysis",
    "text": "3.20 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.5 + 1.0 i\\right) - 1.0 i v_{2} - 0.5 v_{4}\\\\I_{F1} - 1.0 i v_{1} + v_{2} \\cdot \\left(0.5 + 1.0 i\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 i I_{L1} - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -0.637837837837838 + 0.372972972972973 i, \\  I_{F1} : -0.8 + 0.4 i, \\  I_{L1} : 0.162162162162162 - 0.027027027027027 i, \\  I_{V1} : 0.237837837837838 - 0.172972972972973 i, \\  I_{V2} : -0.4 + 0.2 i, \\  v_{1} : 1.0, \\  v_{2} : 0.8 - 0.4 i, \\  v_{3} : 0.648648648648649 - 0.108108108108108 i, \\  v_{4} : 0.675675675675676 + 0.0540540540540541 i, \\  v_{5} : 0.0\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.000000 phase:     0.00000 deg\nv2   : mag:   0.894427 phase:   -26.56505 deg\nv3   : mag:   0.657596 phase:    -9.46232 deg\nv4   : mag:   0.677834 phase:     4.57392 deg\nv5   : mag:   0.000000 phase:         nan deg\nI_V1 : mag:   0.294086 phase:   -36.02737 deg\nI_V2 : mag:   0.447214 phase:   153.43495 deg\nI_Ea1: mag:   0.738882 phase:   149.68322 deg\nI_F1 : mag:   0.894427 phase:   153.43495 deg\nI_L1 : mag:   0.164399 phase:    -9.46232 deg"
  },
  {
    "objectID": "SMNA_example.html#ac-sweep",
    "href": "SMNA_example.html#ac-sweep",
    "title": "3  Symbolic modified nodal analysis example",
    "section": "3.21 AC Sweep",
    "text": "3.21 AC Sweep\nLooking at node 4 voltage.\n\nv4, I_F1, I_Ea1, v1, v2, v5, I_L1, v3, I_V1, I_V2 = symbols(' v4 I_F1 I_Ea1 v1 v2 v5 I_L1 v3 I_V1 I_V2')\n\n\nH = u1[v4]\nH\n\n\\(\\displaystyle \\frac{s + 4.0}{s + 6.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.1*2*np.pi, 100*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\n#plt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()"
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#abstract",
    "href": "Two amplifier RIAA Phono Preamp.html#abstract",
    "title": "17  Two amplifier RIAA phono preamp",
    "section": "Abstract",
    "text": "Abstract\nThis paper analyizes the circuit for the RIAA preamp given in the Texas Instruments application note AN346, High-Performance Audio Applications of the LM833, shown in the app note as Figure 3. The schematic for the phono preamplifier was entered into LTSpice and the circuit net list was generated. A circuit analysis method called the Modified Nodal Analysis was used to derive the symbolic circuit equations and Python libraries were used to solve the equations. The preamplifier transfer function was used to calculate the Bode, impuse and step response plots. The Python results were compared to those from LTSpice. Deviation from the RIAA response curve was also examined. The sensitivity, Monte Carlo and worst case analysis for the preamplifier circuit was performed. The JupyterLab notebook show cases the use of Python in electrical engineering and circuit analysis.\nContents\n1. Introduction\n2. RIAA pre-emphasis curve\n3. AN346 RIAA Phono Preamplifier Design Procedure\n4. Analysis of the phono preamplifier circuit\n5. Summary"
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#introduction",
    "href": "Two amplifier RIAA Phono Preamp.html#introduction",
    "title": "17  Two amplifier RIAA phono preamp",
    "section": "17.1 Introduction ",
    "text": "17.1 Introduction \nThis JupyterLab notebook uses the SymPy, NumPy,SciPy and the Python programming language libraries to analyze a phono preamplifier circuit from the Texas Instruments application note, AN346, High-Performance Audio Applications of the LM833. The purpose of this analysis is to demonstrate the capability of using the Python libraries in electrical engineering circuit analysis. The circuit chosen for this analysis is a two stage RIAA Phono Preamplifier described in the application note. The preamplifier is designed to accurately reproduce the RIAA equalization curve required for play back of Vinyl LP records. The preamplifier provides about 35 dB of gain at 1kHz along with the proper gain profile and phase response. The schematic of the circuit is shown below with each node explicity annotated.\n\nThere has been a resurgence on the popularity of Vinyl LP records over the last few years. So the use of a RIAA Phono Preamplifier is still relevant in this age where most music is delivered by streaming. Two internet news stories describe the current market for Vinyl LP records:\nThey Said the Album Was Dying. They Were Wrong\n\nVinyl sales have grown steadily for 17 years, but jumped by a stunning 46% in 2020 and 51% in 2021 …\n\nWhy Vinyl Records Are Making a Comeback in 2022\n\nThis year, 2020, marks the first year in more than a generation since record sales — that is to say physical vinyl records — have surpassed CD sales. The reasons for this are twofold: CD sales have dropped dramatically in recent years, while sales of vinyl records are actually up this year. And while you might think it’s nostalgic Boomers or Gen Xers behind the renaissance of records, in fact surveys show it’s millennial consumers driving the rising trend in vinyl sales.\n\n\nSo vinyl is here to stay, it seems, despite all technological advances that would have seemed to threaten it. The same RIAA study that found records surpassing CDs also revealed that streaming music now account for more than 85% of all music enjoyed. Only 6% of music is now downloaded, even less than is physically purchased in the form of records, CDs, or the last tapes.\n\nToday there are hundreds of phono products sold on Amazon. Phono preamps range in price from $10 to $1,000 dollars.\nThe Phono Preamplifier also known as a phono stage, is an audio component that amplifies the signal from your turntable to a level that allows you to connect it to your sound system the same way you would with any other audio source. In addition to boosting the signal from the phono carterage, the preamp applies the RIAA equalization curve to the signal, reverting it back to the shape it was on the original recording. Phono cartridge output varies depending on the type of phono cartridge. Moving Magnet (MM) or Moving Iron (MI) cartridges typically produce a maximum output of 5mV. Moving Coil (MC) cartridges produce a much lower output, typically around 0.5mV maximum. Most phono preamps have switch that allow users to select the type of coil they have installed on their turn table arm.\nTexas Instruments provided the schematic of the preamplifier in their application note to highlight the types of applications their LM833 operational amplifier can support. Application notes are sometimes part of the marketing literature provided along with component data sheets by semiconductor manufactures.\nRIAA equalization is a specification for the recording and playback of phonograph records, established by the Recording Industry Association of America (RIAA). RIAA was formed in 1952. Its original mission was to administer recording copyright fees and problems, work with trade unions, and do research relating to the record industry and government regulations. Early RIAA standards included the RIAA equalization curve, the format of the stereophonic record groove and the dimensions of 33 1/3, 45, and 78 rpm records.\nThe purposes of the equalization are to permit greater recording times (by decreasing the mean width of each groove), to improve sound quality and to reduce the groove damage that would otherwise arise during playback. RIAA equalization is a form of pre-emphasis on recording and de-emphasis on playback. A recording is made with the low frequencies reduced and the high frequencies boosted, and on playback, the opposite occurs. The net result is a flat frequency response, but with attenuation of high-frequency noise such as hiss and clicks that arise from the recording medium. Reducing the low frequencies also limits the excursions the cutter needs to make when cutting a groove. Groove width is thus reduced, allowing more grooves to fit into a given surface area, permitting longer recording times. This also reduces physical stresses on the stylus, which might otherwise cause distortion or groove damage during playback.\n\n17.1.1 Scope\nThe analysis presented in this notebook is intended to illustrate the use of Python for circuit analysis. This is not a tutorial on how to design a better phono preamp. The circuit taken from the Texas Instruments application note is examined for what it is, which is a suggested application for the use of their audio grade op amp. However, in this analysis I don’t address the performance of the op amp relative to the implementation of the RIAA equalization curve. I’m more concerned with examining the circuit’s ability to reproduce the proper gain and phase over the audio band. The performance LM833 op amp is assumed to be sufficient for this application and in my analysis of the circuit, I’ve replaced the LM833 with an ideal op amp model. Also, it is assumed that the reader is familiar with electronic components such as resistors, capacitors and operational amplifiers also known as op amps or opamps.\n\n\n17.1.2 Methodology\nThe analysis presented in this notebook will cover a topics that are often presented during a design review. Ususaly during a design review conformance to requirements is presented. For the phono preamp circuit, the main performance requirement is minimum deviation from the RIAA curve. The application note from TI stated that the deviation is less than 0.1 dB over the audio band when using 1% resistors.\nIn this notebook the analysis is divided into sections.\n\nThe analysis will start with an description of the circuit operation and some basic calculations.\nThere are many symbols used in the equations and these are listed in a table for reference. I also tried to be constant with variable names.\nThe RIAA pre-emphasis curve is discussed and the transfer function, pole/zero plot and amplitude and phase response is plotted.\nCalculations for the phono preamplifier design procedure as covered in the application note are presented. The element values obtain with this procedure are the ones used in the analysis.\nThe equations for the transfer function of the preamp are derived by using a tecnhique known as modified nodal analysis.\nThe preamp poles and zeros are plotted and some comments about stability are provided.\nThe amplitude and phase responce of the preamp transfer function is plotted.\nThe impulse, step and group dealy are plotted\nThe amplitude and phase response of the preamp transfer function is plotted against results taken from LTSpice as a check and comparision.\nThe deviation of the amplitude and phase responce from the RIAA curve is plotted.\nSensitivity analsysis, component selection, monte carlo and worst case analysis are presented.\n\n\nimport os\nimport sys\nimport random\nfrom sympy import *\nimport numpy as np\nfrom scipy import signal\nimport matplotlib.pyplot as plt\ninit_printing()\n\n\n\n17.1.3 Python library versions\n\npython: 3.10.9\nnumpy: 1.23.5\nsympy: 1.11.1\nscipy: 1.10.0\nmatplotlib: 3.7.0\n\nDefine a function to return the system gain at a frequency: get_gain()\n\ndef get_gain(freq_Hz, sys):\n    '''\n    freq_Hz: the frequency in Hz for which the system gain is desired\n    sys: a SciPy instance of the LTI class or a tuple describing the system\n    '''\n    f1 = freq_Hz - freq_Hz*0.1 # lower limit of the frequency range\n    f1a = freq_Hz - freq_Hz*0.01 # lower interpolation point\n    f2 = freq_Hz + freq_Hz*0.1 # upper limit of the frequency range\n    f2a = freq_Hz + freq_Hz*0.01  # upper interpolation point\n\n    x_axis_range = np.linspace(f1*2*np.pi, f2*2*np.pi, 1000, endpoint=True) # define the range frequency range\n    w, mag, phase = sys.bode(w=x_axis_range)\n\n    index_for_f1a = np.where(w &gt; f1a*2*np.pi)[0][0]\n    index_for_f2a = np.where(w &gt; f2a*2*np.pi)[0][0]\n\n    return np.interp(freq_Hz, [w[index_for_f1a]/(2*np.pi),w[index_for_f2a]/(2*np.pi)], [mag[index_for_f1a],mag[index_for_f2a]])\n\n\n\n17.1.4 Schematic and circuit description\nThe circuit from Figure 3 of AN346 was entered into LTSpice and the circuit nodes were numbered as shown above. Any schematic capture program could be used to for this as long as a Spice like netlist can be generated. In the schematic, the voltage source V1, is set to 5 mV to represent the output of a Moving Magnet (MM) or Moving Iron (MI) cartridge. The input to the preamp is shunted by a capacitance, which is equal to the sum of the input cable capacitance and the cartridge. This capacitance resonates with the inductance of the moving magnet cartridge to determine the frequency response of the transducer, so when a moving magnet pickup is used, Cp should be carefully chosen so that the total capacitance is equal to the recommended load capitance for that particular cartridge. 100 pF is used in this analysis. Rp is the recommended resistive load for the phono cartridge. In some comercial preamp designs, the value of Rp is user selectable with switches. As shown in the calculations, Cp and Rp have a resonant frequency of 33.86kHz.\n\nCp = 100e-12\nRp = 47e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Rp*Cp)))\n\nresonant frequency: 33,862.8 Hz\n\n\n33,862 Hz is well above the audio range.\nThe first operational amplifier, U1, takes care of the 50 Hz and 500 Hz breakpoints. For the analysis with Python, the op amp is modeled as and ideal opamp. There is expected to be some differences between the LTSpice results and the Python analysis. Using two amplifiers results in accurate conformance to the RIAA curve without reverting to the noisy inverting topology, as well as lower distortion due to the fact that each amplifier is operating at a lower gain than would be the case in a single-amplifier design.\nThe resistor, R1, which has a value of 80.6k\\(\\Omega\\) and the capacitor C1, which has a value of 0.039 \\(\\mu\\)Farads, form a resonant pair with frequency of 50.6 Hz.\n\nR1 = 80.6e3\nC1 = 0.039e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R1*C1)))\n\nresonant frequency: 50.6 Hz\n\n\n50 Hz is one of the RIAA time constants required by the RIAA specification.\nFrom here on, I’ll refer to resistors that have values in 1000’s of Ohms by using k for thousands of Ohms or just the numerical value if it’s less than 1000. Capacitors will have values indicated in \\(\\mu\\) for micro Farads and p for pico Farads, designated as \\(\\mu\\) or p. \n\nR2 = 8.45e3\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R2*C1)))\n\nresonant frequency: 482.9 Hz\n\n\nC1 and R2, which has a value of 8.45k, have a resonant frequency of 482.94 Hz. As describe later, these frequencies correspond to the time constants required by the RIAA specification.\nCo provides an AC ground for the non-inverting configuration of U1. Ro along with R1 and R2 set the low frequency gain of U1.\n\nRo = 499\nCo = 200e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*Ro*Co)))\n\nresonant frequency: 1.6 Hz\n\n\nRo=499 and Co=200\\(\\mu\\) have a resonant frequency of 1.6 Hz.\n\nRf=R1+R2\nprint('low frequency voltage gain of U1: {:,.2f} or {:,.1f}dB'.format(1+Rf/Ro, 20*np.log10(1+Rf/Ro)))\n\nlow frequency voltage gain of U1: 179.46 or 45.1dB\n\n\nRo along with R1 and R2 set the low frequency gain of U1 at 45 dB.\n\nR3 = 2.37e3\nC3 = 0.033e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R3*C3)))\n\nresonant frequency: 2,035.0 Hz\n\n\nR3=2.37k and C3=0.033\\(\\mu\\) have a resonant frequency of 2034.96 Hz and corresponds to the the third time constant specified by RIAA.\nC4=2\\(\\mu\\) and R6=54.9k form a high pass filter with a corner frequency of 1.45Hz.\n\nR6 = 54.9e3\nC4 = 2e-6\nprint('resonant frequency: {:,.1f} Hz'.format(1/(2*np.pi*R6*C4)))\n\nresonant frequency: 1.4 Hz\n\n\nU2, R4 and R5 form a non inverting configuration with a voltage gain of 3.15 or 9.98 dB.\n\nR4=2e3\nR5=4.3e3\nprint('voltage gain of U2: {:,.2f} or {:,.1f}dB'.format(1+R5/R4, 20*np.log10(1+R5/R4)))\n\nvoltage gain of U2: 3.15 or 10.0dB\n\n\n\n\n17.1.5 Symbols\nIn this notebook the following symbols are used:\n\n\n\n\n\n\n\nSymbol\ndefininition\n\n\n\n\ns\nwhen used in a polynominal: the Laplace variable equal to \\(\\alpha + j\\omega\\)\n\n\n\\(\\mu\\)\n\\(1 \\times 10^{-6}\\) multiplier, either: \\(1 \\times 10^{-6}\\) seconds or \\(1 \\times 10^{-6}\\) Farads\n\n\nT\ntime constant: T1, T2, T3\n\n\n\\(\\omega\\)\nangular frequency, radians per second, \\(\\omega = 1/T\\)\n\n\nf\nfrequency in cycles per second, \\(f = \\frac{\\omega}{2\\pi}\\)\n\n\nR\nresistor: R1, R2 etc.\n\n\nC\ncapacitor: C1, C2 etc.\n\n\nv\nnode voltage: v1, v2, v3 etc.\n\n\nV\nvoltage source, e.g. V1\n\n\nA\nmatrix describing the connectivity of the resistors, capacitors and G type (VCCS) circuit elements\n\n\nX\nvector of unknown node voltages and unknown currents\n\n\nZ\nvector of known voltages and currents\n\n\nRIAA_num\nnumerator of the RIAA pre-emphsis transfer function\n\n\nRIAA_den\ndenominator of the RIAA pre-emphsis transfer function\n\n\nw_RIAA\nradian frequncy of the RIAA pre-emphsis transfer function\n\n\nmag_RIAA\nmagnitude of the RIAA pre-emphsis transfer function\n\n\nphase_RIAA\nphase of the RIAA pre-emphsis transfer function\n\n\nRIAA_gain_1kHz\ngain of the RIAA pre-emphsis transfer function at 1kHz\n\n\npreamp_equ_sym\npreamp circuit equations with symbolic values\n\n\nU_sym\nsymbolic solution to network equations, node voltages and unknown currents\n\n\nH_sym\ntransfer function with symbolic coefficients\n\n\npreamp_equ\ncircuit equations with numeric element values\n\n\nH_preamp_num\nnumerator of the transfer function\n\n\nH_preamp_denom\ndenominator of the transfer function\n\n\npreamp_sys\nSciPy representation of the preamp system\n\n\npreamp_gain_1kHz\ngain of the preamp transfer function at 1kHz\n\n\nw_preamp\nradian frequncy of the preamp transfer function\n\n\nmag_preamp\nmagnitude of the preamp transfer function\n\n\nphase_preamp\nphase of the preamp transfer function"
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "href": "Two amplifier RIAA Phono Preamp.html#riaa-pre-emphasis-curve",
    "title": "17  Two amplifier RIAA phono preamp",
    "section": "17.2 RIAA pre-emphasis curve ",
    "text": "17.2 RIAA pre-emphasis curve \nThe RIAA equalization curve was established in 1954. The equalization is defined by time constants, T1, T2 and T3. During the Phonograph record manufacturing process, a pre-emphsis is applied to the signal, which allows for longer playback times on phonograph records by decreasing the average width of the groove cut into vinyl phonograph disks. The curve attenuates low frequencies and amplifies high frequencies, relative to 1 kHz. Since low frequencies cause wide undulations in the record groove, they must be attenuated to keep the grove within its bounds. Above 1 kHz, the frequencies are amplified which helps overcome the inherent noise produced by the phonograph needle during play-back.\nThe RIAA disc recording/reproduction standard specifies the time constants of, \\(T1 = 75 \\mu s\\), \\(T2 = 318 \\mu s\\) and \\(T3 = 3180 \\mu s\\) and the pre-emphasis transfer function:\n\\(RIAA(s)=\\frac {(sT_{1}+1)(sT_{3}+1)}{(sT_{2}+1)}\\)\nThe three time constants correspond to the frequencies calculated below.\n\nT1 = 75e-6\nT2 = 318e-6\nT3 = 3180e-6\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T1*1e6,1/(T1*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T2*1e6,1/(T2*2*np.pi)))\nprint('{:.0f} \\u03BCs corresponds to {:,.1f} Hz'.format(T3*1e6,1/(T3*2*np.pi)))\n\n75 μs corresponds to 2,122.1 Hz\n318 μs corresponds to 500.5 Hz\n3180 μs corresponds to 50.0 Hz\n\n\nThe time constants are put in polynominal form using s as the Laplace variable. The numerator and denominator of the pre-emphasis transfer function is defined below.\n\ns = symbols('s')\nRIAA_num = Eq(((s*T3+1)*(s*T1+1)),0)\nRIAA_denom = Eq(s*T2+1,0)\n\nSolve for the poles and zeros of the pre-emphasis transfer function and plot the locations on the complex s-plane. The zeros of the transfer function are the roots of the numerator polinominal. The poles of the transfer function are the roots of the denominal polinominal.\n\nRIAA_zeros = solve(RIAA_num,s)\nRIAA_poles = solve(RIAA_denom,s)\n\n\nplt.plot(np.real(RIAA_zeros), np.imag(RIAA_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(RIAA_poles), np.imag(RIAA_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(RIAA_zeros)))\nfor i in RIAA_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 2\n-2,122.07 Hz\n-50.05 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(RIAA_poles)))\nfor i in RIAA_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 1\n-500.49 Hz\n\n\nAs shown in the plot above, the poles and zeros lay on the negative real axis. The de-emphisis transfer function of the phono pre-amplifier should have poles at the zero locations and a zero in the pole location in the plot above.\nThe code below is used to convert SymPy symbolic equations to a numpy polynomial representation. The SciPy function, TransferFunction, represents the system as the continuous-time transfer function. The Numpy function, logspace, is used to generate data points on a log scale for plotting. The SciPy function, bode, is used to generate the magnitude and phase data of a continuous-time system.\n\na = np.array(Poly(RIAA_num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(RIAA_denom, s).all_coeffs(), dtype=float)\nRIAA_sys = signal.TransferFunction(a,b)\n\nx_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\nw_RIAA, mag_RIAA, phase_RIAA = RIAA_sys.bode(w=x_axis_range) # returns: rad/s, mag in dB, phase in deg\n\nFind the gain at 1kHz so the plots can be normalized for 0 dB at 1 kHz.\n\nRIAA_gain_1kHz = get_gain(1000,RIAA_sys)\n\n\nprint('The RIAA gain at 1kHz: {:.3f} dB'.format(RIAA_gain_1kHz))\n\nThe RIAA gain at 1kHz: 19.911 dB\n\n\nPlot the magnitude and phase of the RIAA curve.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_RIAA/(2*np.pi), mag_RIAA-RIAA_gain_1kHz,'-k')    # Bode magnitude plot, normalized to 0 at 1kHz\n\n# mark individual points\np3 = np.where(w_RIAA &gt; 49.9*(2*np.pi))[0][0]\np2 = np.where(w_RIAA &gt; 499.9*(2*np.pi))[0][0]\np1 = np.where(w_RIAA &gt; 2122*(2*np.pi))[0][0]\n\nplt.semilogx(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-RIAA_gain_1kHz,'^k')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-RIAA_gain_1kHz,'^k')\n\nplt.text(w_RIAA[p1]/(2*np.pi), mag_RIAA[p1]-25,'T1')\nplt.text(w_RIAA[p2]/(2*np.pi), mag_RIAA[p2]-25,'T2')\nplt.text(w_RIAA[p3]/(2*np.pi), mag_RIAA[p3]-25,'T3')\n\n# hightlight the audio band, 20 to 20kHz\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\nax1.tick_params(axis='y')\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\nplt.semilogx(w_RIAA/(2*np.pi), phase_RIAA,':',color='b',label='phase')  # Bode phase plot\n\n# mark individual points\nplt.semilogx(w_RIAA[p1]/(2*np.pi), phase_RIAA[p1],'xb')\nplt.semilogx(w_RIAA[p2]/(2*np.pi), phase_RIAA[p2],'xb')\nplt.semilogx(w_RIAA[p3]/(2*np.pi), phase_RIAA[p3],'xb')\n\nax2.set_ylabel('phase, deg',color='b')\nax2.tick_params(axis='y', labelcolor='b')\nax2.set_ylim((0,100))\n\nax2.plot(np.NaN, np.NaN, color='k', label='magnitude')\n\nplt.legend()\nplt.title('RIAA pre-emphasis Bode plot')\nplt.show()\n\n\n\n\nThe plot above shows the frequence response of the RIAA curve. The frequencies coresponsing to the time constants T1, T2 and T3 are plotted on the magnitude and phase curves. The audio band of 20Hz to 20kHz is highlighted. One thing to notice about this curve is that the amplitdue is increasing as the frequency increases. This is not a realistic function, real circuits do not have and inifinite gain at as the frequency goes tio infinity. Also, there is no zero at \\(j\\omega=0\\), so the pre-emphisis transfer function does not block DC."
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "href": "Two amplifier RIAA Phono Preamp.html#phono-preamplifier-design-procedure",
    "title": "17  Two amplifier RIAA phono preamp",
    "section": "17.3 Phono Preamplifier Design Procedure ",
    "text": "17.3 Phono Preamplifier Design Procedure \nThe following notebook cells walk through the design procedure given in the application note, starting on page 5.\nA design procedure is shown below with an illustrative example using 1% tolerance E96 components for close conformance to the ideal RIAA curve. Since 1% tolerance capacitors are often difficult to find except in 5% or 10% standard values, the design procedure calls for re-calculation of a few component values so that standard capacitor values can be used.\n\nChoose \\(R_o\\). \\(R_o\\) should be small for minimum noise contribution, but not so small that the feedback network excessively loads the amplifier. Example: Choose \\(R_o = 500\\)\nChoose 1 kHz gain, A1 of first amplifier. This will typically be around 20 dB to 30 dB. Example: Choose A1 = 26 dB = 20\nCalculate \\(R_11 = 8.058 \\times R_o \\times A_1\\)\n\n\nA1 = 20\nRo = 500\nR1 = 8.058 * Ro * A1\nprint('R1={:,.0f}'.format(R1))\n\n\nCalculate C1\n\n\\(C_1 = \\frac {3.18 \\times 10^{-3}}{R_1}\\)\n\nC1 = 3.18e-3/R1\nprint('C1={:.4e}'.format(C1))\n\nC1=3.9464e-08\n\n\nThe calculated value for capacitor C1 is not a standard value, so step 5 takes care of this.\n\nIf C1 is not a convenient value, choose the nearest convenient value and calculate a new R1 from:\n\n\\(R_1 = \\frac {3.18 \\times 10^{-3}}{3.9 \\times 10^{-8}}\\)\nChoose C1 to be 0.039\\(\\mu\\), which is a standard capacitor value.\n\nC1 = 0.039e-6\nR1 = 3.18e-3/C1\nprint('R1={:,.0f}'.format(R1))\n\nR1=81,538\n\n\nNow choose a standard resistor value close to the the calculated value, which is 80.6k.\nE96 resistor values are a set of perfered values for 1% resistors. When doing the calculations to determin the resistor values, the closest standandard value is chosen from the E96 series. The E series of preferred numbers derived for use in electronic components. It consists of the E3, E6, E12, E24, E48, E96 and E192 series, where the number after the ‘E’ designates the quantity of logarithmic value “steps” per decade.\n\nR1 = 80.6e3\n\nCalculate a new value for Ro.\n\\(R_o=\\frac {R_1}{8.058A_1}\\)\n\nRo = R1/(8.058*A1)\nprint('R1={:,.0f}'.format(Ro))\n\nR1=500\n\n\nChoose a standard value close to this value, which is 499.\n\nRo = 499\n\n\nCaluclate R2\n\\(R_2=\\frac {R_1}{9} - R_o\\)\n\n\nR2 = R1/9-Ro\nprint('R1={:,.0f}'.format(R2))\n\nR1=8,457\n\n\nChoose a standard value close to this value, which is 8.45k.\n\nR2 = 8.45e3\n\n\nChoose a convenient value for C3 in the range from 0.01 \\(\\mu\\)F to 0.05 \\(\\mu\\)F.\nExample: C3 = 0.033 \\(\\mu\\)F\n\n\nC3 = 0.033e-6\nprint('C3={:,.3f}\\u03BC'.format(C3*1e6))\n\nC3=0.033μ\n\n\n\nCalculate Rp\n\\(R_p=\\frac {75 \\mu s }{C_3}\\)\n\n\\(75 \\mu s\\) is one of the RIAA time constants.\n\nRp = 75e-6/C3\nprint('Rp={:,.0f}'.format(Rp))\n\nRp=2,273\n\n\n\nChoose a standard value for R3 that is slightly larger than Rp.\nExample: R3 = 2.37k, which is a standard resistor value.\n\n\nR3 = 2.37e3\n\n\nCalculate R6 from \\(1/R_6 = 1/R_P − 1/R_3\\)\n\n\nR6 = 1/(1/Rp-1/R3)\nprint('R6={:,.0f}'.format(R6))\n\nR6=55,374\n\n\n54.9k is the closest standard value.\n\nR6 = 54.9e3\n\n\nCalculate \\(C_4\\) for low-frequency rolloff below 1 Hz from design Equation 5.\n\n\\(C_4=\\frac{1}{2\\pi f_L(R_3+R_6)}\\)\nWhere \\(f_L\\) is the low frequency -3dB corner of the second stage.\nIn the application note, there is a comment on page 4:\n&gt; If the preamplifier is to follow the IEC recommendation (IEC Publication 98, Amendment #4), fL should equal 20.2 Hz.\nThe calculations in the app note use 1 Hz.\n\nf_L = 1.0 # Hz\nC4 = 1/(2*np.pi*f_L*(R3+R6))\nprint('C4={:,.3f}\\u03BC'.format(C4*1e6))\n\nC4=2.779μ\n\n\n2\\(\\mu\\)F is a standard value close to the calculated value.\nExample: C4 = 2 \\(\\mu\\)F.\n\nChoose gain of second amplifier.\nExample: The 1 kHz gain up to the input of the second amplifier is about 26 dB for this example. For an overall 1 kHz gain equal to about 36 dB we choose:\n\\(A_2 = 10 dB = 3.16\\)\nChoose value for R4.\nExample: R4 = 2k\n\n\nR4 = 2e3\n\n\nCalculate \\(R_5 = (A_2 − 1) R_4\\)\n\n\nA2 = 3.16\nR5 = (A2-1)*R4\nprint('R5={:,.0f}'.format(R5))\n\nR5=4,320\n\n\n4.3k is a standard value close to the calculated value.\n\nR5 = 4.3e3\n\n\nCalculate Co for low-frequency rolloff below 1 Hz from design Equation 7.\n\n\\(C_o=\\frac {1}{2\\pi f_o R_o}\\)\nwhere fo is the low-frequency −3 dB corner of the first amplifier. fo is chosen to be 1Hz for the calculations since this frequency is well below the audible frequency range.\n\nfo = 1 # 1 Hz\nCo = 1/(2*np.pi*fo*Ro)\nprint('Co={:,.3f}\\u03BC'.format(Co*1e6))\n\nCo=318.948μ\n\n\nThe value chosen in the app note for this component is 200\\(\\mu\\)F.\n\nCo = 200e-6\n\n\nprint('resonant frequency of Ro and Co: {:.2f}Hz'.format(1/(Co*Ro*2*np.pi)))\n\nresonant frequency of Ro and Co: 1.59Hz"
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "href": "Two amplifier RIAA Phono Preamp.html#analysis-of-an-346-phono-preamplifier-circuit",
    "title": "17  Two amplifier RIAA phono preamp",
    "section": "17.4 Analysis of AN-346 phono preamplifier circuit ",
    "text": "17.4 Analysis of AN-346 phono preamplifier circuit \nThe schematic of the preamp was entered into LTSpice and the netlist was generated. Starting with a schematic and then using LTSpice to generate the net list eliminates errors that would occure if these circuits were analyised by hand. For small circuits with a handful of components, symbolic solutions of the node equations can be of interest, but for larger circuits, not so much. This is because the number of symbols and equations is too large to offer in insight with out some simplicication.\nIn this section the modified nodal analysis method will be used to generate the circuit equations. The modified nodal analysis provides an algorithmic method for generating systems of independent equations for linear circuit analysis. Most problems that an electrical engineer encounters on the job are complex enough that they use computers to analyze the circuits. The Python code that generates the circuits equations is located here.\n\n17.4.1 Modified nodal analysis\nThe preamp circuit has 15 branches, 9 nodes, 3 unknown currents, 14 passive components and 2 op amps. The net list generated by LTSpice and some edits were made to put the component values into scientific notation with units of Ohms, Farads and Henerys and the opamp statements were fixed. The edited netlist is:\nV1 1 0 5e-3m\nO1 3 1 6 \nO2 9 8 2 \nC1 3 5 0.039e-6\nCo 4 0 200e-6\nRo 3 4 499\nR3 6 7 2.37e3\nR1 3 5 80.6e3\nR2 5 6 8.45e3\nCp 1 0 100e-12\nRp 1 0 47e3\nC3 7 0 0.033e-6\nC4 8 7 2e-6\nR6 8 0 54.9e3\nR4 9 0 2e3\nR5 2 9 4.3e3\nThis netlist is read into the Symbolic Modified Nodal Analysis Jupyter notebook and the following circuit equations were generated.\n\\(I_{V1} + v_{1} \\left(Cp s + \\frac{1}{R_{20}}\\right) = 0\\)\n\\(v_{2} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{4} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{3}}{Ro} = 0\\)\n\\(v_{3} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{2}}{Ro} = 0\\)\n\\(v_{2} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{4} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{5}}{R_{2}} = 0\\)\n\\(I_{O1} + v_{5} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{6}}{R_{3}} - \\frac{v_{4}}{R_{2}} = 0\\)\n\\(- C_{4} s v_{7} + v_{6} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{5}}{R_{3}} = 0\\)\n\\(- C_{4} s v_{6} + v_{7} \\left(C_{4} s + \\frac{1}{R_{6}}\\right) = 0\\)\n\\(v_{8} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{9}}{R_{5}} = 0\\)\n\\(I_{O2} + v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{22}}\\right) - \\frac{v_{8}}{R_{5}} = 0\\)\n\\(v_{1} = V_{1}\\)\n\\(- v_{1} + v_{2} = 0\\)\n\\(- v_{7} + v_{8} = 0\\)\nThe symbols and matrices generated by the modified nodal analysis code are copied here so that the circuit equations can be solved symbilically and later numerically. All the symboles that SymPy needs defined are delared. The A matrix describs the connectivity of the resistors, capacitors and G type (VCCS) circuit elements. The X matrix contains the unknown node voltages and unknown currents. The Z matrix contains the known voltages and currents sources, e.g. V1.\n\nRp, v6, Co, C4, v2, C3, s, I_V1, R6, Ro, R4, C1, R3, I_O2, R5, v3, I_O1, v4, v8, v7, V1, Cp, v1, R1, R2, v5, v9 = symbols(' Rp  v6  Co  C4  v2  C3  s  I_V1  R6  Ro  R4  C1  R3  I_O2  R5  v3  I_O1  v4  v8  v7  V1  Cp  v1  R1  R2  v5  v9 ')\nA = Matrix([[Cp*s + 1/Rp, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1/R5, 0, 0, 0, 0, 0, 0, -1/R5, 0, 0, 1], [0, 0, C1*s + 1/Ro + 1/R1, -1/Ro, -C1*s - 1/R1, 0, 0, 0, 0, 0, 0, 0], [0, 0, -1/Ro, Co*s + 1/Ro, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, -C1*s - 1/R1, 0, C1*s + 1/R2 + 1/R1, -1/R2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1/R2, 1/R3 + 1/R2, -1/R3, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, -1/R3, C3*s + C4*s + 1/R3, -C4*s, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, -C4*s, C4*s + 1/R6, 0, 0, 0, 0], [0, -1/R5, 0, 0, 0, 0, 0, 0, 1/R5 + 1/R4, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0]])\nX = Matrix( [v1, v2, v3, v4, v5, v6, v7, v8, v9, I_V1, I_O1, I_O2] )\nZ = Matrix( [0, 0, 0, 0, 0, 0, 0, 0, 0, V1, 0, 0] )\n\nThe equations are displayed in maxtrix form below.\n\npreamp_equ_sym = Eq(A*X,Z)\npreamp_equ_sym\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\left(Cp s + \\frac{1}{Rp}\\right)\\\\I_{O2} + \\frac{v_{2}}{R_{5}} - \\frac{v_{9}}{R_{5}}\\\\v_{3} \\left(C_{1} s + \\frac{1}{Ro} + \\frac{1}{R_{1}}\\right) + v_{5} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) - \\frac{v_{4}}{Ro}\\\\v_{4} \\left(Co s + \\frac{1}{Ro}\\right) - \\frac{v_{3}}{Ro}\\\\v_{3} \\left(- C_{1} s - \\frac{1}{R_{1}}\\right) + v_{5} \\left(C_{1} s + \\frac{1}{R_{2}} + \\frac{1}{R_{1}}\\right) - \\frac{v_{6}}{R_{2}}\\\\I_{O1} + v_{6} \\cdot \\left(\\frac{1}{R_{3}} + \\frac{1}{R_{2}}\\right) - \\frac{v_{7}}{R_{3}} - \\frac{v_{5}}{R_{2}}\\\\- C_{4} s v_{8} + v_{7} \\left(C_{3} s + C_{4} s + \\frac{1}{R_{3}}\\right) - \\frac{v_{6}}{R_{3}}\\\\- C_{4} s v_{7} + v_{8} \\left(C_{4} s + \\frac{1}{R_{6}}\\right)\\\\v_{9} \\cdot \\left(\\frac{1}{R_{5}} + \\frac{1}{R_{4}}\\right) - \\frac{v_{2}}{R_{5}}\\\\v_{1}\\\\- v_{1} + v_{3}\\\\- v_{8} + v_{9}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\V_{1}\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThese equations can be solved in thier symbolic form using the solve function from SymPy. The solution time takes about 3 seconds on my i3 laptop.\n\nU_preamp_sym = solve(preamp_equ_sym,X)\n\nThe transfer function for the preamp is the equation for the output node, 2, divided by the equation for the input node 1.\n\nH_preamp_sym = U_preamp_sym[v2]/U_preamp_sym[v1]\n\nThe symbolic solution obtained by SymPy, while not being very interesting since they are unweildly, they illustrate the power of SymPy to easily obtain symbolic solutions that would be very difficult to obtain by hand.\n\nH_preamp_sym\n\n\\(\\displaystyle \\frac{C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro V_{1} s^{3} + C_{1} C_{4} R_{1} R_{4} R_{6} V_{1} s^{2} + C_{1} C_{4} R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{1} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{4} R_{6} V_{1} s^{2} + C_{4} Co R_{2} R_{5} R_{6} V_{1} s^{2} + C_{4} Co R_{4} R_{6} Ro V_{1} s^{2} + C_{4} Co R_{5} R_{6} Ro V_{1} s^{2} + C_{4} R_{4} R_{6} V_{1} s + C_{4} R_{5} R_{6} V_{1} s}{V_{1} \\left(C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} s^{3} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{3} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro s^{3} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro s^{3} + C_{1} C_{4} R_{1} R_{3} R_{4} s^{2} + C_{1} C_{4} R_{1} R_{4} R_{6} s^{2} + C_{1} Co R_{1} R_{4} Ro s^{2} + C_{1} R_{1} R_{4} s + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro s^{3} + C_{3} C_{4} R_{3} R_{4} R_{6} s^{2} + C_{3} Co R_{3} R_{4} Ro s^{2} + C_{3} R_{3} R_{4} s + C_{4} Co R_{3} R_{4} Ro s^{2} + C_{4} Co R_{4} R_{6} Ro s^{2} + C_{4} R_{3} R_{4} s + C_{4} R_{4} R_{6} s + Co R_{4} Ro s + R_{4}\\right)}\\)\n\n\nThe SymPy function, cancel(), can be used to put the preamp transfunction in to standard canonical form, where the polynomials are expanded with no common factors and the leading coefficients do not have denominators (i.e., are integers).\n\ncancel(H_preamp_sym,s)\n\n\\(\\displaystyle \\frac{s^{3} \\left(C_{1} C_{4} Co R_{1} R_{2} R_{4} R_{6} + C_{1} C_{4} Co R_{1} R_{2} R_{5} R_{6} + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{1} C_{4} Co R_{1} R_{5} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} C_{4} R_{1} R_{5} R_{6} + C_{4} Co R_{1} R_{4} R_{6} + C_{4} Co R_{1} R_{5} R_{6} + C_{4} Co R_{2} R_{4} R_{6} + C_{4} Co R_{2} R_{5} R_{6} + C_{4} Co R_{4} R_{6} Ro + C_{4} Co R_{5} R_{6} Ro\\right) + s \\left(C_{4} R_{4} R_{6} + C_{4} R_{5} R_{6}\\right)}{C_{1} C_{3} C_{4} Co R_{1} R_{3} R_{4} R_{6} Ro s^{4} + R_{4} + s^{3} \\left(C_{1} C_{3} C_{4} R_{1} R_{3} R_{4} R_{6} + C_{1} C_{3} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{3} R_{4} Ro + C_{1} C_{4} Co R_{1} R_{4} R_{6} Ro + C_{3} C_{4} Co R_{3} R_{4} R_{6} Ro\\right) + s^{2} \\left(C_{1} C_{3} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{3} R_{4} + C_{1} C_{4} R_{1} R_{4} R_{6} + C_{1} Co R_{1} R_{4} Ro + C_{3} C_{4} R_{3} R_{4} R_{6} + C_{3} Co R_{3} R_{4} Ro + C_{4} Co R_{3} R_{4} Ro + C_{4} Co R_{4} R_{6} Ro\\right) + s \\left(C_{1} R_{1} R_{4} + C_{3} R_{3} R_{4} + C_{4} R_{3} R_{4} + C_{4} R_{4} R_{6} + Co R_{4} Ro\\right)}\\)\n\n\nThe Sympy function, factor(), can be used to factor the polynominals it into irreducible factors over the rational numbers.\n\nH_preamp_sym.factor()\n\n\\(\\displaystyle \\frac{C_{4} R_{6} s \\left(R_{4} + R_{5}\\right) \\left(C_{1} Co R_{1} R_{2} s^{2} + C_{1} Co R_{1} Ro s^{2} + C_{1} R_{1} s + Co R_{1} s + Co R_{2} s + Co Ro s + 1\\right)}{R_{4} \\left(C_{1} R_{1} s + 1\\right) \\left(Co Ro s + 1\\right) \\left(C_{3} C_{4} R_{3} R_{6} s^{2} + C_{3} R_{3} s + C_{4} R_{3} s + C_{4} R_{6} s + 1\\right)}\\)\n\n\nThe symbolic solutions obtained above will be used later when the sinsitivity analysis of the preamp is performed. Otherwise the roots in symbolic form don’t seem to be particulary insightful, but are easily obtained by SymPy.\n\n17.4.1.1 Numerical solution\nThe element values are put into the Python dictionary format so that numerical values can be substituted into the equations.\n\nnominal_component_value = {V1:5.0000e-03, C1:3.9000e-08, Co:2.0000e-04, Ro:4.9900e+02, R3:2.3700e+03, R1:8.0600e+04, \n    R2:8.4500e+03, Cp:1.0000e-10, Rp:4.7000e+04, C3:3.3000e-08, C4:2.0000e-06, R6:5.4900e+04, R4:2.0000e+03, R5:4.3000e+03}\n\n# put the element values into the equations\npreamp_equ = preamp_equ_sym.subs(nominal_component_value)\n\nNow we can diplay the network equations with values for the components instear of symbols.\n\npreamp_equ\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(1.0 \\cdot 10^{-10} s + 2.12765957446809 \\cdot 10^{-5}\\right)\\\\I_{O2} + 0.000232558139534884 v_{2} - 0.000232558139534884 v_{9}\\\\v_{3} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.00201641496392288\\right) - 0.00200400801603206 v_{4} + v_{5} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right)\\\\- 0.00200400801603206 v_{3} + v_{4} \\cdot \\left(0.0002 s + 0.00200400801603206\\right)\\\\v_{3} \\left(- 3.9 \\cdot 10^{-8} s - 1.24069478908189 \\cdot 10^{-5}\\right) + v_{5} \\cdot \\left(3.9 \\cdot 10^{-8} s + 0.000130750143157091\\right) - 0.000118343195266272 v_{6}\\\\I_{O1} - 0.000118343195266272 v_{5} + 0.000540284123536314 v_{6} - 0.000421940928270042 v_{7}\\\\- 2.0 \\cdot 10^{-6} s v_{8} - 0.000421940928270042 v_{6} + v_{7} \\cdot \\left(2.033 \\cdot 10^{-6} s + 0.000421940928270042\\right)\\\\- 2.0 \\cdot 10^{-6} s v_{7} + v_{8} \\cdot \\left(2.0 \\cdot 10^{-6} s + 1.82149362477231 \\cdot 10^{-5}\\right)\\\\- 0.000232558139534884 v_{2} + 0.000732558139534884 v_{9}\\\\v_{1}\\\\- v_{1} + v_{3}\\\\- v_{8} + v_{9}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0.005\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nUsing the SymPy solve function we can solve the system of equations.\n\nU_preamp = solve(preamp_equ,X)\n\nThe values of the exponents are very large in the solution. The numerator and denominator for v2 could be normalized. Another option for avoiding large exponents is to 1st normalize the component values by frequency scaling. I suppose that large exponents don’t become a problem as long as they remain under two digits.\nAlmost all platforms map Python floats to the IEEE754 double precision - 64 total bits. The float information using the sys package can be as shown as follows:\n\nsys.float_info\n\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n\n\n\nprint(sys.float_info)\n\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n\n\nThe maximum exponent that Python can use is 308.\nLetting SciPy do the math and not worrying about the size of the exponents. The transfer function can be obtained by divideing the equation for node 2 by the equation for node 1. The system transfer function, is \\(H(s) = \\frac {v2}{V1}\\)\n\nH_preamp = U_preamp[v2]/U_preamp[v1]\nH_preamp\n\n\\(\\displaystyle \\frac{200.0 \\cdot \\left(2.76499422921242 \\cdot 10^{69} s^{3} + 8.80353368479522 \\cdot 10^{72} s^{2} + 4.91462150480132 \\cdot 10^{71} s\\right)}{7.65600122987477 \\cdot 10^{65} s^{4} + 1.0469819689888 \\cdot 10^{70} s^{3} + 3.44479259637884 \\cdot 10^{72} s^{2} + 6.18286042227129 \\cdot 10^{73} s + 2.84188944100537 \\cdot 10^{74}}\\)\n\n\nfactor() takes a polynomial and factors it into irreducible factors over the rational numbers. For example:\n\nH_preamp.factor()\n\n\\(\\displaystyle \\frac{6.19554973375798 s \\left(0.000314077770155853 s^{2} + 1.0 s + 0.0558255546098434\\right)}{2.69398278462456 \\cdot 10^{-9} s^{4} + 3.68410520790143 \\cdot 10^{-5} s^{3} + 0.012121487017314 s^{2} + 0.21756161 s + 1.0}\\)\n\n\n\n\n17.4.1.2 Convert transfer function to SciPy system\nIn this section we convert the SymPy equations into Numpy format.\nExtract the numerator and denominator polynomials so that the system can be defined in SciPy.\n\nH_preamp_num, H_preamp_denom = fraction(H_preamp) #returns numerator and denominator\n\nThe SciPy function, TransferFunction, represents the system as the continuous-time transfer function and takes as inputs the coeeficients of the numerator and denominator polynominals.\n\n# convert symbolic to numpy polynomial\na2 = np.array(Poly(H_preamp_num, s).all_coeffs(), dtype=float)\nb2 = np.array(Poly(H_preamp_denom, s).all_coeffs(), dtype=float)\npreamp_sys = signal.TransferFunction(a2,b2)\n\nThe poles and zeros of the transfer function can easly be obtained with the following code:\n\npreamp_sys_zeros = np.roots(preamp_sys.num)\npreamp_sys_poles = np.roots(preamp_sys.den)\n\n\n\n\n17.4.2 Pole zero plot\nThe poles and zeros of the preamp transfer function are plotted.\n\nplt.plot(np.real(preamp_sys_zeros), np.imag(preamp_sys_zeros), 'ob', markerfacecolor='none')\nplt.plot(np.real(preamp_sys_poles), np.imag(preamp_sys_poles), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('real part, \\u03B1')\nplt.ylabel('imaginary part, j\\u03C9')\nplt.grid()\nplt.show()\n\n\n\n\nPoles and zeros of the transfer function plotted on the complex plane. The units are in radian frequency.\nPrinting these values in Hz.\n\nprint('number of zeros: {:d}'.format(len(preamp_sys_zeros)))\nfor i in preamp_sys_zeros:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 3\n-506.73 Hz\n-0.01 Hz\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(preamp_sys_poles)))\nfor i in preamp_sys_poles:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 4\n-2,122.88 Hz\n-50.63 Hz\n-1.59 Hz\n-1.39 Hz\n\n\nWe can see that the RIAA time constants, displayed in terms of frequency are present, althought the values diffeer by a few Hz. There are two zeros and two poles at nearly zero hz and these cancel each other.\n\n\n17.4.3 Stability\nBy inspecting the plot above, we can tell the preamplifier is stable since the phase shift at 0 dB of gain is less than 180 degrees. Additionally, all the poles of the transfer function are in the left hand plane.\nNow we can find the preamp gain at 1 kHz, so that the bode plots can be normailized.\n\npreamp_gain_1kHz = get_gain(1000, preamp_sys)\nprint('preamp gain at 1kHz: {:f} dB'.format(preamp_gain_1kHz))\n\npreamp gain at 1kHz: 34.783614 dB\n\n\n\n\n17.4.4 Bode plot\nUse the SciPy function bode to plot the magnitude and phase of the filter. In electrical engineering, a Bode plot is a graph of the frequency response of a system. It is usually a combination of the magnitude (usually in decibels) of the frequency response and the phase shift. As originally conceived by Hendrik Wade Bode in the 1930s, the plot is an asymptotic approximation of the frequency response, using straight line segments. Bode plots are used to assess the stability of systems by finding the gain and phase margins.\n\nextended_x_axis_range = np.logspace(-2, 8, 5000, endpoint=True)*2*np.pi\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=extended_x_axis_range)\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'b' #'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color=color,label='phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude')\n\nplt.legend(loc=0)\nplt.title('preamplifier Bode plot')\nplt.show()\n\n\n\n\nThe Bode plot for the preamplifier is plotted from 0.01 Hz to 100 MHz. The preamplifier circuit blocks DC because C4 in in series with the audio path.\n\n\n17.4.5 Impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\nThe impulse and step response of the filter are plotted below. Any linear, time-invariant is completely characterized by its impulse response. The transfer function is the Laplace transform of the impulse response. The impulse response defines the response of a linear time-invariant system for all frequencies.\nIn electronic engineering and control theory, step response is the time behavior of the outputs of a general system when its inputs change from zero to one in a very short time.\n\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(preamp_sys,N=500)\nplt.plot(t/1e-3, y)\nplt.title('AN-346 phono preamplifier Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n17.4.6 Group delay\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac {d\\phi (\\omega )}{d\\omega }\\)\n\nw_preamp, mag_preamp, phase_preamp = preamp_sys.bode(w=x_axis_range)\n\nplt.title('AN-346 phono preamplifier group delay')\nplt.semilogx(w_preamp/(2*np.pi), -np.gradient(phase_preamp*np.pi/180)/np.gradient(w_preamp),'-',label='group delay')\n\n#plt.semilogx(w_c1/(2*np.pi), -np.gradient(phase_c1)/w_c1/1e-3,'-',label='phase delay')\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\nplt.ylabel('Group delay, sec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\nThe plot above shows that for frequencies below 100 Hz, the group delay is as much as 4 ms in the audio band. According to paper, Audibility of Group-Delay Equalization, the threshold is 2 ms. The abstract for the paper states:\n\nThe audibility thresholds for group-delay variation from several previous related studies are shown in Fig. 1. If not otherwise stated, these studies have been conducted using headphones. Green applied Huffman sequences, or truncated impulse responses of second-order allpass filters, to study the audibility of phase distortion. He found a threshold value for the peak group delay of about 2 ms for center frequencies of 625 Hz, 1875 Hz, and 4062 Hz.\n\nThe preamp group delay in the low end of the audio band is of concern and some re-design should be implemented if this preamp was to be implemented. The group delay plotted above agrees with the group delay results obtained from LTSpice simulation of the preamp circuit.\n\n\n17.4.7 Comparing results to LTSpice\nThe LM833 TINA-TI Spice Model was entered into LTSpice, but it has some errors when run with LTSpice. So rather than debug the errors, an Analog Devices’s LT1115, was substiuded to obtain simulation results with an opamp model in order to comapre with the Python results, which uses an ideal opamp.\nThe table blow shows that the LM833 and LT1115 have simular performance characteristics.\n\n\n\n\n\n\n\n\n\n\n\nOp Amp\nDistortion %, THD + N at 1 kHz\nNoise, at 1 kHz (nV√Hz)\nSlew Rate, (V/µs)\nGBW (MHz)\nPower Bandwidth\n\n\n\n\nLM833N\n0.002\n4.5\n7\n15\n120 kHz @ 27 Vpp, RL = 2 kΩ, THD ≤ 1%\n\n\nLT1115\n0.002\n0.9\n10\n40\n180 kHz @ 30 VP-P, RL=2k\n\n\n\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Problem Circuits/Two amplifier RIAA Phone Preamp/') # change directory to csv file location\n\nfn = 'Two amplifier RIAA Phone Preamp.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage))+11.257,'-k')    # Bode magnitude plot, adding 11.257 dBV offset to normalized LTSpice data at 1KHz\nplt.semilogx(w_preamp/(2*np.pi), mag_preamp-preamp_gain_1kHz,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-40,20))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color,label='LT1115 phase')  # Bode phase plot\nplt.semilogx(w_preamp/(2*np.pi), phase_preamp,':',color='black',label='MNA phase')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nax2.plot(np.NaN, np.NaN, '-', color='b', label='LT1115 magnitude')\nax2.plot(np.NaN, np.NaN, '-.', color='k', label='MNA magnitude')\n\nplt.legend(loc=0)\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nAs is evident in the plot above, the results from LTSpice and Python agree.\n\n\n17.4.8 Preamplifier deviation from RIAA response\nThe plot below shows the deviation of the preamplifier from the RIAA response. The TI app note says conformance to the RIAA curve is within 0.1 dB from 20 Hz to 20 kHz.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w_preamp/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.2,0.1))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w_preamp/(2*np.pi), phase_RIAA+phase_preamp,':',color=color,label='phase of S2')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nax2.plot(np.NaN, np.NaN, '-', color='k', label='magnitude of S1')\nplt.legend(loc=0)\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe calculations below will find the minimum and maximunation deviation of the amplitude response from the RIAA curve.\n\nidx_low = np.where(w_preamp/(2*np.pi) &gt; 20)[0][0]\nidx_high = np.where(w_preamp/(2*np.pi) &gt; 20e3)[0][0]\nprint('preamp deviation from RIAA curve: {:.3f} to {:.3f} dB'.format(((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].min(),((mag_RIAA-RIAA_gain_1kHz) + mag_preamp-preamp_gain_1kHz)[idx_low:idx_high].max()))\n\npreamp deviation from RIAA curve: -0.045 to 0.066 dB\n\n\nThe calculations above show that within the audio range the deviation of the preamp amplitude response from the RIAA curve varies from -0.044 to 0.066 dB when the nominal component values are used.\n\n\n17.4.9 Sensitivity analysis\nAll circuits have characteristics that dependent on the values of the component. The sensitivity of a circuit’s performance is a measure of how much a particular circuit characteristic changes as a particular component value varies. In this analysis i’ll look at the changes of each pole or zero relative to the compenents value.\nThe root sensitivity function \\(S_x^y\\) gives the change occuring in filter characteristic per \\(\\delta y/ \\delta x\\).\n\\(S_x^y\\) is read as the sensitivity of the characteristic (i.e. y = \\(\\omega_n,\\) or Q or some other characteristic) with respect to the element x.\n\\(S_x^y = \\frac {x}{y} \\frac{\\delta y}{\\delta x}\\)\nWhere x is the filter component that is varied and y is the filter characteristic (\\(\\omega_n,\\) or Q etc.) that we wish to evaluate as x is varied.\nThe preamp transfer function is symbolic form is, H_preamp_sym, and we can get the numerator and denominator with the SymPy fraction function.\n\nH_sym_num, H_sym_denom = fraction(H_preamp_sym)\n\nThe Sympy solve function is used to find the root of the numerator and denimator polynominals.\n\nH_sym_zeros = solve(H_sym_num,s)\nH_sym_poles = solve(H_sym_denom,s)\n\n\n17.4.9.1 Zeros\nHow many roots are there for the numerator polynominial?\n\nprint('there are {:d} zeros'.format(len(H_sym_zeros)))\n\nthere are 3 zeros\n\n\n\n\n17.4.9.2 Z0\nThe first zero is at DC.\n\nH_sym_Z0 = H_sym_zeros[0]\nH_sym_Z0\n\n\\(\\displaystyle 0\\)\n\n\n\n\n17.4.9.3 Z1\nThe second zero is given symbolically by the expression:\n\nH_sym_Z1 = H_sym_zeros[1]\nH_sym_Z1\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\nWhat are the compenets that determine Z1?\n\nprint('the compenets that determine Z1 are: {:s} '.format(str(H_sym_Z1.free_symbols)))\n\nthe compenets that determine Z1 are: {R2, Ro, R1, C1, Co} \n\n\nWhat is the locations of Z1?\n\nprint('location of zero: {:.2f} Hz'.format(N(H_sym_Z1.subs(nominal_component_value))/(2*np.pi)))\n\nlocation of zero: -506.73 Hz\n\n\nZ1 is the zero at 500 Hz and is one of the RIAA time constants.\nWe can fine the sensitivity of Z1 to C1 with the following operation.\n\nS_C1_H_sym_Z1 = (C1/H_sym_Z1)*(H_sym_Z1.diff(C1))\nS_C1_H_sym_Z1\n\n\\(\\displaystyle \\frac{C_{1} \\left(- \\frac{1}{2 C_{1} Co \\left(R_{2} + Ro\\right)} - \\frac{C_{1} R_{1}^{2} + Co R_{1}^{2} - Co R_{1} R_{2} - Co R_{1} Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right) \\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}} + \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1}^{2} Co R_{1} \\left(R_{2} + Ro\\right)}\\right)}{- \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} - \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}}\\)\n\n\nEvaluating this numerically with the component values, we get get the sensitivity of Z1 to C1.\n\nprint('the sensitivity of Z1 to C1 is: {:.2f}'.format(N(S_C1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to C1 is: -1.00\n\n\nDoing the math with SymPy, we can get the sensitivity of Z1 to the other components.\n\nS_R1_H_sym_Z1 = (R1/H_sym_Z1)*(H_sym_Z1.diff(R1))\nprint('the sensitivity of Z1 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R1 is: -0.10\n\n\n\nS_R2_H_sym_Z1 = (R2/H_sym_Z1)*(H_sym_Z1.diff(R2))\nprint('the sensitivity of Z1 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to R2 is: -0.85\n\n\n\nS_Co_H_sym_Z1 = (Co/H_sym_Z1)*(H_sym_Z1.diff(Co))\nprint('the sensitivity of Z1 to Co is: {:.4f}'.format(N(S_Co_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Co is: -0.0002\n\n\n\nS_Ro_H_sym_Z1 = (Ro/H_sym_Z1)*(H_sym_Z1.diff(Ro))\nprint('the sensitivity of Z1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_Z1.subs(nominal_component_value))))\n\nthe sensitivity of Z1 to Ro is: -0.05\n\n\nLater, we we are doing the worst case analsys, we can ignore Co. \n\n\n17.4.9.4 Z2\nThe third zero of the transfer function is Z2.\n\nH_sym_Z2 = H_sym_zeros[2]\nH_sym_Z2\n\n\\(\\displaystyle - \\frac{C_{1} R_{1} + Co R_{1} + Co R_{2} + Co Ro}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)} + \\frac{\\sqrt{C_{1}^{2} R_{1}^{2} + 2 C_{1} Co R_{1}^{2} - 2 C_{1} Co R_{1} R_{2} - 2 C_{1} Co R_{1} Ro + Co^{2} R_{1}^{2} + 2 Co^{2} R_{1} R_{2} + 2 Co^{2} R_{1} Ro + Co^{2} R_{2}^{2} + 2 Co^{2} R_{2} Ro + Co^{2} Ro^{2}}}{2 C_{1} Co R_{1} \\left(R_{2} + Ro\\right)}\\)\n\n\n\nprint('the compenets that determine Z2 are: {:s} '.format(str(H_sym_Z2.free_symbols)))\n\nthe compenets that determine Z2 are: {R2, Ro, R1, C1, Co} \n\n\n\nprint('Z2: {:.3e} Hz'.format(N(H_sym_Z2.subs(nominal_component_value))/(2*np.pi)))\n\nZ2: -8.885e-3 Hz\n\n\nThe zero Z2, evaluates to a system zero at DC and is not one the of RIAA time constants.\n\nS_C1_H_sym_Z2 = (C1/H_sym_Z2)*(H_sym_Z2.diff(C1))\nprint('the sensitivity of Z2 to C1 is: {:.3e}'.format(N(S_C1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to C1 is: -1.580e-4\n\n\n\nS_Co_H_sym_Z2 = (Co/H_sym_Z2)*(H_sym_Z2.diff(Co))\nprint('the sensitivity of Z2 to Co is: {:.2f}'.format(N(S_Co_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Co is: -1.00\n\n\n\nS_R1_H_sym_Z2 = (R1/H_sym_Z2)*(H_sym_Z2.diff(R1))\nprint('the sensitivity of Z2 to R1 is: {:.2f}'.format(N(S_R1_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R1 is: -0.90\n\n\n\nS_R2_H_sym_Z2 = (R2/H_sym_Z2)*(H_sym_Z2.diff(R2))\nprint('the sensitivity of Z2 to R2 is: {:.2f}'.format(N(S_R2_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to R2 is: -0.09\n\n\n\nS_Ro_H_sym_Z2 = (Ro/H_sym_Z2)*(H_sym_Z2.diff(Ro))\nprint('the sensitivity of Z2 to Ro is: {:.3f}'.format(N(S_Ro_H_sym_Z2.subs(nominal_component_value))))\n\nthe sensitivity of Z2 to Ro is: -0.006\n\n\n\n\n17.4.9.5 Poles\nHow many poles are there in the preamp transfer function?\n\nprint('there are {:d} poles in the transfer function'.format(len(H_sym_poles)))\n\nthere are 4 poles in the transfer function\n\n\n\n\n17.4.9.6 P0\nThe first pole is:\n\nH_sym_P0 = H_sym_poles[0]\nH_sym_P0\n\n\\(\\displaystyle - \\frac{1}{C_{1} R_{1}}\\)\n\n\nThe pole P0 evaluates to one of the RIAA time constants.\n\nprint('P0: {:.2f}Hz'.format(N(H_sym_P0.subs(nominal_component_value))/(2*np.pi)))\n\nP0: -50.63Hz\n\n\n\nS_C1_H_sym_P0 = (C1/H_sym_P0)*(H_sym_P0.diff(C1))\nprint('the sensitivity of P0 to C1 is: {:.2f}'.format(N(S_C1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to C1 is: -1.00\n\n\n\nS_R1_H_sym_P0 = (R1/H_sym_P0)*(H_sym_P0.diff(R1))\nprint('the sensitivity of P0 to R1 is: {:.2f}'.format(N(S_R1_H_sym_P0.subs(nominal_component_value))))\n\nthe sensitivity of P0 to R1 is: -1.00\n\n\n\n\n17.4.9.7 P1\nThe second pole is:\n\nH_sym_P1 = H_sym_poles[1]\nH_sym_P1\n\n\\(\\displaystyle - \\frac{1}{Co Ro}\\)\n\n\nThe pole P1 evaluates to a frequency near DC.\n\nprint('P1: {:.2f}Hz'.format(N(H_sym_P1.subs(nominal_component_value))/(2*np.pi)))\n\nP1: -1.59Hz\n\n\n\nS_Co_H_sym_P1 = (Co/H_sym_P1)*(H_sym_P1.diff(Co))\nprint('the sensitivity of P1 to Co is: {:.2f}'.format(N(S_Co_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Co is: -1.00\n\n\n\nS_Ro_H_sym_P1 = (Ro/H_sym_P1)*(H_sym_P1.diff(Ro))\nprint('the sensitivity of P1 to Ro is: {:.2f}'.format(N(S_Ro_H_sym_P1.subs(nominal_component_value))))\n\nthe sensitivity of P1 to Ro is: -1.00\n\n\n\n\n17.4.9.8 P2\nThe 3rd pole is:\n\nH_sym_P2 = H_sym_poles[2]\nH_sym_P2\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} - \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the compenets that determine P2 are: {:s} '.format(str(H_sym_P2.free_symbols)))\n\nthe compenets that determine P2 are: {R3, R6, C4, C3} \n\n\n\nprint('P2: {:.2f}Hz'.format(N(H_sym_P2.subs(nominal_component_value))/(2*np.pi)))\n\nP2: -2122.88Hz\n\n\n\nS_C3_H_sym_P2 = (C3/H_sym_P2)*(H_sym_P2.diff(C3))\nprint('the sensitivity of P2 to C3 is: {:.2f}'.format(N(S_C3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C3 is: -1.00\n\n\n\nS_C4_H_sym_P2 = (C4/H_sym_P2)*(H_sym_P2.diff(C4))\nprint('the sensitivity of P2 to C4 is: {:.3e}'.format(N(S_C4_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to C4 is: -2.829e-5\n\n\n\nS_R3_H_sym_P2 = (R3/H_sym_P2)*(H_sym_P2.diff(R3))\nprint('the sensitivity of P2 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R3 is: -0.96\n\n\n\nS_R6_H_sym_P2 = (R6/H_sym_P2)*(H_sym_P2.diff(R6))\nprint('the sensitivity of P2 to R6 is: {:.3f}'.format(N(S_R6_H_sym_P2.subs(nominal_component_value))))\n\nthe sensitivity of P2 to R6 is: -0.041\n\n\n\n\n17.4.9.9 P3\nThe 4th pole is:\n\nH_sym_P3 = H_sym_poles[3]\nH_sym_P3\n\n\\(\\displaystyle \\frac{- C_{3} R_{3} - C_{4} R_{3} - C_{4} R_{6} + \\sqrt{C_{3}^{2} R_{3}^{2} + 2 C_{3} C_{4} R_{3}^{2} - 2 C_{3} C_{4} R_{3} R_{6} + C_{4}^{2} R_{3}^{2} + 2 C_{4}^{2} R_{3} R_{6} + C_{4}^{2} R_{6}^{2}}}{2 C_{3} C_{4} R_{3} R_{6}}\\)\n\n\n\nprint('the compenets that determine P3 are: {:s} '.format(str(H_sym_P3.free_symbols)))\n\nthe compenets that determine P3 are: {R3, R6, C4, C3} \n\n\n\nprint('P3: {:.2f}Hz'.format(N(H_sym_P3.subs(nominal_component_value))/(2*np.pi)))\n\nP3: -1.39Hz\n\n\n\nS_C3_H_sym_P3 = (C3/H_sym_P3)*(H_sym_P3.diff(C3))\nprint('the sensitivity of P3 to C3 is: {:.2e}'.format(N(S_C3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C3 is: -2.83e-5\n\n\n\nS_C4_H_sym_P3 = (C4/H_sym_P3)*(H_sym_P3.diff(C4))\nprint('the sensitivity of P3 to C5 is: {:.2f}'.format(N(S_C4_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to C5 is: -1.00\n\n\n\nS_R3_H_sym_P3 = (R3/H_sym_P3)*(H_sym_P3.diff(R3))\nprint('the sensitivity of P3 to R3 is: {:.2f}'.format(N(S_R3_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R3 is: -0.04\n\n\n\nS_R6_H_sym_P3 = (R6/H_sym_P3)*(H_sym_P3.diff(R6))\nprint('the sensitivity of P3 to R6 is: {:.2f}'.format(N(S_R6_H_sym_P3.subs(nominal_component_value))))\n\nthe sensitivity of P3 to R6 is: -0.96\n\n\nIn the worst case analysis below, the componets that have sensitivites greater than 0.05 are the ones that factor into the worst case analysis.\n\n\n\n17.4.10 Component selection\nThe table below list each of the components used in the preamp along with a link to the Digikey pages for each of the components in the preamp. Digikey is a larger distributor of electronic components in the US. All the components have operating temperature ranges that exceed the normal household envirment.\nThe resistors chosen are all 1% Metal film type resistors. Metal film resistors possess good noise characteristics and low non-linearity due to a low voltage coefficient. They are also beneficial due to long-term stability.\nThe capacitors are all polypropylene Film capacitor types. Polystyrene or polypropylene are considered the best for audio applications.\nThe Op Amp, LM833N, is a dual bipolar low noise (\\(\\frac {4.5nV}{\\sqrt{Hz}}\\)), wide bandwidth (16 MHz) audio operational amplifier from Texas Instrments.\n\n\n\nRef\nValue\nDescription\nDigikey PN\n\n\n\n\nRo\n499\n±1% 1/4W Metal Film\nRNF14FTD499RCT-ND\n\n\nRp\n47k\n±1% 1/4W Metal Film\n13-MFR-25FTE52-47KTB-ND\n\n\nR1\n80.6k\n±1% 1/4W Metal Film\n80.6KXBK-ND\n\n\nR2\n58.45k\n±1% 1/4W Metal Film\nRNF14FTD8K45CT-ND\n\n\nR3\n2.37k\n±1% 1/4W Metal Film\n13-MFR-25FBF52-2K37-ND\n\n\nR4\n2k\n±1% 1/4W Metal Film\n13-MFR-25FRF52-2KCT-ND\n\n\nR5\n4.3k\n±1% 1/4W Metal Film\nS4.3KCACT-ND\n\n\nR6\n54.9k\n±1% 1/4W Metal Film\nRNF14FTD54K9CT-ND\n\n\nCo\n200\\(\\mu\\)\n10% Film Capacitor 450V Polypropylene\n283-EFDKS45K207F064DH-ND\n\n\nCp\n100p\n10% Film Capacitor 250V Polypropylene\n399-RSBEC0100ZA00M-ND\n\n\nC1\n0.039\\(\\mu\\)\n2% Film Capacitor 25V 63V Polypropylene\nBC2066-ND\n\n\nC3\n0.033\\(\\mu\\)\n1% Film Capacitor 63V 100V Polypropylene\n399-PHE426DJ5330FR17T0CT-ND\n\n\nC4\n2\\(\\mu\\)\n10% Film Capacitor 305V 630V Polypropylene\n495-B32923P3205K000-ND\n\n\nU1, U2\nLM833N\nAudio op amp\n296-44419-5-ND\n\n\n\nThe parts in this list are considered good choices for a first pass at the bill of materials. The size of the production run and the piece part cost are also a factors which must be considered if the preamp is going to be built. One thing to notice is that Co, the 200 \\(\\mu\\) F capacitor is expensive. The use of a polypropylene film capacitor for this component is consistent with the advice of keeping all capacitors in the audio path polystyrene or polypropylene.\n\n\n17.4.11 Monte Carlo simulation\nIn this analysis the circuit equations are solved after assigning random element values from within the tolerance band to the components. This simulates building a large number of circuits with components chosen at random from bins or reals of components during the board stuffing process. All the components are required to met their specifications, but are allowed to have some varaition accorting to theier tolerance. For example a 1% 2k resistor can range from 1980 to 2020 \\(\\Omega\\). In addition to the components initial tolerance, the temperature coefficient and aging of paramters can also be included.\nIn this simulation, I’m only including the initial tolerances of parameters and I’m assuming the distritution is uniform. The Numpy function random.uniform is used to generate the random values within the tolerance range, however, for this function, the hight end-point value may or may not be included in the range depending on floating-point rounding, so if this is important, some adjustments to the code are required. The Numpy function random.seed is used to re-seed the random number generator.\n\nnum = 20 # number of simulations to run\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to the hold the results of each run\nmag_ans = np.zeros(shape=(num,len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(num,len(new_x_axis_range)))\n\ncomponent_values_tol = nominal_component_value.copy() # makde a copy\n\nrandom.seed(a=None, version=2) # re-seed the random number generator\n\nThe following takes about 15 seconds to run on for num=20 on an i3 machine.\n\nfor i in range(0,num):\n\n    component_values_tol[Ro] = random.uniform(nominal_component_value[Ro]-nominal_component_value[Ro]*0.01,nominal_component_value[Ro]+nominal_component_value[Ro]*0.01)\n    component_values_tol[Rp] = random.uniform(nominal_component_value[Rp]-nominal_component_value[Rp]*0.01,nominal_component_value[Rp]+nominal_component_value[Ro]*0.01)\n\n    component_values_tol[R1] = random.uniform(nominal_component_value[R1]-nominal_component_value[R1]*0.01,nominal_component_value[R1]+nominal_component_value[R1]*0.01)\n    component_values_tol[R2] = random.uniform(nominal_component_value[R2]-nominal_component_value[R2]*0.01,nominal_component_value[R2]+nominal_component_value[R2]*0.01)    \n    component_values_tol[R3] = random.uniform(nominal_component_value[R3]-nominal_component_value[R3]*0.01,nominal_component_value[R3]+nominal_component_value[R3]*0.01)\n    component_values_tol[R4] = random.uniform(nominal_component_value[R4]-nominal_component_value[R4]*0.01,nominal_component_value[R4]+nominal_component_value[R4]*0.01)    \n    component_values_tol[R5] = random.uniform(nominal_component_value[R5]-nominal_component_value[R5]*0.01,nominal_component_value[R5]+nominal_component_value[R5]*0.01)\n    component_values_tol[R6] = random.uniform(nominal_component_value[R6]-nominal_component_value[R6]*0.01,nominal_component_value[R6]+nominal_component_value[R6]*0.01)    \n\n    component_values_tol[Co] = random.uniform(nominal_component_value[Co]-nominal_component_value[Co]*0.1,nominal_component_value[Co]+nominal_component_value[Co]*0.1)\n    component_values_tol[Cp] = random.uniform(nominal_component_value[Cp]-nominal_component_value[Cp]*0.1,nominal_component_value[Cp]+nominal_component_value[Cp]*0.1)\n    component_values_tol[C1] = random.uniform(nominal_component_value[C1]-nominal_component_value[C1]*0.02,nominal_component_value[C1]+nominal_component_value[C1]*0.02)\n    component_values_tol[C3] = random.uniform(nominal_component_value[C3]-nominal_component_value[C3]*0.01,nominal_component_value[C3]+nominal_component_value[C3]*0.01)\n    component_values_tol[C4] = random.uniform(nominal_component_value[C4]-nominal_component_value[C4]*0.1,nominal_component_value[C4]+nominal_component_value[C4]*0.1)\n\n    # enter the element values\n    preamp_equ_tol = preamp_equ_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    \n    # save the results from each run\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\n\n17.4.12 Preamplifier deviation from RIAA response\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.3))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Monte Carlo runs showing deviation from RIAA curve')\nplt.show()\n\n\n\n\nThe Monte Carlo simulation shows that the preamp amplitude response deviatin from the RIAA curve can very from -0.2 to 0.3 dB over the audio band. If the performance requirement for this preamp was to be within \\(\\pm\\) 0.1 dB of the RIAA curve, then some redesign or tighter component tolerancing is required.\n\n\n17.4.13 Worst case analysis\nIn a worst case analysis, we would look at:\n\nminimum and maximum values of the initial component tolerance\n\nmaximum or minumum temperature coefficients of the parameters\n\nmaximum aging or drift of parameter values\n\nSince we usually can’t tell by inspection which combination of minimum and maximum values will give the worst case, we can run a number of simulations in which all combination of minum and maximium variations are included. From the family of results we can look for the worst case.\nHow resistors and capactors in the preamp circuit?\n\nprint('number of components: {:d}'.format(len(nominal_component_value)))\n\nnumber of components: 14\n\n\nHow many combinations min and max combinations?\n\nprint('number of min and max combinations: {:,d}'.format(2**14))\n\nnumber of min and max combinations: 16,384\n\n\n16 thousand simulation runs to too many. From the sensitivity analysis above, only R1, R2, R3, R6, Ro, C1 and C3 are sensitive. Running all combinations of the min and max tolerance for this set is reasonable and is \\(2^7=128\\) combinations.\nThe tolerances for each of the componts is defined below:\n\nTol = {Ro:0.01,R1:0.01,R2:0.01,R3:0.01,R6:0.01,C1:0.02,C3:0.01}\n\nOnly C1 has a tolerance other than 1%.\nThe array ‘run’ is created that consists of a binary count, with leading zeros from 0 to 127. Then the zero values are replaced with -1.\n\nrun = []\nfor i in range(0,2**(len(Tol))):\n    temp = list('{:07b}'.format(i)) # include leading zeros\n    for j in range(len(temp)):\n        temp[j] = int(temp[j])\n    run.append(temp)\n\nrun = np.asarray(run)\nrun = np.where(run == 0, -1, run)\n\nThe first row of run is:\n\nrun[0]\n\narray([-1, -1, -1, -1, -1, -1, -1])\n\n\nIn the for loop below, at i = 0, run[0] would be all -1’s and this could apply the low tolerance range to the nominal component values.\n\nrun[-1]\n\narray([1, 1, 1, 1, 1, 1, 1])\n\n\nThe last time through the for loop, where i = 127, run[-1] is all 1’s and this would apply the high tolerance range to the nominal component values. Between i = 0 and i = 127, all combinations of minumum and maximum tolerance is appled.\n\nnew_x_axis_range = np.logspace(1, 5.5, 100, endpoint=True)*2*np.pi\n\n# make some arrays to hold the results\nmag_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\nphase_ans = np.zeros(shape=(len(run),len(new_x_axis_range)))\n\nThe following cell takes about 90 seconds to run on an i3 machine.\n\nfor i in range(len(run)):\n    component_values_tol[Ro] = nominal_component_value[Ro]*(1+run[i][0]*Tol[Ro])\n    component_values_tol[Rp] = nominal_component_value[Rp]\n\n    component_values_tol[R1] = nominal_component_value[R1]*(1+run[i][1]*Tol[R1])\n    component_values_tol[R2] = nominal_component_value[R2]*(1+run[i][2]*Tol[R2]) \n    component_values_tol[R3] = nominal_component_value[R3]*(1+run[i][3]*Tol[R3])\n\n    component_values_tol[R4] = nominal_component_value[R4] \n    component_values_tol[R5] = nominal_component_value[R5]\n    component_values_tol[R6] = nominal_component_value[R6]*(1+run[i][4]*Tol[R6])\n\n    component_values_tol[Co] = nominal_component_value[Co]\n    component_values_tol[Cp] = nominal_component_value[Cp]\n    component_values_tol[C1] = nominal_component_value[C1]*(1+run[i][5]*Tol[C1])\n    component_values_tol[C3] = nominal_component_value[C3]*(1+run[i][6]*Tol[C3])\n    component_values_tol[C4] = nominal_component_value[C4]\n    \n    # enter the element values\n    preamp_equ_tol = preamp_equ_sym.subs(component_values_tol)\n\n    U_preamp_tol = solve(preamp_equ_tol,X)\n\n    H_preamp_tol = U_preamp_tol[v2]/U_preamp_tol[v1]\n\n    # Extract the numerator and denominator polynomials so that the system can be defined in SciPy.\n    H_preamp_tol_num, H_preamp_tol_denom = fraction(H_preamp_tol) #returns numerator and denominator\n\n    # convert symbolic to numpy polynomial\n    a2 = np.array(Poly(H_preamp_tol_num, s).all_coeffs(), dtype=float)\n    b2 = np.array(Poly(H_preamp_tol_denom, s).all_coeffs(), dtype=float)\n    preamp_sys_tol = signal.TransferFunction(a2,b2)\n\n    w_preamp_sys_tol, mag_preamp_sys_tol, phase_preamp_sys_tol = preamp_sys_tol.bode(w=new_x_axis_range)\n    mag_ans[i] = mag_preamp_sys_tol\n    phase_ans[i] = phase_preamp_sys_tol\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), (mag_RIAA-RIAA_gain_1kHz) + (mag_ans[i]-preamp_gain_1kHz),'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-0.3,0.4))\nplt.grid()\nplt.axvspan(20, 20e3, color='y', alpha=0.3)\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nfor i in range(0,num):\n    plt.semilogx(w_RIAA/(2*np.pi), phase_RIAA+phase_ans[i],':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nplt.title('Worst Case deviation from RIAA curve')\nplt.show()\n\n\n\n\nThe results above show that the worst case tolerance conditions yeild deviations of -0.19 to 0.3 dB from the RIAA curve."
  },
  {
    "objectID": "Two amplifier RIAA Phono Preamp.html#summary",
    "href": "Two amplifier RIAA Phono Preamp.html#summary",
    "title": "17  Two amplifier RIAA phono preamp",
    "section": "17.5 Summary ",
    "text": "17.5 Summary \nThe circuit presented in this analysis is just one example of many circuits that can be found on line. For each design to be evaluated, some type of side by side analysis should be used used to down select. This notebook can be used as template for any compartivite analysis.\nThe circuit in the app note appears to have low frequency group delay that might be an issue. Also the deviation from the RIAA curve using normal component tolerances does not meet the 0.1 dB requirement. The worst case analysis also confirms this. The circuit employs an expesive 200\\(\\mu\\) Farad film capacitor. The circuit is missing a subsonic filter."
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Symbolic Modified Nodal Analysis",
    "section": "About this book",
    "text": "About this book\n\n\n\n\n\n\nNote\n\n\n\nLast update: 28 Nov 2023\nThis book is a work in progress and is a working draft. Spelling and grammer checks are needed. This book is for testing only.\n\n\nThis is the website is an online verion of my book: Symbolic Modified Nodal Analysis using Python. Symbolic circuit analysis is a circuit analysis method that derives network equations with the circuit elements represented by symbols.\n\nPython module verions\nThe following verions were used in this book.\n\n\n\nlibrary\nversion\n\n\n\n\npython\n3.10.9\n\n\nJupyterLab notebook\n3.5.3\n\n\nNumPy\n1.23.5\n\n\nSymPy\n1.11.1\n\n\nSciPy\n1.10.0\n\n\nPandas\n1.5.3\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8\n\n\n\n\n\nUpdate History\nThis website will be updated periodically as new early release content becomes available, and post-publication for errata fixes.\n\n\n\ndate\ndescription\n\n\n\n\n29 Dec 2023\ntest version\n\n\n1 Jan 2024\nanother update\n\n\n\n\n\nLicense\nThis work (includes python code, documentation, test circuits, etc.) is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\nShare — copy and redistribute the material in any medium or format\nAdapt — remix, transform, and build upon the material for any purpose, even commercially.\nhttps://creativecommons.org/licenses/by-sa/4.0/"
  },
  {
    "objectID": "index.html#update-history",
    "href": "index.html#update-history",
    "title": "Symbolic Modified Nodal Analysis",
    "section": "Update History",
    "text": "Update History\nThis website will be updated periodically as new early release content becomes available, and post-publication for errata fixes.\n\n\n\ndate\ndescription\n\n\n\n\n29 Dec 2023\ntest version\n\n\n1 Jan 2024\nanother update"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Symbolic Modified Nodal Analysis",
    "section": "License",
    "text": "License\nThis work (includes python code, documentation, test circuits, etc.) is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\nShare — copy and redistribute the material in any medium or format\nAdapt — remix, transform, and build upon the material for any purpose, even commercially.\nhttps://creativecommons.org/licenses/by-sa/4.0/"
  },
  {
    "objectID": "index.html#python-module-verions",
    "href": "index.html#python-module-verions",
    "title": "Symbolic Modified Nodal Analysis",
    "section": "Python module verions",
    "text": "Python module verions\nThe following verions were used in this book.\n\n\n\nenvironment\nversion\n\n\n\n\npython\n3.10.9\n\n\nnumpy\n1.23.5\n\n\nsympy\n1.11.1\n\n\nscipy\n1.10.0\n\n\npandas\n1.5.3\n\n\nmatplotlib\n3.7.0\n\n\nLTSpice\n17.1.8"
  },
  {
    "objectID": "Introduction.html#python",
    "href": "Introduction.html#python",
    "title": "1  Introduction",
    "section": "1.3 Python",
    "text": "1.3 Python"
  },
  {
    "objectID": "Introduction.html#python-modules",
    "href": "Introduction.html#python-modules",
    "title": "1  Introduction",
    "section": "1.4 Python modules",
    "text": "1.4 Python modules"
  },
  {
    "objectID": "Introduction.html#other-packages",
    "href": "Introduction.html#other-packages",
    "title": "1  Introduction",
    "section": "1.6 Other packages",
    "text": "1.6 Other packages"
  },
  {
    "objectID": "Introduction.html#jupyterlab",
    "href": "Introduction.html#jupyterlab",
    "title": "1  Introduction",
    "section": "1.7 JupyterLab",
    "text": "1.7 JupyterLab"
  },
  {
    "objectID": "Introduction.html#what-this-book-is-about",
    "href": "Introduction.html#what-this-book-is-about",
    "title": "1  Introduction",
    "section": "1.1 What this book is about",
    "text": "1.1 What this book is about"
  },
  {
    "objectID": "Verification.html#test-circuits",
    "href": "Verification.html#test-circuits",
    "title": "Verification",
    "section": "Test Circuits",
    "text": "Test Circuits\nThis folder contains the test circuits used to validate the network analysis code. The code was validated under the following enviroment:\nmight want new names rather than test_1\nBasic validation of the code consisted of analyzing simple networks and examining the results. A more comprehensive evaluation of the code was performed by solving test circuits and comparing the results to LTSpice. As of October 2023 all the element types have been tested. The validation circuits range from simple to large and complex. The largest validation circuit consist of 32 nodes, 59 branches and multiple instances all of the element types. For this large test circuit, there are small numerical differences between the Python MNA code results and the LTSpice solution, which are describe in the JupyterLab notebooks.\nThe table below lists the test circuits used to validate and test the code. Each test circuit has its own folder with the support files. The test circuits are a collection of problems from text books or large and complex circuits that I made up that include various elements or unique combinations of elements or topologies. In LTSpice the series resistance for inductors defaults to 1e-3 Ohms unless set to zero. Leaving the default series inductance at 1e-3 Ohms will cause small numerical differences in the solution obtained by LTSpice.\n\n\n\n\n\n\n\n\nTest file\nCircuit Description\nnotes\n\n\n\n\ntest_1\nResistors, independent and dependent sources\nDC analysis\n\n\ntest_2\nResistors and independent sources\nDC analysis\n\n\ntest_3\nSame circuit as test_1, but with R2 replaced with C2 and R3 replaced with L1.\nAC analysis\n\n\ntest_4\nResistors and one of each type of source\nAC analysis\n\n\ntest_5\nRLC and one of each type of source\nAC analysis\n\n\ntest_6\nRLC, coupled inductors and one of each type of source\nAC analysis\n\n\ntest_7\nLarge circuit and two or more of each element type w/o Op Amps\nAC analysis\n\n\ntest_8\nTest_7 w/ op amps included\nAC analysis\n\n\ntest_9\nCurrent sources only dependent and independent\nDC analysis\n\n\ntest_10\nCurrent and voltage sources only, no LRCs\nDC analysis\n\n\ntest_11\nThree coupled inductors\nAC analysis\n\n\ntest_12\nLC ladder low pass filter\nAC analysis\n\n\ntest_13\nRing of current sources and inductors\nAC analysis\n\n\n\n\\(\\large{\\color {red} {\\text{Spelling and grammer of the jupyter notebooks has not been completed}}}\\)\nThe following file types are in each folder:\n\n\n\nfile name\nDescription\n\n\n\n\ntest_*.asc\nLTSpice circuit schematic\n\n\nreadme.md\na description of the circuit\n\n\ntest_*.ipynb\ntest report Jupyter notebook\n\n\ntest_*.net\nSpice net list\n\n\ntest_*.png\nimage of the schematic for display in the notebook\n\n\ntest_*.csv\ncsv data exported from LTSpice"
  },
  {
    "objectID": "test_3.html#symbolic-solution",
    "href": "test_3.html#symbolic-solution",
    "title": "6  test_3",
    "section": "6.1 Symbolic solution",
    "text": "6.1 Symbolic solution\n\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- C_{1} I_{1} R_{1} R_{2} ea_{1} s - C_{1} I_{1} R_{1} R_{2} s - C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} f_{1} s + C_{1} R_{2} V_{1} s + I_{1} R_{1} ea_{1} f_{1} - I_{1} R_{1} ea_{1} + I_{1} R_{1} f_{1} - I_{1} R_{1} - V_{1} f_{1} + V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}, \\  I_{F1} : \\frac{- C_{1} V_{1} f_{1} s - C_{1} V_{2} f_{1} s}{C_{1} R_{2} s - f_{1} + 1}, \\  I_{L1} : \\frac{- I_{1} R_{1} ea_{1} - I_{1} R_{1} + V_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  I_{V1} : \\frac{- C_{1} I_{1} L_{1} R_{2} s^{2} + C_{1} L_{1} V_{1} f_{1} s^{2} - C_{1} L_{1} V_{1} s^{2} + C_{1} L_{1} V_{2} f_{1} s^{2} - C_{1} L_{1} V_{2} s^{2} + C_{1} R_{1} V_{1} ea_{1} f_{1} s - C_{1} R_{1} V_{1} ea_{1} s + C_{1} R_{1} V_{1} f_{1} s - C_{1} R_{1} V_{1} s + C_{1} R_{1} V_{2} ea_{1} f_{1} s - C_{1} R_{1} V_{2} ea_{1} s + C_{1} R_{1} V_{2} f_{1} s - C_{1} R_{1} V_{2} s - C_{1} R_{2} V_{1} s + I_{1} L_{1} f_{1} s - I_{1} L_{1} s + V_{1} f_{1} - V_{1}}{C_{1} L_{1} R_{2} s^{2} + C_{1} R_{1} R_{2} ea_{1} s + C_{1} R_{1} R_{2} s - L_{1} f_{1} s + L_{1} s - R_{1} ea_{1} f_{1} + R_{1} ea_{1} - R_{1} f_{1} + R_{1}}, \\  I_{V2} : \\frac{- C_{1} V_{1} s - C_{1} V_{2} s}{C_{1} R_{2} s - f_{1} + 1}, \\  v_{1} : V_{1}, \\  v_{2} : \\frac{C_{1} R_{2} V_{1} s + V_{2} f_{1} - V_{2}}{C_{1} R_{2} s - f_{1} + 1}, \\  v_{3} : \\frac{I_{1} L_{1} R_{1} ea_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  v_{4} : \\frac{- I_{1} L_{1} R_{1} s + L_{1} V_{1} s + R_{1} V_{1} ea_{1}}{L_{1} s + R_{1} ea_{1} + R_{1}}, \\  v_{5} : - V_{2}\\right\\}\\)\n\n\n\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\nv₁ = V₁\n     C₁⋅R₂⋅V₁⋅s + V₂⋅f₁ - V₂\nv₂ = ───────────────────────\n         C₁⋅R₂⋅s - f₁ + 1   \n     I₁⋅L₁⋅R₁⋅ea₁⋅s + R₁⋅V₁⋅ea₁\nv₃ = ──────────────────────────\n         L₁⋅s + R₁⋅ea₁ + R₁    \n     -I₁⋅L₁⋅R₁⋅s + L₁⋅V₁⋅s + R₁⋅V₁⋅ea₁\nv₄ = ─────────────────────────────────\n             L₁⋅s + R₁⋅ea₁ + R₁       \nv₅ = -V₂\n                      2                2             2                2       \n       - C₁⋅I₁⋅L₁⋅R₂⋅s  + C₁⋅L₁⋅V₁⋅f₁⋅s  - C₁⋅L₁⋅V₁⋅s  + C₁⋅L₁⋅V₂⋅f₁⋅s  - C₁⋅L\nI_V1 = ───────────────────────────────────────────────────────────────────────\n                                                                              \n                                                                              \n\n      2                                                                       \n₁⋅V₂⋅s  + C₁⋅R₁⋅V₁⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₁⋅ea₁⋅s + C₁⋅R₁⋅V₁⋅f₁⋅s - C₁⋅R₁⋅V₁⋅s + C₁\n──────────────────────────────────────────────────────────────────────────────\n                       2                                                      \n             C₁⋅L₁⋅R₂⋅s  + C₁⋅R₁⋅R₂⋅ea₁⋅s + C₁⋅R₁⋅R₂⋅s - L₁⋅f₁⋅s + L₁⋅s - R₁⋅e\n\n                                                                              \n⋅R₁⋅V₂⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₂⋅ea₁⋅s + C₁⋅R₁⋅V₂⋅f₁⋅s - C₁⋅R₁⋅V₂⋅s - C₁⋅R₂⋅V₁⋅s + I\n──────────────────────────────────────────────────────────────────────────────\n                                                                              \na₁⋅f₁ + R₁⋅ea₁ - R₁⋅f₁ + R₁                                                   \n\n                                \n₁⋅L₁⋅f₁⋅s - I₁⋅L₁⋅s + V₁⋅f₁ - V₁\n────────────────────────────────\n                                \n                                \n       -C₁⋅V₁⋅s - C₁⋅V₂⋅s\nI_V2 = ──────────────────\n        C₁⋅R₂⋅s - f₁ + 1 \n                                                          2                2  \n        -C₁⋅I₁⋅R₁⋅R₂⋅ea₁⋅s - C₁⋅I₁⋅R₁⋅R₂⋅s - C₁⋅L₁⋅V₁⋅f₁⋅s  - C₁⋅L₁⋅V₂⋅f₁⋅s  -\nI_Ea1 = ──────────────────────────────────────────────────────────────────────\n                                                                              \n                                                                    C₁⋅L₁⋅R₂⋅s\n\n                                                                              \n C₁⋅R₁⋅V₁⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₁⋅f₁⋅s - C₁⋅R₁⋅V₂⋅ea₁⋅f₁⋅s - C₁⋅R₁⋅V₂⋅f₁⋅s + C₁⋅R₂\n──────────────────────────────────────────────────────────────────────────────\n2                                                                             \n  + C₁⋅R₁⋅R₂⋅ea₁⋅s + C₁⋅R₁⋅R₂⋅s - L₁⋅f₁⋅s + L₁⋅s - R₁⋅ea₁⋅f₁ + R₁⋅ea₁ - R₁⋅f₁ \n\n                                                                \n⋅V₁⋅s + I₁⋅R₁⋅ea₁⋅f₁ - I₁⋅R₁⋅ea₁ + I₁⋅R₁⋅f₁ - I₁⋅R₁ - V₁⋅f₁ + V₁\n────────────────────────────────────────────────────────────────\n                                                                \n+ R₁                                                            \n       -C₁⋅V₁⋅f₁⋅s - C₁⋅V₂⋅f₁⋅s\nI_F1 = ────────────────────────\n           C₁⋅R₂⋅s - f₁ + 1    \n       -I₁⋅R₁⋅ea₁ - I₁⋅R₁ + V₁\nI_L1 = ───────────────────────\n          L₁⋅s + R₁⋅ea₁ + R₁"
  },
  {
    "objectID": "test_3.html#numeric-solution",
    "href": "test_3.html#numeric-solution",
    "title": "6  test_3",
    "section": "6.2 Numeric solution",
    "text": "6.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents. Need to set the current source, I1, to zero.\n\n# enter the element values\nequ1a = equ.subs({    \nR2:2.000000,\nV1:1.000000,\nI1:0.000000,\nV2:0.000000,\nea1:2.000000,\nf1:2.000000,\nR1:2.000000,\nC1:1.000000,\nL1:1.000000})\n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} - 1.0 s v_{2} + v_{1} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{4}\\\\I_{F1} - 1.0 s v_{1} + v_{2} \\cdot \\left(1.0 s + 0.5\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 I_{L1} s - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nSolve for voltages and currents in terms of Laplace variable s.\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{- 2.0 s^{2} - 10.0 s - 1.0}{2.0 s^{2} + 11.0 s - 6.0}, \\  I_{F1} : - \\frac{2.0 s}{2.0 s - 1.0}, \\  I_{L1} : \\frac{1}{s + 6.0}, \\  I_{V1} : \\frac{s^{2} + 4.0 s + 1.0}{2.0 s^{2} + 11.0 s - 6.0}, \\  I_{V2} : - \\frac{s}{2.0 s - 1.0}, \\  v_{1} : 1.0, \\  v_{2} : \\frac{2.0 s}{2.0 s - 1.0}, \\  v_{3} : \\frac{4.0}{s + 6.0}, \\  v_{4} : \\frac{s + 4.0}{s + 6.0}, \\  v_{5} : 0.0\\right\\}\\)"
  },
  {
    "objectID": "test_3.html#ac-analysis",
    "href": "test_3.html#ac-analysis",
    "title": "6  test_3",
    "section": "6.3 AC analysis",
    "text": "6.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V1} + v_{1} \\cdot \\left(0.5 + 1.0 i\\right) - 1.0 i v_{2} - 0.5 v_{4}\\\\I_{F1} - 1.0 i v_{1} + v_{2} \\cdot \\left(0.5 + 1.0 i\\right) - 0.5 v_{5}\\\\I_{Ea1} - I_{F1} - I_{L1}\\\\I_{L1} - 0.5 v_{1} + 0.5 v_{4}\\\\- I_{V2} - 0.5 v_{2} + 0.5 v_{5}\\\\v_{1}\\\\- v_{5}\\\\- 2.0 v_{1} + v_{3} + 2.0 v_{4}\\\\I_{F1} - 2.0 I_{V2}\\\\- 1.0 i I_{L1} - v_{3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\1.0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -0.637837837837838 + 0.372972972972973 i, \\  I_{F1} : -0.8 + 0.4 i, \\  I_{L1} : 0.162162162162162 - 0.027027027027027 i, \\  I_{V1} : 0.237837837837838 - 0.172972972972973 i, \\  I_{V2} : -0.4 + 0.2 i, \\  v_{1} : 1.0, \\  v_{2} : 0.8 - 0.4 i, \\  v_{3} : 0.648648648648649 - 0.108108108108108 i, \\  v_{4} : 0.675675675675676 + 0.0540540540540541 i, \\  v_{5} : 0.0\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.000000 phase:     0.00000 deg\nv2   : mag:   0.894427 phase:   -26.56505 deg\nv3   : mag:   0.657596 phase:    -9.46232 deg\nv4   : mag:   0.677834 phase:     4.57392 deg\nv5   : mag:   0.000000 phase:         nan deg\nI_V1 : mag:   0.294086 phase:   -36.02737 deg\nI_V2 : mag:   0.447214 phase:   153.43495 deg\nI_Ea1: mag:   0.738882 phase:   149.68322 deg\nI_F1 : mag:   0.894427 phase:   153.43495 deg\nI_L1 : mag:   0.164399 phase:    -9.46232 deg\n\n\nThe solution obtained from LTSpice at a frequency of 0.159155 Hz is shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:   0.894427 phase:   -26.5651°  voltage\nV(5):   mag:          0 phase:          0°  voltage\nV(1):   mag:          1 phase:          0°  voltage\nV(4):   mag:   0.677834 phase:    4.57392°  voltage\nV(3):   mag:   0.657596 phase:   -9.46232°  voltage\nI(C1):  mag:   0.447214 phase:    153.435°  device_current\nI(F1):  mag:   0.894427 phase:    153.435°  device_current\nI(L1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(R2):  mag:   0.447214 phase:   -26.5651°  device_current\nI(R1):  mag:   0.164399 phase:   -9.46232°  device_current\nI(E1):  mag:   0.738882 phase:    149.683°  device_current\nI(V1):  mag:   0.294086 phase:   -36.0274°  device_current\nI(V2):  mag:   0.447214 phase:    153.435°  device_current\nThe LTSpice results are the same."
  },
  {
    "objectID": "test_3.html#ac-sweep",
    "href": "test_3.html#ac-sweep",
    "title": "6  test_3",
    "section": "6.4 AC Sweep",
    "text": "6.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. Thr frequenct weep is from 0.01 Hz to 1 Hz.\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{2.0 s}{2.0 s - 1.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_3/') # change directory to net list location\n\nfn = 'test_3.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe SymPy and LTSpice results overlay each other."
  },
  {
    "objectID": "test_4.html#symbolic-solution",
    "href": "test_4.html#symbolic-solution",
    "title": "7  test_4",
    "section": "7.1 Symbolic solution",
    "text": "7.1 Symbolic solution\nTakes too long, cells converted to raw.\nans = solve(equ,X) ans\nleft_side = list(ans.keys()) right_side = list(ans.values())\nfor i in range(len(ans)): pprint(Eq(left_side[i],right_side[i]))"
  },
  {
    "objectID": "test_4.html#numeric-solution",
    "href": "test_4.html#numeric-solution",
    "title": "7  test_4",
    "section": "7.2 Numeric solution",
    "text": "7.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nequ1a = equ.subs({\n    V4:10.000000,\n    I2:5.000000,\n    f1:5.000000,\n    ea1:3.000000,\n    g1:2.000000,\n    h1:2.000000,\n    R3:10.000000,\n    R4:1.000000,\n    R5:5.000000,\n    R9:9.000000,\n    R1:3.000000,\n    R10:10.000000,\n    R13:7.000000,\n    R14:10.000000,\n    R15:3.000000,\n    R2:5.000000,\n    R6:2.000000,\n    R7:6.000000,\n    R11:5.000000,\n    R12:9.000000,\n    R16:10.000000,\n    R8:5.000000,\n    R17:8.000000,\n    V1:0.000000,\n    V2:0.000000,\n    R18:4.000000})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V4} + 1.04444444444444 v_{1} - 0.433333333333333 v_{5} - 0.5 v_{7} - 0.111111111111111 v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.2 v_{4} - 0.2 v_{8}\\\\I_{F1} - I_{V2} - 0.433333333333333 v_{1} - 0.2 v_{3} + 0.633333333333333 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 0.5 v_{1} - 1.0 v_{3} - 2.0 v_{4} + 1.66666666666667 v_{7} - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.2 v_{4} - 0.166666666666667 v_{7} + 0.666666666666667 v_{8}\\\\- I_{F1} - 0.111111111111111 v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + 0.553968253968254 v_{9}\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\0.576190476190476 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\-5.0\\\\5.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -14.0210168779779, \\  I_{F1} : 8.95375840852359, \\  I_{H1} : -14.1681115305374, \\  I_{V1} : 1.79075168170472, \\  I_{V2} : 1.55950578456621, \\  I_{V4} : -12.3773598488327, \\  v_{1} : -2.52814763743623, \\  v_{10} : 1.20751965739888, \\  v_{11} : 1.41884516468896, \\  v_{12} : -15.6471592065687, \\  v_{13} : -21.8851823448335, \\  v_{2} : -12.5281476374362, \\  v_{3} : -26.854161091074, \\  v_{4} : 18.9288276094825, \\  v_{5} : -21.8851823448335, \\  v_{6} : -26.854161091074, \\  v_{7} : -14.7742893841602, \\  v_{8} : -6.0711723905175, \\  v_{9} : 16.6756869421768\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:5s}: {:11.5f}'.format(str(name),float(value)))\n\nv1   :    -2.52815\nv2   :   -12.52815\nv3   :   -26.85416\nv4   :    18.92883\nv5   :   -21.88518\nv6   :   -26.85416\nv7   :   -14.77429\nv8   :    -6.07117\nv9   :    16.67569\nv10  :     1.20752\nv11  :     1.41885\nv12  :   -15.64716\nv13  :   -21.88518\nI_V4 :   -12.37736\nI_F1 :     8.95376\nI_Ea1:   -14.02102\nI_H1 :   -14.16811\nI_V1 :     1.79075\nI_V2 :     1.55951\n\n\nThe results agree with the LTSpice answers.\n       --- Operating Point ---\n\nV(1):    -2.52815    voltage\nV(2):    -12.5281    voltage\nV(3):    -26.8542    voltage\nV(4):    18.9288     voltage\nV(5):    -21.8852    voltage\nV(9):    16.6757     voltage\nV(12):   -15.6472    voltage\nV(10):   1.20752     voltage\nV(7):    -14.7743    voltage\nV(8):    -6.07117    voltage\nV(11):   1.41885     voltage\nV(6):    -26.8542    voltage\nV(13):   -21.8852    voltage\nI(F1):   8.95376     device_current\nI(H1):   -14.1681    device_current\nI(I2):   5   device_current\nI(R3):   -1.9357     device_current\nI(R4):   -12.0799    device_current\nI(R5):   5   device_current\nI(R9):   -2.13376    device_current\nI(R1):   6.45234     device_current\nI(R10):  -0.607117   device_current\nI(R13):  2.17955     device_current\nI(R14):  -1.54682    device_current\nI(R15):  -0.472948   device_current\nI(R2):   -0.993796   device_current\nI(R6):   -6.12307    device_current\nI(R7):   1.45052     device_current\nI(R11):  -3.09363    device_current\nI(R12):  -0.134169   device_current\nI(R16):  -1.7066     device_current\nI(R8):   -4.1566     device_current\nI(R17):  1.79075     device_current\nI(R18):  1.55951     device_current\nI(G1):   -4.50628    device_current\nI(E1):   -14.021     device_current\nI(V4):   -12.3774    device_current\nI(V1):   1.79075     device_current\nI(V2):   1.55951     device_current"
  },
  {
    "objectID": "test_5.html#numeric-solution",
    "href": "test_5.html#numeric-solution",
    "title": "8  test_5",
    "section": "8.1 Numeric solution",
    "text": "8.1 Numeric solution\n\n# enter the element values, set I2=0\nequ1a = equ.subs({\n    V4:20.000000,\n    I2:0.000000,\n    f1:5.000000,\n    ea1:3.000000,\n    g1:2.000000,\n    h1:2.000000,\n    R3:10.000000,\n    R4:1.000000,\n    R9:9.000000,\n    R10:10.000000,\n    R13:7.000000,\n    R14:10.000000,\n    R2:5.000000,\n    R7:6.000000,\n    R11:5.000000,\n    R12:9.000000,\n    R16:10.000000,\n    R8:5.000000,\n    R17:8.000000,\n    V1:0.000000,\n    V2:0.000000,\n    R18:4.000000,\n    C1:2.000000,\n    C2:5.000000,\n    L1:3.000000,\n    L2:8.000000})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 5.0 s v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(5.0 s + 0.442857142857143\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 I_{L1} s + v_{1} - v_{5}\\\\- 8.0 I_{L2} s - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nu1 = solve(equ1a,X)\nu1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : \\frac{484516320.0 s^{4} - 7013459176.0 s^{3} - 14876492386.0 s^{2} - 6753210350.0 s + 701248900.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{F1} : \\frac{- 18729852000.0 s^{4} - 55151203400.0 s^{3} - 54295631150.0 s^{2} - 19257377500.0 s - 1182340000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{H1} : \\frac{- 9813782880.0 s^{4} - 34791104416.0 s^{3} - 40120646726.0 s^{2} - 15835630125.0 s - 404170350.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{L1} : \\frac{- 10390318400.0 s^{3} - 20644756880.0 s^{2} - 9214475380.0 s + 640638350.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{L2} : \\frac{228057000.0 s^{3} + 1149868000.0 s^{2} + 1056127000.0 s + 196789500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{V1} : \\frac{- 3745970400.0 s^{4} - 11030240680.0 s^{3} - 10859126230.0 s^{2} - 3851475500.0 s - 236468000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{V2} : \\frac{- 9821049600.0 s^{4} - 25552655920.0 s^{3} - 21936878920.0 s^{2} - 7453388375.0 s - 1000603250.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  I_{V4} : \\frac{- 13559753280.0 s^{4} - 45821345096.0 s^{3} - 50979772956.0 s^{2} - 19687105625.0 s - 640638350.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{1} : \\frac{1516291200.0 s^{4} + 8827515840.0 s^{3} + 18582319340.0 s^{2} + 13870838550.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{10} : \\frac{- 641865600.0 s^{4} - 1183785120.0 s^{3} + 1416411780.0 s^{2} + 2856387600.0 s + 996913500.0}{462589040.0 s^{4} + 1523027748.0 s^{3} + 1732964123.0 s^{2} + 777370755.0 s + 100060325.0}, \\  v_{11} : \\frac{- 1824456000.0 s^{4} - 9198944000.0 s^{3} - 8449016000.0 s^{2} - 1574316000.0 s}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{12} : \\frac{- 6596952000.0 s^{4} - 31448837200.0 s^{3} - 41521770200.0 s^{2} - 17864630000.0 s - 1048160000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{13} : \\frac{32687246400.0 s^{4} + 70761786480.0 s^{3} + 46225745480.0 s^{2} + 11948923500.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{2} : \\frac{- 26239051200.0 s^{4} - 82554149040.0 s^{3} - 85395528040.0 s^{2} - 32771406750.0 s - 3049366500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{3} : \\frac{3728712000.0 s^{4} + 5687776400.0 s^{3} + 1477481800.0 s^{2} - 1959602750.0 s - 1157622500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{4} : \\frac{2139552000.0 s^{4} + 6226520400.0 s^{3} + 6777307400.0 s^{2} + 1039978000.0 s - 1355150000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{5} : \\frac{32687246400.0 s^{4} + 70761786480.0 s^{3} + 46225745480.0 s^{2} + 11948923500.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{6} : \\frac{3728712000.0 s^{4} + 5687776400.0 s^{3} + 1477481800.0 s^{2} - 1959602750.0 s - 1157622500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{7} : \\frac{1516291200.0 s^{4} + 10608925440.0 s^{3} + 17203482560.0 s^{2} + 5263461700.0 s - 2405273000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{8} : \\frac{2139552000.0 s^{4} + 6226520400.0 s^{3} + 6777307400.0 s^{2} + 1039978000.0 s - 1355150000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}, \\  v_{9} : \\frac{1516291200.0 s^{4} + 4779582240.0 s^{3} + 6652835940.0 s^{2} + 2436014800.0 s - 643814500.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}\\right\\}\\)"
  },
  {
    "objectID": "test_5.html#ac-analysis",
    "href": "test_5.html#ac-analysis",
    "title": "8  test_5",
    "section": "8.2 AC analysis",
    "text": "8.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\0.111111111111111 v_{4} - 0.111111111111111 v_{8}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- 0.2 v_{3} - 0.111111111111111 v_{4} - 0.166666666666667 v_{7} + 0.577777777777778 v_{8}\\\\- I_{F1} - 5.0 i v_{1} - 0.3 v_{10} - 0.142857142857143 v_{11} + v_{9} \\cdot \\left(0.442857142857143 + 5.0 i\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} + 0.242857142857143 v_{11} - 0.1 v_{12} - 0.142857142857143 v_{9}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 i I_{L1} + v_{1} - v_{5}\\\\- 8.0 i I_{L2} - v_{11}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\20.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -3.28755526738118 + 2.02051537859022 i, \\  I_{F1} : -11.5985498010872 - 2.83348461841226 i, \\  I_{H1} : -8.50450073009283 + 0.0196092639839988 i, \\  I_{L1} : -4.46386215504314 + 2.50920732075621 i, \\  I_{L2} : 0.086195653296013 - 0.290772822143382 i, \\  I_{V1} : -2.31970996021745 - 0.566696923682452 i, \\  I_{V2} : -4.58793699371144 - 2.23193107752157 i, \\  I_{V4} : -10.8242106903103 - 0.547087659698453 i, \\  v_{1} : 2.20785874542791 - 2.84317775225776 i, \\  v_{10} : -0.919409819344333 - 2.86641549706325 i, \\  v_{11} : -2.32618257714705 - 0.689565226368104 i, \\  v_{12} : -8.61626726714921 + 1.62068440278538 i, \\  v_{13} : 9.73548070769654 + 10.5484087128717 i, \\  v_{2} : -17.7921412545721 - 2.84317775225776 i, \\  v_{3} : 0.765538427167506 + 1.69039763720186 i, \\  v_{4} : 1.88352299889828 + 0.277177886414242 i, \\  v_{5} : 9.73548070769654 + 10.5484087128717 i, \\  v_{6} : 0.765538427167506 + 1.69039763720186 i, \\  v_{7} : 4.35521828431417 - 1.25237908268235 i, \\  v_{8} : 1.88352299889828 + 0.277177886414242 i, \\  v_{9} : 1.47350713278237 - 0.271330211771869 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   3.599764 phase:   -52.16901 deg\nv2   : mag:  18.017879 phase:  -170.92092 deg\nv3   : mag:   1.855665 phase:    65.63543 deg\nv4   : mag:   1.903808 phase:     8.37152 deg\nv5   : mag:  14.354390 phase:    47.29504 deg\nv6   : mag:   1.855665 phase:    65.63543 deg\nv7   : mag:   4.531708 phase:   -16.04303 deg\nv8   : mag:   1.903808 phase:     8.37152 deg\nv9   : mag:   1.498280 phase:   -10.43351 deg\nv10  : mag:   3.010258 phase:  -107.78377 deg\nv11  : mag:   2.426237 phase:  -163.48826 deg\nv12  : mag:   8.767364 phase:   169.34737 deg\nv13  : mag:  14.354390 phase:    47.29504 deg\nI_V4 : mag:  10.838028 phase:  -177.10656 deg\nI_F1 : mag:  11.939640 phase:  -166.27173 deg\nI_Ea1: mag:   3.858821 phase:   148.42532 deg\nI_H1 : mag:   8.504523 phase:   179.86789 deg\nI_V1 : mag:   2.387928 phase:  -166.27173 deg\nI_V2 : mag:   5.102027 phase:  -154.05809 deg\nI_L1 : mag:   5.120760 phase:   150.65897 deg\nI_L2 : mag:   0.303280 phase:   -73.48826 deg\n\n\nThe following results were obtained from LTSpice.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    3.59976 phase:    -52.169°  voltage\nV(2):   mag:    18.0179 phase:   -170.921°  voltage\nV(3):   mag:    1.85567 phase:    65.6354°  voltage\nV(4):   mag:    1.90381 phase:    8.37152°  voltage\nV(5):   mag:    14.3544 phase:     47.295°  voltage\nV(9):   mag:    1.49828 phase:   -10.4335°  voltage\nV(12):  mag:    8.76736 phase:    169.347°  voltage\nV(10):  mag:    3.01026 phase:   -107.784°  voltage\nV(7):   mag:    4.53171 phase:    -16.043°  voltage\nV(8):   mag:    1.90381 phase:    8.37152°  voltage\nV(11):  mag:    2.42624 phase:   -163.488°  voltage\nV(6):   mag:    1.85567 phase:    65.6354°  voltage\nV(13):  mag:    14.3544 phase:     47.295°  voltage\nI(C1):  mag:    5.34483 phase:    126.532°  device_current\nI(C2):  mag:    13.3732 phase:    15.9359°  device_current\nI(F1):  mag:    11.9396 phase:   -166.272°  device_current\nI(H1):  mag:    8.50452 phase:    179.868°  device_current\nI(L1):  mag:    5.12076 phase:    150.659°  device_current\nI(L2):  mag:    0.30328 phase:   -73.4883°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:    1.53623 phase:     60.659°  device_current\nI(R4):  mag:    4.64174 phase:    140.656°  device_current\nI(R9):  mag:          0 phase:          0°  device_current\nI(R10): mag:   0.190381 phase:    8.37152°  device_current\nI(R13): mag:   0.546091 phase:    6.28131°  device_current\nI(R14): mag:   0.352995 phase:   -132.679°  device_current\nI(R2):  mag:     2.5213 phase:    -135.36°  device_current\nI(R7):  mag:   0.484448 phase:     148.25°  device_current\nI(R11): mag:   0.705989 phase:   -132.679°  device_current\nI(R12): mag:   0.334473 phase:    72.2162°  device_current\nI(R16): mag:   0.670093 phase:    159.833°  device_current\nI(R8):  mag:   0.360393 phase:    128.347°  device_current\nI(R17): mag:    2.38793 phase:   -166.272°  device_current\nI(R18): mag:    5.10203 phase:   -154.058°  device_current\nI(G1):  mag:    1.36963 phase:   -126.779°  device_current\nI(E1):  mag:    3.85882 phase:    148.425°  device_current\nI(V4):  mag:     10.838 phase:   -177.107°  device_current\nI(V1):  mag:    2.38793 phase:   -166.272°  device_current\nI(V2):  mag:    5.10203 phase:   -154.058°  device_current\n\nThe LTSpice results are the same."
  },
  {
    "objectID": "test_5.html#ac-sweep",
    "href": "test_5.html#ac-sweep",
    "title": "8  test_5",
    "section": "8.3 AC Sweep",
    "text": "8.3 AC Sweep\nLooking at node 5 voltage and comparing the results with those obtained from LTSpice. Thr frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 5 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_5/') # change directory to net list location\n\nfn = 'test_5.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 5\n\nH = u1[v5]\nH\n\n\\(\\displaystyle \\frac{32687246400.0 s^{4} + 70761786480.0 s^{3} + 46225745480.0 s^{2} + 11948923500.0 s + 2954253000.0}{1387767120.0 s^{4} + 4569083244.0 s^{3} + 5198892369.0 s^{2} + 2332112265.0 s + 300180975.0}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe SymPy and LTSpice results overlay each other."
  },
  {
    "objectID": "test_6.html#numeric-solution",
    "href": "test_6.html#numeric-solution",
    "title": "9  test_6",
    "section": "9.1 Numeric solution",
    "text": "9.1 Numeric solution\nIn LTSpice the line:\n\nK1 L3 L4 0.5\n\nK1 identifies the mutual inductance between in two inductors, L3 and L4. k is the coefficient of coupling.\nThis needs to be converted to mutual inductance.\nWith:\nL3 = 8\nL4 = 10\nk = 0.5\nand:\n\\(k = \\frac {M}{\\sqrt{L1 \\times L2}}\\)\nNeed to solve for M\n\\(M = k \\times {\\sqrt{L1 \\times L2}}\\)\n\n# calculate the coupling constant from the mutual inductance\nprint('mutual inductance, M = {:.9f}'.format(0.5*np.sqrt(8*10)))\n\nmutual inductance, M = 4.472135955\n\n\n\n# enter the element values, set I2=0, K1 changed to M1\nequ1a = equ.subs({\n    V4:10.000000,\n    I2:0.000000,\n    f1:5.000000,\n    ea1:3.000000,\n    g1:2.000000,\n    h1:2.000000,\n    R3:10.000000,\n    R4:1.000000,\n    R10:10.000000,\n    R14:10.000000,\n    R2:5.000000,\n    R7:6.000000,\n    R11:5.000000,\n    R12:9.000000,\n    R16:10.000000,\n    R8:5.000000,\n    R17:8.000000,\n    V1:0.000000,\n    V2:0.000000,\n    R18:4.000000,\n    C1:2.000000,\n    C2:5.000000,\n    L1:3.000000,\n    L2:8.000000,\n    L3:8.000000,\n    L4:10.000000,\n    M1:4.472135955})    \n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} - 2.0 s v_{7} - 5.0 s v_{9} + v_{1} \\cdot \\left(7.0 s + 0.1\\right) - 0.1 v_{5}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 s v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(2.0 s + 1.16666666666667\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 5.0 s v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(5.0 s + 0.3\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 I_{L1} s + v_{1} - v_{5}\\\\- 8.0 I_{L2} s - v_{11}\\\\- 8.0 I_{L3} s - 4.472135955 I_{L4} s - v_{11} + v_{9}\\\\- 4.472135955 I_{L3} s - 10.0 I_{L4} s + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\n#u1 # the solution is too long to display correctly\n\n\n# trying pprint for a fwe of the nodes\npprint(u1[v1])\n\n                     5                         4                         3    \n2.2325166790056e+16⋅s  + 1.89060165810445e+17⋅s  + 4.32070251698074e+17⋅s  + 3\n──────────────────────────────────────────────────────────────────────────────\n                       5                       4                       3      \n  7.2576938804988e+15⋅s  + 1.298012194946e+17⋅s  + 2.444740209787e+17⋅s  + 1.6\n\n                     2                                         \n.44523980198078e+17⋅s  + 1.21346542780886e+17⋅s + 2.9930625e+16\n───────────────────────────────────────────────────────────────\n                   2                                           \n9584751982685e+17⋅s  + 4.81277812834983e+16⋅s + 5.0601675e+15  \n\n\n\npprint(u1[v2])\n\n                       5                         4                         3  \n- 5.0251772014932e+16⋅s  - 1.10895202913556e+18⋅s  - 2.01266995808892e+18⋅s  -\n──────────────────────────────────────────────────────────────────────────────\n                       5                       4                       3      \n  7.2576938804988e+15⋅s  + 1.298012194946e+17⋅s  + 2.444740209787e+17⋅s  + 1.6\n\n                       2                                        \n 1.35132353962877e+18⋅s  - 3.59931270054097e+17⋅s - 2.067105e+16\n────────────────────────────────────────────────────────────────\n                   2                                            \n9584751982685e+17⋅s  + 4.81277812834983e+16⋅s + 5.0601675e+15"
  },
  {
    "objectID": "test_6.html#ac-analysis",
    "href": "test_6.html#ac-analysis",
    "title": "9  test_6",
    "section": "9.2 AC analysis",
    "text": "9.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + I_{V4} + v_{1} \\cdot \\left(0.1 + 7.0 i\\right) - 0.1 v_{5} - 2.0 i v_{7} - 5.0 i v_{9}\\\\I_{H1} - I_{V4} + 0.125 v_{2} - 0.125 v_{6}\\\\- I_{Ea1} - I_{V1} + 1.4 v_{3} - 0.2 v_{5} - 1.0 v_{7} - 0.2 v_{8}\\\\I_{L4}\\\\I_{F1} - I_{L1} - I_{V2} - 0.1 v_{1} - 0.2 v_{3} + 0.3 v_{5}\\\\I_{V1} - 0.125 v_{2} + 0.125 v_{6}\\\\- 2.0 i v_{1} - 1.0 v_{3} - 2.0 v_{4} + v_{7} \\cdot \\left(1.16666666666667 + 2.0 i\\right) - 0.166666666666667 v_{8} + 2.0 v_{9}\\\\- I_{L4} - 0.2 v_{3} - 0.166666666666667 v_{7} + 0.466666666666667 v_{8}\\\\- I_{F1} + I_{L3} - 5.0 i v_{1} - 0.3 v_{10} + v_{9} \\cdot \\left(0.3 + 5.0 i\\right)\\\\0.411111111111111 v_{10} + 2.0 v_{4} - 2.3 v_{9}\\\\- I_{L2} - I_{L3} + 0.1 v_{11} - 0.1 v_{12}\\\\I_{Ea1} - I_{H1} - 0.1 v_{11} + 0.35 v_{12} - 0.25 v_{13}\\\\I_{V2} - 0.25 v_{12} + 0.25 v_{13}\\\\v_{1} - v_{2}\\\\I_{F1} - 5.0 I_{V1}\\\\3.0 v_{1} - 3.0 v_{10} + v_{12} - v_{3}\\\\- 2.0 I_{V2} - v_{12} + v_{2}\\\\- v_{3} + v_{6}\\\\v_{13} - v_{5}\\\\- 3.0 i I_{L1} + v_{1} - v_{5}\\\\- 8.0 i I_{L2} - v_{11}\\\\- 8.0 i I_{L3} - 4.472135955 i I_{L4} - v_{11} + v_{9}\\\\- 4.472135955 i I_{L3} - 10.0 i I_{L4} + v_{4} - v_{8}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -1.22523336908514 - 0.840765512512539 i, \\  I_{F1} : -5.62023309737683 - 0.209106198605548 i, \\  I_{H1} : -4.07088397910677 - 1.34550926279174 i, \\  I_{L1} : -1.39813151246412 + 1.68136393529045 i, \\  I_{L2} : 0.114546545119793 - 0.0011123043384594 i, \\  I_{L3} : 0.223755430589947 - 0.193209701614398 i, \\  I_{L4} : 0.0, \\  I_{V1} : -1.12404661947537 - 0.0418212397211095 i, \\  I_{V2} : -2.50734863431189 - 0.699065756232061 i, \\  I_{V4} : -5.19493059858214 - 1.38733050251285 i, \\  v_{1} : 1.59338453957114 - 0.371283813893891 i, \\  v_{10} : 0.267492643844761 - 0.0167632823288092 i, \\  v_{11} : -0.00889843470767521 - 0.916372360958346 i, \\  v_{12} : -3.39191819180508 + 1.02684769857023 i, \\  v_{13} : 6.63747634544249 + 3.82311072349847 i, \\  v_{2} : -8.40661546042886 - 0.371283813893891 i, \\  v_{3} : 0.585757495374071 - 0.0367138961250149 i, \\  v_{4} : 1.7123114559261 + 1.00816753213745 i, \\  v_{5} : 6.63747634544249 + 3.82311072349847 i, \\  v_{6} : 0.585757495374071 - 0.0367138961250149 i, \\  v_{7} : 1.6721949324994 + 0.0650645877850054 i, \\  v_{8} : 0.848251402481531 + 0.0075028258696384 i, \\  v_{9} : 1.53677917820751 + 0.873671083761229 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   1.636070 phase:   -13.11677 deg\nv2   : mag:   8.414810 phase:  -177.47114 deg\nv3   : mag:   0.586907 phase:    -3.58647 deg\nv4   : mag:   1.987061 phase:    30.48855 deg\nv5   : mag:   7.659782 phase:    29.94145 deg\nv6   : mag:   0.586907 phase:    -3.58647 deg\nv7   : mag:   1.673460 phase:     2.22824 deg\nv8   : mag:   0.848285 phase:     0.50677 deg\nv9   : mag:   1.767765 phase:    29.61857 deg\nv10  : mag:   0.268017 phase:    -3.58593 deg\nv11  : mag:   0.916416 phase:   -90.55635 deg\nv12  : mag:   3.543942 phase:   163.15717 deg\nv13  : mag:   7.659782 phase:    29.94145 deg\nI_V4 : mag:   5.376987 phase:  -165.04783 deg\nI_F1 : mag:   5.624122 phase:  -177.86924 deg\nI_Ea1: mag:   1.485962 phase:  -145.54176 deg\nI_H1 : mag:   4.287481 phase:  -161.71024 deg\nI_V1 : mag:   1.124824 phase:  -177.86924 deg\nI_V2 : mag:   2.602977 phase:  -164.42117 deg\nI_L1 : mag:   2.186723 phase:   129.74508 deg\nI_L2 : mag:   0.114552 phase:    -0.55635 deg\nI_L3 : mag:   0.295629 phase:   -40.81015 deg\nI_L4 : mag:   0.000000 phase:         nan deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n--- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    1.63601 phase:   -13.1107°  voltage\nV(2):   mag:    8.41482 phase:   -177.472°  voltage\nV(3):   mag:   0.586932 phase:    -3.5698°  voltage\nV(4):   mag:    1.98715 phase:    30.4941°  voltage\nV(5):   mag:    7.65904 phase:    29.9359°  voltage\nV(9):   mag:    1.76784 phase:    29.6245°  voltage\nV(12):  mag:    3.54398 phase:    163.161°  voltage\nV(10):  mag:   0.267951 phase:   -3.57561°  voltage\nV(7):   mag:    1.67347 phase:    2.23357°  voltage\nV(8):   mag:   0.848303 phase:   0.515418°  voltage\nV(11):  mag:   0.916372 phase:   -90.5542°  voltage\nV(6):   mag:   0.586932 phase:    -3.5698°  voltage\nV(13):  mag:    7.65904 phase:    29.9359°  voltage\nI(C1):  mag:   0.886775 phase:    169.759°  device_current\nI(C2):  mag:    6.23127 phase:    2.60368°  device_current\nI(F1):  mag:    5.62415 phase:   -177.869°  device_current\nI(H1):  mag:    4.28722 phase:   -161.715°  device_current\nI(L1):  mag:     2.1864 phase:    129.758°  device_current\nI(L2):  mag:   0.114546 phase:  -0.547059°  device_current\nI(L3):  mag:   0.295638 phase:   -40.8067°  device_current\nI(L4):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(R3):  mag:   0.655921 phase:    39.7384°  device_current\nI(R4):  mag:    1.09116 phase:   -174.649°  device_current\nI(R10): mag:  0.0848303 phase:   0.515418°  device_current\nI(R14): mag:   0.155058 phase:   -144.946°  device_current\nI(R2):  mag:    1.43539 phase:   -147.477°  device_current\nI(R7):  mag:   0.137657 phase:   -176.002°  device_current\nI(R11): mag:   0.310117 phase:   -144.946°  device_current\nI(R12): mag:  0.0297724 phase:    176.424°  device_current\nI(R16): mag:   0.390139 phase:    150.131°  device_current\nI(R8):  mag:  0.0532334 phase:   -170.446°  device_current\nI(R17): mag:    1.12483 phase:   -177.869°  device_current\nI(R18): mag:    2.60288 phase:   -164.425°  device_current\nI(G1):  mag:   0.442308 phase:   -142.538°  device_current\nI(E1):  mag:    1.48573 phase:   -145.548°  device_current\nI(V4):  mag:    5.37676 phase:   -165.052°  device_current\nI(V1):  mag:    1.12483 phase:   -177.869°  device_current\nI(V2):  mag:    2.60288 phase:   -164.425°  device_current\nThe LTSpice results are the same as those from the Python code."
  },
  {
    "objectID": "test_6.html#ac-sweep",
    "href": "test_6.html#ac-sweep",
    "title": "9  test_6",
    "section": "9.3 AC Sweep",
    "text": "9.3 AC Sweep\nLooking at node 10 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 10 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_6/') # change directory to net list location\n\nfn = 'test_6.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 5\n\nH = u1[v10]\nH\n\n\\(\\displaystyle \\frac{1.0190497760676 \\cdot 10^{16} s^{5} + 3.30689652719137 \\cdot 10^{16} s^{4} + 5.41568605911396 \\cdot 10^{16} s^{3} + 4.70856283994088 \\cdot 10^{16} s^{2} + 2.73004570071188 \\cdot 10^{16} s + 9.864 \\cdot 10^{15}}{2.4192312934996 \\cdot 10^{15} s^{5} + 4.32670731648667 \\cdot 10^{16} s^{4} + 8.14913403262333 \\cdot 10^{16} s^{3} + 5.6528250660895 \\cdot 10^{16} s^{2} + 1.60425937611661 \\cdot 10^{16} s + 1.6867225 \\cdot 10^{15}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe SymPy and LTSpice results overlay each other."
  },
  {
    "objectID": "test_7.html#numeric-solution",
    "href": "test_7.html#numeric-solution",
    "title": "10  test_7",
    "section": "10.1 Numeric solution",
    "text": "10.1 Numeric solution\nFrom the LTSpice netlist:\n\nK1 L1 L2 0.707\nK2 L3 L4 0.707\n\nK1 and K2 identify the mutual inductance between two inductors. k is the coefficient of coupling. These need to be converted to mutual inductance.\nNeed to solve for M1 and M2:\n\\(M_1 = k \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = k \\times {\\sqrt{L_3 \\times L_4}}\\)\n\n# calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]*np.sqrt(component_values[L1] *component_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M1]))\n\ncomponent_values[M2] = component_values[K2]*np.sqrt(component_values[L3] *component_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M2]))\n\nmutual inductance, M1 = 1.414000000\nmutual inductance, M1 = 2.235730306\n\n\nNeed to set the DC sources to zero.\n\ncomponent_values[V2] = 0\ncomponent_values[V3] = 0\ncomponent_values[V4] = 0\ncomponent_values[I1] = 0\ncomponent_values[I2] = 0\ncomponent_values[I3] = 0\ncomponent_values[I4] = 0\n\n\nequ1a = equ.subs(component_values)\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\n#u1 # the solution is too long to display correctly\n\n\n# trying pprint for a few of the nodes\npprint(u1[v2])\n\n                                     6                         5              \n             - 2.76669233552152e+57⋅s  + 2.25716104358934e+59⋅s  - 3.684332723\n──────────────────────────────────────────────────────────────────────────────\n                      7                         6                         5   \n1.28428134428291e+57⋅s  - 1.53271577641517e+59⋅s  - 7.47710915242496e+59⋅s  - \n\n           4                         3                         2              \n97733e+59⋅s  - 3.76516188957225e+60⋅s  + 4.56609467275371e+58⋅s  + 4.994308306\n──────────────────────────────────────────────────────────────────────────────\n                      4                         3                         2   \n2.32648746467081e+59⋅s  + 2.31716567174507e+60⋅s  + 8.76679773386848e+59⋅s  + \n\n                                             \n88774e+58⋅s + 1.1319642578125e+57            \n─────────────────────────────────────────────\n                                             \n1.32574719829542e+58⋅s - 4.53791250561523e+57\n\n\n\npprint(u1[v3])\n\n                        7                         6                        5  \n  7.64827226906654e+58⋅s  + 1.39655014482286e+60⋅s  + 8.3837841437292e+60⋅s  +\n──────────────────────────────────────────────────────────────────────────────\n                      7                         6                         5   \n1.28428134428291e+57⋅s  - 1.53271577641517e+59⋅s  - 7.47710915242496e+59⋅s  - \n\n                       4                        3                         2   \n 1.83805847739724e+61⋅s  + 1.2632626737557e+61⋅s  - 2.39533164939265e+59⋅s  - \n──────────────────────────────────────────────────────────────────────────────\n                      4                         3                         2   \n2.32648746467081e+59⋅s  + 2.31716567174507e+60⋅s  + 8.76679773386848e+59⋅s  + \n\n                                             \n2.12639054297542e+59⋅s - 7.064441015625e+57  \n─────────────────────────────────────────────\n                                             \n1.32574719829542e+58⋅s - 4.53791250561523e+57\n\n\n\npprint(u1[v4])\n\n                         7                         6                         5\n - 1.80079030269442e+58⋅s  - 4.27671690912086e+59⋅s  - 2.85592772872773e+60⋅s \n──────────────────────────────────────────────────────────────────────────────\n                      7                         6                         5   \n4.28093781427636e+56⋅s  - 5.10905258805058e+58⋅s  - 2.49236971747499e+59⋅s  - \n\n                         4                         3                        2 \n - 6.37974746477364e+60⋅s  - 3.88961540059031e+60⋅s  + 1.6081158206044e+59⋅s  \n──────────────────────────────────────────────────────────────────────────────\n                      4                         3                         2   \n7.75495821556937e+58⋅s  + 7.72388557248356e+59⋅s  + 2.92226591128949e+59⋅s  + \n\n                                            \n+ 6.16282933459488e+58⋅s + 1.4934828125e+57 \n────────────────────────────────────────────\n                                            \n4.4191573276514e+57⋅s - 1.51263750187174e+57"
  },
  {
    "objectID": "test_7.html#ac-analysis",
    "href": "test_7.html#ac-analysis",
    "title": "10  test_7",
    "section": "10.2 AC analysis",
    "text": "10.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} + 0.95 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\\\- 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\\\1.03333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.2 v_{24}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 i I_{L1} - 1.414 i I_{L2} + v_{16} - v_{23}\\\\- 1.414 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\- 2.0 i I_{L3} - 2.23573030573904 i I_{L4} - v_{21} + v_{22}\\\\- 2.23573030573904 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\\\- 1.0 i I_{L5} - v_{7}\\\\- 2.0 i I_{L6} - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : 0.504198444608253 + 0.898150393059927 i, \\  I_{Ea2} : -1.5795724647095 + 0.308307697889862 i, \\  I_{F1} : 0.48261496669065 - 3.85180556530855 i, \\  I_{F2} : 0.48261496669065 - 3.85180556530855 i, \\  I_{H1} : 1.24856140500647 + 3.82840673564216 i, \\  I_{H2} : 1.07647165039523 - 0.194994995143953 i, \\  I_{L1} : 0.379885428953428 - 3.63143009468308 i, \\  I_{L2} : -1.3645179529356 - 0.815603561354835 i, \\  I_{L3} : -0.504198444608253 - 0.898150393059927 i, \\  I_{L4} : 1.5795724647095 - 0.308307697889862 i, \\  I_{L5} : -0.48261496669065 + 3.85180556530855 i, \\  I_{L6} : -0.816125604923761 - 0.350847312085518 i, \\  I_{V1} : -0.733805219002842 - 4.81790027750145 i, \\  I_{V2} : 0.241307483345325 - 1.92590278265427 i, \\  I_{V3} : -0.372330023309102 + 4.70437003089402 i, \\  I_{V4} : 0.354469837968848 - 5.83190979816162 i, \\  I_{V5} : 0.726388403536697 - 6.44927697538188 i, \\  I_{V6} : 0.593856683704582 + 3.65681057016459 i, \\  I_{V7} : -0.861417138621336 - 0.928916264100745 i, \\  I_{V8} : -0.11233605948701 - 1.13532155850103 i, \\  v_{1} : 0.0, \\  v_{10} : -0.262045079927554 + 5.55693449647949 i, \\  v_{11} : -0.243203348872735 + 2.68893328006946 i, \\  v_{12} : -0.625263122105315 + 2.62760666315395 i, \\  v_{13} : 0.22467211897402 + 2.27064311700207 i, \\  v_{14} : -0.742608930512742 + 9.6914971547036 i, \\  v_{15} : -2.52099222304126 - 4.49075196529963 i, \\  v_{16} : 8.41066513948474 - 13.2484997478875 i, \\  v_{17} : 3.30635719345208 + 9.45954386089979 i, \\  v_{18} : 4.773031655484 - 11.3031994319571 i, \\  v_{19} : 2.39848749888701 - 4.42083915332865 i, \\  v_{2} : -1.16589372131966 - 0.501210445836454 i, \\  v_{20} : -0.262045079927554 + 5.55693449647949 i, \\  v_{21} : 7.51440635021515 - 2.52310114024543 i, \\  v_{22} : 10.0, \\  v_{23} : 3.62597160904592 - 11.69895679139 i, \\  v_{24} : 7.9330573021526 - 7.05437547088623 i, \\  v_{25} : 7.9330573021526 - 7.05437547088623 i, \\  v_{26} : 2.90204915900995 - 5.92124844342714 i, \\  v_{27} : 3.62597160904592 - 11.69895679139 i, \\  v_{28} : -0.262045079927554 + 5.55693449647949 i, \\  v_{3} : -0.262045079927554 + 5.55693449647949 i, \\  v_{4} : 0.723922450035974 - 5.77770834796282 i, \\  v_{5} : 0.601269216204948 - 5.01358880149766 i, \\  v_{6} : 0.0, \\  v_{7} : 3.85180556530855 + 0.48261496669065 i, \\  v_{8} : 1.64850868801031 - 3.35059511947209 i, \\  v_{9} : -0.464199097148623 - 2.13346165568398 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.000000 phase:         nan deg\nv2   : mag:   1.269063 phase:  -156.73743 deg\nv3   : mag:   5.563110 phase:    92.69986 deg\nv4   : mag:   5.822884 phase:   -82.85830 deg\nv5   : mag:   5.049515 phase:   -83.16130 deg\nv6   : mag:   0.000000 phase:         nan deg\nv7   : mag:   3.881923 phase:     7.14170 deg\nv8   : mag:   3.734176 phase:   -63.80260 deg\nv9   : mag:   2.183378 phase:  -102.27511 deg\nv10  : mag:   5.563110 phase:    92.69986 deg\nv11  : mag:   2.699909 phase:    95.16811 deg\nv12  : mag:   2.700976 phase:   103.38512 deg\nv13  : mag:   2.281731 phase:    84.34918 deg\nv14  : mag:   9.719907 phase:    94.38171 deg\nv15  : mag:   5.149976 phase:  -119.30873 deg\nv16  : mag:  15.692738 phase:   -57.59102 deg\nv17  : mag:  10.020727 phase:    70.73415 deg\nv18  : mag:  12.269643 phase:   -67.10700 deg\nv19  : mag:   5.029569 phase:   -61.51834 deg\nv20  : mag:   5.563110 phase:    92.69986 deg\nv21  : mag:   7.926685 phase:   -18.56043 deg\nv22  : mag:  10.000000 phase:     0.00000 deg\nv23  : mag:  12.247990 phase:   -72.77971 deg\nv24  : mag:  10.615913 phase:   -41.64471 deg\nv25  : mag:  10.615913 phase:   -41.64471 deg\nv26  : mag:   6.594170 phase:   -63.89017 deg\nv27  : mag:  12.247990 phase:   -72.77971 deg\nv28  : mag:   5.563110 phase:    92.69986 deg\nI_V1 : mag:   4.873462 phase:   -98.66006 deg\nI_V2 : mag:   1.940961 phase:   -82.85830 deg\nI_V3 : mag:   4.719081 phase:    94.52527 deg\nI_V4 : mag:   5.842672 phase:   -86.52178 deg\nI_F1 : mag:   3.881923 phase:   -82.85830 deg\nI_Ea1: mag:   1.029995 phase:    60.69127 deg\nI_H1 : mag:   4.026860 phase:    71.93726 deg\nI_L1 : mag:   3.651246 phase:   -84.02799 deg\nI_L2 : mag:   1.589691 phase:  -149.13227 deg\nI_V5 : mag:   6.490055 phase:   -83.57380 deg\nI_V6 : mag:   3.704717 phase:    80.77584 deg\nI_L3 : mag:   1.029995 phase:  -119.30873 deg\nI_L4 : mag:   1.609380 phase:   -11.04438 deg\nI_L5 : mag:   3.881923 phase:    97.14170 deg\nI_L6 : mag:   0.888344 phase:  -156.73743 deg\nI_F2 : mag:   3.881923 phase:   -82.85830 deg\nI_Ea2: mag:   1.609380 phase:   168.95562 deg\nI_H2 : mag:   1.093990 phase:   -10.26738 deg\nI_V7 : mag:   1.266856 phase:  -132.84086 deg\nI_V8 : mag:   1.140866 phase:   -95.65082 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    15.6927 phase:    -57.591°  voltage\nV(8):   mag:    3.73418 phase:   -63.8026°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:    1.26906 phase:   -156.737°  voltage\nV(11):  mag:    2.69991 phase:    95.1681°  voltage\nV(10):  mag:    5.56311 phase:    92.6999°  voltage\nV(23):  mag:     12.248 phase:   -72.7797°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:    2.18338 phase:   -102.275°  voltage\nV(24):  mag:    10.6159 phase:   -41.6447°  voltage\nV(3):   mag:    5.56311 phase:    92.6999°  voltage\nV(20):  mag:    5.56311 phase:    92.6999°  voltage\nV(5):   mag:    5.04951 phase:   -83.1613°  voltage\nV(12):  mag:    2.70098 phase:    103.385°  voltage\nV(18):  mag:    12.2696 phase:    -67.107°  voltage\nV(26):  mag:    6.59417 phase:   -63.8902°  voltage\nV(25):  mag:    10.6159 phase:   -41.6447°  voltage\nV(4):   mag:    5.82288 phase:   -82.8583°  voltage\nV(14):  mag:    9.71991 phase:    94.3817°  voltage\nV(7):   mag:    3.88192 phase:     7.1417°  voltage\nV(15):  mag:    5.14998 phase:   -119.309°  voltage\nV(21):  mag:    7.92669 phase:   -18.5604°  voltage\nV(13):  mag:    2.28173 phase:    84.3492°  voltage\nV(28):  mag:    5.56311 phase:    92.6999°  voltage\nV(27):  mag:     12.248 phase:   -72.7797°  voltage\nV(17):  mag:    10.0207 phase:    70.7341°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    5.02957 phase:   -61.5183°  voltage\nI(C1):  mag:    2.42683 phase:   -70.9646°  device_current\nI(C2):  mag:   0.773901 phase:   -80.8809°  device_current\nI(F1):  mag:    3.88192 phase:   -82.8583°  device_current\nI(F2):  mag:    3.88192 phase:   -82.8583°  device_current\nI(H1):  mag:    4.02686 phase:    71.9373°  device_current\nI(H2):  mag:    1.09399 phase:   -10.2674°  device_current\nI(L1):  mag:    3.65125 phase:    -84.028°  device_current\nI(L2):  mag:    1.58969 phase:   -149.132°  device_current\nI(L3):  mag:       1.03 phase:   -119.309°  device_current\nI(L4):  mag:    1.60938 phase:   -11.0444°  device_current\nI(L5):  mag:    3.88192 phase:    97.1417°  device_current\nI(L6):  mag:   0.888344 phase:   -156.737°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:    2.39746 phase:   -55.6595°  device_current\nI(R2):  mag:    1.86709 phase:   -63.8026°  device_current\nI(R6):  mag:   0.253813 phase:   -156.737°  device_current\nI(R8):  mag:   0.358508 phase:   -89.6236°  device_current\nI(R10): mag:     1.4803 phase:   -118.583°  device_current\nI(R11): mag:   0.609557 phase:    150.054°  device_current\nI(R12): mag:   0.634531 phase:   -156.737°  device_current\nI(R14): mag:   0.769305 phase:    88.4942°  device_current\nI(R15): mag:    1.26686 phase:    47.1591°  device_current\nI(R7):  mag:   0.773901 phase:    99.1191°  device_current\nI(R16): mag:   0.927185 phase:    92.6999°  device_current\nI(R3):  mag:   0.515704 phase:    167.307°  device_current\nI(R4):  mag:    3.79248 phase:   -85.0285°  device_current\nI(R9):  mag:    4.44783 phase:    83.1593°  device_current\nI(R13): mag:       1.03 phase:   -119.309°  device_current\nI(R17): mag:    1.40714 phase:   -72.0029°  device_current\nI(R18): mag:    1.14087 phase:    84.3492°  device_current\nI(R19): mag:    1.05441 phase:   -80.4269°  device_current\nI(R20): mag:    2.06528 phase:     104.93°  device_current\nI(R21): mag:    2.42683 phase:    109.035°  device_current\nI(R22): mag:    2.49454 phase:    97.4264°  device_current\nI(R23): mag:   0.773901 phase:    99.1191°  device_current\nI(R24): mag:    1.38747 phase:   -83.3702°  device_current\nI(R25): mag:    1.76885 phase:   -77.3024°  device_current\nI(R5):  mag:    1.85437 phase:    92.6999°  device_current\nI(G1):  mag:    1.84371 phase:   -22.7819°  device_current\nI(G2):  mag:     10.099 phase:    96.8387°  device_current\nI(E1):  mag:       1.03 phase:    60.6913°  device_current\nI(E2):  mag:    1.60938 phase:    168.956°  device_current\nI(V1):  mag:    4.87346 phase:   -98.6601°  device_current\nI(V2):  mag:    1.94096 phase:   -82.8583°  device_current\nI(V3):  mag:    4.71908 phase:    94.5253°  device_current\nI(V4):  mag:    5.84267 phase:   -86.5218°  device_current\nI(V5):  mag:    6.49005 phase:   -83.5738°  device_current\nI(V6):  mag:    3.70472 phase:    80.7758°  device_current\nI(V7):  mag:    1.26686 phase:   -132.841°  device_current\nI(V8):  mag:    1.14087 phase:   -95.6508°  device_current\nThe LTSpice results are the same as those from the Python code."
  },
  {
    "objectID": "test_7.html#ac-sweep",
    "href": "test_7.html#ac-sweep",
    "title": "10  test_7",
    "section": "10.3 AC Sweep",
    "text": "10.3 AC Sweep\nLooking at node 17 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 17 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_7/') # change directory to net list location\n\nfn = 'test_7.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 17\n\nH = u1[v17]\nH\n\n\\(\\displaystyle \\frac{7.75372831979451 \\cdot 10^{59} s^{7} + 4.8993837334343 \\cdot 10^{60} s^{6} + 2.54067743417075 \\cdot 10^{61} s^{5} + 8.11163541343906 \\cdot 10^{61} s^{4} + 8.09087145235497 \\cdot 10^{61} s^{3} - 9.32472091368078 \\cdot 10^{59} s^{2} - 1.26502178475526 \\cdot 10^{60} s - 4.04308734375 \\cdot 10^{58}}{3.85284403284873 \\cdot 10^{57} s^{7} - 4.59814732924552 \\cdot 10^{59} s^{6} - 2.24313274572749 \\cdot 10^{60} s^{5} - 6.97946239401244 \\cdot 10^{59} s^{4} + 6.95149701523521 \\cdot 10^{60} s^{3} + 2.63003932016054 \\cdot 10^{60} s^{2} + 3.97724159488626 \\cdot 10^{58} s - 1.36137375168457 \\cdot 10^{58}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe SymPy and LTSpice results overlay each other."
  },
  {
    "objectID": "test_8.html#numeric-solution",
    "href": "test_8.html#numeric-solution",
    "title": "11  test_8",
    "section": "11.1 Numeric solution",
    "text": "11.1 Numeric solution\nFrom the LTSpice netlist:\n\nK1 L1 L2 0.8\nK2 L3 L4 0.2\n\nK1 and K2 identify the mutual inductance between two inductors. k is the coefficient of coupling. These need to be converted to mutual inductance.\nNeed to solve for M1 and M2:\n\\(M_1 = k \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = k \\times {\\sqrt{L_3 \\times L_4}}\\)\n\n# calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]*np.sqrt(component_values[L1] *component_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M1]))\n\ncomponent_values[M2] = component_values[K2]*np.sqrt(component_values[L3] *component_values[L4])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M2]))\n\nmutual inductance, M1 = 1.600000000\nmutual inductance, M1 = 0.632455532\n\n\nNeed to set the DC sources to zero.\n\ncomponent_values[V2] = 0\ncomponent_values[V3] = 0\ncomponent_values[V4] = 0\ncomponent_values[I1] = 0\ncomponent_values[I2] = 0\ncomponent_values[I3] = 0\ncomponent_values[I4] = 0\n\n\nequ1a = equ.subs(component_values)\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\n#u1 # the solution is too long to display correctly\n\n\n# trying pprint for a few of the nodes\npprint(u1[v2])\n\n                                7                         6                   \n            - 3.5390069568e+62⋅s  - 4.64954632445963e+63⋅s  - 3.26358740395349\n──────────────────────────────────────────────────────────────────────────────\n                   8                         7                         6      \n9.90414000576e+62⋅s  + 1.41637532380814e+64⋅s  + 2.31172858420853e+65⋅s  + 1.1\n\n      5                         4                         3                   \ne+65⋅s  - 4.18855602017884e+65⋅s  + 7.22358803127554e+65⋅s  - 7.48482405611853\n──────────────────────────────────────────────────────────────────────────────\n                   5                         4                         3      \n7903952541104e+66⋅s  + 1.60667800064429e+66⋅s  - 2.26595141213756e+65⋅s  - 2.2\n\n      2                                                             \ne+64⋅s  - 1.98928837739837e+64⋅s - 5.43997955648437e+62             \n────────────────────────────────────────────────────────────────────\n                   2                                                \n4440876527127e+65⋅s  - 6.23366738041327e+63⋅s + 1.12523056632602e+63\n\n\n\npprint(u1[v3])\n\n                      8                         7                         6   \n- 5.202340226496e+63⋅s  - 2.83150657805778e+65⋅s  - 3.12300458619362e+66⋅s  - \n──────────────────────────────────────────────────────────────────────────────\n                     8                         7                         6    \n 2.971242001728e+63⋅s  + 4.24912597142442e+64⋅s  + 6.93518575262559e+65⋅s  + 3\n\n                      5                        4                         3    \n1.10562230053989e+67⋅s  - 1.4983958176291e+67⋅s  - 5.07790860193152e+66⋅s  + 1\n──────────────────────────────────────────────────────────────────────────────\n                     5                         4                         3    \n.53711857623313e+66⋅s  + 4.82003400193286e+66⋅s  - 6.79785423641268e+65⋅s  - 6\n\n                     2                                                \n.86721677831568e+66⋅s  + 3.41718868879397e+65⋅s + 1.05226672260527e+64\n──────────────────────────────────────────────────────────────────────\n                    2                                                 \n.7332262958138e+65⋅s  - 1.87010021412398e+64⋅s + 3.37569169897805e+63 \n\n\n\npprint(u1[v4])\n\n                                 7                         6                  \n           1.69793472607621e+65⋅s  + 2.96555284913763e+66⋅s  + 1.2136984798616\n──────────────────────────────────────────────────────────────────────────────\n                    8                         7                         6     \n2.971242001728e+63⋅s  + 4.24912597142442e+64⋅s  + 6.93518575262559e+65⋅s  + 3.\n\n       5                         4                         3                  \n3e+67⋅s  + 1.66884617129846e+67⋅s  + 4.43947630710454e+66⋅s  - 1.9596618859036\n──────────────────────────────────────────────────────────────────────────────\n                    5                         4                         3     \n53711857623313e+66⋅s  + 4.82003400193286e+66⋅s  - 6.79785423641268e+65⋅s  - 6.\n\n       2                                                            \n5e+66⋅s  - 3.05907880853766e+65⋅s - 8.36540714026172e+63            \n────────────────────────────────────────────────────────────────────\n                   2                                                \n7332262958138e+65⋅s  - 1.87010021412398e+64⋅s + 3.37569169897805e+63"
  },
  {
    "objectID": "test_8.html#ac-analysis",
    "href": "test_8.html#ac-analysis",
    "title": "11  test_8",
    "section": "11.2 AC analysis",
    "text": "11.2 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{V2} + 1.0 v_{1} - 0.5 v_{2} - 0.5 v_{8}\\\\- I_{L6} - 0.5 v_{1} + 0.7 v_{2}\\\\- I_{V3} + 0.5 v_{3} - 0.333333333333333 v_{4}\\\\I_{H1} + 2.0 v_{12} - 2.0 v_{13} - 0.333333333333333 v_{3} + 1.33333333333333 v_{4} - 1.0 v_{5}\\\\- 0.1 v_{12} - 1.0 v_{4} + 1.1 v_{5}\\\\- I_{V8} - 0.5 v_{13} + 0.5 v_{6}\\\\- I_{F1} - I_{L5}\\\\- 0.5 v_{1} - 0.2 v_{16} - 0.0001 v_{31} + 0.9501 v_{8} - 0.25 v_{9}\\\\- I_{L2} + I_{L6} - 0.1 v_{10} - 0.25 v_{8} + 0.35 v_{9}\\\\I_{V3} + I_{V4} + 0.225 v_{10} - 0.125 v_{11} - 0.1 v_{9}\\\\- I_{L4} - 0.125 v_{10} + v_{11} \\cdot \\left(0.125 + 2.0 i\\right) + v_{12} \\left(-2.0 - 2.0 i\\right) + 2.0 v_{13}\\\\- 2.0 i v_{11} + v_{12} \\cdot \\left(0.1 + 2.0 i\\right) - 0.1 v_{5}\\\\1.53333333333333 v_{13} - 0.333333333333333 v_{14} - 0.2 v_{19} - 0.5 v_{30} - 0.5 v_{6}\\\\I_{F1} - 0.333333333333333 v_{13} + 0.666666666666667 v_{14} - 0.333333333333333 v_{20}\\\\I_{Ea1} + 0.2 v_{15}\\\\I_{L1} + 0.533333333333333 v_{16} - 0.333333333333333 v_{22} - 2.0 v_{5} - 0.2 v_{8}\\\\I_{Ea2} + I_{L4}\\\\v_{18} \\cdot \\left(0.333333333333333 + 2.0 i\\right) - 0.333333333333333 v_{19} - 2.0 i v_{23}\\\\- 0.2 v_{13} - 0.333333333333333 v_{18} + 0.876190476190476 v_{19} - 0.2 v_{20} - 0.142857142857143 v_{23}\\\\- I_{V4} + I_{V5} - 0.333333333333333 v_{14} - 0.2 v_{19} + 0.533333333333333 v_{20}\\\\- I_{Ea1} - I_{L3} + 5.0 \\cdot 10^{-5} v_{21} - 5.0 \\cdot 10^{-5} v_{29}\\\\I_{L3} + I_{V1} - 0.333333333333333 v_{16} + 0.444444444444444 v_{22} - 0.111111111111111 v_{23}\\\\- I_{L1} + I_{V6} - 2.0 i v_{18} - 0.142857142857143 v_{19} - 0.111111111111111 v_{22} + v_{23} \\cdot \\left(0.553968253968254 + 2.0 i\\right) - 0.2 v_{24} - 0.1 v_{28}\\\\I_{V7} - 0.2 v_{23} + 0.4 v_{24} - 0.2 v_{32}\\\\I_{L2} - I_{V7} + 0.1 v_{25} - 0.1 v_{26}\\\\- I_{Ea2} - I_{H2} - 0.1 v_{25} + 0.1 v_{26}\\\\- I_{F2} + I_{H2} - I_{V6}\\\\- I_{V5} - 0.1 v_{23} + 0.433333333333333 v_{28} + 2.0 v_{5}\\\\- 5.0 \\cdot 10^{-5} v_{21} + 0.00015 v_{29} - 0.0001 v_{30}\\\\I_{O1} - 0.5 v_{13} - 0.0001 v_{29} + 0.5001 v_{30}\\\\0.00015 v_{31} - 5.0 \\cdot 10^{-5} v_{32} - 0.0001 v_{8}\\\\I_{O2} - 0.2 v_{24} - 5.0 \\cdot 10^{-5} v_{31} + 0.20005 v_{32}\\\\v_{22}\\\\v_{1}\\\\v_{10} - v_{3}\\\\v_{10} - v_{20}\\\\I_{F1} - 2.0 I_{V2}\\\\v_{15} - 2.0 v_{2} - v_{21} + 2.0 v_{7}\\\\- 3.0 I_{V2} + v_{4}\\\\- 1.0 i I_{L1} - 1.6 i I_{L2} + v_{16} - v_{23}\\\\- 1.6 i I_{L1} - 4.0 i I_{L2} + v_{25} - v_{9}\\\\v_{20} - v_{28}\\\\v_{23} - v_{27}\\\\- 2.0 i I_{L3} - 0.632455532033676 i I_{L4} - v_{21} + v_{22}\\\\- 0.632455532033676 i I_{L3} - 5.0 i I_{L4} - v_{11} + v_{17}\\\\- 1.0 i I_{L5} - v_{7}\\\\- 2.0 i I_{L6} - v_{2} + v_{9}\\\\I_{F2} - 2.0 I_{V2}\\\\- 2.0 v_{10} + v_{17} - v_{26} + 2.0 v_{9}\\\\- 3.0 I_{V2} - v_{26} + v_{27}\\\\v_{24} - v_{25}\\\\- v_{6}\\\\v_{29}\\\\v_{31}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{Ea1} : -1.05373431161195 + 1.24786796031362 i, \\  I_{Ea2} : -0.155959689544689 + 0.51824284400627 i, \\  I_{F1} : 1.73968399560092 - 0.502495662147359 i, \\  I_{F2} : 1.73968399560092 - 0.502495662147359 i, \\  I_{H1} : -1.48314322331905 - 0.0660513166239778 i, \\  I_{H2} : 0.323932696333347 - 0.640114247151401 i, \\  I_{L1} : 2.56990560967261 - 1.2618305380904 i, \\  I_{L2} : -0.667612122261301 - 0.532593445058889 i, \\  I_{L3} : 1.05409312550412 - 1.24797830150459 i, \\  I_{L4} : 0.155959689544689 - 0.51824284400627 i, \\  I_{L5} : -1.73968399560092 + 0.502495662147359 i, \\  I_{L6} : -0.315915236352704 - 0.193601796825927 i, \\  I_{O1} : 0.957467798516351 - 0.221993937824238 i, \\  I_{O2} : 1.69365544045516 + 0.0162079448126214 i, \\  I_{V1} : -1.07189763516873 + 1.10879303667281 i, \\  I_{V2} : 0.86984199780046 - 0.25124783107368 i, \\  I_{V3} : -1.96227871537947 + 0.638900336291395 i, \\  I_{V4} : 2.21532544022067 - 0.749779976982176 i, \\  I_{V5} : 2.60798193941531 - 0.703526705514992 i, \\  I_{V6} : -1.41575129926757 - 0.137618585004041 i, \\  I_{V7} : -0.835585129049959 - 0.410722041913759 i, \\  I_{V8} : 0.836960476216364 - 0.32982235822549 i, \\  v_{1} : 0.0, \\  v_{10} : -2.18487343515801 + 0.775305010435431 i, \\  v_{11} : -1.85711527507315 + 1.23523546779434 i, \\  v_{12} : -1.93812743151411 + 1.02852394848 i, \\  v_{13} : -1.67392095243273 + 0.659644716450981 i, \\  v_{14} : -4.53892318719675 + 1.47121835666425 i, \\  v_{15} : 5.26867155805975 - 6.23933980156809 i, \\  v_{16} : 10.4884348658008 + 0.0622647076421236 i, \\  v_{17} : 1.52338972560277 + 2.68170094402154 i, \\  v_{18} : 8.45673682322186 - 0.646976254910933 i, \\  v_{19} : 3.70182531421306 - 0.153284209276674 i, \\  v_{2} : -0.451307480503863 - 0.27657399546561 i, \\  v_{20} : -2.18487343515801 + 0.775305010435431 i, \\  v_{21} : 7.17627784336219 - 2.20682381943503 i, \\  v_{22} : 10.0, \\  v_{23} : 8.37445481561615 - 1.4394615064124 i, \\  v_{24} : 4.08519875432819 + 0.532996018259946 i, \\  v_{25} : 4.08519875432819 + 0.532996018259946 i, \\  v_{26} : 5.76492882221477 - 0.685718013191361 i, \\  v_{27} : 8.37445481561615 - 1.4394615064124 i, \\  v_{28} : -2.18487343515801 + 0.775305010435431 i, \\  v_{29} : 0.0, \\  v_{3} : -2.18487343515801 + 0.775305010435431 i, \\  v_{30} : -3.5881389216811 + 1.10341190971751 i, \\  v_{31} : 0.0, \\  v_{32} : -4.38198295220956 + 0.451843333363498 i, \\  v_{4} : 2.60952599340138 - 0.753743493221039 i, \\  v_{5} : 2.1961029547727 - 0.591719180339126 i, \\  v_{6} : 0.0, \\  v_{7} : 0.502495662147359 + 1.73968399560092 i, \\  v_{8} : 2.19099147610478 - 0.225921666681749 i, \\  v_{9} : -0.0641038868520081 - 0.908404468171018 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.000000 phase:         nan deg\nv2   : mag:   0.529312 phase:  -148.49885 deg\nv3   : mag:   2.318355 phase:   160.46271 deg\nv4   : mag:   2.716202 phase:   -16.11100 deg\nv5   : mag:   2.274423 phase:   -15.07969 deg\nv6   : mag:   0.000000 phase:         nan deg\nv7   : mag:   1.810802 phase:    73.88900 deg\nv8   : mag:   2.202609 phase:    -5.88718 deg\nv9   : mag:   0.910663 phase:   -94.03653 deg\nv10  : mag:   2.318355 phase:   160.46271 deg\nv11  : mag:   2.230400 phase:   146.37066 deg\nv12  : mag:   2.194128 phase:   152.04604 deg\nv13  : mag:   1.799206 phase:   158.49201 deg\nv14  : mag:   4.771405 phase:   162.04074 deg\nv15  : mag:   8.166288 phase:   -49.82133 deg\nv16  : mag:  10.488620 phase:     0.34013 deg\nv17  : mag:   3.084191 phase:    60.40046 deg\nv18  : mag:   8.481449 phase:    -4.37485 deg\nv19  : mag:   3.704998 phase:    -2.37113 deg\nv20  : mag:   2.318355 phase:   160.46271 deg\nv21  : mag:   7.507931 phase:   -17.09353 deg\nv22  : mag:  10.000000 phase:     0.00000 deg\nv23  : mag:   8.497267 phase:    -9.75310 deg\nv24  : mag:   4.119822 phase:     7.43339 deg\nv25  : mag:   4.119822 phase:     7.43339 deg\nv26  : mag:   5.805567 phase:    -6.78326 deg\nv27  : mag:   8.497267 phase:    -9.75310 deg\nv28  : mag:   2.318355 phase:   160.46271 deg\nv29  : mag:   0.000000 phase:         nan deg\nv30  : mag:   3.753966 phase:   162.90647 deg\nv31  : mag:   0.000000 phase:         nan deg\nv32  : mag:   4.405217 phase:   174.11282 deg\nI_V1 : mag:   1.542202 phase:   134.03070 deg\nI_V2 : mag:   0.905401 phase:   -16.11100 deg\nI_V3 : mag:   2.063669 phase:   161.96522 deg\nI_V4 : mag:   2.338768 phase:   -18.69846 deg\nI_F1 : mag:   1.810802 phase:   -16.11100 deg\nI_Ea1: mag:   1.633258 phase:   130.17867 deg\nI_H1 : mag:   1.484613 phase:  -177.45004 deg\nI_L1 : mag:   2.862976 phase:   -26.15116 deg\nI_L2 : mag:   0.854027 phase:  -141.41858 deg\nI_V5 : mag:   2.701207 phase:   -15.09671 deg\nI_V6 : mag:   1.422424 phase:  -174.44799 deg\nI_L3 : mag:   1.633573 phase:   -49.81421 deg\nI_L4 : mag:   0.541202 phase:   -73.25139 deg\nI_L5 : mag:   1.810802 phase:   163.88900 deg\nI_L6 : mag:   0.370519 phase:  -148.49885 deg\nI_F2 : mag:   1.810802 phase:   -16.11100 deg\nI_Ea2: mag:   0.541202 phase:   106.74861 deg\nI_H2 : mag:   0.717411 phase:   -63.15810 deg\nI_V7 : mag:   0.931072 phase:  -153.82412 deg\nI_V8 : mag:   0.899603 phase:   -21.50799 deg\nI_O1 : mag:   0.982866 phase:   -13.05368 deg\nI_O2 : mag:   1.693733 phase:     0.54829 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(16):  mag:    10.4887 phase:   0.339452°  voltage\nV(8):   mag:    2.20263 phase:    -5.8879°  voltage\nV(1):   mag:          0 phase:          0°  voltage\nV(2):   mag:   0.529319 phase:   -148.499°  voltage\nV(11):  mag:    2.23038 phase:    146.371°  voltage\nV(10):  mag:    2.31839 phase:    160.462°  voltage\nV(23):  mag:    8.49732 phase:   -9.75384°  voltage\nV(22):  mag:         10 phase:          0°  voltage\nV(9):   mag:   0.910675 phase:   -94.0363°  voltage\nV(24):  mag:     4.1199 phase:    7.43283°  voltage\nV(3):   mag:    2.31839 phase:    160.462°  voltage\nV(20):  mag:    2.31839 phase:    160.462°  voltage\nV(5):   mag:    2.27445 phase:   -15.0807°  voltage\nV(12):  mag:    2.19411 phase:    152.046°  voltage\nV(18):  mag:     8.4815 phase:   -4.37559°  voltage\nV(26):  mag:    5.80559 phase:   -6.78388°  voltage\nV(25):  mag:     4.1199 phase:    7.43283°  voltage\nV(4):   mag:    2.71624 phase:   -16.1119°  voltage\nV(14):  mag:    4.77144 phase:     162.04°  voltage\nV(7):   mag:    1.81082 phase:    73.8881°  voltage\nV(15):  mag:    8.16625 phase:   -49.8218°  voltage\nV(21):  mag:    7.50792 phase:   -17.0934°  voltage\nV(13):  mag:    1.79919 phase:    158.492°  voltage\nV(28):  mag:    2.31839 phase:    160.462°  voltage\nV(27):  mag:    8.49732 phase:   -9.75384°  voltage\nV(17):  mag:    3.08423 phase:    60.4014°  voltage\nV(6):   mag:          0 phase:          0°  voltage\nV(19):  mag:    3.70502 phase:   -2.37192°  voltage\nV(32):  mag:    4.40507 phase:    174.112°  voltage\nV(31):  mag: 6.0913e-05 phase:   -4.03597°  voltage\nV(30):  mag:    3.75389 phase:    162.907°  voltage\nV(29):  mag: 4.73489e-05 phase:   -16.1831°     voltage\nI(C1):  mag:     1.5935 phase:   -5.92837°  device_current\nI(C2):  mag:   0.444041 phase:   -21.4012°  device_current\nI(F1):  mag:    1.81082 phase:   -16.1119°  device_current\nI(F2):  mag:    1.81082 phase:   -16.1119°  device_current\nI(H1):  mag:    1.48461 phase:   -177.452°  device_current\nI(H2):  mag:   0.717409 phase:   -63.1574°  device_current\nI(L1):  mag:    2.86299 phase:   -26.1518°  device_current\nI(L2):  mag:   0.854034 phase:   -141.418°  device_current\nI(L3):  mag:    1.63357 phase:   -49.8147°  device_current\nI(L4):  mag:   0.541197 phase:   -73.2497°  device_current\nI(L5):  mag:    1.81082 phase:    163.888°  device_current\nI(L6):  mag:   0.370523 phase:   -148.499°  device_current\nI(I1):  mag:          0 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nI(R1):  mag:     1.6605 phase:    1.98853°  device_current\nI(R2):  mag:    1.10131 phase:    -5.8879°  device_current\nI(R6):  mag:   0.105864 phase:   -148.499°  device_current\nI(R8):  mag:  0.0705929 phase:    54.5194°  device_current\nI(R10): mag:   0.241259 phase:   -138.471°  device_current\nI(R11): mag:   0.589029 phase:   -163.163°  device_current\nI(R12): mag:    0.26466 phase:   -148.499°  device_current\nI(R14): mag:   0.270792 phase:    141.553°  device_current\nI(R15): mag:   0.944208 phase:    155.303°  device_current\nI(R7):  mag:   0.444041 phase:    158.599°  device_current\nI(R16): mag:   0.386398 phase:    160.462°  device_current\nI(R3):  mag:   0.207524 phase:   -35.9644°  device_current\nI(R4):  mag:    1.67746 phase:   -17.6897°  device_current\nI(R9):  mag:   0.164149 phase:   -172.751°  device_current\nI(R13): mag:    1.63325 phase:   -49.8218°  device_current\nI(R17): mag:    1.08737 phase:   -8.59974°  device_current\nI(R18): mag:   0.899593 phase:    158.492°  device_current\nI(R19): mag:   0.692348 phase:   -15.3907°  device_current\nI(R20): mag:    1.19191 phase:    171.035°  device_current\nI(R21): mag:     1.5935 phase:    174.072°  device_current\nI(R22): mag:   0.992596 phase:    164.183°  device_current\nI(R23): mag:   0.444041 phase:    158.599°  device_current\nI(R24): mag:   0.818256 phase:   -16.4696°  device_current\nI(R25): mag:    1.07892 phase:   -11.8466°  device_current\nI(R5):  mag:   0.772795 phase:    160.462°  device_current\nI(R26): mag: 0.000220257 phase:    174.112°     device_current\nI(R27): mag: 0.000375394 phase:    162.907°     device_current\nI(R28): mag:   0.982466 phase:   -13.0516°  device_current\nI(R29): mag:     1.6935 phase:   0.548618°  device_current\nI(R30): mag: 0.000375394 phase:    162.907°     device_current\nI(R31): mag: 0.000220257 phase:    174.112°     device_current\nI(G1):  mag:    0.90747 phase:   -54.3873°  device_current\nI(G2):  mag:    4.54891 phase:    164.919°  device_current\nI(E1):  mag:    1.63325 phase:    130.178°  device_current\nI(E2):  mag:   0.541197 phase:     106.75°  device_current\nI(V1):  mag:    1.54213 phase:    134.031°  device_current\nI(V2):  mag:   0.905412 phase:   -16.1119°  device_current\nI(V3):  mag:     2.0637 phase:    161.964°  device_current\nI(V4):  mag:     2.3388 phase:   -18.6996°  device_current\nI(V5):  mag:    2.70125 phase:   -15.0979°  device_current\nI(V6):  mag:    1.42243 phase:    -174.45°  device_current\nI(V7):  mag:   0.931071 phase:   -153.824°  device_current\nI(V8):  mag:   0.899593 phase:   -21.5082°  device_current\nIx(u1:3):   mag:    0.98284 phase:   -13.0531°  subckt_current\nIx(u2:3):   mag:    1.69372 phase:   0.547783°  subckt_current\nThere are some small numeric differences in some node voltages and phases."
  },
  {
    "objectID": "test_8.html#ac-sweep",
    "href": "test_8.html#ac-sweep",
    "title": "11  test_8",
    "section": "11.3 AC Sweep",
    "text": "11.3 AC Sweep\nLooking at node 21 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 21 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_8/') # change directory to net list location\n\nfn = 'test_8.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 17\n\nH = u1[v21]\nH\n\n\\(\\displaystyle \\frac{6.79004139395635 \\cdot 10^{65} s^{8} + 1.0293431704604 \\cdot 10^{67} s^{7} + 2.49981109098941 \\cdot 10^{67} s^{6} + 5.93953469296071 \\cdot 10^{67} s^{5} + 1.35568791206657 \\cdot 10^{68} s^{4} - 9.16542835349853 \\cdot 10^{66} s^{3} - 1.96333723268553 \\cdot 10^{67} s^{2} - 6.18927920979722 \\cdot 10^{65} s + 1.01270750969341 \\cdot 10^{65}}{8.913726005184 \\cdot 10^{63} s^{8} + 1.27473779142732 \\cdot 10^{65} s^{7} + 2.08055572578768 \\cdot 10^{66} s^{6} + 1.06113557286994 \\cdot 10^{67} s^{5} + 1.44601020057986 \\cdot 10^{67} s^{4} - 2.0393562709238 \\cdot 10^{66} s^{3} - 2.01996788874414 \\cdot 10^{66} s^{2} - 5.61030064237194 \\cdot 10^{64} s + 1.01270750969341 \\cdot 10^{64}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 10*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe SymPy and LTSpice results overlay each other."
  },
  {
    "objectID": "test_9.html#symbolic-solution",
    "href": "test_9.html#symbolic-solution",
    "title": "12  test_9",
    "section": "12.1 Symbolic solution",
    "text": "12.1 Symbolic solution\n\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ v_{1} : - \\frac{I_{1}}{g_{1} - g_{2}}\\right\\}\\)\n\n\n\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\n       -I₁  \nv₁ = ───────\n     g₁ - g₂"
  },
  {
    "objectID": "test_9.html#numeric-solution",
    "href": "test_9.html#numeric-solution",
    "title": "12  test_9",
    "section": "12.2 Numeric solution",
    "text": "12.2 Numeric solution\nSubstitue the element values into the equations and solve for unknown node voltages and currents.\n\n# enter the element values\nelement_values = {g1:0.600000,I1:1.0000e+01,g2:0.800000}\nequ1a = equ.subs(element_values)\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}0.2 v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}10.0\\end{matrix}\\right]\\)\n\n\nSolve the equations for voltages and currents.\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ v_{1} : 50.0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:s}: {:f}'.format(str(name),float(value)))\n    #print(name,value)\n\nv1: 50.000000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(1):    50  voltage\nI(I1):   10  device_current\nI(R1):   5e-07   device_current\nI(G1):   30  device_current\nI(G2):   40  device_current\nThe results from LTSpice agree with the SymPy results.\nFind the power absorbed by each source in the circuit.\n\nelement_values[g1]*ans[v1]**2 # power through G1\n\n\\(\\displaystyle 1500.0\\)\n\n\n\nelement_values[g2]*ans[v1]**2 # power through G2\n\n\\(\\displaystyle 2000.0\\)\n\n\n\nelement_values[I1]*ans[v1] # power through I1\n\n\\(\\displaystyle 500.0\\)"
  },
  {
    "objectID": "test_10.html#symbolic-solution",
    "href": "test_10.html#symbolic-solution",
    "title": "13  test_10",
    "section": "13.1 Symbolic solution",
    "text": "13.1 Symbolic solution\n\nans = solve(equ,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{V1} : I_{1} + I_{3}, \\  I_{V2} : I_{2} - I_{3}, \\  I_{V3} : I_{3}, \\  I_{V4} : - I_{2}, \\  v_{1} : V_{2} - V_{4}, \\  v_{2} : V_{2}, \\  v_{3} : - V_{1} + V_{2}, \\  v_{4} : - V_{1} + V_{2} - V_{3}\\right\\}\\)\n\n\n\nleft_side = list(ans.keys())\nright_side = list(ans.values())\n\nfor i in range(len(ans)):\n    pprint(Eq(left_side[i],right_side[i]))\n\nI_V1 = I₁ + I₃\nI_V2 = I₂ - I₃\nI_V3 = I₃\nI_V4 = -I₂\nv₁ = V₂ - V₄\nv₂ = V₂\nv₃ = -V₁ + V₂\nv₄ = -V₁ + V₂ - V₃"
  },
  {
    "objectID": "test_10.html#numeric-solution",
    "href": "test_10.html#numeric-solution",
    "title": "13  test_10",
    "section": "13.2 Numeric solution",
    "text": "13.2 Numeric solution\n\nelement_values = {\n    I1:2.0000e+00,\n    I2:-3.0000e+00,\n    I3:4.0000e+00,\n    V1:-5.0000e+00,\n    V2:3.0000e+00,\n    V3:4.0000e+00,\n    V4:1.2000e+01}\nequ1a = equ.subs(element_values)\n\nequ1a  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{V4}\\\\I_{V1} + I_{V2} + I_{V4}\\\\- I_{V1} + I_{V3}\\\\- I_{V3}\\\\v_{2} - v_{3}\\\\v_{2}\\\\v_{3} - v_{4}\\\\- v_{1} + v_{2}\\end{matrix}\\right] = \\left[\\begin{matrix}-3.0\\\\2.0\\\\-2.0\\\\-4.0\\\\-5.0\\\\3.0\\\\4.0\\\\12.0\\end{matrix}\\right]\\)\n\n\n\nans = solve(equ1a,X)\nans\n\n\\(\\displaystyle \\left\\{ I_{V1} : 6.0, \\  I_{V2} : -7.0, \\  I_{V3} : 4.0, \\  I_{V4} : 3.0, \\  v_{1} : -9.0, \\  v_{2} : 3.0, \\  v_{3} : 8.0, \\  v_{4} : 4.0\\right\\}\\)\n\n\n\nfor name, value in ans.items():\n    print('{:5s}: {:11.5f}'.format(str(name),float(value)))\n    #print(name,value)\n\nI_V1 :     6.00000\nI_V2 :    -7.00000\nI_V3 :     4.00000\nI_V4 :     3.00000\nv1   :    -9.00000\nv2   :     3.00000\nv3   :     8.00000\nv4   :     4.00000\n\n\nThe node voltages and current through the sources are solved for. The Sympy generated solution matches the LTSpice results:\n      --- Operating Point ---\n\nV(3):    8   voltage\nV(2):    3   voltage\nV(1):    -9  voltage\nV(4):    4   voltage\nI(I1):   2   device_current\nI(I2):   -3  device_current\nI(I3):   4   device_current\nI(V1):   6   device_current\nI(V2):   -7  device_current\nI(V3):   4   device_current\nI(V4):   3   device_current\n\nFind the power supplied by the -5V source (V1)\n\n\nelement_values[V1]*ans[I_V1]\n\n\\(\\displaystyle -30.0\\)\n\n\n\nTo what value should the 4A source (I3) be changed to reduce the supply supplied by the -5V source (I_V1) to zero?\n\n\nI_V1 = I₁ + I₃\nI_V2 = I₂ - I₃\nI_V3 = I₃\nI_V4 = -I₂\nv₁ = V₂ - V₄\nv₂ = V₂\nv₃ = -V₁ + V₂\nv₄ = -V₁ + V₂ - V₃\nLooking at equation I_V1 = I₁ + I₃, set I_V1 to zero\n\nelement_values[I1] + element_values[I3] - 0\n\n\\(\\displaystyle 6.0\\)\n\n\nBy inspection a value of I3 = -2 will make I_V1 = 0\n\nelement_values[I1] + (-2) - 0\n\n\\(\\displaystyle 0.0\\)\n\n\nanswer is -2\nText book answers: (a) 30W; (b) -2A"
  },
  {
    "objectID": "test_11.html#ac-sweep",
    "href": "test_11.html#ac-sweep",
    "title": "14  test_11",
    "section": "14.4 AC Sweep",
    "text": "14.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 10 Hz.\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_11/') # change directory to net list location\n\nfn = 'test_11.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 2\n\nH = u1[v2]\nH\n\n\\(\\displaystyle \\frac{2.12132034355964 \\cdot 10^{42} s^{2} - 7.07106781186548 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 10*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe SymPy and LTSpice results overlay each other."
  },
  {
    "objectID": "test_12.html#ac-sweep",
    "href": "test_12.html#ac-sweep",
    "title": "15  test_12",
    "section": "15.4 AC Sweep",
    "text": "15.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.01 Hz to 1 Hz.\nLoad the csv file of node 4 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_12/') # change directory to net list location\n\nfn = 'test_12_v1.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 2\n\nH = u1[v4]\nH\n\n\\(\\displaystyle \\frac{1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.01*2*np.pi, 1*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\nThe data from python and LTSpice match."
  },
  {
    "objectID": "test_13.html",
    "href": "test_13.html",
    "title": "16  test_13",
    "section": "",
    "text": "17 calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]np.sqrt(component_values[L1] component_values[L2]) print(‘mutual inductance, M1 = {:.9f}’.format(component_values[M1]))\ncomponent_values[M2] = component_values[K2]np.sqrt(component_values[L1] component_values[L3]) print(‘mutual inductance, M2 = {:.9f}’.format(component_values[M2]))\ncomponent_values[M3] = component_values[K3]np.sqrt(component_values[L2] component_values[L3]) print(‘mutual inductance, M3 = {:.9f}’.format(component_values[M3]))\ncomponent_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 2.0, \\  I_{2} : 0, \\  I_{3} : 0, \\  I_{4} : 0, \\  L_{1} : 5.0, \\  L_{2} : 3.0, \\  L_{3} : 1.0, \\  L_{4} : 1.0\\right\\}\\)\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L1} - I_{L2}\\\\- 5.0 I_{L1} s + v_{2} - v_{3}\\\\- 3.0 I_{L2} s - v_{3}\\\\- 1.0 I_{L3} s - v_{1} + v_{2}\\\\- 1.0 I_{L4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\nThe equations above are using the component values and the Laplace variable.\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L1} : 0.2, \\  I_{L2} : -0.2, \\  I_{L3} : 1.8, \\  I_{L4} : -0.2, \\  v_{1} : - 0.2 s, \\  v_{2} : 1.6 s, \\  v_{3} : 0.6 s\\right\\}\\)\nThe transfer function H(s)=V2(s)/I1\nu1[v2]/component_values[I1]\n\n\\(\\displaystyle 0.8 s\\)"
  },
  {
    "objectID": "test_13.html#symbolic-solution",
    "href": "test_13.html#symbolic-solution",
    "title": "16  test_13",
    "section": "16.1 Symbolic solution",
    "text": "16.1 Symbolic solution\n\nsymbolic_solution = solve(equ,X)\n#symbolic_solution\n\n\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\n     -I₁⋅L₃⋅L₄⋅s + I₂⋅L₁⋅L₄⋅s + I₂⋅L₂⋅L₄⋅s + I₂⋅L₃⋅L₄⋅s - I₃⋅L₂⋅L₄⋅s - I₄⋅L₁⋅L\nv₁ = ─────────────────────────────────────────────────────────────────────────\n                                  L₁ + L₂ + L₃ + L₄                           \n\n₄⋅s\n───\n   \n     I₁⋅L₁⋅L₃⋅s + I₁⋅L₂⋅L₃⋅s + I₂⋅L₁⋅L₄⋅s + I₂⋅L₂⋅L₄⋅s - I₃⋅L₂⋅L₃⋅s - I₃⋅L₂⋅L₄\nv₂ = ─────────────────────────────────────────────────────────────────────────\n                                               L₁ + L₂ + L₃ + L₄              \n\n⋅s - I₄⋅L₁⋅L₃⋅s - I₄⋅L₁⋅L₄⋅s\n────────────────────────────\n                            \n     I₁⋅L₂⋅L₃⋅s + I₂⋅L₂⋅L₄⋅s - I₃⋅L₁⋅L₂⋅s - I₃⋅L₂⋅L₃⋅s - I₃⋅L₂⋅L₄⋅s + I₄⋅L₁⋅L₂\nv₃ = ─────────────────────────────────────────────────────────────────────────\n                                  L₁ + L₂ + L₃ + L₄                           \n\n⋅s\n──\n  \n       I₁⋅L₃ + I₂⋅L₄ + I₃⋅L₂ - I₄⋅L₂ - I₄⋅L₃ - I₄⋅L₄\nI_L1 = ─────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄              \n       -I₁⋅L₃ - I₂⋅L₄ + I₃⋅L₁ + I₃⋅L₃ + I₃⋅L₄ - I₄⋅L₁\nI_L2 = ──────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄               \n       I₁⋅L₁ + I₁⋅L₂ + I₁⋅L₄ - I₂⋅L₄ - I₃⋅L₂ - I₄⋅L₁\nI_L3 = ─────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄              \n       -I₁⋅L₃ + I₂⋅L₁ + I₂⋅L₂ + I₂⋅L₃ - I₃⋅L₂ - I₄⋅L₁\nI_L4 = ──────────────────────────────────────────────\n                     L₁ + L₂ + L₃ + L₄               \n\n\nThe transfer function H(s)=V2(s)/I1\n\nI1\n\n\\(\\displaystyle I_{1}\\)\n\n\n\nsymbolic_solution[v2]\n\n\\(\\displaystyle \\frac{I_{1} L_{1} L_{3} s + I_{1} L_{2} L_{3} s + I_{2} L_{1} L_{4} s + I_{2} L_{2} L_{4} s - I_{3} L_{2} L_{3} s - I_{3} L_{2} L_{4} s - I_{4} L_{1} L_{3} s - I_{4} L_{1} L_{4} s}{L_{1} + L_{2} + L_{3} + L_{4}}\\)\n\n\n\nsymbolic_solution[v2]/I1\n\n\\(\\displaystyle \\frac{I_{1} L_{1} L_{3} s + I_{1} L_{2} L_{3} s + I_{2} L_{1} L_{4} s + I_{2} L_{2} L_{4} s - I_{3} L_{2} L_{3} s - I_{3} L_{2} L_{4} s - I_{4} L_{1} L_{3} s - I_{4} L_{1} L_{4} s}{I_{1} \\left(L_{1} + L_{2} + L_{3} + L_{4}\\right)}\\)"
  },
  {
    "objectID": "test_13.html#numeric-solution",
    "href": "test_13.html#numeric-solution",
    "title": "16  test_13",
    "section": "16.2 Numeric solution",
    "text": "16.2 Numeric solution\n\n# put the component values into dictionary format\ncomponent_values = {\n    L1:5.0000e+00,\n    I1:2.0000e+00,\n    L2:3.0000e+00,\n    L3:1.0000e+00,\n    L4:1.0000e+00,\n    I2:1.0000e+00,\n    I3:5.0000e+00,\n    I4:3.0000e+00}\n\nNeed to set the DC sources to zero.\n\ncomponent_values[I2] = 0\ncomponent_values[I3] = 0\ncomponent_values[I4] = 0\n\n\ncomponent_values\n\n\\(\\displaystyle \\left\\{ I_{1} : 2.0, \\  I_{2} : 0, \\  I_{3} : 0, \\  I_{4} : 0, \\  L_{1} : 5.0, \\  L_{2} : 3.0, \\  L_{3} : 1.0, \\  L_{4} : 1.0\\right\\}\\)\n\n\n\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L1} - I_{L2}\\\\- 5.0 I_{L1} s + v_{2} - v_{3}\\\\- 3.0 I_{L2} s - v_{3}\\\\- 1.0 I_{L3} s - v_{1} + v_{2}\\\\- 1.0 I_{L4} s + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L1} : 0.2, \\  I_{L2} : -0.2, \\  I_{L3} : 1.8, \\  I_{L4} : -0.2, \\  v_{1} : - 0.2 s, \\  v_{2} : 1.6 s, \\  v_{3} : 0.6 s\\right\\}\\)\n\n\nThe transfer function H(s)=V2(s)/I1\n\nu1[v2]/component_values[I1]\n\n\\(\\displaystyle 0.8 s\\)"
  },
  {
    "objectID": "test_13.html#ac-analysis",
    "href": "test_13.html#ac-analysis",
    "title": "16  test_13",
    "section": "16.3 AC analysis",
    "text": "16.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}- I_{L3} + I_{L4}\\\\I_{L1} + I_{L3}\\\\- I_{L1} - I_{L2}\\\\- 5.0 i I_{L1} + v_{2} - v_{3}\\\\- 3.0 i I_{L2} - v_{3}\\\\- 1.0 i I_{L3} - v_{1} + v_{2}\\\\- 1.0 i I_{L4} + v_{1}\\end{matrix}\\right] = \\left[\\begin{matrix}-2.0\\\\2.0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L1} : 0.2, \\  I_{L2} : -0.2, \\  I_{L3} : 1.8, \\  I_{L4} : -0.2, \\  v_{1} : - 0.2 i, \\  v_{2} : 1.6 i, \\  v_{3} : 0.6 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.200000 phase:   -90.00000 deg\nv2   : mag:   1.600000 phase:    90.00000 deg\nv3   : mag:   0.600000 phase:    90.00000 deg\nI_L1 : mag:   0.200000 phase:     0.00000 deg\nI_L2 : mag:   0.200000 phase:   180.00000 deg\nI_L3 : mag:   1.800000 phase:     0.00000 deg\nI_L4 : mag:   0.200000 phase:   180.00000 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: 5.72958e-12°     device_current\nI(L2):  mag:        0.2 phase:       -180°  device_current\nI(L3):  mag:        1.8 phase: -6.3662e-13°     device_current\nI(L4):  mag:        0.2 phase:       -180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nUsing the orginal circuit with the series resistance in L1 set to a small value, the phase of the currents in L2 and L4 didn’t agree with the Python results. So the netlist was modified to put the small series resistance in L3, which allowed the phase in L2 and L3 to agree.\nThe new LTSpice net list with Rser=1e-20 added to L3.\n* C:\\users\\jeff32\\My Documents\\Solving Electrical Engineering Problems with Python Blog\\MNA Test Circuits\\test_13\\test_13.asc\nL1 2 3 5 Rser=0\nI1 1 2 2 AC 2\nL2 0 3 3 Rser=0\nL3 2 1 1 Rser=1e-20\nL4 1 0 1 Rser=0\nI2 0 1 1\nI3 3 0 5\nI4 2 3 3\n;op\n* ;.ac list 0.159154943091895\n* ;K1 L3 L2 0.5\n.ac dec 100 0.1 10\n.backanno\n.end\nThe LTStresults now agree.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:        1.6 phase:         90°  voltage\nV(3):   mag:        0.6 phase:         90°  voltage\nV(1):   mag:        0.2 phase:        -90°  voltage\nI(L1):  mag:        0.2 phase: -5.15662e-19°    device_current\nI(L2):  mag:        0.2 phase:        180°  device_current\nI(L3):  mag:        1.8 phase: 5.72958e-20°     device_current\nI(L4):  mag:        0.2 phase:        180°  device_current\nI(I1):  mag:          2 phase:          0°  device_current\nI(I2):  mag:          0 phase:          0°  device_current\nI(I3):  mag:          0 phase:          0°  device_current\nI(I4):  mag:          0 phase:          0°  device_current\nThere are some small numeric differences in some node voltages and phases because of the series resistance. Also note the the phase of the current for L2 and L4 from LTSpice is -180 vs +180 as calculated by SymPy."
  },
  {
    "objectID": "test_13.html#ac-sweep",
    "href": "test_13.html#ac-sweep",
    "title": "16  test_13",
    "section": "16.4 AC Sweep",
    "text": "16.4 AC Sweep\nLooking at node 2 voltage and comparing the results with those obtained from LTSpice. The frequency sweep is from 0.1 Hz to 10 Hz.\nLoad the csv file of node 2 voltage over the sweep range and plot along with the results obtained from SymPy.\n\nos.chdir('/home/jeff32/Documents/Solving Electrical Engineering Problems with Python Blog/MNA Test Circuits/test_13/') # change directory to net list location\n\nfn = 'test_13.csv' # data from LTSpice\nLTSpice_data = np.genfromtxt(fn, delimiter=',')\n\n# change the working director back to the Jupyter folder\nos.chdir('/home/jeff32/Documents/JupyterLab/Node Analysis/')  \n\n\n# initaliaze some empty arrays\nfrequency = np.zeros(len(LTSpice_data))\nvoltage = np.zeros(len(LTSpice_data)).astype(complex)\n\n# convert the csv data to complez numbers and store in the array\nfor i in range(len(LTSpice_data)):\n    frequency[i] = LTSpice_data[i][0]\n    voltage[i] = LTSpice_data[i][1] + LTSpice_data[i][2]*1j\n\nLoad the Laplace polyinominal for node 2\n\nH = u1[v2]\nH\n\n\\(\\displaystyle 1.6 s\\)\n\n\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n# convert symbolic to numpy polynomial\na = np.array(Poly(num, s).all_coeffs(), dtype=float)\nb = np.array(Poly(denom, s).all_coeffs(), dtype=float)\nsystem_c1 = (a, b) # system for circuit 1\n\n\nx = np.linspace(0.1*2*np.pi, 10*2*np.pi, 10000, endpoint=True)\nw_c1, mag_c1, phase_c1 = signal.bode(system_c1, w=x) # returns: rad/s, mag in dB, phase in deg\n\nPlot the results.\nUsing\n\nnp.unwrap(2 * phase) / 2)\n\nto keep the pahse plots the same.\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(frequency, 20*np.log10(np.abs(voltage)),'-k')    # Bode magnitude plot\nplt.semilogx(w_c1/(2*np.pi), mag_c1,'-b')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\n#ax1.set_ylim((-30,20))\nplt.grid()\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\n#plt.semilogx(frequency, np.angle(voltage)*180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(frequency, np.unwrap(2*np.angle(voltage)/2) *180/np.pi,':',color=color)  # Bode phase plot\nplt.semilogx(w_c1/(2*np.pi), phase_c1,':',color='tab:red')  # Bode phase plot\n\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()"
  },
  {
    "objectID": "test_12.html#symbolic-solution",
    "href": "test_12.html#symbolic-solution",
    "title": "15  test_12",
    "section": "15.1 Symbolic solution",
    "text": "15.1 Symbolic solution\nSymbolic equations are too long to display in a useful and meaningful way.\n\nsymbolic_solution = solve(equ,X)\n#symbolic_solution\n\nleft_side = list(symbolic_solution.keys()) right_side = list(symbolic_solution.values())\nfor i in range(len(symbolic_solution)): pprint(Eq(left_side[i],right_side[i]))\nThe transfer function H(s)=V4(s)/I1\n\n# display the transfer function\nH = symbolic_solution[v4]/I1\nH\n\n\\(\\displaystyle \\frac{Rl Rs}{C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs}\\)\n\n\nGet the numerator and denominator of the transfer function.\n\nnum, denom = fraction(H) #returns numerator and denominator\n\n\nnum\n\n\\(\\displaystyle Rl Rs\\)\n\n\n\ndenom\n\n\\(\\displaystyle C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs s^{6} + C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs s^{5} + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{3} L_{2} L_{4} Rs s^{4} + C_{1} C_{3} L_{2} L_{6} Rs s^{4} + C_{1} C_{3} L_{2} Rl Rs s^{3} + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs s^{5} + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{1} C_{5} L_{2} L_{6} Rs s^{4} + C_{1} C_{5} L_{2} Rl Rs s^{3} + C_{1} C_{5} L_{4} L_{6} Rs s^{4} + C_{1} C_{5} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{2} Rl Rs s^{3} + C_{1} C_{7} L_{4} Rl Rs s^{3} + C_{1} C_{7} L_{6} Rl Rs s^{3} + C_{1} L_{2} Rs s^{2} + C_{1} L_{4} Rs s^{2} + C_{1} L_{6} Rs s^{2} + C_{1} Rl Rs s + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl s^{6} + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs s^{5} + C_{3} C_{5} L_{2} L_{4} L_{6} s^{5} + C_{3} C_{5} L_{2} L_{4} Rl s^{4} + C_{3} C_{5} L_{4} L_{6} Rs s^{4} + C_{3} C_{5} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{2} L_{4} Rl s^{4} + C_{3} C_{7} L_{2} L_{6} Rl s^{4} + C_{3} C_{7} L_{4} Rl Rs s^{3} + C_{3} C_{7} L_{6} Rl Rs s^{3} + C_{3} L_{2} L_{4} s^{3} + C_{3} L_{2} L_{6} s^{3} + C_{3} L_{2} Rl s^{2} + C_{3} L_{4} Rs s^{2} + C_{3} L_{6} Rs s^{2} + C_{3} Rl Rs s + C_{5} C_{7} L_{2} L_{6} Rl s^{4} + C_{5} C_{7} L_{4} L_{6} Rl s^{4} + C_{5} C_{7} L_{6} Rl Rs s^{3} + C_{5} L_{2} L_{6} s^{3} + C_{5} L_{2} Rl s^{2} + C_{5} L_{4} L_{6} s^{3} + C_{5} L_{4} Rl s^{2} + C_{5} L_{6} Rs s^{2} + C_{5} Rl Rs s + C_{7} L_{2} Rl s^{2} + C_{7} L_{4} Rl s^{2} + C_{7} L_{6} Rl s^{2} + C_{7} Rl Rs s + L_{2} s + L_{4} s + L_{6} s + Rl + Rs\\)\n\n\n\ncollect((denom).expand(),s)\n\n\\(\\displaystyle C_{1} C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl Rs s^{7} + Rl + Rs + s^{6} \\left(C_{1} C_{3} C_{5} L_{2} L_{4} L_{6} Rs + C_{3} C_{5} C_{7} L_{2} L_{4} L_{6} Rl\\right) + s^{5} \\left(C_{1} C_{3} C_{5} L_{2} L_{4} Rl Rs + C_{1} C_{3} C_{7} L_{2} L_{4} Rl Rs + C_{1} C_{3} C_{7} L_{2} L_{6} Rl Rs + C_{1} C_{5} C_{7} L_{2} L_{6} Rl Rs + C_{1} C_{5} C_{7} L_{4} L_{6} Rl Rs + C_{3} C_{5} C_{7} L_{4} L_{6} Rl Rs + C_{3} C_{5} L_{2} L_{4} L_{6}\\right) + s^{4} \\left(C_{1} C_{3} L_{2} L_{4} Rs + C_{1} C_{3} L_{2} L_{6} Rs + C_{1} C_{5} L_{2} L_{6} Rs + C_{1} C_{5} L_{4} L_{6} Rs + C_{3} C_{5} L_{2} L_{4} Rl + C_{3} C_{5} L_{4} L_{6} Rs + C_{3} C_{7} L_{2} L_{4} Rl + C_{3} C_{7} L_{2} L_{6} Rl + C_{5} C_{7} L_{2} L_{6} Rl + C_{5} C_{7} L_{4} L_{6} Rl\\right) + s^{3} \\left(C_{1} C_{3} L_{2} Rl Rs + C_{1} C_{5} L_{2} Rl Rs + C_{1} C_{5} L_{4} Rl Rs + C_{1} C_{7} L_{2} Rl Rs + C_{1} C_{7} L_{4} Rl Rs + C_{1} C_{7} L_{6} Rl Rs + C_{3} C_{5} L_{4} Rl Rs + C_{3} C_{7} L_{4} Rl Rs + C_{3} C_{7} L_{6} Rl Rs + C_{3} L_{2} L_{4} + C_{3} L_{2} L_{6} + C_{5} C_{7} L_{6} Rl Rs + C_{5} L_{2} L_{6} + C_{5} L_{4} L_{6}\\right) + s^{2} \\left(C_{1} L_{2} Rs + C_{1} L_{4} Rs + C_{1} L_{6} Rs + C_{3} L_{2} Rl + C_{3} L_{4} Rs + C_{3} L_{6} Rs + C_{5} L_{2} Rl + C_{5} L_{4} Rl + C_{5} L_{6} Rs + C_{7} L_{2} Rl + C_{7} L_{4} Rl + C_{7} L_{6} Rl\\right) + s \\left(C_{1} Rl Rs + C_{3} Rl Rs + C_{5} Rl Rs + C_{7} Rl Rs + L_{2} + L_{4} + L_{6}\\right)\\)\n\n\n\nsolve(denom,s) #computes the symbolic roots of a univariate polynomial; will fail for most high-degree polynomials (five or greater)\n\n\\(\\displaystyle \\left[ \\right]\\)\n\n\nAs indicated by the comment above, the degree was too high for SymPy to extract the roots in symbolic form."
  },
  {
    "objectID": "test_12.html#numeric-solution",
    "href": "test_12.html#numeric-solution",
    "title": "15  test_12",
    "section": "15.2 Numeric solution",
    "text": "15.2 Numeric solution\n\n# put the component values into dictionary format\ncomponent_values = {\n    C3:3.7642e+00,\n    I1:1.0000e+00,\n    C5:4.0150e+00,\n    C7:3.0182e+00,\n    L2:7.5290e-01,\n    L4:9.2760e-01,\n    L6:9.1420e-01,\n    Rs:5.0000e-01,\n    Rl:1.0000e+00,\n    C1:1.5948e+00}\n\n\ncomponent_values\n\n\\(\\displaystyle \\left\\{ C_{1} : 1.5948, \\  C_{3} : 3.7642, \\  C_{5} : 4.015, \\  C_{7} : 3.0182, \\  I_{1} : 1.0, \\  L_{2} : 0.7529, \\  L_{4} : 0.9276, \\  L_{6} : 0.9142, \\  Rl : 1.0, \\  Rs : 0.5\\right\\}\\)\n\n\n\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\cdot \\left(1.5948 s + 2.0\\right)\\\\- I_{L2} + I_{L4} + 3.7642 s v_{2}\\\\- I_{L4} + I_{L6} + 4.015 s v_{3}\\\\- I_{L6} + v_{4} \\cdot \\left(3.0182 s + 1.0\\right)\\\\- 0.7529 I_{L2} s + v_{1} - v_{2}\\\\- 0.9276 I_{L4} s + v_{2} - v_{3}\\\\- 0.9142 I_{L6} s + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L2} : \\frac{6.04405263388334 \\cdot 10^{25} s^{5} + 2.00253549595234 \\cdot 10^{25} s^{4} + 7.190983534405 \\cdot 10^{25} s^{3} + 1.6567838375 \\cdot 10^{25} s^{2} + 1.68709375 \\cdot 10^{25} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  I_{L4} : \\frac{1.73099099009375 \\cdot 10^{25} s^{3} + 5.7351765625 \\cdot 10^{24} s^{2} + 1.0989375 \\cdot 10^{25} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  I_{L6} : \\frac{4.7159375 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{1} : \\frac{4.55056722805077 \\cdot 10^{25} s^{6} + 1.50770897490251 \\cdot 10^{25} s^{5} + 7.01975874546449 \\cdot 10^{25} s^{4} + 1.77938752919125 \\cdot 10^{25} s^{3} + 2.720718315625 \\cdot 10^{25} s^{2} + 4.05421875 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{2} : \\frac{1.60566724241096 \\cdot 10^{25} s^{4} + 5.319949779375 \\cdot 10^{24} s^{3} + 1.45050543125 \\cdot 10^{25} s^{2} + 2.8778125 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{3} : \\frac{4.3113100625 \\cdot 10^{24} s^{2} + 1.4284375 \\cdot 10^{24} s + 1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}, \\  v_{4} : \\frac{1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}\\right\\}\\)\n\n\nThe transfer function H(s)=V4(s)/I1\n\nTF = u1[v4]/component_values[I1]\nTF\n\n\\(\\displaystyle \\frac{1.5625 \\cdot 10^{24}}{7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}}\\)\n\n\nThe large exponents can be removed by dividing throught by the numberator. First extract the numerator and denominator.\n\nnum, denom = fraction(TF) #returns numerator and denominator\n\n\nnum\n\n\\(\\displaystyle 1.5625 \\cdot 10^{24}\\)\n\n\n\ndenom\n\n\\(\\displaystyle 7.25724461529537 \\cdot 10^{25} s^{7} + 1.15056287292761 \\cdot 10^{26} s^{6} + 2.02545818309551 \\cdot 10^{26} s^{5} + 1.88798202184355 \\cdot 10^{26} s^{4} + 1.50887601625463 \\cdot 10^{26} s^{3} + 7.744787275 \\cdot 10^{25} s^{2} + 2.747125 \\cdot 10^{25} s + 4.6875 \\cdot 10^{24}\\)\n\n\nDivide both numerator and denominator by the numerator.\n\ndenom = denom/num\ndenom\n\n\\(\\displaystyle 46.4463655378904 s^{7} + 73.6360238673669 s^{6} + 129.629323718113 s^{5} + 120.830849397987 s^{4} + 96.568065040296 s^{3} + 49.56663856 s^{2} + 17.5816 s + 3.0\\)\n\n\n\nnum = num/num\nnum\n\n\\(\\displaystyle 1.0\\)\n\n\n\nPoly(denom, s).all_coeffs()\n\n\\(\\displaystyle \\left[ 46.4463655378904, \\  73.6360238673669, \\  129.629323718113, \\  120.830849397987, \\  96.568065040296, \\  49.56663856, \\  17.5816, \\  3.0\\right]\\)\n\n\n\nsolve(denom,s)\n\n\\(\\displaystyle \\left[ -0.35279422422017, \\  -0.31784520158577 - 0.434123823790121 i, \\  -0.31784520158577 + 0.434123823790121 i, \\  -0.219953275559662 - 0.782281046050157 i, \\  -0.219953275559662 + 0.782281046050157 i, \\  -0.0785039364726643 - 0.975486602515317 i, \\  -0.0785039364726643 + 0.975486602515317 i\\right]\\)\n\n\n\n## plot poles and zeros\ntf2 = TransferFunction(num, denom, s)\n\n#pole_zero_plot(tf1,show=False)\npole_zero_plot(tf2,show=True)\n\n\n\n\n\nbode_plot(tf2,initial_exp=-2, final_exp=0,freq_unit='Hz', phase_unit='deg')  \n\n\n\n\nAs shown above, SymPy can easily plot the poles and zeros as well as the Bode function."
  },
  {
    "objectID": "test_12.html#ac-analysis",
    "href": "test_12.html#ac-analysis",
    "title": "15  test_12",
    "section": "15.3 AC analysis",
    "text": "15.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L2} + v_{1} \\cdot \\left(2.0 + 1.5948 i\\right)\\\\- I_{L2} + I_{L4} + 3.7642 i v_{2}\\\\- I_{L4} + I_{L6} + 4.015 i v_{3}\\\\- I_{L6} + v_{4} \\cdot \\left(1.0 + 3.0182 i\\right)\\\\- 0.7529 i I_{L2} + v_{1} - v_{2}\\\\- 0.9276 i I_{L4} + v_{2} - v_{3}\\\\- 0.9142 i I_{L6} + v_{3} - v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}1.0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L2} : 0.91783063115158 - 0.628201043697012 i, \\  I_{L4} : -1.03597965840028 + 0.48128854484449 i, \\  I_{L6} : 0.738345705661929 - 0.127768789322744 i, \\  v_{1} : 0.178224787110382 + 0.171984076606687 i, \\  v_{2} : -0.294747778689098 - 0.519050605587337 i, \\  v_{3} : 0.151695475508651 + 0.441924125544758 i, \\  v_{4} : 0.0348892483097982 - 0.233071518571377 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   0.247674 phase:    43.97910 deg\nv2   : mag:   0.596900 phase:  -119.59049 deg\nv3   : mag:   0.467235 phase:    71.05463 deg\nv4   : mag:   0.235668 phase:   -81.48642 deg\nI_L2 : mag:   1.112227 phase:   -34.38934 deg\nI_L4 : mag:   1.142319 phase:   155.08167 deg\nI_L6 : mag:   0.749319 phase:    -9.81766 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(2):   mag:     0.5969 phase:    -119.59°  voltage\nV(1):   mag:   0.247674 phase:    43.9791°  voltage\nV(3):   mag:   0.467235 phase:    71.0546°  voltage\nV(4):   mag:   0.235668 phase:   -81.4864°  voltage\nI(C3):  mag:    2.24685 phase:   -29.5905°  device_current\nI(C5):  mag:    1.87595 phase:    161.055°  device_current\nI(C7):  mag:   0.711294 phase:    8.51358°  device_current\nI(C1):  mag:   0.394991 phase:    133.979°  device_current\nI(L2):  mag:    1.11223 phase:   -34.3893°  device_current\nI(L4):  mag:    1.14232 phase:    155.082°  device_current\nI(L6):  mag:   0.749319 phase:   -9.81766°  device_current\nI(I1):  mag:          1 phase:          0°  device_current\nI(Rs):  mag:   0.495349 phase:    43.9791°  device_current\nI(Rl):  mag:   0.235668 phase:   -81.4864°  device_current\nThe python and LTspice results agree."
  },
  {
    "objectID": "test_11.html#symbolic-solution",
    "href": "test_11.html#symbolic-solution",
    "title": "14  test_11",
    "section": "14.1 Symbolic solution",
    "text": "14.1 Symbolic solution\n\nsymbolic_solution = solve(equ,X)\nsymbolic_solution\n\n\\(\\displaystyle \\left\\{ I_{L1} : \\frac{L_{2} L_{3} V_{1} s^{2} + L_{2} R_{3} V_{1} s + L_{3} R_{2} V_{1} s - M_{3}^{2} V_{1} s^{2} + R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  I_{L2} : \\frac{- L_{3} M_{1} V_{1} s^{2} - M_{1} R_{3} V_{1} s + M_{2} M_{3} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  I_{L3} : \\frac{- L_{2} M_{2} V_{1} s^{2} + M_{1} M_{3} V_{1} s^{2} - M_{2} R_{2} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  I_{V1} : \\frac{- L_{2} L_{3} V_{1} s^{2} - L_{2} R_{3} V_{1} s - L_{3} R_{2} V_{1} s + M_{3}^{2} V_{1} s^{2} - R_{2} R_{3} V_{1}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  v_{1} : \\frac{L_{1} L_{2} L_{3} V_{1} s^{3} + L_{1} L_{2} R_{3} V_{1} s^{2} + L_{1} L_{3} R_{2} V_{1} s^{2} - L_{1} M_{3}^{2} V_{1} s^{3} + L_{1} R_{2} R_{3} V_{1} s - L_{2} M_{2}^{2} V_{1} s^{3} - L_{3} M_{1}^{2} V_{1} s^{3} - M_{1}^{2} R_{3} V_{1} s^{2} + 2 M_{1} M_{2} M_{3} V_{1} s^{3} - M_{2}^{2} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  v_{2} : \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}, \\  v_{3} : V_{1}, \\  v_{4} : \\frac{L_{2} M_{2} R_{3} V_{1} s^{2} - M_{1} M_{3} R_{3} V_{1} s^{2} + M_{2} R_{2} R_{3} V_{1} s}{L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}}\\right\\}\\)\n\n\n\nleft_side = list(symbolic_solution.keys())\nright_side = list(symbolic_solution.values())\n\nfor i in range(len(symbolic_solution)):\n    pprint(Eq(left_side[i],right_side[i]))\n\n                                   3                2                2        \n                      L₁⋅L₂⋅L₃⋅V₁⋅s  + L₁⋅L₂⋅R₃⋅V₁⋅s  + L₁⋅L₃⋅R₂⋅V₁⋅s  - L₁⋅M₃\nv₁ = ─────────────────────────────────────────────────────────────────────────\n               3             2             2        2  3                      \n     L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L₃⋅\n\n2     3                        2     3        2     3     2        2          \n ⋅V₁⋅s  + L₁⋅R₂⋅R₃⋅V₁⋅s - L₂⋅M₂ ⋅V₁⋅s  - L₃⋅M₁ ⋅V₁⋅s  - M₁ ⋅R₃⋅V₁⋅s  + 2⋅M₁⋅M₂\n──────────────────────────────────────────────────────────────────────────────\n    2        2  3                     2  3                  2     2           \nR₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M₂⋅\n\n        3     2        2                \n⋅M₃⋅V₁⋅s  - M₂ ⋅R₂⋅V₁⋅s                 \n────────────────────────────────────────\n    3     2     2     2     2           \nM₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                            - \nv₂ = ─────────────────────────────────────────────────────────────────────────\n               3             2             2        2  3                      \n     L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L₃⋅\n\n             2                                2                               \nL₃⋅M₁⋅R₂⋅V₁⋅s  - M₁⋅R₂⋅R₃⋅V₁⋅s + M₂⋅M₃⋅R₂⋅V₁⋅s                                \n──────────────────────────────────────────────────────────────────────────────\n    2        2  3                     2  3                  2     2           \nR₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M₂⋅\n\n                                        \n                                        \n────────────────────────────────────────\n    3     2     2     2     2           \nM₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\nv₃ = V₁\n                                                                              \n                                                                             L\nv₄ = ─────────────────────────────────────────────────────────────────────────\n               3             2             2        2  3                      \n     L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L₃⋅\n\n            2                2                                                \n₂⋅M₂⋅R₃⋅V₁⋅s  - M₁⋅M₃⋅R₃⋅V₁⋅s  + M₂⋅R₂⋅R₃⋅V₁⋅s                                \n──────────────────────────────────────────────────────────────────────────────\n    2        2  3                     2  3                  2     2           \nR₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M₂⋅\n\n                                        \n                                        \n────────────────────────────────────────\n    3     2     2     2     2           \nM₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                        - L₂⋅L\nI_V1 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n      2                               2     2                                 \n₃⋅V₁⋅s  - L₂⋅R₃⋅V₁⋅s - L₃⋅R₂⋅V₁⋅s + M₃ ⋅V₁⋅s  - R₂⋅R₃⋅V₁                      \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                         L₂⋅L₃\nI_L1 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n     2                               2     2                                  \n⋅V₁⋅s  + L₂⋅R₃⋅V₁⋅s + L₃⋅R₂⋅V₁⋅s - M₃ ⋅V₁⋅s  + R₂⋅R₃⋅V₁                       \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                              \nI_L2 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n                 2                          2                                 \n     - L₃⋅M₁⋅V₁⋅s  - M₁⋅R₃⋅V₁⋅s + M₂⋅M₃⋅V₁⋅s                                  \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n                                                                              \n                                                                              \nI_L3 = ───────────────────────────────────────────────────────────────────────\n                 3             2             2        2  3                    \n       L₁⋅L₂⋅L₃⋅s  + L₁⋅L₂⋅R₃⋅s  + L₁⋅L₃⋅R₂⋅s  - L₁⋅M₃ ⋅s  + L₁⋅R₂⋅R₃⋅s + L₂⋅L\n\n                 2             2                                              \n     - L₂⋅M₂⋅V₁⋅s  + M₁⋅M₃⋅V₁⋅s  - M₂⋅R₂⋅V₁⋅s                                 \n──────────────────────────────────────────────────────────────────────────────\n      2        2  3                     2  3                  2     2         \n₃⋅R₁⋅s  - L₂⋅M₂ ⋅s  + L₂⋅R₁⋅R₃⋅s - L₃⋅M₁ ⋅s  + L₃⋅R₁⋅R₂⋅s - M₁ ⋅R₃⋅s  + 2⋅M₁⋅M\n\n                                          \n                                          \n──────────────────────────────────────────\n      3     2     2     2     2           \n₂⋅M₃⋅s  - M₂ ⋅R₂⋅s  - M₃ ⋅R₁⋅s  + R₁⋅R₂⋅R₃\n\n\nThe transfer function H(s)=V2(s)/V1\n\nsymbolic_solution[v2]/V1\n\n\\(\\displaystyle \\frac{- L_{3} M_{1} R_{2} V_{1} s^{2} - M_{1} R_{2} R_{3} V_{1} s + M_{2} M_{3} R_{2} V_{1} s^{2}}{V_{1} \\left(L_{1} L_{2} L_{3} s^{3} + L_{1} L_{2} R_{3} s^{2} + L_{1} L_{3} R_{2} s^{2} - L_{1} M_{3}^{2} s^{3} + L_{1} R_{2} R_{3} s + L_{2} L_{3} R_{1} s^{2} - L_{2} M_{2}^{2} s^{3} + L_{2} R_{1} R_{3} s - L_{3} M_{1}^{2} s^{3} + L_{3} R_{1} R_{2} s - M_{1}^{2} R_{3} s^{2} + 2 M_{1} M_{2} M_{3} s^{3} - M_{2}^{2} R_{2} s^{2} - M_{3}^{2} R_{1} s^{2} + R_{1} R_{2} R_{3}\\right)}\\)"
  },
  {
    "objectID": "test_11.html#numeric-solution",
    "href": "test_11.html#numeric-solution",
    "title": "14  test_11",
    "section": "14.2 Numeric solution",
    "text": "14.2 Numeric solution\n\n# put the component values into dictionary format\nK1, K2, K3 = symbols('K1 K2 K3') # initiate symbols for the inductor coupling coeff\ncomponent_values = {\n    V1:1.0000e+01,\n    L1:1.0000e+01,\n    L2:2.0000e+01,\n    L3:3.0000e+01,\n    R2:5.0000e+00,\n    R3:1.0000e+01,\n    R1:2.0000e+00,\n    K1:2.0000e-01,\n    K2:8.0000e-01,\n    K3:5.0000e-01}\n\nFrom the LTSpice netlist:\n\nK1 L1 L2 0.2\nK2 L1 L3 0.8\nK3 L2 L3 0.5\n\nK1, K2 and K3 are the coefficient of coupling. These need to be converted to mutual inductance.\nNeed to solve for M1, M2 and M3:\n\\(M_1 = K1 \\times {\\sqrt{L_1 \\times L_2}}\\)\n\\(M_2 = K2 \\times {\\sqrt{L_1 \\times L_3}}\\)\n\\(M_3 = K3 \\times {\\sqrt{L_2 \\times L_3}}\\)\n\n# calculate the coupling constant from the mutual inductance\ncomponent_values[M1] = component_values[K1]*np.sqrt(component_values[L1] *component_values[L2])\nprint('mutual inductance, M1 = {:.9f}'.format(component_values[M1]))\n\ncomponent_values[M2] = component_values[K2]*np.sqrt(component_values[L1] *component_values[L3])\nprint('mutual inductance, M2 = {:.9f}'.format(component_values[M2]))\n\ncomponent_values[M3] = component_values[K3]*np.sqrt(component_values[L2] *component_values[L3])\nprint('mutual inductance, M3 = {:.9f}'.format(component_values[M3]))\n\nmutual inductance, M1 = 2.828427125\nmutual inductance, M2 = 13.856406461\nmutual inductance, M3 = 12.247448714\n\n\n\ncomponent_values\n\n\\(\\displaystyle \\left\\{ K_{1} : 0.2, \\  K_{2} : 0.8, \\  K_{3} : 0.5, \\  L_{1} : 10.0, \\  L_{2} : 20.0, \\  L_{3} : 30.0, \\  M_{1} : 2.82842712474619, \\  M_{2} : 13.856406460551, \\  M_{3} : 12.2474487139159, \\  R_{1} : 2.0, \\  R_{2} : 5.0, \\  R_{3} : 10.0, \\  V_{1} : 10.0\\right\\}\\)\n\n\n\nequ1a = equ.subs(component_values)\nequ1a\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\- 10.0 I_{L1} s - 2.82842712474619 I_{L2} s - 13.856406460551 I_{L3} s + v_{1}\\\\- 2.82842712474619 I_{L1} s - 20.0 I_{L2} s - 12.2474487139159 I_{L3} s - v_{2}\\\\- 13.856406460551 I_{L1} s - 12.2474487139159 I_{L2} s - 30.0 I_{L3} s + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\nThe equations above are using the component values and the Laplace variable.\n\n# solve the equations.\nu1 = solve(equ1a,X)\nu1 # the solution is too long to display correctly\n\n\\(\\displaystyle \\left\\{ I_{L1} : \\frac{2.25 \\cdot 10^{42} s^{2} + 1.75 \\cdot 10^{42} s + 2.5 \\cdot 10^{41}}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  I_{L2} : \\frac{4.24264068711928 \\cdot 10^{41} s^{2} - 1.4142135623731 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  I_{L3} : \\frac{- 1.21243556529821 \\cdot 10^{42} s^{2} - 3.46410161513775 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  I_{V1} : \\frac{- 2.25 \\cdot 10^{42} s^{2} - 1.75 \\cdot 10^{42} s - 2.5 \\cdot 10^{41}}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  v_{1} : \\frac{6.90000000000004 \\cdot 10^{42} s^{3} + 1.23 \\cdot 10^{43} s^{2} + 2.5 \\cdot 10^{42} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  v_{2} : \\frac{2.12132034355964 \\cdot 10^{42} s^{2} - 7.07106781186548 \\cdot 10^{41} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}, \\  v_{3} : 10.0, \\  v_{4} : \\frac{1.21243556529821 \\cdot 10^{43} s^{2} + 3.46410161513775 \\cdot 10^{42} s}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}\\right\\}\\)\n\n\nThe transfer function H(s)=V2(s)/V1\n\nu1[v2]/component_values[V1]\n\n\\(\\displaystyle \\frac{0.1 \\cdot \\left(2.12132034355964 \\cdot 10^{42} s^{2} - 7.07106781186548 \\cdot 10^{41} s\\right)}{6.90000000000004 \\cdot 10^{41} s^{3} + 1.68 \\cdot 10^{42} s^{2} + 6.0 \\cdot 10^{41} s + 5.0 \\cdot 10^{40}}\\)"
  },
  {
    "objectID": "test_11.html#ac-analysis",
    "href": "test_11.html#ac-analysis",
    "title": "14  test_11",
    "section": "14.3 AC analysis",
    "text": "14.3 AC analysis\nSolve equations for \\(\\omega\\) equal to 1 radian per second, s = 1j.\n\nequ1a_1rad_per_s = equ1a.subs({s:1j})\nequ1a_1rad_per_s  # display the equations\n\n\\(\\displaystyle \\left[\\begin{matrix}I_{L1} + 0.5 v_{1} - 0.5 v_{3}\\\\- I_{L2} + 0.2 v_{2}\\\\I_{V1} - 0.5 v_{1} + 0.5 v_{3}\\\\I_{L3} + 0.1 v_{4}\\\\v_{3}\\\\- 10.0 i I_{L1} - 2.82842712474619 i I_{L2} - 13.856406460551 i I_{L3} + v_{1}\\\\- 2.82842712474619 i I_{L1} - 20.0 i I_{L2} - 12.2474487139159 i I_{L3} - v_{2}\\\\- 13.856406460551 i I_{L1} - 12.2474487139159 i I_{L2} - 30.0 i I_{L3} + v_{4}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\\\10.0\\\\0\\\\0\\\\0\\end{matrix}\\right]\\)\n\n\n\nans1 = solve(equ1a_1rad_per_s,X)\nans1\n\n\\(\\displaystyle \\left\\{ I_{L1} : 1.16416510318949 - 1.13789868667918 i, \\  I_{L2} : 0.264269551242702 + 0.0721699979297333 i, \\  I_{L3} : -0.729866062626583 + 0.252820924632006 i, \\  I_{V1} : -1.16416510318949 + 1.13789868667918 i, \\  v_{1} : 7.67166979362102 + 2.27579737335835 i, \\  v_{2} : 1.32134775621351 + 0.360849989648667 i, \\  v_{3} : 10.0, \\  v_{4} : 7.29866062626583 - 2.52820924632006 i\\right\\}\\)\n\n\n\nfor name, value in ans1.items():\n    print('{:5s}: mag: {:10.6f} phase: {:11.5f} deg'.format(str(name),float(abs(value)),float(arg(value)*180/np.pi)))\n\nv1   : mag:   8.002110 phase:    16.52297 deg\nv2   : mag:   1.369735 phase:    15.27459 deg\nv3   : mag:  10.000000 phase:     0.00000 deg\nv4   : mag:   7.724137 phase:   -19.10576 deg\nI_V1 : mag:   1.627911 phase:   135.65371 deg\nI_L1 : mag:   1.627911 phase:   -44.34629 deg\nI_L2 : mag:   0.273947 phase:    15.27459 deg\nI_L3 : mag:   0.772414 phase:   160.89424 deg\n\n\nThe results from LTSpice AC analysis at 0.159 Hz are shown below.\n       --- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\n\n\n\n--- AC Analysis ---\n\nfrequency:  0.159155    Hz\nV(1):   mag:    8.00211 phase:     16.523°  voltage\nV(2):   mag:    1.36973 phase:    15.2746°  voltage\nV(4):   mag:    7.72414 phase:   -19.1058°  voltage\nV(3):   mag:         10 phase:          0°  voltage\nI(L1):  mag:    1.62791 phase:   -44.3463°  device_current\nI(L2):  mag:   0.273947 phase:    15.2746°  device_current\nI(L3):  mag:   0.772414 phase:    160.894°  device_current\nI(R2):  mag:   0.273947 phase:    15.2746°  device_current\nI(R3):  mag:   0.772414 phase:   -19.1058°  device_current\nI(R1):  mag:    1.62791 phase:    135.654°  device_current\nI(V1):  mag:    1.62791 phase:    135.654°  device_current\n\nThere are some small numeric differences in some node voltages and phases."
  },
  {
    "objectID": "Preface.html#survey-of-other-symbolic-circuit-analysis-code",
    "href": "Preface.html#survey-of-other-symbolic-circuit-analysis-code",
    "title": "Preface",
    "section": "Survey of other symbolic circuit analysis code",
    "text": "Survey of other symbolic circuit analysis code\nThe python code presented in this notebook is somewhat unique since python is open source, free and runs on a variety of platforms, the code presented in this ipython notebook is portable. As described below, this code is made available under a public domain licence and archived in a github repository.\nThere are other symbolic circuit analysis codes available and some of these are described here. Some of these codes are based on commercial software such as MATLAB, TINA and Maple.\nSLiCAP is a symbolic linear analysis tool. SLiCAP runs in MATLAB.\nTINA is an acronym of Toolkit for Interactive Network Analysis. The TINA design suite is a circuit simulator and PCB design software package for analyzing, designing, and real time testing of analog, digital, HDL, MCU, and mixed electronic circuits and their PCB layouts. TINA has some symbolic analysis capability.\nMaple is a mathematical package and there is an application note available describing it use in symbolic circuit analysis. The application note presents an method for evaluating, solving and designing a common, but not so simple pulse-mode high-gain transimpedance amplifier or TIA circuit.\nSymbolic Circuit Analysis is a web page devoted to symbolic circuit analysis.\nSAPWIN is a windows program package for symbolic and numerical simulation of analog circuits.\nLcapy is an experimental Python package for teaching linear circuit analysis. It uses SymPy for symbolic mathematics."
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "What this book is about\nHow this book is organized\nPython\nPython modules\nPrerequisites\nJupyterLab"
  }
]